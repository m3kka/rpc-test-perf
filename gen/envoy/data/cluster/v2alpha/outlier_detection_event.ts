// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/data/cluster/v2alpha/outlier_detection_event.proto" (package "envoy.data.cluster.v2alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { Timestamp } from "../../../../google/protobuf/timestamp";
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.data.cluster.v2alpha.OutlierDetectionEvent
 */
export interface OutlierDetectionEvent {
    /**
     * In case of eject represents type of ejection that took place.
     *
     * @generated from protobuf field: envoy.data.cluster.v2alpha.OutlierEjectionType type = 1;
     */
    type: OutlierEjectionType;
    /**
     * Timestamp for event.
     *
     * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2;
     */
    timestamp?: Timestamp;
    /**
     * The time in seconds since the last action (either an ejection or unejection) took place.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value secs_since_last_action = 3;
     */
    secsSinceLastAction?: UInt64Value;
    /**
     * The :ref:`cluster <envoy_api_msg_Cluster>` that owns the ejected host.
     *
     * @generated from protobuf field: string cluster_name = 4;
     */
    clusterName: string;
    /**
     * The URL of the ejected host. E.g., ``tcp://1.2.3.4:80``.
     *
     * @generated from protobuf field: string upstream_url = 5;
     */
    upstreamUrl: string;
    /**
     * The action that took place.
     *
     * @generated from protobuf field: envoy.data.cluster.v2alpha.Action action = 6;
     */
    action: Action;
    /**
     * If ``action`` is ``eject``, specifies the number of times the host has been ejected (local to
     * that Envoy and gets reset if the host gets removed from the upstream cluster for any reason and
     * then re-added).
     *
     * @generated from protobuf field: uint32 num_ejections = 7;
     */
    numEjections: number;
    /**
     * If ``action`` is ``eject``, specifies if the ejection was enforced. ``true`` means the host was
     * ejected. ``false`` means the event was logged but the host was not actually ejected.
     *
     * @generated from protobuf field: bool enforced = 8;
     */
    enforced: boolean;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "ejectSuccessRateEvent";
        /**
         * @generated from protobuf field: envoy.data.cluster.v2alpha.OutlierEjectSuccessRate eject_success_rate_event = 9;
         */
        ejectSuccessRateEvent: OutlierEjectSuccessRate;
    } | {
        oneofKind: "ejectConsecutiveEvent";
        /**
         * @generated from protobuf field: envoy.data.cluster.v2alpha.OutlierEjectConsecutive eject_consecutive_event = 10;
         */
        ejectConsecutiveEvent: OutlierEjectConsecutive;
    } | {
        oneofKind: "ejectFailurePercentageEvent";
        /**
         * @generated from protobuf field: envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage eject_failure_percentage_event = 11;
         */
        ejectFailurePercentageEvent: OutlierEjectFailurePercentage;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.data.cluster.v2alpha.OutlierEjectSuccessRate
 */
export interface OutlierEjectSuccessRate {
    /**
     * Hostâ€™s success rate at the time of the ejection event on a 0-100 range.
     *
     * @generated from protobuf field: uint32 host_success_rate = 1;
     */
    hostSuccessRate: number;
    /**
     * Average success rate of the hosts in the cluster at the time of the ejection event on a 0-100
     * range.
     *
     * @generated from protobuf field: uint32 cluster_average_success_rate = 2;
     */
    clusterAverageSuccessRate: number;
    /**
     * Success rate ejection threshold at the time of the ejection event.
     *
     * @generated from protobuf field: uint32 cluster_success_rate_ejection_threshold = 3;
     */
    clusterSuccessRateEjectionThreshold: number;
}
/**
 * @generated from protobuf message envoy.data.cluster.v2alpha.OutlierEjectConsecutive
 */
export interface OutlierEjectConsecutive {
}
/**
 * @generated from protobuf message envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage
 */
export interface OutlierEjectFailurePercentage {
    /**
     * Host's success rate at the time of the ejection event on a 0-100 range.
     *
     * @generated from protobuf field: uint32 host_success_rate = 1;
     */
    hostSuccessRate: number;
}
// [#protodoc-title: Outlier detection logging events]
// :ref:`Outlier detection logging <arch_overview_outlier_detection_logging>`.

/**
 * Type of ejection that took place
 *
 * @generated from protobuf enum envoy.data.cluster.v2alpha.OutlierEjectionType
 */
export enum OutlierEjectionType {
    /**
     * In case upstream host returns certain number of consecutive 5xx.
     * If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is *false*, all type of errors are treated as HTTP 5xx errors.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     * details.
     *
     * @generated from protobuf enum value: CONSECUTIVE_5XX = 0;
     */
    CONSECUTIVE_5XX = 0,
    /**
     * In case upstream host returns certain number of consecutive gateway errors
     *
     * @generated from protobuf enum value: CONSECUTIVE_GATEWAY_FAILURE = 1;
     */
    CONSECUTIVE_GATEWAY_FAILURE = 1,
    /**
     * Runs over aggregated success rate statistics from every host in cluster
     * and selects hosts for which ratio of successful replies deviates from other hosts
     * in the cluster.
     * If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is *false*, all errors (externally and locally generated) are used to calculate success rate
     * statistics. See :ref:`Cluster outlier detection <arch_overview_outlier_detection>`
     * documentation for details.
     *
     * @generated from protobuf enum value: SUCCESS_RATE = 2;
     */
    SUCCESS_RATE = 2,
    /**
     * Consecutive local origin failures: Connection failures, resets, timeouts, etc
     * This type of ejection happens only when
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is set to *true*.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     *
     * @generated from protobuf enum value: CONSECUTIVE_LOCAL_ORIGIN_FAILURE = 3;
     */
    CONSECUTIVE_LOCAL_ORIGIN_FAILURE = 3,
    /**
     * Runs over aggregated success rate statistics for local origin failures
     * for all hosts in the cluster and selects hosts for which success rate deviates from other
     * hosts in the cluster. This type of ejection happens only when
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is set to *true*.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     *
     * @generated from protobuf enum value: SUCCESS_RATE_LOCAL_ORIGIN = 4;
     */
    SUCCESS_RATE_LOCAL_ORIGIN = 4,
    /**
     * Runs over aggregated success rate statistics from every host in cluster and selects hosts for
     * which ratio of failed replies is above configured value.
     *
     * @generated from protobuf enum value: FAILURE_PERCENTAGE = 5;
     */
    FAILURE_PERCENTAGE = 5,
    /**
     * Runs over aggregated success rate statistics for local origin failures from every host in
     * cluster and selects hosts for which ratio of failed replies is above configured value.
     *
     * @generated from protobuf enum value: FAILURE_PERCENTAGE_LOCAL_ORIGIN = 6;
     */
    FAILURE_PERCENTAGE_LOCAL_ORIGIN = 6
}
/**
 * Represents possible action applied to upstream host
 *
 * @generated from protobuf enum envoy.data.cluster.v2alpha.Action
 */
export enum Action {
    /**
     * In case host was excluded from service
     *
     * @generated from protobuf enum value: EJECT = 0;
     */
    EJECT = 0,
    /**
     * In case host was brought back into service
     *
     * @generated from protobuf enum value: UNEJECT = 1;
     */
    UNEJECT = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class OutlierDetectionEvent$Type extends MessageType<OutlierDetectionEvent> {
    constructor() {
        super("envoy.data.cluster.v2alpha.OutlierDetectionEvent", [
            { no: 1, name: "type", kind: "enum", T: () => ["envoy.data.cluster.v2alpha.OutlierEjectionType", OutlierEjectionType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "timestamp", kind: "message", T: () => Timestamp },
            { no: 3, name: "secs_since_last_action", kind: "message", T: () => UInt64Value },
            { no: 4, name: "cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 5, name: "upstream_url", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 6, name: "action", kind: "enum", T: () => ["envoy.data.cluster.v2alpha.Action", Action], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 7, name: "num_ejections", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "enforced", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "eject_success_rate_event", kind: "message", oneof: "event", T: () => OutlierEjectSuccessRate },
            { no: 10, name: "eject_consecutive_event", kind: "message", oneof: "event", T: () => OutlierEjectConsecutive },
            { no: 11, name: "eject_failure_percentage_event", kind: "message", oneof: "event", T: () => OutlierEjectFailurePercentage }
        ]);
    }
    create(value?: PartialMessage<OutlierDetectionEvent>): OutlierDetectionEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.clusterName = "";
        message.upstreamUrl = "";
        message.action = 0;
        message.numEjections = 0;
        message.enforced = false;
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OutlierDetectionEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutlierDetectionEvent): OutlierDetectionEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.cluster.v2alpha.OutlierEjectionType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* google.protobuf.Timestamp timestamp */ 2:
                    message.timestamp = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timestamp);
                    break;
                case /* google.protobuf.UInt64Value secs_since_last_action */ 3:
                    message.secsSinceLastAction = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.secsSinceLastAction);
                    break;
                case /* string cluster_name */ 4:
                    message.clusterName = reader.string();
                    break;
                case /* string upstream_url */ 5:
                    message.upstreamUrl = reader.string();
                    break;
                case /* envoy.data.cluster.v2alpha.Action action */ 6:
                    message.action = reader.int32();
                    break;
                case /* uint32 num_ejections */ 7:
                    message.numEjections = reader.uint32();
                    break;
                case /* bool enforced */ 8:
                    message.enforced = reader.bool();
                    break;
                case /* envoy.data.cluster.v2alpha.OutlierEjectSuccessRate eject_success_rate_event */ 9:
                    message.event = {
                        oneofKind: "ejectSuccessRateEvent",
                        ejectSuccessRateEvent: OutlierEjectSuccessRate.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).ejectSuccessRateEvent)
                    };
                    break;
                case /* envoy.data.cluster.v2alpha.OutlierEjectConsecutive eject_consecutive_event */ 10:
                    message.event = {
                        oneofKind: "ejectConsecutiveEvent",
                        ejectConsecutiveEvent: OutlierEjectConsecutive.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).ejectConsecutiveEvent)
                    };
                    break;
                case /* envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage eject_failure_percentage_event */ 11:
                    message.event = {
                        oneofKind: "ejectFailurePercentageEvent",
                        ejectFailurePercentageEvent: OutlierEjectFailurePercentage.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).ejectFailurePercentageEvent)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutlierDetectionEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.cluster.v2alpha.OutlierEjectionType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* google.protobuf.Timestamp timestamp = 2; */
        if (message.timestamp)
            Timestamp.internalBinaryWrite(message.timestamp, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt64Value secs_since_last_action = 3; */
        if (message.secsSinceLastAction)
            UInt64Value.internalBinaryWrite(message.secsSinceLastAction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string cluster_name = 4; */
        if (message.clusterName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.clusterName);
        /* string upstream_url = 5; */
        if (message.upstreamUrl !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.upstreamUrl);
        /* envoy.data.cluster.v2alpha.Action action = 6; */
        if (message.action !== 0)
            writer.tag(6, WireType.Varint).int32(message.action);
        /* uint32 num_ejections = 7; */
        if (message.numEjections !== 0)
            writer.tag(7, WireType.Varint).uint32(message.numEjections);
        /* bool enforced = 8; */
        if (message.enforced !== false)
            writer.tag(8, WireType.Varint).bool(message.enforced);
        /* envoy.data.cluster.v2alpha.OutlierEjectSuccessRate eject_success_rate_event = 9; */
        if (message.event.oneofKind === "ejectSuccessRateEvent")
            OutlierEjectSuccessRate.internalBinaryWrite(message.event.ejectSuccessRateEvent, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.cluster.v2alpha.OutlierEjectConsecutive eject_consecutive_event = 10; */
        if (message.event.oneofKind === "ejectConsecutiveEvent")
            OutlierEjectConsecutive.internalBinaryWrite(message.event.ejectConsecutiveEvent, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage eject_failure_percentage_event = 11; */
        if (message.event.oneofKind === "ejectFailurePercentageEvent")
            OutlierEjectFailurePercentage.internalBinaryWrite(message.event.ejectFailurePercentageEvent, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.cluster.v2alpha.OutlierDetectionEvent
 */
export const OutlierDetectionEvent = new OutlierDetectionEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutlierEjectSuccessRate$Type extends MessageType<OutlierEjectSuccessRate> {
    constructor() {
        super("envoy.data.cluster.v2alpha.OutlierEjectSuccessRate", [
            { no: 1, name: "host_success_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 2, name: "cluster_average_success_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 3, name: "cluster_success_rate_ejection_threshold", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 100 } } } }
        ]);
    }
    create(value?: PartialMessage<OutlierEjectSuccessRate>): OutlierEjectSuccessRate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostSuccessRate = 0;
        message.clusterAverageSuccessRate = 0;
        message.clusterSuccessRateEjectionThreshold = 0;
        if (value !== undefined)
            reflectionMergePartial<OutlierEjectSuccessRate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutlierEjectSuccessRate): OutlierEjectSuccessRate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 host_success_rate */ 1:
                    message.hostSuccessRate = reader.uint32();
                    break;
                case /* uint32 cluster_average_success_rate */ 2:
                    message.clusterAverageSuccessRate = reader.uint32();
                    break;
                case /* uint32 cluster_success_rate_ejection_threshold */ 3:
                    message.clusterSuccessRateEjectionThreshold = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutlierEjectSuccessRate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 host_success_rate = 1; */
        if (message.hostSuccessRate !== 0)
            writer.tag(1, WireType.Varint).uint32(message.hostSuccessRate);
        /* uint32 cluster_average_success_rate = 2; */
        if (message.clusterAverageSuccessRate !== 0)
            writer.tag(2, WireType.Varint).uint32(message.clusterAverageSuccessRate);
        /* uint32 cluster_success_rate_ejection_threshold = 3; */
        if (message.clusterSuccessRateEjectionThreshold !== 0)
            writer.tag(3, WireType.Varint).uint32(message.clusterSuccessRateEjectionThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.cluster.v2alpha.OutlierEjectSuccessRate
 */
export const OutlierEjectSuccessRate = new OutlierEjectSuccessRate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutlierEjectConsecutive$Type extends MessageType<OutlierEjectConsecutive> {
    constructor() {
        super("envoy.data.cluster.v2alpha.OutlierEjectConsecutive", []);
    }
    create(value?: PartialMessage<OutlierEjectConsecutive>): OutlierEjectConsecutive {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<OutlierEjectConsecutive>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutlierEjectConsecutive): OutlierEjectConsecutive {
        return target ?? this.create();
    }
    internalBinaryWrite(message: OutlierEjectConsecutive, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.cluster.v2alpha.OutlierEjectConsecutive
 */
export const OutlierEjectConsecutive = new OutlierEjectConsecutive$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutlierEjectFailurePercentage$Type extends MessageType<OutlierEjectFailurePercentage> {
    constructor() {
        super("envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage", [
            { no: 1, name: "host_success_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 100 } } } }
        ]);
    }
    create(value?: PartialMessage<OutlierEjectFailurePercentage>): OutlierEjectFailurePercentage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostSuccessRate = 0;
        if (value !== undefined)
            reflectionMergePartial<OutlierEjectFailurePercentage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutlierEjectFailurePercentage): OutlierEjectFailurePercentage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 host_success_rate */ 1:
                    message.hostSuccessRate = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutlierEjectFailurePercentage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 host_success_rate = 1; */
        if (message.hostSuccessRate !== 0)
            writer.tag(1, WireType.Varint).uint32(message.hostSuccessRate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.cluster.v2alpha.OutlierEjectFailurePercentage
 */
export const OutlierEjectFailurePercentage = new OutlierEjectFailurePercentage$Type();
