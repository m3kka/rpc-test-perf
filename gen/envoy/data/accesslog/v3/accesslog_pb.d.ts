// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/data/accesslog/v3/accesslog.proto (package envoy.data.accesslog.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Address } from "../../../config/core/v3/address_pb.js";
import type { Metadata, RequestMethod } from "../../../config/core/v3/base_pb.js";

/**
 * @generated from enum envoy.data.accesslog.v3.AccessLogType
 */
export declare enum AccessLogType {
  /**
   * @generated from enum value: NotSet = 0;
   */
  NotSet = 0,

  /**
   * @generated from enum value: TcpUpstreamConnected = 1;
   */
  TcpUpstreamConnected = 1,

  /**
   * @generated from enum value: TcpPeriodic = 2;
   */
  TcpPeriodic = 2,

  /**
   * @generated from enum value: TcpConnectionEnd = 3;
   */
  TcpConnectionEnd = 3,

  /**
   * @generated from enum value: DownstreamStart = 4;
   */
  DownstreamStart = 4,

  /**
   * @generated from enum value: DownstreamPeriodic = 5;
   */
  DownstreamPeriodic = 5,

  /**
   * @generated from enum value: DownstreamEnd = 6;
   */
  DownstreamEnd = 6,

  /**
   * @generated from enum value: UpstreamPoolReady = 7;
   */
  UpstreamPoolReady = 7,

  /**
   * @generated from enum value: UpstreamPeriodic = 8;
   */
  UpstreamPeriodic = 8,

  /**
   * @generated from enum value: UpstreamEnd = 9;
   */
  UpstreamEnd = 9,

  /**
   * @generated from enum value: DownstreamTunnelSuccessfullyEstablished = 10;
   */
  DownstreamTunnelSuccessfullyEstablished = 10,
}

/**
 * @generated from message envoy.data.accesslog.v3.TCPAccessLogEntry
 */
export declare class TCPAccessLogEntry extends Message<TCPAccessLogEntry> {
  /**
   * Common properties shared by all Envoy access logs.
   *
   * @generated from field: envoy.data.accesslog.v3.AccessLogCommon common_properties = 1;
   */
  commonProperties?: AccessLogCommon;

  /**
   * Properties of the TCP connection.
   *
   * @generated from field: envoy.data.accesslog.v3.ConnectionProperties connection_properties = 2;
   */
  connectionProperties?: ConnectionProperties;

  constructor(data?: PartialMessage<TCPAccessLogEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.TCPAccessLogEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TCPAccessLogEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TCPAccessLogEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TCPAccessLogEntry;

  static equals(a: TCPAccessLogEntry | PlainMessage<TCPAccessLogEntry> | undefined, b: TCPAccessLogEntry | PlainMessage<TCPAccessLogEntry> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v3.HTTPAccessLogEntry
 */
export declare class HTTPAccessLogEntry extends Message<HTTPAccessLogEntry> {
  /**
   * Common properties shared by all Envoy access logs.
   *
   * @generated from field: envoy.data.accesslog.v3.AccessLogCommon common_properties = 1;
   */
  commonProperties?: AccessLogCommon;

  /**
   * @generated from field: envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion protocol_version = 2;
   */
  protocolVersion: HTTPAccessLogEntry_HTTPVersion;

  /**
   * Description of the incoming HTTP request.
   *
   * @generated from field: envoy.data.accesslog.v3.HTTPRequestProperties request = 3;
   */
  request?: HTTPRequestProperties;

  /**
   * Description of the outgoing HTTP response.
   *
   * @generated from field: envoy.data.accesslog.v3.HTTPResponseProperties response = 4;
   */
  response?: HTTPResponseProperties;

  constructor(data?: PartialMessage<HTTPAccessLogEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.HTTPAccessLogEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPAccessLogEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPAccessLogEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPAccessLogEntry;

  static equals(a: HTTPAccessLogEntry | PlainMessage<HTTPAccessLogEntry> | undefined, b: HTTPAccessLogEntry | PlainMessage<HTTPAccessLogEntry> | undefined): boolean;
}

/**
 * HTTP version
 *
 * @generated from enum envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion
 */
export declare enum HTTPAccessLogEntry_HTTPVersion {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  PROTOCOL_UNSPECIFIED = 0,

  /**
   * @generated from enum value: HTTP10 = 1;
   */
  HTTP10 = 1,

  /**
   * @generated from enum value: HTTP11 = 2;
   */
  HTTP11 = 2,

  /**
   * @generated from enum value: HTTP2 = 3;
   */
  HTTP2 = 3,

  /**
   * @generated from enum value: HTTP3 = 4;
   */
  HTTP3 = 4,
}

/**
 * Defines fields for a connection
 *
 * @generated from message envoy.data.accesslog.v3.ConnectionProperties
 */
export declare class ConnectionProperties extends Message<ConnectionProperties> {
  /**
   * Number of bytes received from downstream.
   *
   * @generated from field: uint64 received_bytes = 1;
   */
  receivedBytes: bigint;

  /**
   * Number of bytes sent to downstream.
   *
   * @generated from field: uint64 sent_bytes = 2;
   */
  sentBytes: bigint;

  constructor(data?: PartialMessage<ConnectionProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.ConnectionProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionProperties;

  static equals(a: ConnectionProperties | PlainMessage<ConnectionProperties> | undefined, b: ConnectionProperties | PlainMessage<ConnectionProperties> | undefined): boolean;
}

/**
 * Defines fields that are shared by all Envoy access logs.
 * [#next-free-field: 34]
 *
 * @generated from message envoy.data.accesslog.v3.AccessLogCommon
 */
export declare class AccessLogCommon extends Message<AccessLogCommon> {
  /**
   * [#not-implemented-hide:]
   * This field indicates the rate at which this log entry was sampled.
   * Valid range is (0.0, 1.0].
   *
   * @generated from field: double sample_rate = 1;
   */
  sampleRate: number;

  /**
   * This field is the remote/origin address on which the request from the user was received.
   * Note: This may not be the physical peer. E.g, if the remote address is inferred from for
   * example the x-forwarder-for header, proxy protocol, etc.
   *
   * @generated from field: envoy.config.core.v3.Address downstream_remote_address = 2;
   */
  downstreamRemoteAddress?: Address;

  /**
   * This field is the local/destination address on which the request from the user was received.
   *
   * @generated from field: envoy.config.core.v3.Address downstream_local_address = 3;
   */
  downstreamLocalAddress?: Address;

  /**
   * If the connection is secure,S this field will contain TLS properties.
   *
   * @generated from field: envoy.data.accesslog.v3.TLSProperties tls_properties = 4;
   */
  tlsProperties?: TLSProperties;

  /**
   * The time that Envoy started servicing this request. This is effectively the time that the first
   * downstream byte is received.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 5;
   */
  startTime?: Timestamp;

  /**
   * Interval between the first downstream byte received and the last
   * downstream byte received (i.e. time it takes to receive a request).
   *
   * @generated from field: google.protobuf.Duration time_to_last_rx_byte = 6;
   */
  timeToLastRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first upstream byte sent. There may
   * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
   * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
   * not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_first_upstream_tx_byte = 7;
   */
  timeToFirstUpstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last upstream byte sent. There may
   * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
   * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
   * not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_last_upstream_tx_byte = 8;
   */
  timeToLastUpstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first upstream
   * byte received (i.e. time it takes to start receiving a response).
   *
   * @generated from field: google.protobuf.Duration time_to_first_upstream_rx_byte = 9;
   */
  timeToFirstUpstreamRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last upstream
   * byte received (i.e. time it takes to receive a complete response).
   *
   * @generated from field: google.protobuf.Duration time_to_last_upstream_rx_byte = 10;
   */
  timeToLastUpstreamRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first downstream byte sent.
   * There may be a considerable delta between the ``time_to_first_upstream_rx_byte`` and this field
   * due to filters. Additionally, the same caveats apply as documented in
   * ``time_to_last_downstream_tx_byte`` about not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_first_downstream_tx_byte = 11;
   */
  timeToFirstDownstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last downstream byte sent.
   * Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
   * between ``time_to_last_upstream_rx_byte`` and this field. Note also that this is an approximate
   * time. In the current implementation it does not include kernel socket buffer time. In the
   * current implementation it also does not include send window buffering inside the HTTP/2 codec.
   * In the future it is likely that work will be done to make this duration more accurate.
   *
   * @generated from field: google.protobuf.Duration time_to_last_downstream_tx_byte = 12;
   */
  timeToLastDownstreamTxByte?: Duration;

  /**
   * The upstream remote/destination address that handles this exchange. This does not include
   * retries.
   *
   * @generated from field: envoy.config.core.v3.Address upstream_remote_address = 13;
   */
  upstreamRemoteAddress?: Address;

  /**
   * The upstream local/origin address that handles this exchange. This does not include retries.
   *
   * @generated from field: envoy.config.core.v3.Address upstream_local_address = 14;
   */
  upstreamLocalAddress?: Address;

  /**
   * The upstream cluster that ``upstream_remote_address`` belongs to.
   *
   * @generated from field: string upstream_cluster = 15;
   */
  upstreamCluster: string;

  /**
   * Flags indicating occurrences during request/response processing.
   *
   * @generated from field: envoy.data.accesslog.v3.ResponseFlags response_flags = 16;
   */
  responseFlags?: ResponseFlags;

  /**
   * All metadata encountered during request processing, including endpoint
   * selection.
   *
   * This can be used to associate IDs attached to the various configurations
   * used to process this request with the access log entry. For example, a
   * route created from a higher level forwarding rule with some ID can place
   * that ID in this field and cross reference later. It can also be used to
   * determine if a canary endpoint was used or not.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata = 17;
   */
  metadata?: Metadata;

  /**
   * If upstream connection failed due to transport socket (e.g. TLS handshake), provides the
   * failure reason from the transport socket. The format of this field depends on the configured
   * upstream transport socket. Common TLS failures are in
   * :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
   *
   * @generated from field: string upstream_transport_failure_reason = 18;
   */
  upstreamTransportFailureReason: string;

  /**
   * The name of the route
   *
   * @generated from field: string route_name = 19;
   */
  routeName: string;

  /**
   * This field is the downstream direct remote address on which the request from the user was
   * received. Note: This is always the physical peer, even if the remote address is inferred from
   * for example the x-forwarder-for header, proxy protocol, etc.
   *
   * @generated from field: envoy.config.core.v3.Address downstream_direct_remote_address = 20;
   */
  downstreamDirectRemoteAddress?: Address;

  /**
   * Map of filter state in stream info that have been configured to be logged. If the filter
   * state serialized to any message other than ``google.protobuf.Any`` it will be packed into
   * ``google.protobuf.Any``.
   *
   * @generated from field: map<string, google.protobuf.Any> filter_state_objects = 21;
   */
  filterStateObjects: { [key: string]: Any };

  /**
   * A list of custom tags, which annotate logs with additional information.
   * To configure this value, users should configure
   * :ref:`custom_tags <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.custom_tags>`.
   *
   * @generated from field: map<string, string> custom_tags = 22;
   */
  customTags: { [key: string]: string };

  /**
   * For HTTP: Total duration in milliseconds of the request from the start time to the last byte out.
   * For TCP: Total duration in milliseconds of the downstream connection.
   * This is the total duration of the request (i.e., when the request's ActiveStream is destroyed)
   * and may be longer than ``time_to_last_downstream_tx_byte``.
   *
   * @generated from field: google.protobuf.Duration duration = 23;
   */
  duration?: Duration;

  /**
   * For HTTP: Number of times the request is attempted upstream. Note that the field is omitted when the request was never attempted upstream.
   * For TCP: Number of times the connection request is attempted upstream. Note that the field is omitted when the connect request was never attempted upstream.
   *
   * @generated from field: uint32 upstream_request_attempt_count = 24;
   */
  upstreamRequestAttemptCount: number;

  /**
   * Connection termination details may provide additional information about why the connection was terminated by Envoy for L4 reasons.
   *
   * @generated from field: string connection_termination_details = 25;
   */
  connectionTerminationDetails: string;

  /**
   * Optional unique id of stream (TCP connection, long-live HTTP2 stream, HTTP request) for logging and tracing.
   * This could be any format string that could be used to identify one stream.
   *
   * @generated from field: string stream_id = 26;
   */
  streamId: string;

  /**
   * If this log entry is final log entry that flushed after the stream completed or
   * intermediate log entry that flushed periodically during the stream.
   * There may be multiple intermediate log entries and only one final log entry for each
   * long-live stream (TCP connection, long-live HTTP2 stream).
   * And if it is necessary, unique ID or identifier can be added to the log entry
   * :ref:`stream_id <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.stream_id>` to
   * correlate all these intermediate log entries and final log entry.
   *
   * .. attention::
   *
   *   This field is deprecated in favor of ``access_log_type`` for better indication of the
   *   type of the access log record.
   *
   * @generated from field: bool intermediate_log_entry = 27 [deprecated = true];
   * @deprecated
   */
  intermediateLogEntry: boolean;

  /**
   * If downstream connection in listener failed due to transport socket (e.g. TLS handshake), provides the
   * failure reason from the transport socket. The format of this field depends on the configured downstream
   * transport socket. Common TLS failures are in :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
   *
   * @generated from field: string downstream_transport_failure_reason = 28;
   */
  downstreamTransportFailureReason: string;

  /**
   * For HTTP: Total number of bytes sent to the downstream by the http stream.
   * For TCP: Total number of bytes sent to the downstream by the tcp proxy.
   *
   * @generated from field: uint64 downstream_wire_bytes_sent = 29;
   */
  downstreamWireBytesSent: bigint;

  /**
   * For HTTP: Total number of bytes received from the downstream by the http stream. Envoy over counts sizes of received HTTP/1.1 pipelined requests by adding up bytes of requests in the pipeline to the one currently being processed.
   * For TCP: Total number of bytes received from the downstream by the tcp proxy.
   *
   * @generated from field: uint64 downstream_wire_bytes_received = 30;
   */
  downstreamWireBytesReceived: bigint;

  /**
   * For HTTP: Total number of bytes sent to the upstream by the http stream. This value accumulates during upstream retries.
   * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
   *
   * @generated from field: uint64 upstream_wire_bytes_sent = 31;
   */
  upstreamWireBytesSent: bigint;

  /**
   * For HTTP: Total number of bytes received from the upstream by the http stream.
   * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
   *
   * @generated from field: uint64 upstream_wire_bytes_received = 32;
   */
  upstreamWireBytesReceived: bigint;

  /**
   * The type of the access log, which indicates when the log was recorded.
   * See :ref:`ACCESS_LOG_TYPE <config_access_log_format_access_log_type>` for the available values.
   * In case the access log was recorded by a flow which does not correspond to one of the supported
   * values, then the default value will be ``NotSet``.
   * For more information about how access log behaves and when it is being recorded,
   * please refer to :ref:`access logging <arch_overview_access_logs>`.
   *
   * @generated from field: envoy.data.accesslog.v3.AccessLogType access_log_type = 33;
   */
  accessLogType: AccessLogType;

  constructor(data?: PartialMessage<AccessLogCommon>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.AccessLogCommon";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessLogCommon;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessLogCommon;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessLogCommon;

  static equals(a: AccessLogCommon | PlainMessage<AccessLogCommon> | undefined, b: AccessLogCommon | PlainMessage<AccessLogCommon> | undefined): boolean;
}

/**
 * Flags indicating occurrences during request/response processing.
 * [#next-free-field: 28]
 *
 * @generated from message envoy.data.accesslog.v3.ResponseFlags
 */
export declare class ResponseFlags extends Message<ResponseFlags> {
  /**
   * Indicates local server healthcheck failed.
   *
   * @generated from field: bool failed_local_healthcheck = 1;
   */
  failedLocalHealthcheck: boolean;

  /**
   * Indicates there was no healthy upstream.
   *
   * @generated from field: bool no_healthy_upstream = 2;
   */
  noHealthyUpstream: boolean;

  /**
   * Indicates an there was an upstream request timeout.
   *
   * @generated from field: bool upstream_request_timeout = 3;
   */
  upstreamRequestTimeout: boolean;

  /**
   * Indicates local codec level reset was sent on the stream.
   *
   * @generated from field: bool local_reset = 4;
   */
  localReset: boolean;

  /**
   * Indicates remote codec level reset was received on the stream.
   *
   * @generated from field: bool upstream_remote_reset = 5;
   */
  upstreamRemoteReset: boolean;

  /**
   * Indicates there was a local reset by a connection pool due to an initial connection failure.
   *
   * @generated from field: bool upstream_connection_failure = 6;
   */
  upstreamConnectionFailure: boolean;

  /**
   * Indicates the stream was reset due to an upstream connection termination.
   *
   * @generated from field: bool upstream_connection_termination = 7;
   */
  upstreamConnectionTermination: boolean;

  /**
   * Indicates the stream was reset because of a resource overflow.
   *
   * @generated from field: bool upstream_overflow = 8;
   */
  upstreamOverflow: boolean;

  /**
   * Indicates no route was found for the request.
   *
   * @generated from field: bool no_route_found = 9;
   */
  noRouteFound: boolean;

  /**
   * Indicates that the request was delayed before proxying.
   *
   * @generated from field: bool delay_injected = 10;
   */
  delayInjected: boolean;

  /**
   * Indicates that the request was aborted with an injected error code.
   *
   * @generated from field: bool fault_injected = 11;
   */
  faultInjected: boolean;

  /**
   * Indicates that the request was rate-limited locally.
   *
   * @generated from field: bool rate_limited = 12;
   */
  rateLimited: boolean;

  /**
   * Indicates if the request was deemed unauthorized and the reason for it.
   *
   * @generated from field: envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13;
   */
  unauthorizedDetails?: ResponseFlags_Unauthorized;

  /**
   * Indicates that the request was rejected because there was an error in rate limit service.
   *
   * @generated from field: bool rate_limit_service_error = 14;
   */
  rateLimitServiceError: boolean;

  /**
   * Indicates the stream was reset due to a downstream connection termination.
   *
   * @generated from field: bool downstream_connection_termination = 15;
   */
  downstreamConnectionTermination: boolean;

  /**
   * Indicates that the upstream retry limit was exceeded, resulting in a downstream error.
   *
   * @generated from field: bool upstream_retry_limit_exceeded = 16;
   */
  upstreamRetryLimitExceeded: boolean;

  /**
   * Indicates that the stream idle timeout was hit, resulting in a downstream 408.
   *
   * @generated from field: bool stream_idle_timeout = 17;
   */
  streamIdleTimeout: boolean;

  /**
   * Indicates that the request was rejected because an envoy request header failed strict
   * validation.
   *
   * @generated from field: bool invalid_envoy_request_headers = 18;
   */
  invalidEnvoyRequestHeaders: boolean;

  /**
   * Indicates there was an HTTP protocol error on the downstream request.
   *
   * @generated from field: bool downstream_protocol_error = 19;
   */
  downstreamProtocolError: boolean;

  /**
   * Indicates there was a max stream duration reached on the upstream request.
   *
   * @generated from field: bool upstream_max_stream_duration_reached = 20;
   */
  upstreamMaxStreamDurationReached: boolean;

  /**
   * Indicates the response was served from a cache filter.
   *
   * @generated from field: bool response_from_cache_filter = 21;
   */
  responseFromCacheFilter: boolean;

  /**
   * Indicates that a filter configuration is not available.
   *
   * @generated from field: bool no_filter_config_found = 22;
   */
  noFilterConfigFound: boolean;

  /**
   * Indicates that request or connection exceeded the downstream connection duration.
   *
   * @generated from field: bool duration_timeout = 23;
   */
  durationTimeout: boolean;

  /**
   * Indicates there was an HTTP protocol error in the upstream response.
   *
   * @generated from field: bool upstream_protocol_error = 24;
   */
  upstreamProtocolError: boolean;

  /**
   * Indicates no cluster was found for the request.
   *
   * @generated from field: bool no_cluster_found = 25;
   */
  noClusterFound: boolean;

  /**
   * Indicates overload manager terminated the request.
   *
   * @generated from field: bool overload_manager = 26;
   */
  overloadManager: boolean;

  /**
   * Indicates a DNS resolution failed.
   *
   * @generated from field: bool dns_resolution_failure = 27;
   */
  dnsResolutionFailure: boolean;

  constructor(data?: PartialMessage<ResponseFlags>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.ResponseFlags";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseFlags;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseFlags;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseFlags;

  static equals(a: ResponseFlags | PlainMessage<ResponseFlags> | undefined, b: ResponseFlags | PlainMessage<ResponseFlags> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v3.ResponseFlags.Unauthorized
 */
export declare class ResponseFlags_Unauthorized extends Message<ResponseFlags_Unauthorized> {
  /**
   * @generated from field: envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason reason = 1;
   */
  reason: ResponseFlags_Unauthorized_Reason;

  constructor(data?: PartialMessage<ResponseFlags_Unauthorized>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.ResponseFlags.Unauthorized";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseFlags_Unauthorized;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseFlags_Unauthorized;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseFlags_Unauthorized;

  static equals(a: ResponseFlags_Unauthorized | PlainMessage<ResponseFlags_Unauthorized> | undefined, b: ResponseFlags_Unauthorized | PlainMessage<ResponseFlags_Unauthorized> | undefined): boolean;
}

/**
 * Reasons why the request was unauthorized
 *
 * @generated from enum envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason
 */
export declare enum ResponseFlags_Unauthorized_Reason {
  /**
   * @generated from enum value: REASON_UNSPECIFIED = 0;
   */
  REASON_UNSPECIFIED = 0,

  /**
   * The request was denied by the external authorization service.
   *
   * @generated from enum value: EXTERNAL_SERVICE = 1;
   */
  EXTERNAL_SERVICE = 1,
}

/**
 * Properties of a negotiated TLS connection.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.data.accesslog.v3.TLSProperties
 */
export declare class TLSProperties extends Message<TLSProperties> {
  /**
   * Version of TLS that was negotiated.
   *
   * @generated from field: envoy.data.accesslog.v3.TLSProperties.TLSVersion tls_version = 1;
   */
  tlsVersion: TLSProperties_TLSVersion;

  /**
   * TLS cipher suite negotiated during handshake. The value is a
   * four-digit hex code defined by the IANA TLS Cipher Suite Registry
   * (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
   *
   * Here it is expressed as an integer.
   *
   * @generated from field: google.protobuf.UInt32Value tls_cipher_suite = 2;
   */
  tlsCipherSuite?: number;

  /**
   * SNI hostname from handshake.
   *
   * @generated from field: string tls_sni_hostname = 3;
   */
  tlsSniHostname: string;

  /**
   * Properties of the local certificate used to negotiate TLS.
   *
   * @generated from field: envoy.data.accesslog.v3.TLSProperties.CertificateProperties local_certificate_properties = 4;
   */
  localCertificateProperties?: TLSProperties_CertificateProperties;

  /**
   * Properties of the peer certificate used to negotiate TLS.
   *
   * @generated from field: envoy.data.accesslog.v3.TLSProperties.CertificateProperties peer_certificate_properties = 5;
   */
  peerCertificateProperties?: TLSProperties_CertificateProperties;

  /**
   * The TLS session ID.
   *
   * @generated from field: string tls_session_id = 6;
   */
  tlsSessionId: string;

  /**
   * The ``JA3`` fingerprint when ``JA3`` fingerprinting is enabled.
   *
   * @generated from field: string ja3_fingerprint = 7;
   */
  ja3Fingerprint: string;

  constructor(data?: PartialMessage<TLSProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.TLSProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties;

  static equals(a: TLSProperties | PlainMessage<TLSProperties> | undefined, b: TLSProperties | PlainMessage<TLSProperties> | undefined): boolean;
}

/**
 * @generated from enum envoy.data.accesslog.v3.TLSProperties.TLSVersion
 */
export declare enum TLSProperties_TLSVersion {
  /**
   * @generated from enum value: VERSION_UNSPECIFIED = 0;
   */
  VERSION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: TLSv1 = 1;
   */
  TLSv1 = 1,

  /**
   * @generated from enum value: TLSv1_1 = 2;
   */
  TLSv1_1 = 2,

  /**
   * @generated from enum value: TLSv1_2 = 3;
   */
  TLSv1_2 = 3,

  /**
   * @generated from enum value: TLSv1_3 = 4;
   */
  TLSv1_3 = 4,
}

/**
 * @generated from message envoy.data.accesslog.v3.TLSProperties.CertificateProperties
 */
export declare class TLSProperties_CertificateProperties extends Message<TLSProperties_CertificateProperties> {
  /**
   * SANs present in the certificate.
   *
   * @generated from field: repeated envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName subject_alt_name = 1;
   */
  subjectAltName: TLSProperties_CertificateProperties_SubjectAltName[];

  /**
   * The subject field of the certificate.
   *
   * @generated from field: string subject = 2;
   */
  subject: string;

  constructor(data?: PartialMessage<TLSProperties_CertificateProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.TLSProperties.CertificateProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties_CertificateProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties;

  static equals(a: TLSProperties_CertificateProperties | PlainMessage<TLSProperties_CertificateProperties> | undefined, b: TLSProperties_CertificateProperties | PlainMessage<TLSProperties_CertificateProperties> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName
 */
export declare class TLSProperties_CertificateProperties_SubjectAltName extends Message<TLSProperties_CertificateProperties_SubjectAltName> {
  /**
   * @generated from oneof envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName.san
   */
  san: {
    /**
     * @generated from field: string uri = 1;
     */
    value: string;
    case: "uri";
  } | {
    /**
     * [#not-implemented-hide:]
     *
     * @generated from field: string dns = 2;
     */
    value: string;
    case: "dns";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<TLSProperties_CertificateProperties_SubjectAltName>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static equals(a: TLSProperties_CertificateProperties_SubjectAltName | PlainMessage<TLSProperties_CertificateProperties_SubjectAltName> | undefined, b: TLSProperties_CertificateProperties_SubjectAltName | PlainMessage<TLSProperties_CertificateProperties_SubjectAltName> | undefined): boolean;
}

/**
 * [#next-free-field: 16]
 *
 * @generated from message envoy.data.accesslog.v3.HTTPRequestProperties
 */
export declare class HTTPRequestProperties extends Message<HTTPRequestProperties> {
  /**
   * The request method (RFC 7231/2616).
   *
   * @generated from field: envoy.config.core.v3.RequestMethod request_method = 1;
   */
  requestMethod: RequestMethod;

  /**
   * The scheme portion of the incoming request URI.
   *
   * @generated from field: string scheme = 2;
   */
  scheme: string;

  /**
   * HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
   *
   * @generated from field: string authority = 3;
   */
  authority: string;

  /**
   * The port of the incoming request URI
   * (unused currently, as port is composed onto authority).
   *
   * @generated from field: google.protobuf.UInt32Value port = 4;
   */
  port?: number;

  /**
   * The path portion from the incoming request URI.
   *
   * @generated from field: string path = 5;
   */
  path: string;

  /**
   * Value of the ``User-Agent`` request header.
   *
   * @generated from field: string user_agent = 6;
   */
  userAgent: string;

  /**
   * Value of the ``Referer`` request header.
   *
   * @generated from field: string referer = 7;
   */
  referer: string;

  /**
   * Value of the ``X-Forwarded-For`` request header.
   *
   * @generated from field: string forwarded_for = 8;
   */
  forwardedFor: string;

  /**
   * Value of the ``X-Request-Id`` request header
   *
   * This header is used by Envoy to uniquely identify a request.
   * It will be generated for all external requests and internal requests that
   * do not already have a request ID.
   *
   * @generated from field: string request_id = 9;
   */
  requestId: string;

  /**
   * Value of the ``X-Envoy-Original-Path`` request header.
   *
   * @generated from field: string original_path = 10;
   */
  originalPath: string;

  /**
   * Size of the HTTP request headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 request_headers_bytes = 11;
   */
  requestHeadersBytes: bigint;

  /**
   * Size of the HTTP request body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 request_body_bytes = 12;
   */
  requestBodyBytes: bigint;

  /**
   * Map of additional headers that have been configured to be logged.
   *
   * @generated from field: map<string, string> request_headers = 13;
   */
  requestHeaders: { [key: string]: string };

  /**
   * Number of header bytes sent to the upstream by the http stream, including protocol overhead.
   *
   * This value accumulates during upstream retries.
   *
   * @generated from field: uint64 upstream_header_bytes_sent = 14;
   */
  upstreamHeaderBytesSent: bigint;

  /**
   * Number of header bytes received from the downstream by the http stream, including protocol overhead.
   *
   * @generated from field: uint64 downstream_header_bytes_received = 15;
   */
  downstreamHeaderBytesReceived: bigint;

  constructor(data?: PartialMessage<HTTPRequestProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.HTTPRequestProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPRequestProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPRequestProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPRequestProperties;

  static equals(a: HTTPRequestProperties | PlainMessage<HTTPRequestProperties> | undefined, b: HTTPRequestProperties | PlainMessage<HTTPRequestProperties> | undefined): boolean;
}

/**
 * [#next-free-field: 9]
 *
 * @generated from message envoy.data.accesslog.v3.HTTPResponseProperties
 */
export declare class HTTPResponseProperties extends Message<HTTPResponseProperties> {
  /**
   * The HTTP response code returned by Envoy.
   *
   * @generated from field: google.protobuf.UInt32Value response_code = 1;
   */
  responseCode?: number;

  /**
   * Size of the HTTP response headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include protocol overhead or overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 response_headers_bytes = 2;
   */
  responseHeadersBytes: bigint;

  /**
   * Size of the HTTP response body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 response_body_bytes = 3;
   */
  responseBodyBytes: bigint;

  /**
   * Map of additional headers configured to be logged.
   *
   * @generated from field: map<string, string> response_headers = 4;
   */
  responseHeaders: { [key: string]: string };

  /**
   * Map of trailers configured to be logged.
   *
   * @generated from field: map<string, string> response_trailers = 5;
   */
  responseTrailers: { [key: string]: string };

  /**
   * The HTTP response code details.
   *
   * @generated from field: string response_code_details = 6;
   */
  responseCodeDetails: string;

  /**
   * Number of header bytes received from the upstream by the http stream, including protocol overhead.
   *
   * @generated from field: uint64 upstream_header_bytes_received = 7;
   */
  upstreamHeaderBytesReceived: bigint;

  /**
   * Number of header bytes sent to the downstream by the http stream, including protocol overhead.
   *
   * @generated from field: uint64 downstream_header_bytes_sent = 8;
   */
  downstreamHeaderBytesSent: bigint;

  constructor(data?: PartialMessage<HTTPResponseProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v3.HTTPResponseProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPResponseProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPResponseProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPResponseProperties;

  static equals(a: HTTPResponseProperties | PlainMessage<HTTPResponseProperties> | undefined, b: HTTPResponseProperties | PlainMessage<HTTPResponseProperties> | undefined): boolean;
}

