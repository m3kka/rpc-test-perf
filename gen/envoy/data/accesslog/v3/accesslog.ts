// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/data/accesslog/v3/accesslog.proto" (package "envoy.data.accesslog.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RequestMethod } from "../../../config/core/v3/base";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
import { Metadata } from "../../../config/core/v3/base";
import { Duration } from "../../../../google/protobuf/duration";
import { Timestamp } from "../../../../google/protobuf/timestamp";
import { Address } from "../../../config/core/v3/address";
/**
 * @generated from protobuf message envoy.data.accesslog.v3.TCPAccessLogEntry
 */
export interface TCPAccessLogEntry {
    /**
     * Common properties shared by all Envoy access logs.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.AccessLogCommon common_properties = 1;
     */
    commonProperties?: AccessLogCommon;
    /**
     * Properties of the TCP connection.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.ConnectionProperties connection_properties = 2;
     */
    connectionProperties?: ConnectionProperties;
}
/**
 * @generated from protobuf message envoy.data.accesslog.v3.HTTPAccessLogEntry
 */
export interface HTTPAccessLogEntry {
    /**
     * Common properties shared by all Envoy access logs.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.AccessLogCommon common_properties = 1;
     */
    commonProperties?: AccessLogCommon;
    /**
     * @generated from protobuf field: envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion protocol_version = 2;
     */
    protocolVersion: HTTPAccessLogEntry_HTTPVersion;
    /**
     * Description of the incoming HTTP request.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.HTTPRequestProperties request = 3;
     */
    request?: HTTPRequestProperties;
    /**
     * Description of the outgoing HTTP response.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.HTTPResponseProperties response = 4;
     */
    response?: HTTPResponseProperties;
}
/**
 * HTTP version
 *
 * @generated from protobuf enum envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion
 */
export enum HTTPAccessLogEntry_HTTPVersion {
    /**
     * @generated from protobuf enum value: PROTOCOL_UNSPECIFIED = 0;
     */
    PROTOCOL_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HTTP10 = 1;
     */
    HTTP10 = 1,
    /**
     * @generated from protobuf enum value: HTTP11 = 2;
     */
    HTTP11 = 2,
    /**
     * @generated from protobuf enum value: HTTP2 = 3;
     */
    HTTP2 = 3,
    /**
     * @generated from protobuf enum value: HTTP3 = 4;
     */
    HTTP3 = 4
}
/**
 * Defines fields for a connection
 *
 * @generated from protobuf message envoy.data.accesslog.v3.ConnectionProperties
 */
export interface ConnectionProperties {
    /**
     * Number of bytes received from downstream.
     *
     * @generated from protobuf field: uint64 received_bytes = 1;
     */
    receivedBytes: bigint;
    /**
     * Number of bytes sent to downstream.
     *
     * @generated from protobuf field: uint64 sent_bytes = 2;
     */
    sentBytes: bigint;
}
/**
 * Defines fields that are shared by all Envoy access logs.
 * [#next-free-field: 34]
 *
 * @generated from protobuf message envoy.data.accesslog.v3.AccessLogCommon
 */
export interface AccessLogCommon {
    /**
     * [#not-implemented-hide:]
     * This field indicates the rate at which this log entry was sampled.
     * Valid range is (0.0, 1.0].
     *
     * @generated from protobuf field: double sample_rate = 1;
     */
    sampleRate: number;
    /**
     * This field is the remote/origin address on which the request from the user was received.
     * Note: This may not be the physical peer. E.g, if the remote address is inferred from for
     * example the x-forwarder-for header, proxy protocol, etc.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address downstream_remote_address = 2;
     */
    downstreamRemoteAddress?: Address;
    /**
     * This field is the local/destination address on which the request from the user was received.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address downstream_local_address = 3;
     */
    downstreamLocalAddress?: Address;
    /**
     * If the connection is secure,S this field will contain TLS properties.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.TLSProperties tls_properties = 4;
     */
    tlsProperties?: TLSProperties;
    /**
     * The time that Envoy started servicing this request. This is effectively the time that the first
     * downstream byte is received.
     *
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 5;
     */
    startTime?: Timestamp;
    /**
     * Interval between the first downstream byte received and the last
     * downstream byte received (i.e. time it takes to receive a request).
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_last_rx_byte = 6;
     */
    timeToLastRxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the first upstream byte sent. There may
     * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
     * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
     * not accounting for kernel socket buffer time, etc.
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_first_upstream_tx_byte = 7;
     */
    timeToFirstUpstreamTxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the last upstream byte sent. There may
     * by considerable delta between ``time_to_last_rx_byte`` and this value due to filters.
     * Additionally, the same caveats apply as documented in ``time_to_last_downstream_tx_byte`` about
     * not accounting for kernel socket buffer time, etc.
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_last_upstream_tx_byte = 8;
     */
    timeToLastUpstreamTxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the first upstream
     * byte received (i.e. time it takes to start receiving a response).
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_first_upstream_rx_byte = 9;
     */
    timeToFirstUpstreamRxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the last upstream
     * byte received (i.e. time it takes to receive a complete response).
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_last_upstream_rx_byte = 10;
     */
    timeToLastUpstreamRxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the first downstream byte sent.
     * There may be a considerable delta between the ``time_to_first_upstream_rx_byte`` and this field
     * due to filters. Additionally, the same caveats apply as documented in
     * ``time_to_last_downstream_tx_byte`` about not accounting for kernel socket buffer time, etc.
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_first_downstream_tx_byte = 11;
     */
    timeToFirstDownstreamTxByte?: Duration;
    /**
     * Interval between the first downstream byte received and the last downstream byte sent.
     * Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
     * between ``time_to_last_upstream_rx_byte`` and this field. Note also that this is an approximate
     * time. In the current implementation it does not include kernel socket buffer time. In the
     * current implementation it also does not include send window buffering inside the HTTP/2 codec.
     * In the future it is likely that work will be done to make this duration more accurate.
     *
     * @generated from protobuf field: google.protobuf.Duration time_to_last_downstream_tx_byte = 12;
     */
    timeToLastDownstreamTxByte?: Duration;
    /**
     * The upstream remote/destination address that handles this exchange. This does not include
     * retries.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address upstream_remote_address = 13;
     */
    upstreamRemoteAddress?: Address;
    /**
     * The upstream local/origin address that handles this exchange. This does not include retries.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address upstream_local_address = 14;
     */
    upstreamLocalAddress?: Address;
    /**
     * The upstream cluster that ``upstream_remote_address`` belongs to.
     *
     * @generated from protobuf field: string upstream_cluster = 15;
     */
    upstreamCluster: string;
    /**
     * Flags indicating occurrences during request/response processing.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.ResponseFlags response_flags = 16;
     */
    responseFlags?: ResponseFlags;
    /**
     * All metadata encountered during request processing, including endpoint
     * selection.
     *
     * This can be used to associate IDs attached to the various configurations
     * used to process this request with the access log entry. For example, a
     * route created from a higher level forwarding rule with some ID can place
     * that ID in this field and cross reference later. It can also be used to
     * determine if a canary endpoint was used or not.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 17;
     */
    metadata?: Metadata;
    /**
     * If upstream connection failed due to transport socket (e.g. TLS handshake), provides the
     * failure reason from the transport socket. The format of this field depends on the configured
     * upstream transport socket. Common TLS failures are in
     * :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
     *
     * @generated from protobuf field: string upstream_transport_failure_reason = 18;
     */
    upstreamTransportFailureReason: string;
    /**
     * The name of the route
     *
     * @generated from protobuf field: string route_name = 19;
     */
    routeName: string;
    /**
     * This field is the downstream direct remote address on which the request from the user was
     * received. Note: This is always the physical peer, even if the remote address is inferred from
     * for example the x-forwarder-for header, proxy protocol, etc.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address downstream_direct_remote_address = 20;
     */
    downstreamDirectRemoteAddress?: Address;
    /**
     * Map of filter state in stream info that have been configured to be logged. If the filter
     * state serialized to any message other than ``google.protobuf.Any`` it will be packed into
     * ``google.protobuf.Any``.
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> filter_state_objects = 21;
     */
    filterStateObjects: {
        [key: string]: Any;
    };
    /**
     * A list of custom tags, which annotate logs with additional information.
     * To configure this value, users should configure
     * :ref:`custom_tags <envoy_v3_api_field_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig.custom_tags>`.
     *
     * @generated from protobuf field: map<string, string> custom_tags = 22;
     */
    customTags: {
        [key: string]: string;
    };
    /**
     * For HTTP: Total duration in milliseconds of the request from the start time to the last byte out.
     * For TCP: Total duration in milliseconds of the downstream connection.
     * This is the total duration of the request (i.e., when the request's ActiveStream is destroyed)
     * and may be longer than ``time_to_last_downstream_tx_byte``.
     *
     * @generated from protobuf field: google.protobuf.Duration duration = 23;
     */
    duration?: Duration;
    /**
     * For HTTP: Number of times the request is attempted upstream. Note that the field is omitted when the request was never attempted upstream.
     * For TCP: Number of times the connection request is attempted upstream. Note that the field is omitted when the connect request was never attempted upstream.
     *
     * @generated from protobuf field: uint32 upstream_request_attempt_count = 24;
     */
    upstreamRequestAttemptCount: number;
    /**
     * Connection termination details may provide additional information about why the connection was terminated by Envoy for L4 reasons.
     *
     * @generated from protobuf field: string connection_termination_details = 25;
     */
    connectionTerminationDetails: string;
    /**
     * Optional unique id of stream (TCP connection, long-live HTTP2 stream, HTTP request) for logging and tracing.
     * This could be any format string that could be used to identify one stream.
     *
     * @generated from protobuf field: string stream_id = 26;
     */
    streamId: string;
    /**
     * If this log entry is final log entry that flushed after the stream completed or
     * intermediate log entry that flushed periodically during the stream.
     * There may be multiple intermediate log entries and only one final log entry for each
     * long-live stream (TCP connection, long-live HTTP2 stream).
     * And if it is necessary, unique ID or identifier can be added to the log entry
     * :ref:`stream_id <envoy_v3_api_field_data.accesslog.v3.AccessLogCommon.stream_id>` to
     * correlate all these intermediate log entries and final log entry.
     *
     * .. attention::
     *
     *   This field is deprecated in favor of ``access_log_type`` for better indication of the
     *   type of the access log record.
     *
     * @deprecated
     * @generated from protobuf field: bool intermediate_log_entry = 27 [deprecated = true];
     */
    intermediateLogEntry: boolean;
    /**
     * If downstream connection in listener failed due to transport socket (e.g. TLS handshake), provides the
     * failure reason from the transport socket. The format of this field depends on the configured downstream
     * transport socket. Common TLS failures are in :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
     *
     * @generated from protobuf field: string downstream_transport_failure_reason = 28;
     */
    downstreamTransportFailureReason: string;
    /**
     * For HTTP: Total number of bytes sent to the downstream by the http stream.
     * For TCP: Total number of bytes sent to the downstream by the tcp proxy.
     *
     * @generated from protobuf field: uint64 downstream_wire_bytes_sent = 29;
     */
    downstreamWireBytesSent: bigint;
    /**
     * For HTTP: Total number of bytes received from the downstream by the http stream. Envoy over counts sizes of received HTTP/1.1 pipelined requests by adding up bytes of requests in the pipeline to the one currently being processed.
     * For TCP: Total number of bytes received from the downstream by the tcp proxy.
     *
     * @generated from protobuf field: uint64 downstream_wire_bytes_received = 30;
     */
    downstreamWireBytesReceived: bigint;
    /**
     * For HTTP: Total number of bytes sent to the upstream by the http stream. This value accumulates during upstream retries.
     * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
     *
     * @generated from protobuf field: uint64 upstream_wire_bytes_sent = 31;
     */
    upstreamWireBytesSent: bigint;
    /**
     * For HTTP: Total number of bytes received from the upstream by the http stream.
     * For TCP: Total number of bytes sent to the upstream by the tcp proxy.
     *
     * @generated from protobuf field: uint64 upstream_wire_bytes_received = 32;
     */
    upstreamWireBytesReceived: bigint;
    /**
     * The type of the access log, which indicates when the log was recorded.
     * See :ref:`ACCESS_LOG_TYPE <config_access_log_format_access_log_type>` for the available values.
     * In case the access log was recorded by a flow which does not correspond to one of the supported
     * values, then the default value will be ``NotSet``.
     * For more information about how access log behaves and when it is being recorded,
     * please refer to :ref:`access logging <arch_overview_access_logs>`.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.AccessLogType access_log_type = 33;
     */
    accessLogType: AccessLogType;
}
/**
 * Flags indicating occurrences during request/response processing.
 * [#next-free-field: 28]
 *
 * @generated from protobuf message envoy.data.accesslog.v3.ResponseFlags
 */
export interface ResponseFlags {
    /**
     * Indicates local server healthcheck failed.
     *
     * @generated from protobuf field: bool failed_local_healthcheck = 1;
     */
    failedLocalHealthcheck: boolean;
    /**
     * Indicates there was no healthy upstream.
     *
     * @generated from protobuf field: bool no_healthy_upstream = 2;
     */
    noHealthyUpstream: boolean;
    /**
     * Indicates an there was an upstream request timeout.
     *
     * @generated from protobuf field: bool upstream_request_timeout = 3;
     */
    upstreamRequestTimeout: boolean;
    /**
     * Indicates local codec level reset was sent on the stream.
     *
     * @generated from protobuf field: bool local_reset = 4;
     */
    localReset: boolean;
    /**
     * Indicates remote codec level reset was received on the stream.
     *
     * @generated from protobuf field: bool upstream_remote_reset = 5;
     */
    upstreamRemoteReset: boolean;
    /**
     * Indicates there was a local reset by a connection pool due to an initial connection failure.
     *
     * @generated from protobuf field: bool upstream_connection_failure = 6;
     */
    upstreamConnectionFailure: boolean;
    /**
     * Indicates the stream was reset due to an upstream connection termination.
     *
     * @generated from protobuf field: bool upstream_connection_termination = 7;
     */
    upstreamConnectionTermination: boolean;
    /**
     * Indicates the stream was reset because of a resource overflow.
     *
     * @generated from protobuf field: bool upstream_overflow = 8;
     */
    upstreamOverflow: boolean;
    /**
     * Indicates no route was found for the request.
     *
     * @generated from protobuf field: bool no_route_found = 9;
     */
    noRouteFound: boolean;
    /**
     * Indicates that the request was delayed before proxying.
     *
     * @generated from protobuf field: bool delay_injected = 10;
     */
    delayInjected: boolean;
    /**
     * Indicates that the request was aborted with an injected error code.
     *
     * @generated from protobuf field: bool fault_injected = 11;
     */
    faultInjected: boolean;
    /**
     * Indicates that the request was rate-limited locally.
     *
     * @generated from protobuf field: bool rate_limited = 12;
     */
    rateLimited: boolean;
    /**
     * Indicates if the request was deemed unauthorized and the reason for it.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13;
     */
    unauthorizedDetails?: ResponseFlags_Unauthorized;
    /**
     * Indicates that the request was rejected because there was an error in rate limit service.
     *
     * @generated from protobuf field: bool rate_limit_service_error = 14;
     */
    rateLimitServiceError: boolean;
    /**
     * Indicates the stream was reset due to a downstream connection termination.
     *
     * @generated from protobuf field: bool downstream_connection_termination = 15;
     */
    downstreamConnectionTermination: boolean;
    /**
     * Indicates that the upstream retry limit was exceeded, resulting in a downstream error.
     *
     * @generated from protobuf field: bool upstream_retry_limit_exceeded = 16;
     */
    upstreamRetryLimitExceeded: boolean;
    /**
     * Indicates that the stream idle timeout was hit, resulting in a downstream 408.
     *
     * @generated from protobuf field: bool stream_idle_timeout = 17;
     */
    streamIdleTimeout: boolean;
    /**
     * Indicates that the request was rejected because an envoy request header failed strict
     * validation.
     *
     * @generated from protobuf field: bool invalid_envoy_request_headers = 18;
     */
    invalidEnvoyRequestHeaders: boolean;
    /**
     * Indicates there was an HTTP protocol error on the downstream request.
     *
     * @generated from protobuf field: bool downstream_protocol_error = 19;
     */
    downstreamProtocolError: boolean;
    /**
     * Indicates there was a max stream duration reached on the upstream request.
     *
     * @generated from protobuf field: bool upstream_max_stream_duration_reached = 20;
     */
    upstreamMaxStreamDurationReached: boolean;
    /**
     * Indicates the response was served from a cache filter.
     *
     * @generated from protobuf field: bool response_from_cache_filter = 21;
     */
    responseFromCacheFilter: boolean;
    /**
     * Indicates that a filter configuration is not available.
     *
     * @generated from protobuf field: bool no_filter_config_found = 22;
     */
    noFilterConfigFound: boolean;
    /**
     * Indicates that request or connection exceeded the downstream connection duration.
     *
     * @generated from protobuf field: bool duration_timeout = 23;
     */
    durationTimeout: boolean;
    /**
     * Indicates there was an HTTP protocol error in the upstream response.
     *
     * @generated from protobuf field: bool upstream_protocol_error = 24;
     */
    upstreamProtocolError: boolean;
    /**
     * Indicates no cluster was found for the request.
     *
     * @generated from protobuf field: bool no_cluster_found = 25;
     */
    noClusterFound: boolean;
    /**
     * Indicates overload manager terminated the request.
     *
     * @generated from protobuf field: bool overload_manager = 26;
     */
    overloadManager: boolean;
    /**
     * Indicates a DNS resolution failed.
     *
     * @generated from protobuf field: bool dns_resolution_failure = 27;
     */
    dnsResolutionFailure: boolean;
}
/**
 * @generated from protobuf message envoy.data.accesslog.v3.ResponseFlags.Unauthorized
 */
export interface ResponseFlags_Unauthorized {
    /**
     * @generated from protobuf field: envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason reason = 1;
     */
    reason: ResponseFlags_Unauthorized_Reason;
}
/**
 * Reasons why the request was unauthorized
 *
 * @generated from protobuf enum envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason
 */
export enum ResponseFlags_Unauthorized_Reason {
    /**
     * @generated from protobuf enum value: REASON_UNSPECIFIED = 0;
     */
    REASON_UNSPECIFIED = 0,
    /**
     * The request was denied by the external authorization service.
     *
     * @generated from protobuf enum value: EXTERNAL_SERVICE = 1;
     */
    EXTERNAL_SERVICE = 1
}
/**
 * Properties of a negotiated TLS connection.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.data.accesslog.v3.TLSProperties
 */
export interface TLSProperties {
    /**
     * Version of TLS that was negotiated.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.TLSProperties.TLSVersion tls_version = 1;
     */
    tlsVersion: TLSProperties_TLSVersion;
    /**
     * TLS cipher suite negotiated during handshake. The value is a
     * four-digit hex code defined by the IANA TLS Cipher Suite Registry
     * (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
     *
     * Here it is expressed as an integer.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value tls_cipher_suite = 2;
     */
    tlsCipherSuite?: UInt32Value;
    /**
     * SNI hostname from handshake.
     *
     * @generated from protobuf field: string tls_sni_hostname = 3;
     */
    tlsSniHostname: string;
    /**
     * Properties of the local certificate used to negotiate TLS.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.TLSProperties.CertificateProperties local_certificate_properties = 4;
     */
    localCertificateProperties?: TLSProperties_CertificateProperties;
    /**
     * Properties of the peer certificate used to negotiate TLS.
     *
     * @generated from protobuf field: envoy.data.accesslog.v3.TLSProperties.CertificateProperties peer_certificate_properties = 5;
     */
    peerCertificateProperties?: TLSProperties_CertificateProperties;
    /**
     * The TLS session ID.
     *
     * @generated from protobuf field: string tls_session_id = 6;
     */
    tlsSessionId: string;
    /**
     * The ``JA3`` fingerprint when ``JA3`` fingerprinting is enabled.
     *
     * @generated from protobuf field: string ja3_fingerprint = 7;
     */
    ja3Fingerprint: string;
}
/**
 * @generated from protobuf message envoy.data.accesslog.v3.TLSProperties.CertificateProperties
 */
export interface TLSProperties_CertificateProperties {
    /**
     * SANs present in the certificate.
     *
     * @generated from protobuf field: repeated envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName subject_alt_name = 1;
     */
    subjectAltName: TLSProperties_CertificateProperties_SubjectAltName[];
    /**
     * The subject field of the certificate.
     *
     * @generated from protobuf field: string subject = 2;
     */
    subject: string;
}
/**
 * @generated from protobuf message envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName
 */
export interface TLSProperties_CertificateProperties_SubjectAltName {
    /**
     * @generated from protobuf oneof: san
     */
    san: {
        oneofKind: "uri";
        /**
         * @generated from protobuf field: string uri = 1;
         */
        uri: string;
    } | {
        oneofKind: "dns";
        /**
         * [#not-implemented-hide:]
         *
         * @generated from protobuf field: string dns = 2;
         */
        dns: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum envoy.data.accesslog.v3.TLSProperties.TLSVersion
 */
export enum TLSProperties_TLSVersion {
    /**
     * @generated from protobuf enum value: VERSION_UNSPECIFIED = 0;
     */
    VERSION_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TLSv1 = 1;
     */
    TLSv1 = 1,
    /**
     * @generated from protobuf enum value: TLSv1_1 = 2;
     */
    TLSv1_1 = 2,
    /**
     * @generated from protobuf enum value: TLSv1_2 = 3;
     */
    TLSv1_2 = 3,
    /**
     * @generated from protobuf enum value: TLSv1_3 = 4;
     */
    TLSv1_3 = 4
}
/**
 * [#next-free-field: 16]
 *
 * @generated from protobuf message envoy.data.accesslog.v3.HTTPRequestProperties
 */
export interface HTTPRequestProperties {
    /**
     * The request method (RFC 7231/2616).
     *
     * @generated from protobuf field: envoy.config.core.v3.RequestMethod request_method = 1;
     */
    requestMethod: RequestMethod;
    /**
     * The scheme portion of the incoming request URI.
     *
     * @generated from protobuf field: string scheme = 2;
     */
    scheme: string;
    /**
     * HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
     *
     * @generated from protobuf field: string authority = 3;
     */
    authority: string;
    /**
     * The port of the incoming request URI
     * (unused currently, as port is composed onto authority).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value port = 4;
     */
    port?: UInt32Value;
    /**
     * The path portion from the incoming request URI.
     *
     * @generated from protobuf field: string path = 5;
     */
    path: string;
    /**
     * Value of the ``User-Agent`` request header.
     *
     * @generated from protobuf field: string user_agent = 6;
     */
    userAgent: string;
    /**
     * Value of the ``Referer`` request header.
     *
     * @generated from protobuf field: string referer = 7;
     */
    referer: string;
    /**
     * Value of the ``X-Forwarded-For`` request header.
     *
     * @generated from protobuf field: string forwarded_for = 8;
     */
    forwardedFor: string;
    /**
     * Value of the ``X-Request-Id`` request header
     *
     * This header is used by Envoy to uniquely identify a request.
     * It will be generated for all external requests and internal requests that
     * do not already have a request ID.
     *
     * @generated from protobuf field: string request_id = 9;
     */
    requestId: string;
    /**
     * Value of the ``X-Envoy-Original-Path`` request header.
     *
     * @generated from protobuf field: string original_path = 10;
     */
    originalPath: string;
    /**
     * Size of the HTTP request headers in bytes.
     *
     * This value is captured from the OSI layer 7 perspective, i.e. it does not
     * include overhead from framing or encoding at other networking layers.
     *
     * @generated from protobuf field: uint64 request_headers_bytes = 11;
     */
    requestHeadersBytes: bigint;
    /**
     * Size of the HTTP request body in bytes.
     *
     * This value is captured from the OSI layer 7 perspective, i.e. it does not
     * include overhead from framing or encoding at other networking layers.
     *
     * @generated from protobuf field: uint64 request_body_bytes = 12;
     */
    requestBodyBytes: bigint;
    /**
     * Map of additional headers that have been configured to be logged.
     *
     * @generated from protobuf field: map<string, string> request_headers = 13;
     */
    requestHeaders: {
        [key: string]: string;
    };
    /**
     * Number of header bytes sent to the upstream by the http stream, including protocol overhead.
     *
     * This value accumulates during upstream retries.
     *
     * @generated from protobuf field: uint64 upstream_header_bytes_sent = 14;
     */
    upstreamHeaderBytesSent: bigint;
    /**
     * Number of header bytes received from the downstream by the http stream, including protocol overhead.
     *
     * @generated from protobuf field: uint64 downstream_header_bytes_received = 15;
     */
    downstreamHeaderBytesReceived: bigint;
}
/**
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.data.accesslog.v3.HTTPResponseProperties
 */
export interface HTTPResponseProperties {
    /**
     * The HTTP response code returned by Envoy.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value response_code = 1;
     */
    responseCode?: UInt32Value;
    /**
     * Size of the HTTP response headers in bytes.
     *
     * This value is captured from the OSI layer 7 perspective, i.e. it does not
     * include protocol overhead or overhead from framing or encoding at other networking layers.
     *
     * @generated from protobuf field: uint64 response_headers_bytes = 2;
     */
    responseHeadersBytes: bigint;
    /**
     * Size of the HTTP response body in bytes.
     *
     * This value is captured from the OSI layer 7 perspective, i.e. it does not
     * include overhead from framing or encoding at other networking layers.
     *
     * @generated from protobuf field: uint64 response_body_bytes = 3;
     */
    responseBodyBytes: bigint;
    /**
     * Map of additional headers configured to be logged.
     *
     * @generated from protobuf field: map<string, string> response_headers = 4;
     */
    responseHeaders: {
        [key: string]: string;
    };
    /**
     * Map of trailers configured to be logged.
     *
     * @generated from protobuf field: map<string, string> response_trailers = 5;
     */
    responseTrailers: {
        [key: string]: string;
    };
    /**
     * The HTTP response code details.
     *
     * @generated from protobuf field: string response_code_details = 6;
     */
    responseCodeDetails: string;
    /**
     * Number of header bytes received from the upstream by the http stream, including protocol overhead.
     *
     * @generated from protobuf field: uint64 upstream_header_bytes_received = 7;
     */
    upstreamHeaderBytesReceived: bigint;
    /**
     * Number of header bytes sent to the downstream by the http stream, including protocol overhead.
     *
     * @generated from protobuf field: uint64 downstream_header_bytes_sent = 8;
     */
    downstreamHeaderBytesSent: bigint;
}
// [#protodoc-title: gRPC access logs]
// Envoy access logs describe incoming interaction with Envoy over a fixed
// period of time, and typically cover a single request/response exchange,
// (e.g. HTTP), stream (e.g. over HTTP/gRPC), or proxied connection (e.g. TCP).
// Access logs contain fields defined in protocol-specific protobuf messages.
// 
// Except where explicitly declared otherwise, all fields describe
// *downstream* interaction between Envoy and a connected client.
// Fields describing *upstream* interaction will explicitly include ``upstream``
// in their name.

/**
 * @generated from protobuf enum envoy.data.accesslog.v3.AccessLogType
 */
export enum AccessLogType {
    /**
     * @generated from protobuf enum value: NotSet = 0;
     */
    NotSet = 0,
    /**
     * @generated from protobuf enum value: TcpUpstreamConnected = 1;
     */
    TcpUpstreamConnected = 1,
    /**
     * @generated from protobuf enum value: TcpPeriodic = 2;
     */
    TcpPeriodic = 2,
    /**
     * @generated from protobuf enum value: TcpConnectionEnd = 3;
     */
    TcpConnectionEnd = 3,
    /**
     * @generated from protobuf enum value: DownstreamStart = 4;
     */
    DownstreamStart = 4,
    /**
     * @generated from protobuf enum value: DownstreamPeriodic = 5;
     */
    DownstreamPeriodic = 5,
    /**
     * @generated from protobuf enum value: DownstreamEnd = 6;
     */
    DownstreamEnd = 6,
    /**
     * @generated from protobuf enum value: UpstreamPoolReady = 7;
     */
    UpstreamPoolReady = 7,
    /**
     * @generated from protobuf enum value: UpstreamPeriodic = 8;
     */
    UpstreamPeriodic = 8,
    /**
     * @generated from protobuf enum value: UpstreamEnd = 9;
     */
    UpstreamEnd = 9,
    /**
     * @generated from protobuf enum value: DownstreamTunnelSuccessfullyEstablished = 10;
     */
    DownstreamTunnelSuccessfullyEstablished = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class TCPAccessLogEntry$Type extends MessageType<TCPAccessLogEntry> {
    constructor() {
        super("envoy.data.accesslog.v3.TCPAccessLogEntry", [
            { no: 1, name: "common_properties", kind: "message", T: () => AccessLogCommon },
            { no: 2, name: "connection_properties", kind: "message", T: () => ConnectionProperties }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.TCPAccessLogEntry" } });
    }
    create(value?: PartialMessage<TCPAccessLogEntry>): TCPAccessLogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TCPAccessLogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TCPAccessLogEntry): TCPAccessLogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.accesslog.v3.AccessLogCommon common_properties */ 1:
                    message.commonProperties = AccessLogCommon.internalBinaryRead(reader, reader.uint32(), options, message.commonProperties);
                    break;
                case /* envoy.data.accesslog.v3.ConnectionProperties connection_properties */ 2:
                    message.connectionProperties = ConnectionProperties.internalBinaryRead(reader, reader.uint32(), options, message.connectionProperties);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TCPAccessLogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.accesslog.v3.AccessLogCommon common_properties = 1; */
        if (message.commonProperties)
            AccessLogCommon.internalBinaryWrite(message.commonProperties, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.accesslog.v3.ConnectionProperties connection_properties = 2; */
        if (message.connectionProperties)
            ConnectionProperties.internalBinaryWrite(message.connectionProperties, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.TCPAccessLogEntry
 */
export const TCPAccessLogEntry = new TCPAccessLogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPAccessLogEntry$Type extends MessageType<HTTPAccessLogEntry> {
    constructor() {
        super("envoy.data.accesslog.v3.HTTPAccessLogEntry", [
            { no: 1, name: "common_properties", kind: "message", T: () => AccessLogCommon },
            { no: 2, name: "protocol_version", kind: "enum", T: () => ["envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion", HTTPAccessLogEntry_HTTPVersion] },
            { no: 3, name: "request", kind: "message", T: () => HTTPRequestProperties },
            { no: 4, name: "response", kind: "message", T: () => HTTPResponseProperties }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.HTTPAccessLogEntry" } });
    }
    create(value?: PartialMessage<HTTPAccessLogEntry>): HTTPAccessLogEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocolVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<HTTPAccessLogEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPAccessLogEntry): HTTPAccessLogEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.accesslog.v3.AccessLogCommon common_properties */ 1:
                    message.commonProperties = AccessLogCommon.internalBinaryRead(reader, reader.uint32(), options, message.commonProperties);
                    break;
                case /* envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion protocol_version */ 2:
                    message.protocolVersion = reader.int32();
                    break;
                case /* envoy.data.accesslog.v3.HTTPRequestProperties request */ 3:
                    message.request = HTTPRequestProperties.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* envoy.data.accesslog.v3.HTTPResponseProperties response */ 4:
                    message.response = HTTPResponseProperties.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPAccessLogEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.accesslog.v3.AccessLogCommon common_properties = 1; */
        if (message.commonProperties)
            AccessLogCommon.internalBinaryWrite(message.commonProperties, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.accesslog.v3.HTTPAccessLogEntry.HTTPVersion protocol_version = 2; */
        if (message.protocolVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.protocolVersion);
        /* envoy.data.accesslog.v3.HTTPRequestProperties request = 3; */
        if (message.request)
            HTTPRequestProperties.internalBinaryWrite(message.request, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.accesslog.v3.HTTPResponseProperties response = 4; */
        if (message.response)
            HTTPResponseProperties.internalBinaryWrite(message.response, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.HTTPAccessLogEntry
 */
export const HTTPAccessLogEntry = new HTTPAccessLogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConnectionProperties$Type extends MessageType<ConnectionProperties> {
    constructor() {
        super("envoy.data.accesslog.v3.ConnectionProperties", [
            { no: 1, name: "received_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sent_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.ConnectionProperties" } });
    }
    create(value?: PartialMessage<ConnectionProperties>): ConnectionProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.receivedBytes = 0n;
        message.sentBytes = 0n;
        if (value !== undefined)
            reflectionMergePartial<ConnectionProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionProperties): ConnectionProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 received_bytes */ 1:
                    message.receivedBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 sent_bytes */ 2:
                    message.sentBytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConnectionProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 received_bytes = 1; */
        if (message.receivedBytes !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.receivedBytes);
        /* uint64 sent_bytes = 2; */
        if (message.sentBytes !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.sentBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.ConnectionProperties
 */
export const ConnectionProperties = new ConnectionProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessLogCommon$Type extends MessageType<AccessLogCommon> {
    constructor() {
        super("envoy.data.accesslog.v3.AccessLogCommon", [
            { no: 1, name: "sample_rate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/, options: { "validate.rules": { double: { lte: 1, gt: 0 } } } },
            { no: 2, name: "downstream_remote_address", kind: "message", T: () => Address },
            { no: 3, name: "downstream_local_address", kind: "message", T: () => Address },
            { no: 4, name: "tls_properties", kind: "message", T: () => TLSProperties },
            { no: 5, name: "start_time", kind: "message", T: () => Timestamp },
            { no: 6, name: "time_to_last_rx_byte", kind: "message", T: () => Duration },
            { no: 7, name: "time_to_first_upstream_tx_byte", kind: "message", T: () => Duration },
            { no: 8, name: "time_to_last_upstream_tx_byte", kind: "message", T: () => Duration },
            { no: 9, name: "time_to_first_upstream_rx_byte", kind: "message", T: () => Duration },
            { no: 10, name: "time_to_last_upstream_rx_byte", kind: "message", T: () => Duration },
            { no: 11, name: "time_to_first_downstream_tx_byte", kind: "message", T: () => Duration },
            { no: 12, name: "time_to_last_downstream_tx_byte", kind: "message", T: () => Duration },
            { no: 13, name: "upstream_remote_address", kind: "message", T: () => Address },
            { no: 14, name: "upstream_local_address", kind: "message", T: () => Address },
            { no: 15, name: "upstream_cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "response_flags", kind: "message", T: () => ResponseFlags },
            { no: 17, name: "metadata", kind: "message", T: () => Metadata },
            { no: 18, name: "upstream_transport_failure_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "route_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "downstream_direct_remote_address", kind: "message", T: () => Address },
            { no: 21, name: "filter_state_objects", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 22, name: "custom_tags", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 23, name: "duration", kind: "message", T: () => Duration },
            { no: 24, name: "upstream_request_attempt_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 25, name: "connection_termination_details", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 26, name: "stream_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 27, name: "intermediate_log_entry", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 28, name: "downstream_transport_failure_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 29, name: "downstream_wire_bytes_sent", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 30, name: "downstream_wire_bytes_received", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 31, name: "upstream_wire_bytes_sent", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 32, name: "upstream_wire_bytes_received", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 33, name: "access_log_type", kind: "enum", T: () => ["envoy.data.accesslog.v3.AccessLogType", AccessLogType] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.AccessLogCommon" } });
    }
    create(value?: PartialMessage<AccessLogCommon>): AccessLogCommon {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleRate = 0;
        message.upstreamCluster = "";
        message.upstreamTransportFailureReason = "";
        message.routeName = "";
        message.filterStateObjects = {};
        message.customTags = {};
        message.upstreamRequestAttemptCount = 0;
        message.connectionTerminationDetails = "";
        message.streamId = "";
        message.intermediateLogEntry = false;
        message.downstreamTransportFailureReason = "";
        message.downstreamWireBytesSent = 0n;
        message.downstreamWireBytesReceived = 0n;
        message.upstreamWireBytesSent = 0n;
        message.upstreamWireBytesReceived = 0n;
        message.accessLogType = 0;
        if (value !== undefined)
            reflectionMergePartial<AccessLogCommon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessLogCommon): AccessLogCommon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double sample_rate */ 1:
                    message.sampleRate = reader.double();
                    break;
                case /* envoy.config.core.v3.Address downstream_remote_address */ 2:
                    message.downstreamRemoteAddress = Address.internalBinaryRead(reader, reader.uint32(), options, message.downstreamRemoteAddress);
                    break;
                case /* envoy.config.core.v3.Address downstream_local_address */ 3:
                    message.downstreamLocalAddress = Address.internalBinaryRead(reader, reader.uint32(), options, message.downstreamLocalAddress);
                    break;
                case /* envoy.data.accesslog.v3.TLSProperties tls_properties */ 4:
                    message.tlsProperties = TLSProperties.internalBinaryRead(reader, reader.uint32(), options, message.tlsProperties);
                    break;
                case /* google.protobuf.Timestamp start_time */ 5:
                    message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Duration time_to_last_rx_byte */ 6:
                    message.timeToLastRxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToLastRxByte);
                    break;
                case /* google.protobuf.Duration time_to_first_upstream_tx_byte */ 7:
                    message.timeToFirstUpstreamTxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToFirstUpstreamTxByte);
                    break;
                case /* google.protobuf.Duration time_to_last_upstream_tx_byte */ 8:
                    message.timeToLastUpstreamTxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToLastUpstreamTxByte);
                    break;
                case /* google.protobuf.Duration time_to_first_upstream_rx_byte */ 9:
                    message.timeToFirstUpstreamRxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToFirstUpstreamRxByte);
                    break;
                case /* google.protobuf.Duration time_to_last_upstream_rx_byte */ 10:
                    message.timeToLastUpstreamRxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToLastUpstreamRxByte);
                    break;
                case /* google.protobuf.Duration time_to_first_downstream_tx_byte */ 11:
                    message.timeToFirstDownstreamTxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToFirstDownstreamTxByte);
                    break;
                case /* google.protobuf.Duration time_to_last_downstream_tx_byte */ 12:
                    message.timeToLastDownstreamTxByte = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeToLastDownstreamTxByte);
                    break;
                case /* envoy.config.core.v3.Address upstream_remote_address */ 13:
                    message.upstreamRemoteAddress = Address.internalBinaryRead(reader, reader.uint32(), options, message.upstreamRemoteAddress);
                    break;
                case /* envoy.config.core.v3.Address upstream_local_address */ 14:
                    message.upstreamLocalAddress = Address.internalBinaryRead(reader, reader.uint32(), options, message.upstreamLocalAddress);
                    break;
                case /* string upstream_cluster */ 15:
                    message.upstreamCluster = reader.string();
                    break;
                case /* envoy.data.accesslog.v3.ResponseFlags response_flags */ 16:
                    message.responseFlags = ResponseFlags.internalBinaryRead(reader, reader.uint32(), options, message.responseFlags);
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 17:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string upstream_transport_failure_reason */ 18:
                    message.upstreamTransportFailureReason = reader.string();
                    break;
                case /* string route_name */ 19:
                    message.routeName = reader.string();
                    break;
                case /* envoy.config.core.v3.Address downstream_direct_remote_address */ 20:
                    message.downstreamDirectRemoteAddress = Address.internalBinaryRead(reader, reader.uint32(), options, message.downstreamDirectRemoteAddress);
                    break;
                case /* map<string, google.protobuf.Any> filter_state_objects */ 21:
                    this.binaryReadMap21(message.filterStateObjects, reader, options);
                    break;
                case /* map<string, string> custom_tags */ 22:
                    this.binaryReadMap22(message.customTags, reader, options);
                    break;
                case /* google.protobuf.Duration duration */ 23:
                    message.duration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                case /* uint32 upstream_request_attempt_count */ 24:
                    message.upstreamRequestAttemptCount = reader.uint32();
                    break;
                case /* string connection_termination_details */ 25:
                    message.connectionTerminationDetails = reader.string();
                    break;
                case /* string stream_id */ 26:
                    message.streamId = reader.string();
                    break;
                case /* bool intermediate_log_entry = 27 [deprecated = true];*/ 27:
                    message.intermediateLogEntry = reader.bool();
                    break;
                case /* string downstream_transport_failure_reason */ 28:
                    message.downstreamTransportFailureReason = reader.string();
                    break;
                case /* uint64 downstream_wire_bytes_sent */ 29:
                    message.downstreamWireBytesSent = reader.uint64().toBigInt();
                    break;
                case /* uint64 downstream_wire_bytes_received */ 30:
                    message.downstreamWireBytesReceived = reader.uint64().toBigInt();
                    break;
                case /* uint64 upstream_wire_bytes_sent */ 31:
                    message.upstreamWireBytesSent = reader.uint64().toBigInt();
                    break;
                case /* uint64 upstream_wire_bytes_received */ 32:
                    message.upstreamWireBytesReceived = reader.uint64().toBigInt();
                    break;
                case /* envoy.data.accesslog.v3.AccessLogType access_log_type */ 33:
                    message.accessLogType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap21(map: AccessLogCommon["filterStateObjects"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessLogCommon["filterStateObjects"] | undefined, val: AccessLogCommon["filterStateObjects"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.data.accesslog.v3.AccessLogCommon.filter_state_objects");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    private binaryReadMap22(map: AccessLogCommon["customTags"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof AccessLogCommon["customTags"] | undefined, val: AccessLogCommon["customTags"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.data.accesslog.v3.AccessLogCommon.custom_tags");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: AccessLogCommon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double sample_rate = 1; */
        if (message.sampleRate !== 0)
            writer.tag(1, WireType.Bit64).double(message.sampleRate);
        /* envoy.config.core.v3.Address downstream_remote_address = 2; */
        if (message.downstreamRemoteAddress)
            Address.internalBinaryWrite(message.downstreamRemoteAddress, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Address downstream_local_address = 3; */
        if (message.downstreamLocalAddress)
            Address.internalBinaryWrite(message.downstreamLocalAddress, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.accesslog.v3.TLSProperties tls_properties = 4; */
        if (message.tlsProperties)
            TLSProperties.internalBinaryWrite(message.tlsProperties, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp start_time = 5; */
        if (message.startTime)
            Timestamp.internalBinaryWrite(message.startTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_last_rx_byte = 6; */
        if (message.timeToLastRxByte)
            Duration.internalBinaryWrite(message.timeToLastRxByte, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_first_upstream_tx_byte = 7; */
        if (message.timeToFirstUpstreamTxByte)
            Duration.internalBinaryWrite(message.timeToFirstUpstreamTxByte, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_last_upstream_tx_byte = 8; */
        if (message.timeToLastUpstreamTxByte)
            Duration.internalBinaryWrite(message.timeToLastUpstreamTxByte, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_first_upstream_rx_byte = 9; */
        if (message.timeToFirstUpstreamRxByte)
            Duration.internalBinaryWrite(message.timeToFirstUpstreamRxByte, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_last_upstream_rx_byte = 10; */
        if (message.timeToLastUpstreamRxByte)
            Duration.internalBinaryWrite(message.timeToLastUpstreamRxByte, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_first_downstream_tx_byte = 11; */
        if (message.timeToFirstDownstreamTxByte)
            Duration.internalBinaryWrite(message.timeToFirstDownstreamTxByte, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration time_to_last_downstream_tx_byte = 12; */
        if (message.timeToLastDownstreamTxByte)
            Duration.internalBinaryWrite(message.timeToLastDownstreamTxByte, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Address upstream_remote_address = 13; */
        if (message.upstreamRemoteAddress)
            Address.internalBinaryWrite(message.upstreamRemoteAddress, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Address upstream_local_address = 14; */
        if (message.upstreamLocalAddress)
            Address.internalBinaryWrite(message.upstreamLocalAddress, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string upstream_cluster = 15; */
        if (message.upstreamCluster !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.upstreamCluster);
        /* envoy.data.accesslog.v3.ResponseFlags response_flags = 16; */
        if (message.responseFlags)
            ResponseFlags.internalBinaryWrite(message.responseFlags, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata = 17; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* string upstream_transport_failure_reason = 18; */
        if (message.upstreamTransportFailureReason !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.upstreamTransportFailureReason);
        /* string route_name = 19; */
        if (message.routeName !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.routeName);
        /* envoy.config.core.v3.Address downstream_direct_remote_address = 20; */
        if (message.downstreamDirectRemoteAddress)
            Address.internalBinaryWrite(message.downstreamDirectRemoteAddress, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Any> filter_state_objects = 21; */
        for (let k of globalThis.Object.keys(message.filterStateObjects)) {
            writer.tag(21, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.filterStateObjects[k], writer, options);
            writer.join().join();
        }
        /* map<string, string> custom_tags = 22; */
        for (let k of globalThis.Object.keys(message.customTags))
            writer.tag(22, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.customTags[k]).join();
        /* google.protobuf.Duration duration = 23; */
        if (message.duration)
            Duration.internalBinaryWrite(message.duration, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* uint32 upstream_request_attempt_count = 24; */
        if (message.upstreamRequestAttemptCount !== 0)
            writer.tag(24, WireType.Varint).uint32(message.upstreamRequestAttemptCount);
        /* string connection_termination_details = 25; */
        if (message.connectionTerminationDetails !== "")
            writer.tag(25, WireType.LengthDelimited).string(message.connectionTerminationDetails);
        /* string stream_id = 26; */
        if (message.streamId !== "")
            writer.tag(26, WireType.LengthDelimited).string(message.streamId);
        /* bool intermediate_log_entry = 27 [deprecated = true]; */
        if (message.intermediateLogEntry !== false)
            writer.tag(27, WireType.Varint).bool(message.intermediateLogEntry);
        /* string downstream_transport_failure_reason = 28; */
        if (message.downstreamTransportFailureReason !== "")
            writer.tag(28, WireType.LengthDelimited).string(message.downstreamTransportFailureReason);
        /* uint64 downstream_wire_bytes_sent = 29; */
        if (message.downstreamWireBytesSent !== 0n)
            writer.tag(29, WireType.Varint).uint64(message.downstreamWireBytesSent);
        /* uint64 downstream_wire_bytes_received = 30; */
        if (message.downstreamWireBytesReceived !== 0n)
            writer.tag(30, WireType.Varint).uint64(message.downstreamWireBytesReceived);
        /* uint64 upstream_wire_bytes_sent = 31; */
        if (message.upstreamWireBytesSent !== 0n)
            writer.tag(31, WireType.Varint).uint64(message.upstreamWireBytesSent);
        /* uint64 upstream_wire_bytes_received = 32; */
        if (message.upstreamWireBytesReceived !== 0n)
            writer.tag(32, WireType.Varint).uint64(message.upstreamWireBytesReceived);
        /* envoy.data.accesslog.v3.AccessLogType access_log_type = 33; */
        if (message.accessLogType !== 0)
            writer.tag(33, WireType.Varint).int32(message.accessLogType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.AccessLogCommon
 */
export const AccessLogCommon = new AccessLogCommon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlags$Type extends MessageType<ResponseFlags> {
    constructor() {
        super("envoy.data.accesslog.v3.ResponseFlags", [
            { no: 1, name: "failed_local_healthcheck", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "no_healthy_upstream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "upstream_request_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "local_reset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "upstream_remote_reset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "upstream_connection_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "upstream_connection_termination", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "upstream_overflow", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "no_route_found", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "delay_injected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "fault_injected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "rate_limited", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "unauthorized_details", kind: "message", T: () => ResponseFlags_Unauthorized },
            { no: 14, name: "rate_limit_service_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "downstream_connection_termination", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "upstream_retry_limit_exceeded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "stream_idle_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "invalid_envoy_request_headers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "downstream_protocol_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "upstream_max_stream_duration_reached", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "response_from_cache_filter", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "no_filter_config_found", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "duration_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "upstream_protocol_error", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 25, name: "no_cluster_found", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 26, name: "overload_manager", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "dns_resolution_failure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.ResponseFlags" } });
    }
    create(value?: PartialMessage<ResponseFlags>): ResponseFlags {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failedLocalHealthcheck = false;
        message.noHealthyUpstream = false;
        message.upstreamRequestTimeout = false;
        message.localReset = false;
        message.upstreamRemoteReset = false;
        message.upstreamConnectionFailure = false;
        message.upstreamConnectionTermination = false;
        message.upstreamOverflow = false;
        message.noRouteFound = false;
        message.delayInjected = false;
        message.faultInjected = false;
        message.rateLimited = false;
        message.rateLimitServiceError = false;
        message.downstreamConnectionTermination = false;
        message.upstreamRetryLimitExceeded = false;
        message.streamIdleTimeout = false;
        message.invalidEnvoyRequestHeaders = false;
        message.downstreamProtocolError = false;
        message.upstreamMaxStreamDurationReached = false;
        message.responseFromCacheFilter = false;
        message.noFilterConfigFound = false;
        message.durationTimeout = false;
        message.upstreamProtocolError = false;
        message.noClusterFound = false;
        message.overloadManager = false;
        message.dnsResolutionFailure = false;
        if (value !== undefined)
            reflectionMergePartial<ResponseFlags>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFlags): ResponseFlags {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool failed_local_healthcheck */ 1:
                    message.failedLocalHealthcheck = reader.bool();
                    break;
                case /* bool no_healthy_upstream */ 2:
                    message.noHealthyUpstream = reader.bool();
                    break;
                case /* bool upstream_request_timeout */ 3:
                    message.upstreamRequestTimeout = reader.bool();
                    break;
                case /* bool local_reset */ 4:
                    message.localReset = reader.bool();
                    break;
                case /* bool upstream_remote_reset */ 5:
                    message.upstreamRemoteReset = reader.bool();
                    break;
                case /* bool upstream_connection_failure */ 6:
                    message.upstreamConnectionFailure = reader.bool();
                    break;
                case /* bool upstream_connection_termination */ 7:
                    message.upstreamConnectionTermination = reader.bool();
                    break;
                case /* bool upstream_overflow */ 8:
                    message.upstreamOverflow = reader.bool();
                    break;
                case /* bool no_route_found */ 9:
                    message.noRouteFound = reader.bool();
                    break;
                case /* bool delay_injected */ 10:
                    message.delayInjected = reader.bool();
                    break;
                case /* bool fault_injected */ 11:
                    message.faultInjected = reader.bool();
                    break;
                case /* bool rate_limited */ 12:
                    message.rateLimited = reader.bool();
                    break;
                case /* envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details */ 13:
                    message.unauthorizedDetails = ResponseFlags_Unauthorized.internalBinaryRead(reader, reader.uint32(), options, message.unauthorizedDetails);
                    break;
                case /* bool rate_limit_service_error */ 14:
                    message.rateLimitServiceError = reader.bool();
                    break;
                case /* bool downstream_connection_termination */ 15:
                    message.downstreamConnectionTermination = reader.bool();
                    break;
                case /* bool upstream_retry_limit_exceeded */ 16:
                    message.upstreamRetryLimitExceeded = reader.bool();
                    break;
                case /* bool stream_idle_timeout */ 17:
                    message.streamIdleTimeout = reader.bool();
                    break;
                case /* bool invalid_envoy_request_headers */ 18:
                    message.invalidEnvoyRequestHeaders = reader.bool();
                    break;
                case /* bool downstream_protocol_error */ 19:
                    message.downstreamProtocolError = reader.bool();
                    break;
                case /* bool upstream_max_stream_duration_reached */ 20:
                    message.upstreamMaxStreamDurationReached = reader.bool();
                    break;
                case /* bool response_from_cache_filter */ 21:
                    message.responseFromCacheFilter = reader.bool();
                    break;
                case /* bool no_filter_config_found */ 22:
                    message.noFilterConfigFound = reader.bool();
                    break;
                case /* bool duration_timeout */ 23:
                    message.durationTimeout = reader.bool();
                    break;
                case /* bool upstream_protocol_error */ 24:
                    message.upstreamProtocolError = reader.bool();
                    break;
                case /* bool no_cluster_found */ 25:
                    message.noClusterFound = reader.bool();
                    break;
                case /* bool overload_manager */ 26:
                    message.overloadManager = reader.bool();
                    break;
                case /* bool dns_resolution_failure */ 27:
                    message.dnsResolutionFailure = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseFlags, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool failed_local_healthcheck = 1; */
        if (message.failedLocalHealthcheck !== false)
            writer.tag(1, WireType.Varint).bool(message.failedLocalHealthcheck);
        /* bool no_healthy_upstream = 2; */
        if (message.noHealthyUpstream !== false)
            writer.tag(2, WireType.Varint).bool(message.noHealthyUpstream);
        /* bool upstream_request_timeout = 3; */
        if (message.upstreamRequestTimeout !== false)
            writer.tag(3, WireType.Varint).bool(message.upstreamRequestTimeout);
        /* bool local_reset = 4; */
        if (message.localReset !== false)
            writer.tag(4, WireType.Varint).bool(message.localReset);
        /* bool upstream_remote_reset = 5; */
        if (message.upstreamRemoteReset !== false)
            writer.tag(5, WireType.Varint).bool(message.upstreamRemoteReset);
        /* bool upstream_connection_failure = 6; */
        if (message.upstreamConnectionFailure !== false)
            writer.tag(6, WireType.Varint).bool(message.upstreamConnectionFailure);
        /* bool upstream_connection_termination = 7; */
        if (message.upstreamConnectionTermination !== false)
            writer.tag(7, WireType.Varint).bool(message.upstreamConnectionTermination);
        /* bool upstream_overflow = 8; */
        if (message.upstreamOverflow !== false)
            writer.tag(8, WireType.Varint).bool(message.upstreamOverflow);
        /* bool no_route_found = 9; */
        if (message.noRouteFound !== false)
            writer.tag(9, WireType.Varint).bool(message.noRouteFound);
        /* bool delay_injected = 10; */
        if (message.delayInjected !== false)
            writer.tag(10, WireType.Varint).bool(message.delayInjected);
        /* bool fault_injected = 11; */
        if (message.faultInjected !== false)
            writer.tag(11, WireType.Varint).bool(message.faultInjected);
        /* bool rate_limited = 12; */
        if (message.rateLimited !== false)
            writer.tag(12, WireType.Varint).bool(message.rateLimited);
        /* envoy.data.accesslog.v3.ResponseFlags.Unauthorized unauthorized_details = 13; */
        if (message.unauthorizedDetails)
            ResponseFlags_Unauthorized.internalBinaryWrite(message.unauthorizedDetails, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool rate_limit_service_error = 14; */
        if (message.rateLimitServiceError !== false)
            writer.tag(14, WireType.Varint).bool(message.rateLimitServiceError);
        /* bool downstream_connection_termination = 15; */
        if (message.downstreamConnectionTermination !== false)
            writer.tag(15, WireType.Varint).bool(message.downstreamConnectionTermination);
        /* bool upstream_retry_limit_exceeded = 16; */
        if (message.upstreamRetryLimitExceeded !== false)
            writer.tag(16, WireType.Varint).bool(message.upstreamRetryLimitExceeded);
        /* bool stream_idle_timeout = 17; */
        if (message.streamIdleTimeout !== false)
            writer.tag(17, WireType.Varint).bool(message.streamIdleTimeout);
        /* bool invalid_envoy_request_headers = 18; */
        if (message.invalidEnvoyRequestHeaders !== false)
            writer.tag(18, WireType.Varint).bool(message.invalidEnvoyRequestHeaders);
        /* bool downstream_protocol_error = 19; */
        if (message.downstreamProtocolError !== false)
            writer.tag(19, WireType.Varint).bool(message.downstreamProtocolError);
        /* bool upstream_max_stream_duration_reached = 20; */
        if (message.upstreamMaxStreamDurationReached !== false)
            writer.tag(20, WireType.Varint).bool(message.upstreamMaxStreamDurationReached);
        /* bool response_from_cache_filter = 21; */
        if (message.responseFromCacheFilter !== false)
            writer.tag(21, WireType.Varint).bool(message.responseFromCacheFilter);
        /* bool no_filter_config_found = 22; */
        if (message.noFilterConfigFound !== false)
            writer.tag(22, WireType.Varint).bool(message.noFilterConfigFound);
        /* bool duration_timeout = 23; */
        if (message.durationTimeout !== false)
            writer.tag(23, WireType.Varint).bool(message.durationTimeout);
        /* bool upstream_protocol_error = 24; */
        if (message.upstreamProtocolError !== false)
            writer.tag(24, WireType.Varint).bool(message.upstreamProtocolError);
        /* bool no_cluster_found = 25; */
        if (message.noClusterFound !== false)
            writer.tag(25, WireType.Varint).bool(message.noClusterFound);
        /* bool overload_manager = 26; */
        if (message.overloadManager !== false)
            writer.tag(26, WireType.Varint).bool(message.overloadManager);
        /* bool dns_resolution_failure = 27; */
        if (message.dnsResolutionFailure !== false)
            writer.tag(27, WireType.Varint).bool(message.dnsResolutionFailure);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.ResponseFlags
 */
export const ResponseFlags = new ResponseFlags$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlags_Unauthorized$Type extends MessageType<ResponseFlags_Unauthorized> {
    constructor() {
        super("envoy.data.accesslog.v3.ResponseFlags.Unauthorized", [
            { no: 1, name: "reason", kind: "enum", T: () => ["envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason", ResponseFlags_Unauthorized_Reason] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.ResponseFlags.Unauthorized" } });
    }
    create(value?: PartialMessage<ResponseFlags_Unauthorized>): ResponseFlags_Unauthorized {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseFlags_Unauthorized>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFlags_Unauthorized): ResponseFlags_Unauthorized {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason reason */ 1:
                    message.reason = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseFlags_Unauthorized, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.accesslog.v3.ResponseFlags.Unauthorized.Reason reason = 1; */
        if (message.reason !== 0)
            writer.tag(1, WireType.Varint).int32(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.ResponseFlags.Unauthorized
 */
export const ResponseFlags_Unauthorized = new ResponseFlags_Unauthorized$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSProperties$Type extends MessageType<TLSProperties> {
    constructor() {
        super("envoy.data.accesslog.v3.TLSProperties", [
            { no: 1, name: "tls_version", kind: "enum", T: () => ["envoy.data.accesslog.v3.TLSProperties.TLSVersion", TLSProperties_TLSVersion] },
            { no: 2, name: "tls_cipher_suite", kind: "message", T: () => UInt32Value },
            { no: 3, name: "tls_sni_hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "local_certificate_properties", kind: "message", T: () => TLSProperties_CertificateProperties },
            { no: 5, name: "peer_certificate_properties", kind: "message", T: () => TLSProperties_CertificateProperties },
            { no: 6, name: "tls_session_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "ja3_fingerprint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.TLSProperties" } });
    }
    create(value?: PartialMessage<TLSProperties>): TLSProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tlsVersion = 0;
        message.tlsSniHostname = "";
        message.tlsSessionId = "";
        message.ja3Fingerprint = "";
        if (value !== undefined)
            reflectionMergePartial<TLSProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSProperties): TLSProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.accesslog.v3.TLSProperties.TLSVersion tls_version */ 1:
                    message.tlsVersion = reader.int32();
                    break;
                case /* google.protobuf.UInt32Value tls_cipher_suite */ 2:
                    message.tlsCipherSuite = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.tlsCipherSuite);
                    break;
                case /* string tls_sni_hostname */ 3:
                    message.tlsSniHostname = reader.string();
                    break;
                case /* envoy.data.accesslog.v3.TLSProperties.CertificateProperties local_certificate_properties */ 4:
                    message.localCertificateProperties = TLSProperties_CertificateProperties.internalBinaryRead(reader, reader.uint32(), options, message.localCertificateProperties);
                    break;
                case /* envoy.data.accesslog.v3.TLSProperties.CertificateProperties peer_certificate_properties */ 5:
                    message.peerCertificateProperties = TLSProperties_CertificateProperties.internalBinaryRead(reader, reader.uint32(), options, message.peerCertificateProperties);
                    break;
                case /* string tls_session_id */ 6:
                    message.tlsSessionId = reader.string();
                    break;
                case /* string ja3_fingerprint */ 7:
                    message.ja3Fingerprint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.accesslog.v3.TLSProperties.TLSVersion tls_version = 1; */
        if (message.tlsVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.tlsVersion);
        /* google.protobuf.UInt32Value tls_cipher_suite = 2; */
        if (message.tlsCipherSuite)
            UInt32Value.internalBinaryWrite(message.tlsCipherSuite, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string tls_sni_hostname = 3; */
        if (message.tlsSniHostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.tlsSniHostname);
        /* envoy.data.accesslog.v3.TLSProperties.CertificateProperties local_certificate_properties = 4; */
        if (message.localCertificateProperties)
            TLSProperties_CertificateProperties.internalBinaryWrite(message.localCertificateProperties, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.data.accesslog.v3.TLSProperties.CertificateProperties peer_certificate_properties = 5; */
        if (message.peerCertificateProperties)
            TLSProperties_CertificateProperties.internalBinaryWrite(message.peerCertificateProperties, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string tls_session_id = 6; */
        if (message.tlsSessionId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.tlsSessionId);
        /* string ja3_fingerprint = 7; */
        if (message.ja3Fingerprint !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.ja3Fingerprint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.TLSProperties
 */
export const TLSProperties = new TLSProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSProperties_CertificateProperties$Type extends MessageType<TLSProperties_CertificateProperties> {
    constructor() {
        super("envoy.data.accesslog.v3.TLSProperties.CertificateProperties", [
            { no: 1, name: "subject_alt_name", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TLSProperties_CertificateProperties_SubjectAltName },
            { no: 2, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.TLSProperties.CertificateProperties" } });
    }
    create(value?: PartialMessage<TLSProperties_CertificateProperties>): TLSProperties_CertificateProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subjectAltName = [];
        message.subject = "";
        if (value !== undefined)
            reflectionMergePartial<TLSProperties_CertificateProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSProperties_CertificateProperties): TLSProperties_CertificateProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName subject_alt_name */ 1:
                    message.subjectAltName.push(TLSProperties_CertificateProperties_SubjectAltName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string subject */ 2:
                    message.subject = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSProperties_CertificateProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName subject_alt_name = 1; */
        for (let i = 0; i < message.subjectAltName.length; i++)
            TLSProperties_CertificateProperties_SubjectAltName.internalBinaryWrite(message.subjectAltName[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string subject = 2; */
        if (message.subject !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subject);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.TLSProperties.CertificateProperties
 */
export const TLSProperties_CertificateProperties = new TLSProperties_CertificateProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TLSProperties_CertificateProperties_SubjectAltName$Type extends MessageType<TLSProperties_CertificateProperties_SubjectAltName> {
    constructor() {
        super("envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName", [
            { no: 1, name: "uri", kind: "scalar", oneof: "san", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dns", kind: "scalar", oneof: "san", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.TLSProperties.CertificateProperties.SubjectAltName" } });
    }
    create(value?: PartialMessage<TLSProperties_CertificateProperties_SubjectAltName>): TLSProperties_CertificateProperties_SubjectAltName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.san = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TLSProperties_CertificateProperties_SubjectAltName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TLSProperties_CertificateProperties_SubjectAltName): TLSProperties_CertificateProperties_SubjectAltName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri */ 1:
                    message.san = {
                        oneofKind: "uri",
                        uri: reader.string()
                    };
                    break;
                case /* string dns */ 2:
                    message.san = {
                        oneofKind: "dns",
                        dns: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TLSProperties_CertificateProperties_SubjectAltName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri = 1; */
        if (message.san.oneofKind === "uri")
            writer.tag(1, WireType.LengthDelimited).string(message.san.uri);
        /* string dns = 2; */
        if (message.san.oneofKind === "dns")
            writer.tag(2, WireType.LengthDelimited).string(message.san.dns);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.TLSProperties.CertificateProperties.SubjectAltName
 */
export const TLSProperties_CertificateProperties_SubjectAltName = new TLSProperties_CertificateProperties_SubjectAltName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPRequestProperties$Type extends MessageType<HTTPRequestProperties> {
    constructor() {
        super("envoy.data.accesslog.v3.HTTPRequestProperties", [
            { no: 1, name: "request_method", kind: "enum", T: () => ["envoy.config.core.v3.RequestMethod", RequestMethod], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "scheme", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "port", kind: "message", T: () => UInt32Value },
            { no: 5, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "user_agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "referer", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "forwarded_for", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "original_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "request_headers_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "request_body_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "request_headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 14, name: "upstream_header_bytes_sent", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "downstream_header_bytes_received", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.HTTPRequestProperties" } });
    }
    create(value?: PartialMessage<HTTPRequestProperties>): HTTPRequestProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestMethod = 0;
        message.scheme = "";
        message.authority = "";
        message.path = "";
        message.userAgent = "";
        message.referer = "";
        message.forwardedFor = "";
        message.requestId = "";
        message.originalPath = "";
        message.requestHeadersBytes = 0n;
        message.requestBodyBytes = 0n;
        message.requestHeaders = {};
        message.upstreamHeaderBytesSent = 0n;
        message.downstreamHeaderBytesReceived = 0n;
        if (value !== undefined)
            reflectionMergePartial<HTTPRequestProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPRequestProperties): HTTPRequestProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.RequestMethod request_method */ 1:
                    message.requestMethod = reader.int32();
                    break;
                case /* string scheme */ 2:
                    message.scheme = reader.string();
                    break;
                case /* string authority */ 3:
                    message.authority = reader.string();
                    break;
                case /* google.protobuf.UInt32Value port */ 4:
                    message.port = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.port);
                    break;
                case /* string path */ 5:
                    message.path = reader.string();
                    break;
                case /* string user_agent */ 6:
                    message.userAgent = reader.string();
                    break;
                case /* string referer */ 7:
                    message.referer = reader.string();
                    break;
                case /* string forwarded_for */ 8:
                    message.forwardedFor = reader.string();
                    break;
                case /* string request_id */ 9:
                    message.requestId = reader.string();
                    break;
                case /* string original_path */ 10:
                    message.originalPath = reader.string();
                    break;
                case /* uint64 request_headers_bytes */ 11:
                    message.requestHeadersBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 request_body_bytes */ 12:
                    message.requestBodyBytes = reader.uint64().toBigInt();
                    break;
                case /* map<string, string> request_headers */ 13:
                    this.binaryReadMap13(message.requestHeaders, reader, options);
                    break;
                case /* uint64 upstream_header_bytes_sent */ 14:
                    message.upstreamHeaderBytesSent = reader.uint64().toBigInt();
                    break;
                case /* uint64 downstream_header_bytes_received */ 15:
                    message.downstreamHeaderBytesReceived = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: HTTPRequestProperties["requestHeaders"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPRequestProperties["requestHeaders"] | undefined, val: HTTPRequestProperties["requestHeaders"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.data.accesslog.v3.HTTPRequestProperties.request_headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HTTPRequestProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.RequestMethod request_method = 1; */
        if (message.requestMethod !== 0)
            writer.tag(1, WireType.Varint).int32(message.requestMethod);
        /* string scheme = 2; */
        if (message.scheme !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.scheme);
        /* string authority = 3; */
        if (message.authority !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.authority);
        /* google.protobuf.UInt32Value port = 4; */
        if (message.port)
            UInt32Value.internalBinaryWrite(message.port, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string path = 5; */
        if (message.path !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.path);
        /* string user_agent = 6; */
        if (message.userAgent !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userAgent);
        /* string referer = 7; */
        if (message.referer !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.referer);
        /* string forwarded_for = 8; */
        if (message.forwardedFor !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.forwardedFor);
        /* string request_id = 9; */
        if (message.requestId !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.requestId);
        /* string original_path = 10; */
        if (message.originalPath !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.originalPath);
        /* uint64 request_headers_bytes = 11; */
        if (message.requestHeadersBytes !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.requestHeadersBytes);
        /* uint64 request_body_bytes = 12; */
        if (message.requestBodyBytes !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.requestBodyBytes);
        /* map<string, string> request_headers = 13; */
        for (let k of globalThis.Object.keys(message.requestHeaders))
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.requestHeaders[k]).join();
        /* uint64 upstream_header_bytes_sent = 14; */
        if (message.upstreamHeaderBytesSent !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.upstreamHeaderBytesSent);
        /* uint64 downstream_header_bytes_received = 15; */
        if (message.downstreamHeaderBytesReceived !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.downstreamHeaderBytesReceived);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.HTTPRequestProperties
 */
export const HTTPRequestProperties = new HTTPRequestProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPResponseProperties$Type extends MessageType<HTTPResponseProperties> {
    constructor() {
        super("envoy.data.accesslog.v3.HTTPResponseProperties", [
            { no: 1, name: "response_code", kind: "message", T: () => UInt32Value },
            { no: 2, name: "response_headers_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "response_body_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "response_headers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 5, name: "response_trailers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "response_code_details", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "upstream_header_bytes_received", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "downstream_header_bytes_sent", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.data.accesslog.v2.HTTPResponseProperties" } });
    }
    create(value?: PartialMessage<HTTPResponseProperties>): HTTPResponseProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responseHeadersBytes = 0n;
        message.responseBodyBytes = 0n;
        message.responseHeaders = {};
        message.responseTrailers = {};
        message.responseCodeDetails = "";
        message.upstreamHeaderBytesReceived = 0n;
        message.downstreamHeaderBytesSent = 0n;
        if (value !== undefined)
            reflectionMergePartial<HTTPResponseProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPResponseProperties): HTTPResponseProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value response_code */ 1:
                    message.responseCode = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.responseCode);
                    break;
                case /* uint64 response_headers_bytes */ 2:
                    message.responseHeadersBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 response_body_bytes */ 3:
                    message.responseBodyBytes = reader.uint64().toBigInt();
                    break;
                case /* map<string, string> response_headers */ 4:
                    this.binaryReadMap4(message.responseHeaders, reader, options);
                    break;
                case /* map<string, string> response_trailers */ 5:
                    this.binaryReadMap5(message.responseTrailers, reader, options);
                    break;
                case /* string response_code_details */ 6:
                    message.responseCodeDetails = reader.string();
                    break;
                case /* uint64 upstream_header_bytes_received */ 7:
                    message.upstreamHeaderBytesReceived = reader.uint64().toBigInt();
                    break;
                case /* uint64 downstream_header_bytes_sent */ 8:
                    message.downstreamHeaderBytesSent = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: HTTPResponseProperties["responseHeaders"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPResponseProperties["responseHeaders"] | undefined, val: HTTPResponseProperties["responseHeaders"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.data.accesslog.v3.HTTPResponseProperties.response_headers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    private binaryReadMap5(map: HTTPResponseProperties["responseTrailers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HTTPResponseProperties["responseTrailers"] | undefined, val: HTTPResponseProperties["responseTrailers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.data.accesslog.v3.HTTPResponseProperties.response_trailers");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HTTPResponseProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value response_code = 1; */
        if (message.responseCode)
            UInt32Value.internalBinaryWrite(message.responseCode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 response_headers_bytes = 2; */
        if (message.responseHeadersBytes !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.responseHeadersBytes);
        /* uint64 response_body_bytes = 3; */
        if (message.responseBodyBytes !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.responseBodyBytes);
        /* map<string, string> response_headers = 4; */
        for (let k of globalThis.Object.keys(message.responseHeaders))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.responseHeaders[k]).join();
        /* map<string, string> response_trailers = 5; */
        for (let k of globalThis.Object.keys(message.responseTrailers))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.responseTrailers[k]).join();
        /* string response_code_details = 6; */
        if (message.responseCodeDetails !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.responseCodeDetails);
        /* uint64 upstream_header_bytes_received = 7; */
        if (message.upstreamHeaderBytesReceived !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.upstreamHeaderBytesReceived);
        /* uint64 downstream_header_bytes_sent = 8; */
        if (message.downstreamHeaderBytesSent !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.downstreamHeaderBytesSent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.data.accesslog.v3.HTTPResponseProperties
 */
export const HTTPResponseProperties = new HTTPResponseProperties$Type();
