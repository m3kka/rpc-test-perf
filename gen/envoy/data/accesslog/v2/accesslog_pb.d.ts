// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/data/accesslog/v2/accesslog.proto (package envoy.data.accesslog.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Address } from "../../../api/v2/core/address_pb.js";
import type { Metadata, RequestMethod } from "../../../api/v2/core/base_pb.js";

/**
 * @generated from message envoy.data.accesslog.v2.TCPAccessLogEntry
 */
export declare class TCPAccessLogEntry extends Message<TCPAccessLogEntry> {
  /**
   * Common properties shared by all Envoy access logs.
   *
   * @generated from field: envoy.data.accesslog.v2.AccessLogCommon common_properties = 1;
   */
  commonProperties?: AccessLogCommon;

  /**
   * Properties of the TCP connection.
   *
   * @generated from field: envoy.data.accesslog.v2.ConnectionProperties connection_properties = 2;
   */
  connectionProperties?: ConnectionProperties;

  constructor(data?: PartialMessage<TCPAccessLogEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.TCPAccessLogEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TCPAccessLogEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TCPAccessLogEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TCPAccessLogEntry;

  static equals(a: TCPAccessLogEntry | PlainMessage<TCPAccessLogEntry> | undefined, b: TCPAccessLogEntry | PlainMessage<TCPAccessLogEntry> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v2.HTTPAccessLogEntry
 */
export declare class HTTPAccessLogEntry extends Message<HTTPAccessLogEntry> {
  /**
   * Common properties shared by all Envoy access logs.
   *
   * @generated from field: envoy.data.accesslog.v2.AccessLogCommon common_properties = 1;
   */
  commonProperties?: AccessLogCommon;

  /**
   * @generated from field: envoy.data.accesslog.v2.HTTPAccessLogEntry.HTTPVersion protocol_version = 2;
   */
  protocolVersion: HTTPAccessLogEntry_HTTPVersion;

  /**
   * Description of the incoming HTTP request.
   *
   * @generated from field: envoy.data.accesslog.v2.HTTPRequestProperties request = 3;
   */
  request?: HTTPRequestProperties;

  /**
   * Description of the outgoing HTTP response.
   *
   * @generated from field: envoy.data.accesslog.v2.HTTPResponseProperties response = 4;
   */
  response?: HTTPResponseProperties;

  constructor(data?: PartialMessage<HTTPAccessLogEntry>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.HTTPAccessLogEntry";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPAccessLogEntry;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPAccessLogEntry;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPAccessLogEntry;

  static equals(a: HTTPAccessLogEntry | PlainMessage<HTTPAccessLogEntry> | undefined, b: HTTPAccessLogEntry | PlainMessage<HTTPAccessLogEntry> | undefined): boolean;
}

/**
 * HTTP version
 *
 * @generated from enum envoy.data.accesslog.v2.HTTPAccessLogEntry.HTTPVersion
 */
export declare enum HTTPAccessLogEntry_HTTPVersion {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  PROTOCOL_UNSPECIFIED = 0,

  /**
   * @generated from enum value: HTTP10 = 1;
   */
  HTTP10 = 1,

  /**
   * @generated from enum value: HTTP11 = 2;
   */
  HTTP11 = 2,

  /**
   * @generated from enum value: HTTP2 = 3;
   */
  HTTP2 = 3,

  /**
   * @generated from enum value: HTTP3 = 4;
   */
  HTTP3 = 4,
}

/**
 * Defines fields for a connection
 *
 * @generated from message envoy.data.accesslog.v2.ConnectionProperties
 */
export declare class ConnectionProperties extends Message<ConnectionProperties> {
  /**
   * Number of bytes received from downstream.
   *
   * @generated from field: uint64 received_bytes = 1;
   */
  receivedBytes: bigint;

  /**
   * Number of bytes sent to downstream.
   *
   * @generated from field: uint64 sent_bytes = 2;
   */
  sentBytes: bigint;

  constructor(data?: PartialMessage<ConnectionProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.ConnectionProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionProperties;

  static equals(a: ConnectionProperties | PlainMessage<ConnectionProperties> | undefined, b: ConnectionProperties | PlainMessage<ConnectionProperties> | undefined): boolean;
}

/**
 * Defines fields that are shared by all Envoy access logs.
 * [#next-free-field: 22]
 *
 * @generated from message envoy.data.accesslog.v2.AccessLogCommon
 */
export declare class AccessLogCommon extends Message<AccessLogCommon> {
  /**
   * [#not-implemented-hide:]
   * This field indicates the rate at which this log entry was sampled.
   * Valid range is (0.0, 1.0].
   *
   * @generated from field: double sample_rate = 1;
   */
  sampleRate: number;

  /**
   * This field is the remote/origin address on which the request from the user was received.
   * Note: This may not be the physical peer. E.g, if the remote address is inferred from for
   * example the x-forwarder-for header, proxy protocol, etc.
   *
   * @generated from field: envoy.api.v2.core.Address downstream_remote_address = 2;
   */
  downstreamRemoteAddress?: Address;

  /**
   * This field is the local/destination address on which the request from the user was received.
   *
   * @generated from field: envoy.api.v2.core.Address downstream_local_address = 3;
   */
  downstreamLocalAddress?: Address;

  /**
   * If the connection is secure,S this field will contain TLS properties.
   *
   * @generated from field: envoy.data.accesslog.v2.TLSProperties tls_properties = 4;
   */
  tlsProperties?: TLSProperties;

  /**
   * The time that Envoy started servicing this request. This is effectively the time that the first
   * downstream byte is received.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 5;
   */
  startTime?: Timestamp;

  /**
   * Interval between the first downstream byte received and the last
   * downstream byte received (i.e. time it takes to receive a request).
   *
   * @generated from field: google.protobuf.Duration time_to_last_rx_byte = 6;
   */
  timeToLastRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first upstream byte sent. There may
   * by considerable delta between *time_to_last_rx_byte* and this value due to filters.
   * Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
   * not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_first_upstream_tx_byte = 7;
   */
  timeToFirstUpstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last upstream byte sent. There may
   * by considerable delta between *time_to_last_rx_byte* and this value due to filters.
   * Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
   * not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_last_upstream_tx_byte = 8;
   */
  timeToLastUpstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first upstream
   * byte received (i.e. time it takes to start receiving a response).
   *
   * @generated from field: google.protobuf.Duration time_to_first_upstream_rx_byte = 9;
   */
  timeToFirstUpstreamRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last upstream
   * byte received (i.e. time it takes to receive a complete response).
   *
   * @generated from field: google.protobuf.Duration time_to_last_upstream_rx_byte = 10;
   */
  timeToLastUpstreamRxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the first downstream byte sent.
   * There may be a considerable delta between the *time_to_first_upstream_rx_byte* and this field
   * due to filters. Additionally, the same caveats apply as documented in
   * *time_to_last_downstream_tx_byte* about not accounting for kernel socket buffer time, etc.
   *
   * @generated from field: google.protobuf.Duration time_to_first_downstream_tx_byte = 11;
   */
  timeToFirstDownstreamTxByte?: Duration;

  /**
   * Interval between the first downstream byte received and the last downstream byte sent.
   * Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
   * between *time_to_last_upstream_rx_byte* and this field. Note also that this is an approximate
   * time. In the current implementation it does not include kernel socket buffer time. In the
   * current implementation it also does not include send window buffering inside the HTTP/2 codec.
   * In the future it is likely that work will be done to make this duration more accurate.
   *
   * @generated from field: google.protobuf.Duration time_to_last_downstream_tx_byte = 12;
   */
  timeToLastDownstreamTxByte?: Duration;

  /**
   * The upstream remote/destination address that handles this exchange. This does not include
   * retries.
   *
   * @generated from field: envoy.api.v2.core.Address upstream_remote_address = 13;
   */
  upstreamRemoteAddress?: Address;

  /**
   * The upstream local/origin address that handles this exchange. This does not include retries.
   *
   * @generated from field: envoy.api.v2.core.Address upstream_local_address = 14;
   */
  upstreamLocalAddress?: Address;

  /**
   * The upstream cluster that *upstream_remote_address* belongs to.
   *
   * @generated from field: string upstream_cluster = 15;
   */
  upstreamCluster: string;

  /**
   * Flags indicating occurrences during request/response processing.
   *
   * @generated from field: envoy.data.accesslog.v2.ResponseFlags response_flags = 16;
   */
  responseFlags?: ResponseFlags;

  /**
   * All metadata encountered during request processing, including endpoint
   * selection.
   *
   * This can be used to associate IDs attached to the various configurations
   * used to process this request with the access log entry. For example, a
   * route created from a higher level forwarding rule with some ID can place
   * that ID in this field and cross reference later. It can also be used to
   * determine if a canary endpoint was used or not.
   *
   * @generated from field: envoy.api.v2.core.Metadata metadata = 17;
   */
  metadata?: Metadata;

  /**
   * If upstream connection failed due to transport socket (e.g. TLS handshake), provides the
   * failure reason from the transport socket. The format of this field depends on the configured
   * upstream transport socket. Common TLS failures are in
   * :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
   *
   * @generated from field: string upstream_transport_failure_reason = 18;
   */
  upstreamTransportFailureReason: string;

  /**
   * The name of the route
   *
   * @generated from field: string route_name = 19;
   */
  routeName: string;

  /**
   * This field is the downstream direct remote address on which the request from the user was
   * received. Note: This is always the physical peer, even if the remote address is inferred from
   * for example the x-forwarder-for header, proxy protocol, etc.
   *
   * @generated from field: envoy.api.v2.core.Address downstream_direct_remote_address = 20;
   */
  downstreamDirectRemoteAddress?: Address;

  /**
   * Map of filter state in stream info that have been configured to be logged. If the filter
   * state serialized to any message other than `google.protobuf.Any` it will be packed into
   * `google.protobuf.Any`.
   *
   * @generated from field: map<string, google.protobuf.Any> filter_state_objects = 21;
   */
  filterStateObjects: { [key: string]: Any };

  constructor(data?: PartialMessage<AccessLogCommon>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.AccessLogCommon";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessLogCommon;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessLogCommon;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessLogCommon;

  static equals(a: AccessLogCommon | PlainMessage<AccessLogCommon> | undefined, b: AccessLogCommon | PlainMessage<AccessLogCommon> | undefined): boolean;
}

/**
 * Flags indicating occurrences during request/response processing.
 * [#next-free-field: 20]
 *
 * @generated from message envoy.data.accesslog.v2.ResponseFlags
 */
export declare class ResponseFlags extends Message<ResponseFlags> {
  /**
   * Indicates local server healthcheck failed.
   *
   * @generated from field: bool failed_local_healthcheck = 1;
   */
  failedLocalHealthcheck: boolean;

  /**
   * Indicates there was no healthy upstream.
   *
   * @generated from field: bool no_healthy_upstream = 2;
   */
  noHealthyUpstream: boolean;

  /**
   * Indicates an there was an upstream request timeout.
   *
   * @generated from field: bool upstream_request_timeout = 3;
   */
  upstreamRequestTimeout: boolean;

  /**
   * Indicates local codec level reset was sent on the stream.
   *
   * @generated from field: bool local_reset = 4;
   */
  localReset: boolean;

  /**
   * Indicates remote codec level reset was received on the stream.
   *
   * @generated from field: bool upstream_remote_reset = 5;
   */
  upstreamRemoteReset: boolean;

  /**
   * Indicates there was a local reset by a connection pool due to an initial connection failure.
   *
   * @generated from field: bool upstream_connection_failure = 6;
   */
  upstreamConnectionFailure: boolean;

  /**
   * Indicates the stream was reset due to an upstream connection termination.
   *
   * @generated from field: bool upstream_connection_termination = 7;
   */
  upstreamConnectionTermination: boolean;

  /**
   * Indicates the stream was reset because of a resource overflow.
   *
   * @generated from field: bool upstream_overflow = 8;
   */
  upstreamOverflow: boolean;

  /**
   * Indicates no route was found for the request.
   *
   * @generated from field: bool no_route_found = 9;
   */
  noRouteFound: boolean;

  /**
   * Indicates that the request was delayed before proxying.
   *
   * @generated from field: bool delay_injected = 10;
   */
  delayInjected: boolean;

  /**
   * Indicates that the request was aborted with an injected error code.
   *
   * @generated from field: bool fault_injected = 11;
   */
  faultInjected: boolean;

  /**
   * Indicates that the request was rate-limited locally.
   *
   * @generated from field: bool rate_limited = 12;
   */
  rateLimited: boolean;

  /**
   * Indicates if the request was deemed unauthorized and the reason for it.
   *
   * @generated from field: envoy.data.accesslog.v2.ResponseFlags.Unauthorized unauthorized_details = 13;
   */
  unauthorizedDetails?: ResponseFlags_Unauthorized;

  /**
   * Indicates that the request was rejected because there was an error in rate limit service.
   *
   * @generated from field: bool rate_limit_service_error = 14;
   */
  rateLimitServiceError: boolean;

  /**
   * Indicates the stream was reset due to a downstream connection termination.
   *
   * @generated from field: bool downstream_connection_termination = 15;
   */
  downstreamConnectionTermination: boolean;

  /**
   * Indicates that the upstream retry limit was exceeded, resulting in a downstream error.
   *
   * @generated from field: bool upstream_retry_limit_exceeded = 16;
   */
  upstreamRetryLimitExceeded: boolean;

  /**
   * Indicates that the stream idle timeout was hit, resulting in a downstream 408.
   *
   * @generated from field: bool stream_idle_timeout = 17;
   */
  streamIdleTimeout: boolean;

  /**
   * Indicates that the request was rejected because an envoy request header failed strict
   * validation.
   *
   * @generated from field: bool invalid_envoy_request_headers = 18;
   */
  invalidEnvoyRequestHeaders: boolean;

  /**
   * Indicates there was an HTTP protocol error on the downstream request.
   *
   * @generated from field: bool downstream_protocol_error = 19;
   */
  downstreamProtocolError: boolean;

  constructor(data?: PartialMessage<ResponseFlags>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.ResponseFlags";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseFlags;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseFlags;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseFlags;

  static equals(a: ResponseFlags | PlainMessage<ResponseFlags> | undefined, b: ResponseFlags | PlainMessage<ResponseFlags> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v2.ResponseFlags.Unauthorized
 */
export declare class ResponseFlags_Unauthorized extends Message<ResponseFlags_Unauthorized> {
  /**
   * @generated from field: envoy.data.accesslog.v2.ResponseFlags.Unauthorized.Reason reason = 1;
   */
  reason: ResponseFlags_Unauthorized_Reason;

  constructor(data?: PartialMessage<ResponseFlags_Unauthorized>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.ResponseFlags.Unauthorized";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseFlags_Unauthorized;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseFlags_Unauthorized;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseFlags_Unauthorized;

  static equals(a: ResponseFlags_Unauthorized | PlainMessage<ResponseFlags_Unauthorized> | undefined, b: ResponseFlags_Unauthorized | PlainMessage<ResponseFlags_Unauthorized> | undefined): boolean;
}

/**
 * Reasons why the request was unauthorized
 *
 * @generated from enum envoy.data.accesslog.v2.ResponseFlags.Unauthorized.Reason
 */
export declare enum ResponseFlags_Unauthorized_Reason {
  /**
   * @generated from enum value: REASON_UNSPECIFIED = 0;
   */
  REASON_UNSPECIFIED = 0,

  /**
   * The request was denied by the external authorization service.
   *
   * @generated from enum value: EXTERNAL_SERVICE = 1;
   */
  EXTERNAL_SERVICE = 1,
}

/**
 * Properties of a negotiated TLS connection.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.data.accesslog.v2.TLSProperties
 */
export declare class TLSProperties extends Message<TLSProperties> {
  /**
   * Version of TLS that was negotiated.
   *
   * @generated from field: envoy.data.accesslog.v2.TLSProperties.TLSVersion tls_version = 1;
   */
  tlsVersion: TLSProperties_TLSVersion;

  /**
   * TLS cipher suite negotiated during handshake. The value is a
   * four-digit hex code defined by the IANA TLS Cipher Suite Registry
   * (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
   *
   * Here it is expressed as an integer.
   *
   * @generated from field: google.protobuf.UInt32Value tls_cipher_suite = 2;
   */
  tlsCipherSuite?: number;

  /**
   * SNI hostname from handshake.
   *
   * @generated from field: string tls_sni_hostname = 3;
   */
  tlsSniHostname: string;

  /**
   * Properties of the local certificate used to negotiate TLS.
   *
   * @generated from field: envoy.data.accesslog.v2.TLSProperties.CertificateProperties local_certificate_properties = 4;
   */
  localCertificateProperties?: TLSProperties_CertificateProperties;

  /**
   * Properties of the peer certificate used to negotiate TLS.
   *
   * @generated from field: envoy.data.accesslog.v2.TLSProperties.CertificateProperties peer_certificate_properties = 5;
   */
  peerCertificateProperties?: TLSProperties_CertificateProperties;

  /**
   * The TLS session ID.
   *
   * @generated from field: string tls_session_id = 6;
   */
  tlsSessionId: string;

  constructor(data?: PartialMessage<TLSProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.TLSProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties;

  static equals(a: TLSProperties | PlainMessage<TLSProperties> | undefined, b: TLSProperties | PlainMessage<TLSProperties> | undefined): boolean;
}

/**
 * @generated from enum envoy.data.accesslog.v2.TLSProperties.TLSVersion
 */
export declare enum TLSProperties_TLSVersion {
  /**
   * @generated from enum value: VERSION_UNSPECIFIED = 0;
   */
  VERSION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: TLSv1 = 1;
   */
  TLSv1 = 1,

  /**
   * @generated from enum value: TLSv1_1 = 2;
   */
  TLSv1_1 = 2,

  /**
   * @generated from enum value: TLSv1_2 = 3;
   */
  TLSv1_2 = 3,

  /**
   * @generated from enum value: TLSv1_3 = 4;
   */
  TLSv1_3 = 4,
}

/**
 * @generated from message envoy.data.accesslog.v2.TLSProperties.CertificateProperties
 */
export declare class TLSProperties_CertificateProperties extends Message<TLSProperties_CertificateProperties> {
  /**
   * SANs present in the certificate.
   *
   * @generated from field: repeated envoy.data.accesslog.v2.TLSProperties.CertificateProperties.SubjectAltName subject_alt_name = 1;
   */
  subjectAltName: TLSProperties_CertificateProperties_SubjectAltName[];

  /**
   * The subject field of the certificate.
   *
   * @generated from field: string subject = 2;
   */
  subject: string;

  constructor(data?: PartialMessage<TLSProperties_CertificateProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.TLSProperties.CertificateProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties_CertificateProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties;

  static equals(a: TLSProperties_CertificateProperties | PlainMessage<TLSProperties_CertificateProperties> | undefined, b: TLSProperties_CertificateProperties | PlainMessage<TLSProperties_CertificateProperties> | undefined): boolean;
}

/**
 * @generated from message envoy.data.accesslog.v2.TLSProperties.CertificateProperties.SubjectAltName
 */
export declare class TLSProperties_CertificateProperties_SubjectAltName extends Message<TLSProperties_CertificateProperties_SubjectAltName> {
  /**
   * @generated from oneof envoy.data.accesslog.v2.TLSProperties.CertificateProperties.SubjectAltName.san
   */
  san: {
    /**
     * @generated from field: string uri = 1;
     */
    value: string;
    case: "uri";
  } | {
    /**
     * [#not-implemented-hide:]
     *
     * @generated from field: string dns = 2;
     */
    value: string;
    case: "dns";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<TLSProperties_CertificateProperties_SubjectAltName>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.TLSProperties.CertificateProperties.SubjectAltName";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TLSProperties_CertificateProperties_SubjectAltName;

  static equals(a: TLSProperties_CertificateProperties_SubjectAltName | PlainMessage<TLSProperties_CertificateProperties_SubjectAltName> | undefined, b: TLSProperties_CertificateProperties_SubjectAltName | PlainMessage<TLSProperties_CertificateProperties_SubjectAltName> | undefined): boolean;
}

/**
 * [#next-free-field: 14]
 *
 * @generated from message envoy.data.accesslog.v2.HTTPRequestProperties
 */
export declare class HTTPRequestProperties extends Message<HTTPRequestProperties> {
  /**
   * The request method (RFC 7231/2616).
   *
   * @generated from field: envoy.api.v2.core.RequestMethod request_method = 1;
   */
  requestMethod: RequestMethod;

  /**
   * The scheme portion of the incoming request URI.
   *
   * @generated from field: string scheme = 2;
   */
  scheme: string;

  /**
   * HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
   *
   * @generated from field: string authority = 3;
   */
  authority: string;

  /**
   * The port of the incoming request URI
   * (unused currently, as port is composed onto authority).
   *
   * @generated from field: google.protobuf.UInt32Value port = 4;
   */
  port?: number;

  /**
   * The path portion from the incoming request URI.
   *
   * @generated from field: string path = 5;
   */
  path: string;

  /**
   * Value of the ``User-Agent`` request header.
   *
   * @generated from field: string user_agent = 6;
   */
  userAgent: string;

  /**
   * Value of the ``Referer`` request header.
   *
   * @generated from field: string referer = 7;
   */
  referer: string;

  /**
   * Value of the ``X-Forwarded-For`` request header.
   *
   * @generated from field: string forwarded_for = 8;
   */
  forwardedFor: string;

  /**
   * Value of the ``X-Request-Id`` request header
   *
   * This header is used by Envoy to uniquely identify a request.
   * It will be generated for all external requests and internal requests that
   * do not already have a request ID.
   *
   * @generated from field: string request_id = 9;
   */
  requestId: string;

  /**
   * Value of the ``X-Envoy-Original-Path`` request header.
   *
   * @generated from field: string original_path = 10;
   */
  originalPath: string;

  /**
   * Size of the HTTP request headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 request_headers_bytes = 11;
   */
  requestHeadersBytes: bigint;

  /**
   * Size of the HTTP request body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 request_body_bytes = 12;
   */
  requestBodyBytes: bigint;

  /**
   * Map of additional headers that have been configured to be logged.
   *
   * @generated from field: map<string, string> request_headers = 13;
   */
  requestHeaders: { [key: string]: string };

  constructor(data?: PartialMessage<HTTPRequestProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.HTTPRequestProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPRequestProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPRequestProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPRequestProperties;

  static equals(a: HTTPRequestProperties | PlainMessage<HTTPRequestProperties> | undefined, b: HTTPRequestProperties | PlainMessage<HTTPRequestProperties> | undefined): boolean;
}

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.data.accesslog.v2.HTTPResponseProperties
 */
export declare class HTTPResponseProperties extends Message<HTTPResponseProperties> {
  /**
   * The HTTP response code returned by Envoy.
   *
   * @generated from field: google.protobuf.UInt32Value response_code = 1;
   */
  responseCode?: number;

  /**
   * Size of the HTTP response headers in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 response_headers_bytes = 2;
   */
  responseHeadersBytes: bigint;

  /**
   * Size of the HTTP response body in bytes.
   *
   * This value is captured from the OSI layer 7 perspective, i.e. it does not
   * include overhead from framing or encoding at other networking layers.
   *
   * @generated from field: uint64 response_body_bytes = 3;
   */
  responseBodyBytes: bigint;

  /**
   * Map of additional headers configured to be logged.
   *
   * @generated from field: map<string, string> response_headers = 4;
   */
  responseHeaders: { [key: string]: string };

  /**
   * Map of trailers configured to be logged.
   *
   * @generated from field: map<string, string> response_trailers = 5;
   */
  responseTrailers: { [key: string]: string };

  /**
   * The HTTP response code details.
   *
   * @generated from field: string response_code_details = 6;
   */
  responseCodeDetails: string;

  constructor(data?: PartialMessage<HTTPResponseProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.accesslog.v2.HTTPResponseProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPResponseProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPResponseProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPResponseProperties;

  static equals(a: HTTPResponseProperties | PlainMessage<HTTPResponseProperties> | undefined, b: HTTPResponseProperties | PlainMessage<HTTPResponseProperties> | undefined): boolean;
}

