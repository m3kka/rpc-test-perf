// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/data/dns/v3/dns_table.proto (package envoy.data.dns.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { StringMatcher } from "../../../type/matcher/v3/string_pb.js";

/**
 * This message contains the configuration for the DNS Filter if populated
 * from the control plane
 *
 * @generated from message envoy.data.dns.v3.DnsTable
 */
export declare class DnsTable extends Message<DnsTable> {
  /**
   * Control how many times Envoy makes an attempt to forward a query to an external DNS server
   *
   * @generated from field: uint32 external_retry_count = 1;
   */
  externalRetryCount: number;

  /**
   * Fully qualified domain names for which Envoy will respond to DNS queries. By leaving this
   * list empty, Envoy will forward all queries to external resolvers
   *
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsVirtualDomain virtual_domains = 2;
   */
  virtualDomains: DnsTable_DnsVirtualDomain[];

  /**
   * This field is deprecated and no longer used in Envoy. The filter's behavior has changed
   * internally to use a different data structure allowing the filter to determine whether a
   * query is for known domain without the use of this field.
   *
   * This field serves to help Envoy determine whether it can authoritatively answer a query
   * for a name matching a suffix in this list. If the query name does not match a suffix in
   * this list, Envoy will forward the query to an upstream DNS server
   *
   * @generated from field: repeated envoy.type.matcher.v3.StringMatcher known_suffixes = 3 [deprecated = true];
   * @deprecated
   */
  knownSuffixes: StringMatcher[];

  constructor(data?: PartialMessage<DnsTable>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable;

  static equals(a: DnsTable | PlainMessage<DnsTable> | undefined, b: DnsTable | PlainMessage<DnsTable> | undefined): boolean;
}

/**
 * This message contains a list of IP addresses returned for a query for a known name
 *
 * @generated from message envoy.data.dns.v3.DnsTable.AddressList
 */
export declare class DnsTable_AddressList extends Message<DnsTable_AddressList> {
  /**
   * This field contains a well formed IP address that is returned in the answer for a
   * name query. The address field can be an IPv4 or IPv6 address. Address family
   * detection is done automatically when Envoy parses the string. Since this field is
   * repeated, Envoy will return as many entries from this list in the DNS response while
   * keeping the response under 512 bytes
   *
   * @generated from field: repeated string address = 1;
   */
  address: string[];

  constructor(data?: PartialMessage<DnsTable_AddressList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.AddressList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_AddressList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_AddressList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_AddressList;

  static equals(a: DnsTable_AddressList | PlainMessage<DnsTable_AddressList> | undefined, b: DnsTable_AddressList | PlainMessage<DnsTable_AddressList> | undefined): boolean;
}

/**
 * Specify the service protocol using a numeric or string value
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceProtocol
 */
export declare class DnsTable_DnsServiceProtocol extends Message<DnsTable_DnsServiceProtocol> {
  /**
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsServiceProtocol.protocol_config
   */
  protocolConfig: {
    /**
     * Specify the protocol number for the service. Envoy will try to resolve the number to
     * the protocol name. For example, 6 will resolve to "tcp". Refer to:
     * https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
     * for protocol names and numbers
     *
     * @generated from field: uint32 number = 1;
     */
    value: number;
    case: "number";
  } | {
    /**
     * Specify the protocol name for the service.
     *
     * @generated from field: string name = 2;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<DnsTable_DnsServiceProtocol>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsServiceProtocol";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsServiceProtocol;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceProtocol;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceProtocol;

  static equals(a: DnsTable_DnsServiceProtocol | PlainMessage<DnsTable_DnsServiceProtocol> | undefined, b: DnsTable_DnsServiceProtocol | PlainMessage<DnsTable_DnsServiceProtocol> | undefined): boolean;
}

/**
 * Specify the target for a given DNS service
 * [#next-free-field: 6]
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceTarget
 */
export declare class DnsTable_DnsServiceTarget extends Message<DnsTable_DnsServiceTarget> {
  /**
   * Specify the name of the endpoint for the Service. The name is a hostname or a cluster
   *
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsServiceTarget.endpoint_type
   */
  endpointType: {
    /**
     * Use a resolvable hostname as the endpoint for a service.
     *
     * @generated from field: string host_name = 1;
     */
    value: string;
    case: "hostName";
  } | {
    /**
     * Use a cluster name as the endpoint for a service.
     *
     * @generated from field: string cluster_name = 2;
     */
    value: string;
    case: "clusterName";
  } | { case: undefined; value?: undefined };

  /**
   * The priority of the service record target
   *
   * @generated from field: uint32 priority = 3;
   */
  priority: number;

  /**
   * The weight of the service record target
   *
   * @generated from field: uint32 weight = 4;
   */
  weight: number;

  /**
   * The port to which the service is bound. This value is optional if the target is a
   * cluster. Setting port to zero in this case makes the filter use the port value
   * from the cluster host
   *
   * @generated from field: uint32 port = 5;
   */
  port: number;

  constructor(data?: PartialMessage<DnsTable_DnsServiceTarget>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsServiceTarget";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsServiceTarget;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceTarget;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceTarget;

  static equals(a: DnsTable_DnsServiceTarget | PlainMessage<DnsTable_DnsServiceTarget> | undefined, b: DnsTable_DnsServiceTarget | PlainMessage<DnsTable_DnsServiceTarget> | undefined): boolean;
}

/**
 * This message defines a service selection record returned for a service query in a domain
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsService
 */
export declare class DnsTable_DnsService extends Message<DnsTable_DnsService> {
  /**
   * The name of the service without the protocol or domain name
   *
   * @generated from field: string service_name = 1;
   */
  serviceName: string;

  /**
   * The service protocol. This can be specified as a string or the numeric value of the protocol
   *
   * @generated from field: envoy.data.dns.v3.DnsTable.DnsServiceProtocol protocol = 2;
   */
  protocol?: DnsTable_DnsServiceProtocol;

  /**
   * The service entry time to live. This is independent from the DNS Answer record TTL
   *
   * @generated from field: google.protobuf.Duration ttl = 3;
   */
  ttl?: Duration;

  /**
   * The list of targets hosting the service
   *
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsServiceTarget targets = 4;
   */
  targets: DnsTable_DnsServiceTarget[];

  constructor(data?: PartialMessage<DnsTable_DnsService>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsService";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsService;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsService;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsService;

  static equals(a: DnsTable_DnsService | PlainMessage<DnsTable_DnsService> | undefined, b: DnsTable_DnsService | PlainMessage<DnsTable_DnsService> | undefined): boolean;
}

/**
 * Define a list of service records for a given service
 *
 * @generated from message envoy.data.dns.v3.DnsTable.DnsServiceList
 */
export declare class DnsTable_DnsServiceList extends Message<DnsTable_DnsServiceList> {
  /**
   * @generated from field: repeated envoy.data.dns.v3.DnsTable.DnsService services = 1;
   */
  services: DnsTable_DnsService[];

  constructor(data?: PartialMessage<DnsTable_DnsServiceList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsServiceList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsServiceList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsServiceList;

  static equals(a: DnsTable_DnsServiceList | PlainMessage<DnsTable_DnsServiceList> | undefined, b: DnsTable_DnsServiceList | PlainMessage<DnsTable_DnsServiceList> | undefined): boolean;
}

/**
 * @generated from message envoy.data.dns.v3.DnsTable.DnsEndpoint
 */
export declare class DnsTable_DnsEndpoint extends Message<DnsTable_DnsEndpoint> {
  /**
   * @generated from oneof envoy.data.dns.v3.DnsTable.DnsEndpoint.endpoint_config
   */
  endpointConfig: {
    /**
     * Define a list of addresses to return for the specified endpoint
     *
     * @generated from field: envoy.data.dns.v3.DnsTable.AddressList address_list = 1;
     */
    value: DnsTable_AddressList;
    case: "addressList";
  } | {
    /**
     * Define a cluster whose addresses are returned for the specified endpoint
     *
     * @generated from field: string cluster_name = 2;
     */
    value: string;
    case: "clusterName";
  } | {
    /**
     * Define a DNS Service List for the specified endpoint
     *
     * @generated from field: envoy.data.dns.v3.DnsTable.DnsServiceList service_list = 3;
     */
    value: DnsTable_DnsServiceList;
    case: "serviceList";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<DnsTable_DnsEndpoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsEndpoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsEndpoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsEndpoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsEndpoint;

  static equals(a: DnsTable_DnsEndpoint | PlainMessage<DnsTable_DnsEndpoint> | undefined, b: DnsTable_DnsEndpoint | PlainMessage<DnsTable_DnsEndpoint> | undefined): boolean;
}

/**
 * @generated from message envoy.data.dns.v3.DnsTable.DnsVirtualDomain
 */
export declare class DnsTable_DnsVirtualDomain extends Message<DnsTable_DnsVirtualDomain> {
  /**
   * A domain name for which Envoy will respond to query requests
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The configuration containing the method to determine the address of this endpoint
   *
   * @generated from field: envoy.data.dns.v3.DnsTable.DnsEndpoint endpoint = 2;
   */
  endpoint?: DnsTable_DnsEndpoint;

  /**
   * Sets the TTL in DNS answers from Envoy returned to the client. The default TTL is 300s
   *
   * @generated from field: google.protobuf.Duration answer_ttl = 3;
   */
  answerTtl?: Duration;

  constructor(data?: PartialMessage<DnsTable_DnsVirtualDomain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v3.DnsTable.DnsVirtualDomain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsVirtualDomain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsVirtualDomain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsVirtualDomain;

  static equals(a: DnsTable_DnsVirtualDomain | PlainMessage<DnsTable_DnsVirtualDomain> | undefined, b: DnsTable_DnsVirtualDomain | PlainMessage<DnsTable_DnsVirtualDomain> | undefined): boolean;
}

