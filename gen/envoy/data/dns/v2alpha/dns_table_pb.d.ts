// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/data/dns/v2alpha/dns_table.proto (package envoy.data.dns.v2alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { StringMatcher } from "../../../type/matcher/string_pb.js";

/**
 * This message contains the configuration for the DNS Filter if populated
 * from the control plane
 *
 * @generated from message envoy.data.dns.v2alpha.DnsTable
 */
export declare class DnsTable extends Message<DnsTable> {
  /**
   * Control how many times envoy makes an attempt to forward a query to
   * an external server
   *
   * @generated from field: uint32 external_retry_count = 1;
   */
  externalRetryCount: number;

  /**
   * Fully qualified domain names for which Envoy will respond to queries
   *
   * @generated from field: repeated envoy.data.dns.v2alpha.DnsTable.DnsVirtualDomain virtual_domains = 2;
   */
  virtualDomains: DnsTable_DnsVirtualDomain[];

  /**
   * This field serves to help Envoy determine whether it can authoritatively
   * answer a query for a name matching a suffix in this list. If the query
   * name does not match a suffix in this list, Envoy will forward
   * the query to an upstream DNS server
   *
   * @generated from field: repeated envoy.type.matcher.StringMatcher known_suffixes = 3;
   */
  knownSuffixes: StringMatcher[];

  constructor(data?: PartialMessage<DnsTable>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v2alpha.DnsTable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable;

  static equals(a: DnsTable | PlainMessage<DnsTable> | undefined, b: DnsTable | PlainMessage<DnsTable> | undefined): boolean;
}

/**
 * This message contains a list of IP addresses returned for a query for a known name
 *
 * @generated from message envoy.data.dns.v2alpha.DnsTable.AddressList
 */
export declare class DnsTable_AddressList extends Message<DnsTable_AddressList> {
  /**
   * This field contains a well formed IP address that is returned
   * in the answer for a name query. The address field can be an
   * IPv4 or IPv6 address. Address family detection is done automatically
   * when Envoy parses the string. Since this field is repeated,
   * Envoy will return one randomly chosen entry from this list in the
   * DNS response. The random index will vary per query so that we prevent
   * clients pinning on a single address for a configured domain
   *
   * @generated from field: repeated string address = 1;
   */
  address: string[];

  constructor(data?: PartialMessage<DnsTable_AddressList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v2alpha.DnsTable.AddressList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_AddressList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_AddressList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_AddressList;

  static equals(a: DnsTable_AddressList | PlainMessage<DnsTable_AddressList> | undefined, b: DnsTable_AddressList | PlainMessage<DnsTable_AddressList> | undefined): boolean;
}

/**
 * This message type is extensible and can contain a list of addresses
 * or dictate some other method for resolving the addresses for an
 * endpoint
 *
 * @generated from message envoy.data.dns.v2alpha.DnsTable.DnsEndpoint
 */
export declare class DnsTable_DnsEndpoint extends Message<DnsTable_DnsEndpoint> {
  /**
   * @generated from oneof envoy.data.dns.v2alpha.DnsTable.DnsEndpoint.endpoint_config
   */
  endpointConfig: {
    /**
     * @generated from field: envoy.data.dns.v2alpha.DnsTable.AddressList address_list = 1;
     */
    value: DnsTable_AddressList;
    case: "addressList";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<DnsTable_DnsEndpoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v2alpha.DnsTable.DnsEndpoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsEndpoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsEndpoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsEndpoint;

  static equals(a: DnsTable_DnsEndpoint | PlainMessage<DnsTable_DnsEndpoint> | undefined, b: DnsTable_DnsEndpoint | PlainMessage<DnsTable_DnsEndpoint> | undefined): boolean;
}

/**
 * @generated from message envoy.data.dns.v2alpha.DnsTable.DnsVirtualDomain
 */
export declare class DnsTable_DnsVirtualDomain extends Message<DnsTable_DnsVirtualDomain> {
  /**
   * The domain name for which Envoy will respond to query requests
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The configuration containing the method to determine the address
   * of this endpoint
   *
   * @generated from field: envoy.data.dns.v2alpha.DnsTable.DnsEndpoint endpoint = 2;
   */
  endpoint?: DnsTable_DnsEndpoint;

  /**
   * Sets the TTL in dns answers from Envoy returned to the client
   *
   * @generated from field: google.protobuf.Duration answer_ttl = 3;
   */
  answerTtl?: Duration;

  constructor(data?: PartialMessage<DnsTable_DnsVirtualDomain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.data.dns.v2alpha.DnsTable.DnsVirtualDomain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsTable_DnsVirtualDomain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsTable_DnsVirtualDomain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsTable_DnsVirtualDomain;

  static equals(a: DnsTable_DnsVirtualDomain | PlainMessage<DnsTable_DnsVirtualDomain> | undefined, b: DnsTable_DnsVirtualDomain | PlainMessage<DnsTable_DnsVirtualDomain> | undefined): boolean;
}

