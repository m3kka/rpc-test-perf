// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/upstreams/http/v3/http_protocol_options.proto (package envoy.extensions.upstreams.http.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { AlternateProtocolsCacheOptions, Http1ProtocolOptions, Http2ProtocolOptions, Http3ProtocolOptions, HttpProtocolOptions as HttpProtocolOptions$1, UpstreamHttpProtocolOptions } from "../../../../config/core/v3/protocol_pb.js";
import { HttpFilter } from "../../../filters/network/http_connection_manager/v3/http_connection_manager_pb.js";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension_pb.js";

/**
 * HttpProtocolOptions specifies Http upstream protocol options. This object
 * is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.extensions.upstreams.http.v3.HttpProtocolOptions``.
 *
 * This controls what protocol(s) should be used for upstream and how said protocol(s) are configured.
 *
 * This replaces the prior pattern of explicit protocol configuration directly
 * in the cluster. So a configuration like this, explicitly configuring the use of HTTP/2 upstream:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       upstream_http_protocol_options:
 *         auto_sni: true
 *       common_http_protocol_options:
 *         idle_timeout: 1s
 *       http2_protocol_options:
 *         max_concurrent_streams: 100
 *        .... [further cluster config]
 *
 * Would now look like this:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       typed_extension_protocol_options:
 *         envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
 *           "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 *           upstream_http_protocol_options:
 *             auto_sni: true
 *           common_http_protocol_options:
 *             idle_timeout: 1s
 *           explicit_http_config:
 *             http2_protocol_options:
 *               max_concurrent_streams: 100
 *        .... [further cluster config]
 * [#next-free-field: 8]
 *
 * @generated from message envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 */
export const HttpProtocolOptions = proto3.makeMessageType(
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions",
  () => [
    { no: 1, name: "common_http_protocol_options", kind: "message", T: HttpProtocolOptions$1 },
    { no: 2, name: "upstream_http_protocol_options", kind: "message", T: UpstreamHttpProtocolOptions },
    { no: 3, name: "explicit_http_config", kind: "message", T: HttpProtocolOptions_ExplicitHttpConfig, oneof: "upstream_protocol_options" },
    { no: 4, name: "use_downstream_protocol_config", kind: "message", T: HttpProtocolOptions_UseDownstreamHttpConfig, oneof: "upstream_protocol_options" },
    { no: 5, name: "auto_config", kind: "message", T: HttpProtocolOptions_AutoHttpConfig, oneof: "upstream_protocol_options" },
    { no: 6, name: "http_filters", kind: "message", T: HttpFilter, repeated: true },
    { no: 7, name: "header_validation_config", kind: "message", T: TypedExtensionConfig },
  ],
);

/**
 * If this is used, the cluster will only operate on one of the possible upstream protocols.
 * Note that HTTP/2 or above should generally be used for upstream gRPC clusters.
 *
 * @generated from message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig
 */
export const HttpProtocolOptions_ExplicitHttpConfig = proto3.makeMessageType(
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig",
  () => [
    { no: 1, name: "http_protocol_options", kind: "message", T: Http1ProtocolOptions, oneof: "protocol_config" },
    { no: 2, name: "http2_protocol_options", kind: "message", T: Http2ProtocolOptions, oneof: "protocol_config" },
    { no: 3, name: "http3_protocol_options", kind: "message", T: Http3ProtocolOptions, oneof: "protocol_config" },
  ],
  {localName: "HttpProtocolOptions_ExplicitHttpConfig"},
);

/**
 * If this is used, the cluster can use either of the configured protocols, and
 * will use whichever protocol was used by the downstream connection.
 *
 * If HTTP/3 is configured for downstream and not configured for upstream,
 * HTTP/3 requests will fail over to HTTP/2.
 *
 * @generated from message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig
 */
export const HttpProtocolOptions_UseDownstreamHttpConfig = proto3.makeMessageType(
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig",
  () => [
    { no: 1, name: "http_protocol_options", kind: "message", T: Http1ProtocolOptions },
    { no: 2, name: "http2_protocol_options", kind: "message", T: Http2ProtocolOptions },
    { no: 3, name: "http3_protocol_options", kind: "message", T: Http3ProtocolOptions },
  ],
  {localName: "HttpProtocolOptions_UseDownstreamHttpConfig"},
);

/**
 * If this is used, the cluster can use either HTTP/1 or HTTP/2, and will use whichever
 * protocol is negotiated by ALPN with the upstream.
 * Clusters configured with ``AutoHttpConfig`` will use the highest available
 * protocol; HTTP/2 if supported, otherwise HTTP/1.
 * If the upstream does not support ALPN, ``AutoHttpConfig`` will fail over to HTTP/1.
 * This can only be used with transport sockets which support ALPN. Using a
 * transport socket which does not support ALPN will result in configuration
 * failure. The transport layer may be configured with custom ALPN, but the default ALPN
 * for the cluster (or if custom ALPN fails) will be "h2,http/1.1".
 *
 * @generated from message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig
 */
export const HttpProtocolOptions_AutoHttpConfig = proto3.makeMessageType(
  "envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig",
  () => [
    { no: 1, name: "http_protocol_options", kind: "message", T: Http1ProtocolOptions },
    { no: 2, name: "http2_protocol_options", kind: "message", T: Http2ProtocolOptions },
    { no: 3, name: "http3_protocol_options", kind: "message", T: Http3ProtocolOptions },
    { no: 4, name: "alternate_protocols_cache_options", kind: "message", T: AlternateProtocolsCacheOptions },
  ],
  {localName: "HttpProtocolOptions_AutoHttpConfig"},
);

