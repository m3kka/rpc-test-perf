// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/upstreams/http/v3/http_protocol_options.proto" (package "envoy.extensions.upstreams.http.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AlternateProtocolsCacheOptions } from "../../../../config/core/v3/protocol";
import { Http3ProtocolOptions } from "../../../../config/core/v3/protocol";
import { Http2ProtocolOptions } from "../../../../config/core/v3/protocol";
import { Http1ProtocolOptions } from "../../../../config/core/v3/protocol";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import { HttpFilter } from "../../../filters/network/http_connection_manager/v3/http_connection_manager";
import { UpstreamHttpProtocolOptions } from "../../../../config/core/v3/protocol";
import { HttpProtocolOptions as HttpProtocolOptions$ } from "../../../../config/core/v3/protocol";
// [#protodoc-title: HTTP Protocol Options]
// [#extension: envoy.upstreams.http.http_protocol_options]

/**
 * HttpProtocolOptions specifies Http upstream protocol options. This object
 * is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.extensions.upstreams.http.v3.HttpProtocolOptions``.
 *
 * This controls what protocol(s) should be used for upstream and how said protocol(s) are configured.
 *
 * This replaces the prior pattern of explicit protocol configuration directly
 * in the cluster. So a configuration like this, explicitly configuring the use of HTTP/2 upstream:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       upstream_http_protocol_options:
 *         auto_sni: true
 *       common_http_protocol_options:
 *         idle_timeout: 1s
 *       http2_protocol_options:
 *         max_concurrent_streams: 100
 *        .... [further cluster config]
 *
 * Would now look like this:
 *
 * .. code::
 *
 *   clusters:
 *     - name: some_service
 *       connect_timeout: 5s
 *       typed_extension_protocol_options:
 *         envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
 *           "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 *           upstream_http_protocol_options:
 *             auto_sni: true
 *           common_http_protocol_options:
 *             idle_timeout: 1s
 *           explicit_http_config:
 *             http2_protocol_options:
 *               max_concurrent_streams: 100
 *        .... [further cluster config]
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 */
export interface HttpProtocolOptions {
    /**
     * This contains options common across HTTP/1 and HTTP/2
     *
     * @generated from protobuf field: envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 1;
     */
    commonHttpProtocolOptions?: HttpProtocolOptions$;
    /**
     * This contains common protocol options which are only applied upstream.
     *
     * @generated from protobuf field: envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 2;
     */
    upstreamHttpProtocolOptions?: UpstreamHttpProtocolOptions;
    /**
     * @generated from protobuf oneof: upstream_protocol_options
     */
    upstreamProtocolOptions: {
        oneofKind: "explicitHttpConfig";
        /**
         * To explicitly configure either HTTP/1 or HTTP/2 (but not both!) use ``explicit_http_config``.
         * If the ``explicit_http_config`` is empty, HTTP/1.1 is used.
         *
         * @generated from protobuf field: envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig explicit_http_config = 3;
         */
        explicitHttpConfig: HttpProtocolOptions_ExplicitHttpConfig;
    } | {
        oneofKind: "useDownstreamProtocolConfig";
        /**
         * This allows switching on protocol based on what protocol the downstream
         * connection used.
         *
         * @generated from protobuf field: envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig use_downstream_protocol_config = 4;
         */
        useDownstreamProtocolConfig: HttpProtocolOptions_UseDownstreamHttpConfig;
    } | {
        oneofKind: "autoConfig";
        /**
         * This allows switching on protocol based on ALPN
         *
         * @generated from protobuf field: envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig auto_config = 5;
         */
        autoConfig: HttpProtocolOptions_AutoHttpConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * .. note::
     *   Upstream HTTP filters are currently in alpha.
     *
     * Optional HTTP filters for the upstream filter chain.
     *
     * These filters will be applied for all HTTP streams which flow through this
     * cluster. Unlike downstream filters, they will *not* be applied to terminated CONNECT requests.
     *
     * If using upstream filters, please be aware that local errors sent by
     * upstream filters will not trigger retries, and local errors sent by
     * upstream filters will count as a final response if hedging is configured.
     * [#extension-category: envoy.filters.http.upstream]
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 6;
     */
    httpFilters: HttpFilter[];
    /**
     * Configuration options for Unified Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP responses.
     *
     * [#comment:TODO(yanavlasov): Make it a link to the default header validator doc when it becomes visible.]
     * Leaving this field unspecified, selects the default header validator ``envoy.http.header_validators.envoy_default``.
     *
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig header_validation_config = 7;
     */
    headerValidationConfig?: TypedExtensionConfig;
}
/**
 * If this is used, the cluster will only operate on one of the possible upstream protocols.
 * Note that HTTP/2 or above should generally be used for upstream gRPC clusters.
 *
 * @generated from protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig
 */
export interface HttpProtocolOptions_ExplicitHttpConfig {
    /**
     * @generated from protobuf oneof: protocol_config
     */
    protocolConfig: {
        oneofKind: "httpProtocolOptions";
        /**
         * @generated from protobuf field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1;
         */
        httpProtocolOptions: Http1ProtocolOptions;
    } | {
        oneofKind: "http2ProtocolOptions";
        /**
         * @generated from protobuf field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;
         */
        http2ProtocolOptions: Http2ProtocolOptions;
    } | {
        oneofKind: "http3ProtocolOptions";
        /**
         * .. warning::
         *   QUIC upstream support is currently not ready for internet use.
         *   Please see :ref:`here <arch_overview_http3>` for details.
         *
         * @generated from protobuf field: envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;
         */
        http3ProtocolOptions: Http3ProtocolOptions;
    } | {
        oneofKind: undefined;
    };
}
/**
 * If this is used, the cluster can use either of the configured protocols, and
 * will use whichever protocol was used by the downstream connection.
 *
 * If HTTP/3 is configured for downstream and not configured for upstream,
 * HTTP/3 requests will fail over to HTTP/2.
 *
 * @generated from protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig
 */
export interface HttpProtocolOptions_UseDownstreamHttpConfig {
    /**
     * @generated from protobuf field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1;
     */
    httpProtocolOptions?: Http1ProtocolOptions;
    /**
     * @generated from protobuf field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;
     */
    http2ProtocolOptions?: Http2ProtocolOptions;
    /**
     * .. warning::
     *   QUIC upstream support is currently not ready for internet use.
     *   Please see :ref:`here <arch_overview_http3>` for details.
     *
     * @generated from protobuf field: envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;
     */
    http3ProtocolOptions?: Http3ProtocolOptions;
}
/**
 * If this is used, the cluster can use either HTTP/1 or HTTP/2, and will use whichever
 * protocol is negotiated by ALPN with the upstream.
 * Clusters configured with ``AutoHttpConfig`` will use the highest available
 * protocol; HTTP/2 if supported, otherwise HTTP/1.
 * If the upstream does not support ALPN, ``AutoHttpConfig`` will fail over to HTTP/1.
 * This can only be used with transport sockets which support ALPN. Using a
 * transport socket which does not support ALPN will result in configuration
 * failure. The transport layer may be configured with custom ALPN, but the default ALPN
 * for the cluster (or if custom ALPN fails) will be "h2,http/1.1".
 *
 * @generated from protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig
 */
export interface HttpProtocolOptions_AutoHttpConfig {
    /**
     * @generated from protobuf field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1;
     */
    httpProtocolOptions?: Http1ProtocolOptions;
    /**
     * @generated from protobuf field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2;
     */
    http2ProtocolOptions?: Http2ProtocolOptions;
    /**
     * Unlike HTTP/1 and HTTP/2, HTTP/3 will not be configured unless it is
     * present, and (soon) only if there is an indication of server side
     * support.
     * See :ref:`here <arch_overview_http3_upstream>` for more information on
     * when HTTP/3 will be used, and when Envoy will fail over to TCP.
     *
     * .. warning::
     *   QUIC upstream support is currently not ready for internet use.
     *   Please see :ref:`here <arch_overview_http3>` for details.
     *
     * @generated from protobuf field: envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3;
     */
    http3ProtocolOptions?: Http3ProtocolOptions;
    /**
     * The presence of alternate protocols cache options causes the use of the
     * alternate protocols cache, which is responsible for parsing and caching
     * HTTP Alt-Svc headers. This enables the use of HTTP/3 for origins that
     * advertise supporting it.
     *
     * .. note::
     *   This is required when HTTP/3 is enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.AlternateProtocolsCacheOptions alternate_protocols_cache_options = 4;
     */
    alternateProtocolsCacheOptions?: AlternateProtocolsCacheOptions;
}
// @generated message type with reflection information, may provide speed optimized methods
class HttpProtocolOptions$Type extends MessageType<HttpProtocolOptions> {
    constructor() {
        super("envoy.extensions.upstreams.http.v3.HttpProtocolOptions", [
            { no: 1, name: "common_http_protocol_options", kind: "message", T: () => HttpProtocolOptions$ },
            { no: 2, name: "upstream_http_protocol_options", kind: "message", T: () => UpstreamHttpProtocolOptions },
            { no: 3, name: "explicit_http_config", kind: "message", oneof: "upstreamProtocolOptions", T: () => HttpProtocolOptions_ExplicitHttpConfig },
            { no: 4, name: "use_downstream_protocol_config", kind: "message", oneof: "upstreamProtocolOptions", T: () => HttpProtocolOptions_UseDownstreamHttpConfig },
            { no: 5, name: "auto_config", kind: "message", oneof: "upstreamProtocolOptions", T: () => HttpProtocolOptions_AutoHttpConfig },
            { no: 6, name: "http_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpFilter },
            { no: 7, name: "header_validation_config", kind: "message", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<HttpProtocolOptions>): HttpProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upstreamProtocolOptions = { oneofKind: undefined };
        message.httpFilters = [];
        if (value !== undefined)
            reflectionMergePartial<HttpProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpProtocolOptions): HttpProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options */ 1:
                    message.commonHttpProtocolOptions = HttpProtocolOptions$.internalBinaryRead(reader, reader.uint32(), options, message.commonHttpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options */ 2:
                    message.upstreamHttpProtocolOptions = UpstreamHttpProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.upstreamHttpProtocolOptions);
                    break;
                case /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig explicit_http_config */ 3:
                    message.upstreamProtocolOptions = {
                        oneofKind: "explicitHttpConfig",
                        explicitHttpConfig: HttpProtocolOptions_ExplicitHttpConfig.internalBinaryRead(reader, reader.uint32(), options, (message.upstreamProtocolOptions as any).explicitHttpConfig)
                    };
                    break;
                case /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig use_downstream_protocol_config */ 4:
                    message.upstreamProtocolOptions = {
                        oneofKind: "useDownstreamProtocolConfig",
                        useDownstreamProtocolConfig: HttpProtocolOptions_UseDownstreamHttpConfig.internalBinaryRead(reader, reader.uint32(), options, (message.upstreamProtocolOptions as any).useDownstreamProtocolConfig)
                    };
                    break;
                case /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig auto_config */ 5:
                    message.upstreamProtocolOptions = {
                        oneofKind: "autoConfig",
                        autoConfig: HttpProtocolOptions_AutoHttpConfig.internalBinaryRead(reader, reader.uint32(), options, (message.upstreamProtocolOptions as any).autoConfig)
                    };
                    break;
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters */ 6:
                    message.httpFilters.push(HttpFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig header_validation_config */ 7:
                    message.headerValidationConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.headerValidationConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 1; */
        if (message.commonHttpProtocolOptions)
            HttpProtocolOptions$.internalBinaryWrite(message.commonHttpProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.UpstreamHttpProtocolOptions upstream_http_protocol_options = 2; */
        if (message.upstreamHttpProtocolOptions)
            UpstreamHttpProtocolOptions.internalBinaryWrite(message.upstreamHttpProtocolOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig explicit_http_config = 3; */
        if (message.upstreamProtocolOptions.oneofKind === "explicitHttpConfig")
            HttpProtocolOptions_ExplicitHttpConfig.internalBinaryWrite(message.upstreamProtocolOptions.explicitHttpConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig use_downstream_protocol_config = 4; */
        if (message.upstreamProtocolOptions.oneofKind === "useDownstreamProtocolConfig")
            HttpProtocolOptions_UseDownstreamHttpConfig.internalBinaryWrite(message.upstreamProtocolOptions.useDownstreamProtocolConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig auto_config = 5; */
        if (message.upstreamProtocolOptions.oneofKind === "autoConfig")
            HttpProtocolOptions_AutoHttpConfig.internalBinaryWrite(message.upstreamProtocolOptions.autoConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 6; */
        for (let i = 0; i < message.httpFilters.length; i++)
            HttpFilter.internalBinaryWrite(message.httpFilters[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig header_validation_config = 7; */
        if (message.headerValidationConfig)
            TypedExtensionConfig.internalBinaryWrite(message.headerValidationConfig, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions
 */
export const HttpProtocolOptions = new HttpProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpProtocolOptions_ExplicitHttpConfig$Type extends MessageType<HttpProtocolOptions_ExplicitHttpConfig> {
    constructor() {
        super("envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig", [
            { no: 1, name: "http_protocol_options", kind: "message", oneof: "protocolConfig", T: () => Http1ProtocolOptions },
            { no: 2, name: "http2_protocol_options", kind: "message", oneof: "protocolConfig", T: () => Http2ProtocolOptions },
            { no: 3, name: "http3_protocol_options", kind: "message", oneof: "protocolConfig", T: () => Http3ProtocolOptions }
        ]);
    }
    create(value?: PartialMessage<HttpProtocolOptions_ExplicitHttpConfig>): HttpProtocolOptions_ExplicitHttpConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocolConfig = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HttpProtocolOptions_ExplicitHttpConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpProtocolOptions_ExplicitHttpConfig): HttpProtocolOptions_ExplicitHttpConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options */ 1:
                    message.protocolConfig = {
                        oneofKind: "httpProtocolOptions",
                        httpProtocolOptions: Http1ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, (message.protocolConfig as any).httpProtocolOptions)
                    };
                    break;
                case /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options */ 2:
                    message.protocolConfig = {
                        oneofKind: "http2ProtocolOptions",
                        http2ProtocolOptions: Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, (message.protocolConfig as any).http2ProtocolOptions)
                    };
                    break;
                case /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options */ 3:
                    message.protocolConfig = {
                        oneofKind: "http3ProtocolOptions",
                        http3ProtocolOptions: Http3ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, (message.protocolConfig as any).http3ProtocolOptions)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpProtocolOptions_ExplicitHttpConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1; */
        if (message.protocolConfig.oneofKind === "httpProtocolOptions")
            Http1ProtocolOptions.internalBinaryWrite(message.protocolConfig.httpProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2; */
        if (message.protocolConfig.oneofKind === "http2ProtocolOptions")
            Http2ProtocolOptions.internalBinaryWrite(message.protocolConfig.http2ProtocolOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3; */
        if (message.protocolConfig.oneofKind === "http3ProtocolOptions")
            Http3ProtocolOptions.internalBinaryWrite(message.protocolConfig.http3ProtocolOptions, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.ExplicitHttpConfig
 */
export const HttpProtocolOptions_ExplicitHttpConfig = new HttpProtocolOptions_ExplicitHttpConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpProtocolOptions_UseDownstreamHttpConfig$Type extends MessageType<HttpProtocolOptions_UseDownstreamHttpConfig> {
    constructor() {
        super("envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig", [
            { no: 1, name: "http_protocol_options", kind: "message", T: () => Http1ProtocolOptions },
            { no: 2, name: "http2_protocol_options", kind: "message", T: () => Http2ProtocolOptions },
            { no: 3, name: "http3_protocol_options", kind: "message", T: () => Http3ProtocolOptions }
        ]);
    }
    create(value?: PartialMessage<HttpProtocolOptions_UseDownstreamHttpConfig>): HttpProtocolOptions_UseDownstreamHttpConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HttpProtocolOptions_UseDownstreamHttpConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpProtocolOptions_UseDownstreamHttpConfig): HttpProtocolOptions_UseDownstreamHttpConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options */ 1:
                    message.httpProtocolOptions = Http1ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.httpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options */ 2:
                    message.http2ProtocolOptions = Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http2ProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options */ 3:
                    message.http3ProtocolOptions = Http3ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http3ProtocolOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpProtocolOptions_UseDownstreamHttpConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1; */
        if (message.httpProtocolOptions)
            Http1ProtocolOptions.internalBinaryWrite(message.httpProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2; */
        if (message.http2ProtocolOptions)
            Http2ProtocolOptions.internalBinaryWrite(message.http2ProtocolOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3; */
        if (message.http3ProtocolOptions)
            Http3ProtocolOptions.internalBinaryWrite(message.http3ProtocolOptions, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.UseDownstreamHttpConfig
 */
export const HttpProtocolOptions_UseDownstreamHttpConfig = new HttpProtocolOptions_UseDownstreamHttpConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpProtocolOptions_AutoHttpConfig$Type extends MessageType<HttpProtocolOptions_AutoHttpConfig> {
    constructor() {
        super("envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig", [
            { no: 1, name: "http_protocol_options", kind: "message", T: () => Http1ProtocolOptions },
            { no: 2, name: "http2_protocol_options", kind: "message", T: () => Http2ProtocolOptions },
            { no: 3, name: "http3_protocol_options", kind: "message", T: () => Http3ProtocolOptions },
            { no: 4, name: "alternate_protocols_cache_options", kind: "message", T: () => AlternateProtocolsCacheOptions }
        ]);
    }
    create(value?: PartialMessage<HttpProtocolOptions_AutoHttpConfig>): HttpProtocolOptions_AutoHttpConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HttpProtocolOptions_AutoHttpConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpProtocolOptions_AutoHttpConfig): HttpProtocolOptions_AutoHttpConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options */ 1:
                    message.httpProtocolOptions = Http1ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.httpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options */ 2:
                    message.http2ProtocolOptions = Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http2ProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options */ 3:
                    message.http3ProtocolOptions = Http3ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http3ProtocolOptions);
                    break;
                case /* envoy.config.core.v3.AlternateProtocolsCacheOptions alternate_protocols_cache_options */ 4:
                    message.alternateProtocolsCacheOptions = AlternateProtocolsCacheOptions.internalBinaryRead(reader, reader.uint32(), options, message.alternateProtocolsCacheOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpProtocolOptions_AutoHttpConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 1; */
        if (message.httpProtocolOptions)
            Http1ProtocolOptions.internalBinaryWrite(message.httpProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 2; */
        if (message.http2ProtocolOptions)
            Http2ProtocolOptions.internalBinaryWrite(message.http2ProtocolOptions, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 3; */
        if (message.http3ProtocolOptions)
            Http3ProtocolOptions.internalBinaryWrite(message.http3ProtocolOptions, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.AlternateProtocolsCacheOptions alternate_protocols_cache_options = 4; */
        if (message.alternateProtocolsCacheOptions)
            AlternateProtocolsCacheOptions.internalBinaryWrite(message.alternateProtocolsCacheOptions, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.upstreams.http.v3.HttpProtocolOptions.AutoHttpConfig
 */
export const HttpProtocolOptions_AutoHttpConfig = new HttpProtocolOptions_AutoHttpConfig$Type();
