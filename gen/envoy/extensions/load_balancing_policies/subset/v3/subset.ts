// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/load_balancing_policies/subset/v3/subset.proto" (package "envoy.extensions.load_balancing_policies.subset.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { LoadBalancingPolicy } from "../../../../config/cluster/v3/cluster";
import { Struct } from "../../../../../google/protobuf/struct";
// [#protodoc-title: Subset Load Balancing Policy]
// [#extension: envoy.load_balancing_policies.subset]

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.subset.v3.Subset
 */
export interface Subset {
    /**
     * The behavior used when no endpoint subset matches the selected route's
     * metadata. The value defaults to
     * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
     *
     * @generated from protobuf field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy fallback_policy = 1;
     */
    fallbackPolicy: Subset_LbSubsetFallbackPolicy;
    /**
     * Specifies the default subset of endpoints used during fallback if
     * fallback_policy is
     * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
     * Each field in default_subset is
     * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
     * namespace. It is valid for no hosts to match, in which case the behavior
     * is the same as a fallback_policy of
     * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
     *
     * @generated from protobuf field: google.protobuf.Struct default_subset = 2;
     */
    defaultSubset?: Struct;
    /**
     * For each entry, LbEndpoint.Metadata's
     * ``envoy.lb`` namespace is traversed and a subset is created for each unique
     * combination of key and value. For example:
     *
     * .. code-block:: json
     *
     *   { "subset_selectors": [
     *       { "keys": [ "version" ] },
     *       { "keys": [ "stage", "hardware_type" ] }
     *   ]}
     *
     * A subset is matched when the metadata from the selected route and
     * weighted cluster contains the same keys and values as the subset's
     * metadata. The same host may appear in multiple subsets.
     *
     * @generated from protobuf field: repeated envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector subset_selectors = 3;
     */
    subsetSelectors: Subset_LbSubsetSelector[];
    /**
     * If true, routing to subsets will take into account the localities and locality weights of the
     * endpoints when making the routing decision.
     *
     * There are some potential pitfalls associated with enabling this feature, as the resulting
     * traffic split after applying both a subset match and locality weights might be undesirable.
     *
     * Consider for example a situation in which you have 50/50 split across two localities X/Y
     * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
     * host selected but Y having 100, then a lot more load is being dumped on the single host in X
     * than originally anticipated in the load balancing assignment delivered via EDS.
     *
     * @generated from protobuf field: bool locality_weight_aware = 4;
     */
    localityWeightAware: boolean;
    /**
     * When used with locality_weight_aware, scales the weight of each locality by the ratio
     * of hosts in the subset vs hosts in the original subset. This aims to even out the load
     * going to an individual locality if said locality is disproportionately affected by the
     * subset predicate.
     *
     * @generated from protobuf field: bool scale_locality_weight = 5;
     */
    scaleLocalityWeight: boolean;
    /**
     * If true, when a fallback policy is configured and its corresponding subset fails to find
     * a host this will cause any host to be selected instead.
     *
     * This is useful when using the default subset as the fallback policy, given the default
     * subset might become empty. With this option enabled, if that happens the LB will attempt
     * to select a host from the entire cluster.
     *
     * @generated from protobuf field: bool panic_mode_any = 6;
     */
    panicModeAny: boolean;
    /**
     * If true, metadata specified for a metadata key will be matched against the corresponding
     * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
     * and any of the elements in the list matches the criteria.
     *
     * @generated from protobuf field: bool list_as_any = 7;
     */
    listAsAny: boolean;
    /**
     * Fallback mechanism that allows to try different route metadata until a host is found.
     * If load balancing process, including all its mechanisms (like
     * :ref:`fallback_policy<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.subset.fallback_policy>`)
     * fails to select a host, this policy decides if and how the process is repeated using another metadata.
     *
     * The value defaults to
     * :ref:`METADATA_NO_FALLBACK
     * <envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.subset.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
     *
     * @generated from protobuf field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8;
     */
    metadataFallbackPolicy: Subset_LbSubsetMetadataFallbackPolicy;
    /**
     * The child LB policy to create for endpoint-picking within the chosen subset.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.LoadBalancingPolicy subset_lb_policy = 9;
     */
    subsetLbPolicy?: LoadBalancingPolicy;
}
/**
 * Specifications for subsets.
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector
 */
export interface Subset_LbSubsetSelector {
    /**
     * List of keys to match with the weighted cluster metadata.
     *
     * @generated from protobuf field: repeated string keys = 1;
     */
    keys: string[];
    /**
     * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
     * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
     *
     * If a match is found to a host, that host will be used regardless of priority levels.
     *
     * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
     * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
     * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
     * present in the current configuration.
     *
     * @generated from protobuf field: bool single_host_per_subset = 4;
     */
    singleHostPerSubset: boolean;
    /**
     * The behavior used when no endpoint subset matches the selected route's
     * metadata.
     *
     * @generated from protobuf field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2;
     */
    fallbackPolicy: Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;
    /**
     * Subset of
     * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` used by
     * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
     * fallback policy.
     * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
     * For any other fallback policy the parameter is not used and should not be set.
     * Only values also present in
     * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` are allowed, but
     * ``fallback_keys_subset`` cannot be equal to ``keys``.
     *
     * @generated from protobuf field: repeated string fallback_keys_subset = 3;
     */
    fallbackKeysSubset: string[];
}
/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from protobuf enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
    /**
     * If NOT_DEFINED top level config fallback policy is used instead.
     *
     * @generated from protobuf enum value: NOT_DEFINED = 0;
     */
    NOT_DEFINED = 0,
    /**
     * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
     *
     * @generated from protobuf enum value: NO_FALLBACK = 1;
     */
    NO_FALLBACK = 1,
    /**
     * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
     * (subject to policy, health checks, etc).
     *
     * @generated from protobuf enum value: ANY_ENDPOINT = 2;
     */
    ANY_ENDPOINT = 2,
    /**
     * If DEFAULT_SUBSET is selected, load balancing is performed over the
     * endpoints matching the values from the default_subset field.
     *
     * @generated from protobuf enum value: DEFAULT_SUBSET = 3;
     */
    DEFAULT_SUBSET = 3,
    /**
     * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
     * keys reduced to
     * :ref:`fallback_keys_subset<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.fallback_keys_subset>`.
     * It allows for a fallback to a different, less specific selector if some of the keys of
     * the selector are considered optional.
     *
     * @generated from protobuf enum value: KEYS_SUBSET = 4;
     */
    KEYS_SUBSET = 4
}
/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from protobuf enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy
 */
export enum Subset_LbSubsetFallbackPolicy {
    /**
     * @generated from protobuf enum value: NO_FALLBACK = 0;
     */
    NO_FALLBACK = 0,
    /**
     * @generated from protobuf enum value: ANY_ENDPOINT = 1;
     */
    ANY_ENDPOINT = 1,
    /**
     * @generated from protobuf enum value: DEFAULT_SUBSET = 2;
     */
    DEFAULT_SUBSET = 2
}
/**
 * @generated from protobuf enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy
 */
export enum Subset_LbSubsetMetadataFallbackPolicy {
    /**
     * No fallback. Route metadata will be used as-is.
     *
     * @generated from protobuf enum value: METADATA_NO_FALLBACK = 0;
     */
    METADATA_NO_FALLBACK = 0,
    /**
     * A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
     * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
     * be merged with route metadata, overriding keys that appear in both places.
     * ``fallback_list`` entries will be used in order until a host is found.
     *
     * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
     *
     * Example:
     *
     * for metadata:
     *
     * .. code-block:: yaml
     *
     *   version: 1.0
     *   fallback_list:
     *     - version: 2.0
     *       hardware: c64
     *     - hardware: c32
     *     - version: 3.0
     *
     * at first, metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "2.0", "hardware": "c64"}
     *
     * will be used for load balancing. If no host is found, metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "1.0", "hardware": "c32"}
     *
     * is next to try. If it still results in no host, finally metadata:
     *
     * .. code-block:: json
     *
     *   {"version": "3.0"}
     *
     * is used.
     *
     * @generated from protobuf enum value: FALLBACK_LIST = 1;
     */
    FALLBACK_LIST = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Subset$Type extends MessageType<Subset> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.subset.v3.Subset", [
            { no: 1, name: "fallback_policy", kind: "enum", T: () => ["envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy", Subset_LbSubsetFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "default_subset", kind: "message", T: () => Struct },
            { no: 3, name: "subset_selectors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Subset_LbSubsetSelector },
            { no: 4, name: "locality_weight_aware", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "scale_locality_weight", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "panic_mode_any", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "list_as_any", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "metadata_fallback_policy", kind: "enum", T: () => ["envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy", Subset_LbSubsetMetadataFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 9, name: "subset_lb_policy", kind: "message", T: () => LoadBalancingPolicy, options: { "validate.rules": { message: { required: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.cluster.v3.LbSubsetConfig" } });
    }
    create(value?: PartialMessage<Subset>): Subset {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fallbackPolicy = 0;
        message.subsetSelectors = [];
        message.localityWeightAware = false;
        message.scaleLocalityWeight = false;
        message.panicModeAny = false;
        message.listAsAny = false;
        message.metadataFallbackPolicy = 0;
        if (value !== undefined)
            reflectionMergePartial<Subset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subset): Subset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy fallback_policy */ 1:
                    message.fallbackPolicy = reader.int32();
                    break;
                case /* google.protobuf.Struct default_subset */ 2:
                    message.defaultSubset = Struct.internalBinaryRead(reader, reader.uint32(), options, message.defaultSubset);
                    break;
                case /* repeated envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector subset_selectors */ 3:
                    message.subsetSelectors.push(Subset_LbSubsetSelector.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool locality_weight_aware */ 4:
                    message.localityWeightAware = reader.bool();
                    break;
                case /* bool scale_locality_weight */ 5:
                    message.scaleLocalityWeight = reader.bool();
                    break;
                case /* bool panic_mode_any */ 6:
                    message.panicModeAny = reader.bool();
                    break;
                case /* bool list_as_any */ 7:
                    message.listAsAny = reader.bool();
                    break;
                case /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy metadata_fallback_policy */ 8:
                    message.metadataFallbackPolicy = reader.int32();
                    break;
                case /* envoy.config.cluster.v3.LoadBalancingPolicy subset_lb_policy */ 9:
                    message.subsetLbPolicy = LoadBalancingPolicy.internalBinaryRead(reader, reader.uint32(), options, message.subsetLbPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy fallback_policy = 1; */
        if (message.fallbackPolicy !== 0)
            writer.tag(1, WireType.Varint).int32(message.fallbackPolicy);
        /* google.protobuf.Struct default_subset = 2; */
        if (message.defaultSubset)
            Struct.internalBinaryWrite(message.defaultSubset, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector subset_selectors = 3; */
        for (let i = 0; i < message.subsetSelectors.length; i++)
            Subset_LbSubsetSelector.internalBinaryWrite(message.subsetSelectors[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool locality_weight_aware = 4; */
        if (message.localityWeightAware !== false)
            writer.tag(4, WireType.Varint).bool(message.localityWeightAware);
        /* bool scale_locality_weight = 5; */
        if (message.scaleLocalityWeight !== false)
            writer.tag(5, WireType.Varint).bool(message.scaleLocalityWeight);
        /* bool panic_mode_any = 6; */
        if (message.panicModeAny !== false)
            writer.tag(6, WireType.Varint).bool(message.panicModeAny);
        /* bool list_as_any = 7; */
        if (message.listAsAny !== false)
            writer.tag(7, WireType.Varint).bool(message.listAsAny);
        /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8; */
        if (message.metadataFallbackPolicy !== 0)
            writer.tag(8, WireType.Varint).int32(message.metadataFallbackPolicy);
        /* envoy.config.cluster.v3.LoadBalancingPolicy subset_lb_policy = 9; */
        if (message.subsetLbPolicy)
            LoadBalancingPolicy.internalBinaryWrite(message.subsetLbPolicy, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.subset.v3.Subset
 */
export const Subset = new Subset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subset_LbSubsetSelector$Type extends MessageType<Subset_LbSubsetSelector> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "single_host_per_subset", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "fallback_policy", kind: "enum", T: () => ["envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy", Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "fallback_keys_subset", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Subset_LbSubsetSelector>): Subset_LbSubsetSelector {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.singleHostPerSubset = false;
        message.fallbackPolicy = 0;
        message.fallbackKeysSubset = [];
        if (value !== undefined)
            reflectionMergePartial<Subset_LbSubsetSelector>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subset_LbSubsetSelector): Subset_LbSubsetSelector {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string keys */ 1:
                    message.keys.push(reader.string());
                    break;
                case /* bool single_host_per_subset */ 4:
                    message.singleHostPerSubset = reader.bool();
                    break;
                case /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy */ 2:
                    message.fallbackPolicy = reader.int32();
                    break;
                case /* repeated string fallback_keys_subset */ 3:
                    message.fallbackKeysSubset.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subset_LbSubsetSelector, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.keys[i]);
        /* bool single_host_per_subset = 4; */
        if (message.singleHostPerSubset !== false)
            writer.tag(4, WireType.Varint).bool(message.singleHostPerSubset);
        /* envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2; */
        if (message.fallbackPolicy !== 0)
            writer.tag(2, WireType.Varint).int32(message.fallbackPolicy);
        /* repeated string fallback_keys_subset = 3; */
        for (let i = 0; i < message.fallbackKeysSubset.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.fallbackKeysSubset[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector
 */
export const Subset_LbSubsetSelector = new Subset_LbSubsetSelector$Type();
