// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/load_balancing_policies/subset/v3/subset.proto (package envoy.extensions.load_balancing_policies.subset.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { LoadBalancingPolicy } from "../../../../config/cluster/v3/cluster_pb.js";

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.load_balancing_policies.subset.v3.Subset
 */
export declare class Subset extends Message<Subset> {
  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata. The value defaults to
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   *
   * @generated from field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy fallback_policy = 1;
   */
  fallbackPolicy: Subset_LbSubsetFallbackPolicy;

  /**
   * Specifies the default subset of endpoints used during fallback if
   * fallback_policy is
   * :ref:`DEFAULT_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
   * Each field in default_subset is
   * compared to the matching LbEndpoint.Metadata under the ``envoy.lb``
   * namespace. It is valid for no hosts to match, in which case the behavior
   * is the same as a fallback_policy of
   * :ref:`NO_FALLBACK<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy.NO_FALLBACK>`.
   *
   * @generated from field: google.protobuf.Struct default_subset = 2;
   */
  defaultSubset?: Struct;

  /**
   * For each entry, LbEndpoint.Metadata's
   * ``envoy.lb`` namespace is traversed and a subset is created for each unique
   * combination of key and value. For example:
   *
   * .. code-block:: json
   *
   *   { "subset_selectors": [
   *       { "keys": [ "version" ] },
   *       { "keys": [ "stage", "hardware_type" ] }
   *   ]}
   *
   * A subset is matched when the metadata from the selected route and
   * weighted cluster contains the same keys and values as the subset's
   * metadata. The same host may appear in multiple subsets.
   *
   * @generated from field: repeated envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector subset_selectors = 3;
   */
  subsetSelectors: Subset_LbSubsetSelector[];

  /**
   * If true, routing to subsets will take into account the localities and locality weights of the
   * endpoints when making the routing decision.
   *
   * There are some potential pitfalls associated with enabling this feature, as the resulting
   * traffic split after applying both a subset match and locality weights might be undesirable.
   *
   * Consider for example a situation in which you have 50/50 split across two localities X/Y
   * which have 100 hosts each without subsetting. If the subset LB results in X having only 1
   * host selected but Y having 100, then a lot more load is being dumped on the single host in X
   * than originally anticipated in the load balancing assignment delivered via EDS.
   *
   * @generated from field: bool locality_weight_aware = 4;
   */
  localityWeightAware: boolean;

  /**
   * When used with locality_weight_aware, scales the weight of each locality by the ratio
   * of hosts in the subset vs hosts in the original subset. This aims to even out the load
   * going to an individual locality if said locality is disproportionately affected by the
   * subset predicate.
   *
   * @generated from field: bool scale_locality_weight = 5;
   */
  scaleLocalityWeight: boolean;

  /**
   * If true, when a fallback policy is configured and its corresponding subset fails to find
   * a host this will cause any host to be selected instead.
   *
   * This is useful when using the default subset as the fallback policy, given the default
   * subset might become empty. With this option enabled, if that happens the LB will attempt
   * to select a host from the entire cluster.
   *
   * @generated from field: bool panic_mode_any = 6;
   */
  panicModeAny: boolean;

  /**
   * If true, metadata specified for a metadata key will be matched against the corresponding
   * endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
   * and any of the elements in the list matches the criteria.
   *
   * @generated from field: bool list_as_any = 7;
   */
  listAsAny: boolean;

  /**
   * Fallback mechanism that allows to try different route metadata until a host is found.
   * If load balancing process, including all its mechanisms (like
   * :ref:`fallback_policy<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.subset.fallback_policy>`)
   * fails to select a host, this policy decides if and how the process is repeated using another metadata.
   *
   * The value defaults to
   * :ref:`METADATA_NO_FALLBACK
   * <envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.subset.LbSubsetMetadataFallbackPolicy.METADATA_NO_FALLBACK>`.
   *
   * @generated from field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy metadata_fallback_policy = 8;
   */
  metadataFallbackPolicy: Subset_LbSubsetMetadataFallbackPolicy;

  /**
   * The child LB policy to create for endpoint-picking within the chosen subset.
   *
   * @generated from field: envoy.config.cluster.v3.LoadBalancingPolicy subset_lb_policy = 9;
   */
  subsetLbPolicy?: LoadBalancingPolicy;

  constructor(data?: PartialMessage<Subset>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.subset.v3.Subset";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subset;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subset;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subset;

  static equals(a: Subset | PlainMessage<Subset> | undefined, b: Subset | PlainMessage<Subset> | undefined): boolean;
}

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetFallbackPolicy
 */
export declare enum Subset_LbSubsetFallbackPolicy {
  /**
   * @generated from enum value: NO_FALLBACK = 0;
   */
  NO_FALLBACK = 0,

  /**
   * @generated from enum value: ANY_ENDPOINT = 1;
   */
  ANY_ENDPOINT = 1,

  /**
   * @generated from enum value: DEFAULT_SUBSET = 2;
   */
  DEFAULT_SUBSET = 2,
}

/**
 * @generated from enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetMetadataFallbackPolicy
 */
export declare enum Subset_LbSubsetMetadataFallbackPolicy {
  /**
   * No fallback. Route metadata will be used as-is.
   *
   * @generated from enum value: METADATA_NO_FALLBACK = 0;
   */
  METADATA_NO_FALLBACK = 0,

  /**
   * A special metadata key ``fallback_list`` will be used to provide variants of metadata to try.
   * Value of ``fallback_list`` key has to be a list. Every list element has to be a struct - it will
   * be merged with route metadata, overriding keys that appear in both places.
   * ``fallback_list`` entries will be used in order until a host is found.
   *
   * ``fallback_list`` key itself is removed from metadata before subset load balancing is performed.
   *
   * Example:
   *
   * for metadata:
   *
   * .. code-block:: yaml
   *
   *   version: 1.0
   *   fallback_list:
   *     - version: 2.0
   *       hardware: c64
   *     - hardware: c32
   *     - version: 3.0
   *
   * at first, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "2.0", "hardware": "c64"}
   *
   * will be used for load balancing. If no host is found, metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "1.0", "hardware": "c32"}
   *
   * is next to try. If it still results in no host, finally metadata:
   *
   * .. code-block:: json
   *
   *   {"version": "3.0"}
   *
   * is used.
   *
   * @generated from enum value: FALLBACK_LIST = 1;
   */
  FALLBACK_LIST = 1,
}

/**
 * Specifications for subsets.
 *
 * @generated from message envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector
 */
export declare class Subset_LbSubsetSelector extends Message<Subset_LbSubsetSelector> {
  /**
   * List of keys to match with the weighted cluster metadata.
   *
   * @generated from field: repeated string keys = 1;
   */
  keys: string[];

  /**
   * Selects a mode of operation in which each subset has only one host. This mode uses the same rules for
   * choosing a host, but updating hosts is faster, especially for large numbers of hosts.
   *
   * If a match is found to a host, that host will be used regardless of priority levels.
   *
   * When this mode is enabled, configurations that contain more than one host with the same metadata value for the single key in ``keys``
   * will use only one of the hosts with the given key; no requests will be routed to the others. The cluster gauge
   * :ref:`lb_subsets_single_host_per_subset_duplicate<config_cluster_manager_cluster_stats_subset_lb>` indicates how many duplicates are
   * present in the current configuration.
   *
   * @generated from field: bool single_host_per_subset = 4;
   */
  singleHostPerSubset: boolean;

  /**
   * The behavior used when no endpoint subset matches the selected route's
   * metadata.
   *
   * @generated from field: envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy fallback_policy = 2;
   */
  fallbackPolicy: Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy;

  /**
   * Subset of
   * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` used by
   * :ref:`KEYS_SUBSET<envoy_v3_api_enum_value_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
   * fallback policy.
   * It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
   * For any other fallback policy the parameter is not used and should not be set.
   * Only values also present in
   * :ref:`keys<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.keys>` are allowed, but
   * ``fallback_keys_subset`` cannot be equal to ``keys``.
   *
   * @generated from field: repeated string fallback_keys_subset = 3;
   */
  fallbackKeysSubset: string[];

  constructor(data?: PartialMessage<Subset_LbSubsetSelector>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subset_LbSubsetSelector;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subset_LbSubsetSelector;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subset_LbSubsetSelector;

  static equals(a: Subset_LbSubsetSelector | PlainMessage<Subset_LbSubsetSelector> | undefined, b: Subset_LbSubsetSelector | PlainMessage<Subset_LbSubsetSelector> | undefined): boolean;
}

/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from enum envoy.extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export declare enum Subset_LbSubsetSelector_LbSubsetSelectorFallbackPolicy {
  /**
   * If NOT_DEFINED top level config fallback policy is used instead.
   *
   * @generated from enum value: NOT_DEFINED = 0;
   */
  NOT_DEFINED = 0,

  /**
   * If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
   *
   * @generated from enum value: NO_FALLBACK = 1;
   */
  NO_FALLBACK = 1,

  /**
   * If ANY_ENDPOINT is selected, any cluster endpoint may be returned
   * (subject to policy, health checks, etc).
   *
   * @generated from enum value: ANY_ENDPOINT = 2;
   */
  ANY_ENDPOINT = 2,

  /**
   * If DEFAULT_SUBSET is selected, load balancing is performed over the
   * endpoints matching the values from the default_subset field.
   *
   * @generated from enum value: DEFAULT_SUBSET = 3;
   */
  DEFAULT_SUBSET = 3,

  /**
   * If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
   * keys reduced to
   * :ref:`fallback_keys_subset<envoy_v3_api_field_extensions.load_balancing_policies.subset.v3.Subset.LbSubsetSelector.fallback_keys_subset>`.
   * It allows for a fallback to a different, less specific selector if some of the keys of
   * the selector are considered optional.
   *
   * @generated from enum value: KEYS_SUBSET = 4;
   */
  KEYS_SUBSET = 4,
}

