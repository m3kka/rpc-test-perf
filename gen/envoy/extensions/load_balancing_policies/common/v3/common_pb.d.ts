// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/load_balancing_policies/common/v3/common.proto (package envoy.extensions.load_balancing_policies.common.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Percent } from "../../../../type/v3/percent_pb.js";
import type { RuntimeDouble } from "../../../../config/core/v3/base_pb.js";

/**
 * @generated from message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig
 */
export declare class LocalityLbConfig extends Message<LocalityLbConfig> {
  /**
   * @generated from oneof envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.locality_config_specifier
   */
  localityConfigSpecifier: {
    /**
     * Configuration for local zone aware load balancing.
     *
     * @generated from field: envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 1;
     */
    value: LocalityLbConfig_ZoneAwareLbConfig;
    case: "zoneAwareLbConfig";
  } | {
    /**
     * Enable locality weighted load balancing.
     *
     * @generated from field: envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 2;
     */
    value: LocalityLbConfig_LocalityWeightedLbConfig;
    case: "localityWeightedLbConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<LocalityLbConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbConfig;

  static equals(a: LocalityLbConfig | PlainMessage<LocalityLbConfig> | undefined, b: LocalityLbConfig | PlainMessage<LocalityLbConfig> | undefined): boolean;
}

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig
 */
export declare class LocalityLbConfig_ZoneAwareLbConfig extends Message<LocalityLbConfig_ZoneAwareLbConfig> {
  /**
   * Configures percentage of requests that will be considered for zone aware routing
   * if zone aware routing is configured. If not specified, the default is 100%.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   *
   * @generated from field: envoy.type.v3.Percent routing_enabled = 1;
   */
  routingEnabled?: Percent;

  /**
   * Configures minimum upstream cluster size required for zone aware routing
   * If upstream cluster size is less than specified, zone aware routing is not performed
   * even if zone aware routing is configured. If not specified, the default is 6.
   * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
   * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
   *
   * @generated from field: google.protobuf.UInt64Value min_cluster_size = 2;
   */
  minClusterSize?: bigint;

  /**
   * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
   * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
   * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
   * failing service.
   *
   * @generated from field: bool fail_traffic_on_panic = 3;
   */
  failTrafficOnPanic: boolean;

  constructor(data?: PartialMessage<LocalityLbConfig_ZoneAwareLbConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbConfig_ZoneAwareLbConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbConfig_ZoneAwareLbConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbConfig_ZoneAwareLbConfig;

  static equals(a: LocalityLbConfig_ZoneAwareLbConfig | PlainMessage<LocalityLbConfig_ZoneAwareLbConfig> | undefined, b: LocalityLbConfig_ZoneAwareLbConfig | PlainMessage<LocalityLbConfig_ZoneAwareLbConfig> | undefined): boolean;
}

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig
 */
export declare class LocalityLbConfig_LocalityWeightedLbConfig extends Message<LocalityLbConfig_LocalityWeightedLbConfig> {
  constructor(data?: PartialMessage<LocalityLbConfig_LocalityWeightedLbConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbConfig_LocalityWeightedLbConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbConfig_LocalityWeightedLbConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbConfig_LocalityWeightedLbConfig;

  static equals(a: LocalityLbConfig_LocalityWeightedLbConfig | PlainMessage<LocalityLbConfig_LocalityWeightedLbConfig> | undefined, b: LocalityLbConfig_LocalityWeightedLbConfig | PlainMessage<LocalityLbConfig_LocalityWeightedLbConfig> | undefined): boolean;
}

/**
 * Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
 *
 * @generated from message envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig
 */
export declare class SlowStartConfig extends Message<SlowStartConfig> {
  /**
   * Represents the size of slow start window.
   * If set, the newly created host remains in slow start mode starting from its creation time
   * for the duration of slow start window.
   *
   * @generated from field: google.protobuf.Duration slow_start_window = 1;
   */
  slowStartWindow?: Duration;

  /**
   * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
   * so that endpoint would get linearly increasing amount of traffic.
   * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
   * The value of aggression parameter should be greater than 0.0.
   * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
   *
   * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
   * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
   * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
   *
   * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
   * Once host exits slow start, time_factor and aggression no longer affect its weight.
   *
   * @generated from field: envoy.config.core.v3.RuntimeDouble aggression = 2;
   */
  aggression?: RuntimeDouble;

  /**
   * Configures the minimum percentage of origin weight that avoids too small new weight,
   * which may cause endpoints in slow start mode receive no traffic in slow start window.
   * If not specified, the default is 10%.
   *
   * @generated from field: envoy.type.v3.Percent min_weight_percent = 3;
   */
  minWeightPercent?: Percent;

  constructor(data?: PartialMessage<SlowStartConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SlowStartConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SlowStartConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SlowStartConfig;

  static equals(a: SlowStartConfig | PlainMessage<SlowStartConfig> | undefined, b: SlowStartConfig | PlainMessage<SlowStartConfig> | undefined): boolean;
}

/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from message envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig
 */
export declare class ConsistentHashingLbConfig extends Message<ConsistentHashingLbConfig> {
  /**
   * If set to ``true``, the cluster will use hostname instead of the resolved
   * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
   *
   * @generated from field: bool use_hostname_for_hashing = 1;
   */
  useHostnameForHashing: boolean;

  /**
   * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
   * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
   * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
   * Minimum is 100.
   *
   * Applies to both Ring Hash and Maglev load balancers.
   *
   * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
   * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
   * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
   * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
   * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
   * cascading overflow effect when choosing the next host in the ring/table).
   *
   * If weights are specified on the hosts, they are respected.
   *
   * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
   * being probed, so use a higher value if you require better performance.
   *
   * @generated from field: google.protobuf.UInt32Value hash_balance_factor = 2;
   */
  hashBalanceFactor?: number;

  constructor(data?: PartialMessage<ConsistentHashingLbConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsistentHashingLbConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsistentHashingLbConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsistentHashingLbConfig;

  static equals(a: ConsistentHashingLbConfig | PlainMessage<ConsistentHashingLbConfig> | undefined, b: ConsistentHashingLbConfig | PlainMessage<ConsistentHashingLbConfig> | undefined): boolean;
}

