// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/load_balancing_policies/common/v3/common.proto" (package "envoy.extensions.load_balancing_policies.common.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt32Value } from "../../../../../google/protobuf/wrappers";
import { RuntimeDouble } from "../../../../config/core/v3/base";
import { Duration } from "../../../../../google/protobuf/duration";
import { UInt64Value } from "../../../../../google/protobuf/wrappers";
import { Percent } from "../../../../type/v3/percent";
// [#protodoc-title: Common configuration for two or more load balancing policy extensions]

/**
 * @generated from protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig
 */
export interface LocalityLbConfig {
    /**
     * @generated from protobuf oneof: locality_config_specifier
     */
    localityConfigSpecifier: {
        oneofKind: "zoneAwareLbConfig";
        /**
         * Configuration for local zone aware load balancing.
         *
         * @generated from protobuf field: envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 1;
         */
        zoneAwareLbConfig: LocalityLbConfig_ZoneAwareLbConfig;
    } | {
        oneofKind: "localityWeightedLbConfig";
        /**
         * Enable locality weighted load balancing.
         *
         * @generated from protobuf field: envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 2;
         */
        localityWeightedLbConfig: LocalityLbConfig_LocalityWeightedLbConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig
 */
export interface LocalityLbConfig_ZoneAwareLbConfig {
    /**
     * Configures percentage of requests that will be considered for zone aware routing
     * if zone aware routing is configured. If not specified, the default is 100%.
     * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
     * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
     *
     * @generated from protobuf field: envoy.type.v3.Percent routing_enabled = 1;
     */
    routingEnabled?: Percent;
    /**
     * Configures minimum upstream cluster size required for zone aware routing
     * If upstream cluster size is less than specified, zone aware routing is not performed
     * even if zone aware routing is configured. If not specified, the default is 6.
     * * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
     * * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value min_cluster_size = 2;
     */
    minClusterSize?: UInt64Value;
    /**
     * If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
     * mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
     * requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
     * failing service.
     *
     * @generated from protobuf field: bool fail_traffic_on_panic = 3;
     */
    failTrafficOnPanic: boolean;
}
/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig
 */
export interface LocalityLbConfig_LocalityWeightedLbConfig {
}
/**
 * Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig
 */
export interface SlowStartConfig {
    /**
     * Represents the size of slow start window.
     * If set, the newly created host remains in slow start mode starting from its creation time
     * for the duration of slow start window.
     *
     * @generated from protobuf field: google.protobuf.Duration slow_start_window = 1;
     */
    slowStartWindow?: Duration;
    /**
     * This parameter controls the speed of traffic increase over the slow start window. Defaults to 1.0,
     * so that endpoint would get linearly increasing amount of traffic.
     * When increasing the value for this parameter, the speed of traffic ramp-up increases non-linearly.
     * The value of aggression parameter should be greater than 0.0.
     * By tuning the parameter, is possible to achieve polynomial or exponential shape of ramp-up curve.
     *
     * During slow start window, effective weight of an endpoint would be scaled with time factor and aggression:
     * ``new_weight = weight * max(min_weight_percent, time_factor ^ (1 / aggression))``,
     * where ``time_factor=(time_since_start_seconds / slow_start_time_seconds)``.
     *
     * As time progresses, more and more traffic would be sent to endpoint, which is in slow start window.
     * Once host exits slow start, time_factor and aggression no longer affect its weight.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeDouble aggression = 2;
     */
    aggression?: RuntimeDouble;
    /**
     * Configures the minimum percentage of origin weight that avoids too small new weight,
     * which may cause endpoints in slow start mode receive no traffic in slow start window.
     * If not specified, the default is 10%.
     *
     * @generated from protobuf field: envoy.type.v3.Percent min_weight_percent = 3;
     */
    minWeightPercent?: Percent;
}
/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from protobuf message envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig
 */
export interface ConsistentHashingLbConfig {
    /**
     * If set to ``true``, the cluster will use hostname instead of the resolved
     * address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
     *
     * @generated from protobuf field: bool use_hostname_for_hashing = 1;
     */
    useHostnameForHashing: boolean;
    /**
     * Configures percentage of average cluster load to bound per upstream host. For example, with a value of 150
     * no upstream host will get a load more than 1.5 times the average load of all the hosts in the cluster.
     * If not specified, the load is not bounded for any upstream host. Typical value for this parameter is between 120 and 200.
     * Minimum is 100.
     *
     * Applies to both Ring Hash and Maglev load balancers.
     *
     * This is implemented based on the method described in the paper https://arxiv.org/abs/1608.01350. For the specified
     * ``hash_balance_factor``, requests to any upstream host are capped at ``hash_balance_factor/100`` times the average number of requests
     * across the cluster. When a request arrives for an upstream host that is currently serving at its max capacity, linear probing
     * is used to identify an eligible host. Further, the linear probe is implemented using a random jump in hosts ring/table to identify
     * the eligible host (this technique is as described in the paper https://arxiv.org/abs/1908.08762 - the random jump avoids the
     * cascading overflow effect when choosing the next host in the ring/table).
     *
     * If weights are specified on the hosts, they are respected.
     *
     * This is an O(N) algorithm, unlike other load balancers. Using a lower ``hash_balance_factor`` results in more hosts
     * being probed, so use a higher value if you require better performance.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value hash_balance_factor = 2;
     */
    hashBalanceFactor?: UInt32Value;
}
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbConfig$Type extends MessageType<LocalityLbConfig> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig", [
            { no: 1, name: "zone_aware_lb_config", kind: "message", oneof: "localityConfigSpecifier", T: () => LocalityLbConfig_ZoneAwareLbConfig },
            { no: 2, name: "locality_weighted_lb_config", kind: "message", oneof: "localityConfigSpecifier", T: () => LocalityLbConfig_LocalityWeightedLbConfig }
        ]);
    }
    create(value?: PartialMessage<LocalityLbConfig>): LocalityLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localityConfigSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LocalityLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbConfig): LocalityLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig zone_aware_lb_config */ 1:
                    message.localityConfigSpecifier = {
                        oneofKind: "zoneAwareLbConfig",
                        zoneAwareLbConfig: LocalityLbConfig_ZoneAwareLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.localityConfigSpecifier as any).zoneAwareLbConfig)
                    };
                    break;
                case /* envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config */ 2:
                    message.localityConfigSpecifier = {
                        oneofKind: "localityWeightedLbConfig",
                        localityWeightedLbConfig: LocalityLbConfig_LocalityWeightedLbConfig.internalBinaryRead(reader, reader.uint32(), options, (message.localityConfigSpecifier as any).localityWeightedLbConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig zone_aware_lb_config = 1; */
        if (message.localityConfigSpecifier.oneofKind === "zoneAwareLbConfig")
            LocalityLbConfig_ZoneAwareLbConfig.internalBinaryWrite(message.localityConfigSpecifier.zoneAwareLbConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig locality_weighted_lb_config = 2; */
        if (message.localityConfigSpecifier.oneofKind === "localityWeightedLbConfig")
            LocalityLbConfig_LocalityWeightedLbConfig.internalBinaryWrite(message.localityConfigSpecifier.localityWeightedLbConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig
 */
export const LocalityLbConfig = new LocalityLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbConfig_ZoneAwareLbConfig$Type extends MessageType<LocalityLbConfig_ZoneAwareLbConfig> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig", [
            { no: 1, name: "routing_enabled", kind: "message", T: () => Percent },
            { no: 2, name: "min_cluster_size", kind: "message", T: () => UInt64Value },
            { no: 3, name: "fail_traffic_on_panic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LocalityLbConfig_ZoneAwareLbConfig>): LocalityLbConfig_ZoneAwareLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failTrafficOnPanic = false;
        if (value !== undefined)
            reflectionMergePartial<LocalityLbConfig_ZoneAwareLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbConfig_ZoneAwareLbConfig): LocalityLbConfig_ZoneAwareLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent routing_enabled */ 1:
                    message.routingEnabled = Percent.internalBinaryRead(reader, reader.uint32(), options, message.routingEnabled);
                    break;
                case /* google.protobuf.UInt64Value min_cluster_size */ 2:
                    message.minClusterSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.minClusterSize);
                    break;
                case /* bool fail_traffic_on_panic */ 3:
                    message.failTrafficOnPanic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityLbConfig_ZoneAwareLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent routing_enabled = 1; */
        if (message.routingEnabled)
            Percent.internalBinaryWrite(message.routingEnabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt64Value min_cluster_size = 2; */
        if (message.minClusterSize)
            UInt64Value.internalBinaryWrite(message.minClusterSize, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool fail_traffic_on_panic = 3; */
        if (message.failTrafficOnPanic !== false)
            writer.tag(3, WireType.Varint).bool(message.failTrafficOnPanic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.ZoneAwareLbConfig
 */
export const LocalityLbConfig_ZoneAwareLbConfig = new LocalityLbConfig_ZoneAwareLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbConfig_LocalityWeightedLbConfig$Type extends MessageType<LocalityLbConfig_LocalityWeightedLbConfig> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig", []);
    }
    create(value?: PartialMessage<LocalityLbConfig_LocalityWeightedLbConfig>): LocalityLbConfig_LocalityWeightedLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LocalityLbConfig_LocalityWeightedLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbConfig_LocalityWeightedLbConfig): LocalityLbConfig_LocalityWeightedLbConfig {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LocalityLbConfig_LocalityWeightedLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.common.v3.LocalityLbConfig.LocalityWeightedLbConfig
 */
export const LocalityLbConfig_LocalityWeightedLbConfig = new LocalityLbConfig_LocalityWeightedLbConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlowStartConfig$Type extends MessageType<SlowStartConfig> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig", [
            { no: 1, name: "slow_start_window", kind: "message", T: () => Duration },
            { no: 2, name: "aggression", kind: "message", T: () => RuntimeDouble },
            { no: 3, name: "min_weight_percent", kind: "message", T: () => Percent }
        ]);
    }
    create(value?: PartialMessage<SlowStartConfig>): SlowStartConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SlowStartConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SlowStartConfig): SlowStartConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration slow_start_window */ 1:
                    message.slowStartWindow = Duration.internalBinaryRead(reader, reader.uint32(), options, message.slowStartWindow);
                    break;
                case /* envoy.config.core.v3.RuntimeDouble aggression */ 2:
                    message.aggression = RuntimeDouble.internalBinaryRead(reader, reader.uint32(), options, message.aggression);
                    break;
                case /* envoy.type.v3.Percent min_weight_percent */ 3:
                    message.minWeightPercent = Percent.internalBinaryRead(reader, reader.uint32(), options, message.minWeightPercent);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SlowStartConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration slow_start_window = 1; */
        if (message.slowStartWindow)
            Duration.internalBinaryWrite(message.slowStartWindow, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeDouble aggression = 2; */
        if (message.aggression)
            RuntimeDouble.internalBinaryWrite(message.aggression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent min_weight_percent = 3; */
        if (message.minWeightPercent)
            Percent.internalBinaryWrite(message.minWeightPercent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.common.v3.SlowStartConfig
 */
export const SlowStartConfig = new SlowStartConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsistentHashingLbConfig$Type extends MessageType<ConsistentHashingLbConfig> {
    constructor() {
        super("envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig", [
            { no: 1, name: "use_hostname_for_hashing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "hash_balance_factor", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 100 } } } }
        ]);
    }
    create(value?: PartialMessage<ConsistentHashingLbConfig>): ConsistentHashingLbConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.useHostnameForHashing = false;
        if (value !== undefined)
            reflectionMergePartial<ConsistentHashingLbConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsistentHashingLbConfig): ConsistentHashingLbConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool use_hostname_for_hashing */ 1:
                    message.useHostnameForHashing = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value hash_balance_factor */ 2:
                    message.hashBalanceFactor = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.hashBalanceFactor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConsistentHashingLbConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool use_hostname_for_hashing = 1; */
        if (message.useHostnameForHashing !== false)
            writer.tag(1, WireType.Varint).bool(message.useHostnameForHashing);
        /* google.protobuf.UInt32Value hash_balance_factor = 2; */
        if (message.hashBalanceFactor)
            UInt32Value.internalBinaryWrite(message.hashBalanceFactor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.load_balancing_policies.common.v3.ConsistentHashingLbConfig
 */
export const ConsistentHashingLbConfig = new ConsistentHashingLbConfig$Type();
