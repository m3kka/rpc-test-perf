// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/rbac/matchers/upstream_ip_port/v3/upstream_ip_port_matcher.proto" (package "envoy.extensions.rbac.matchers.upstream_ip_port.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int64Range } from "../../../../../type/v3/range";
import { CidrRange } from "../../../../../config/core/v3/address";
// [#protodoc-title: RBAC upstream IP and port matcher plugin]
// [#extension: envoy.rbac.matchers.upstream_ip_port]

/**
 * This is configuration for matching upstream ip and port.
 * Note that although both fields are optional, at least one of IP or port must be supplied. If only
 * one is supplied the other is a wildcard match.
 * This matcher requires a filter in the chain to have saved the upstream address in the
 * filter state before the matcher is executed by RBAC filter. The state should be saved with key
 * ``envoy.stream.upstream_address`` (See
 * :repo:`upstream_address.h<source/common/stream_info/upstream_address.h>`).
 * Also, See :repo:`proxy_filter.cc<source/extensions/filters/http/dynamic_forward_proxy/proxy_filter.cc>`
 * for an example of a filter which populates the FilterState.
 *
 * @generated from protobuf message envoy.extensions.rbac.matchers.upstream_ip_port.v3.UpstreamIpPortMatcher
 */
export interface UpstreamIpPortMatcher {
    /**
     * A CIDR block that will be used to match the upstream IP.
     * Both Ipv4 and Ipv6 ranges can be matched.
     *
     * @generated from protobuf field: envoy.config.core.v3.CidrRange upstream_ip = 1;
     */
    upstreamIp?: CidrRange;
    /**
     * A port range that will be used to match the upstream port.
     *
     * @generated from protobuf field: envoy.type.v3.Int64Range upstream_port_range = 2;
     */
    upstreamPortRange?: Int64Range;
}
// @generated message type with reflection information, may provide speed optimized methods
class UpstreamIpPortMatcher$Type extends MessageType<UpstreamIpPortMatcher> {
    constructor() {
        super("envoy.extensions.rbac.matchers.upstream_ip_port.v3.UpstreamIpPortMatcher", [
            { no: 1, name: "upstream_ip", kind: "message", T: () => CidrRange },
            { no: 2, name: "upstream_port_range", kind: "message", T: () => Int64Range }
        ]);
    }
    create(value?: PartialMessage<UpstreamIpPortMatcher>): UpstreamIpPortMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpstreamIpPortMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpstreamIpPortMatcher): UpstreamIpPortMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.CidrRange upstream_ip */ 1:
                    message.upstreamIp = CidrRange.internalBinaryRead(reader, reader.uint32(), options, message.upstreamIp);
                    break;
                case /* envoy.type.v3.Int64Range upstream_port_range */ 2:
                    message.upstreamPortRange = Int64Range.internalBinaryRead(reader, reader.uint32(), options, message.upstreamPortRange);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpstreamIpPortMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.CidrRange upstream_ip = 1; */
        if (message.upstreamIp)
            CidrRange.internalBinaryWrite(message.upstreamIp, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Int64Range upstream_port_range = 2; */
        if (message.upstreamPortRange)
            Int64Range.internalBinaryWrite(message.upstreamPortRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.rbac.matchers.upstream_ip_port.v3.UpstreamIpPortMatcher
 */
export const UpstreamIpPortMatcher = new UpstreamIpPortMatcher$Type();
