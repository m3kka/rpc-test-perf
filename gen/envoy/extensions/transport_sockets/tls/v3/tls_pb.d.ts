// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/transport_sockets/tls/v3/tls.proto (package envoy.extensions.transport_sockets.tls.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { CertificateProviderPluginInstance, CertificateValidationContext, TlsCertificate, TlsParameters, TlsSessionTicketKeys } from "./common_pb.js";
import type { SdsSecretConfig } from "./secret_pb.js";
import type { CidrRange } from "../../../../config/core/v3/address_pb.js";
import type { TypedExtensionConfig } from "../../../../config/core/v3/extension_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
 */
export declare class UpstreamTlsContext extends Message<UpstreamTlsContext> {
  /**
   * Common TLS context settings.
   *
   * .. attention::
   *
   *   Server certificate verification is not enabled by default. Configure
   *   :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
   *   verification.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
   */
  commonTlsContext?: CommonTlsContext;

  /**
   * SNI string to use when creating TLS backend connections.
   *
   * @generated from field: string sni = 2;
   */
  sni: string;

  /**
   * If true, server-initiated TLS renegotiation will be allowed.
   *
   * .. attention::
   *
   *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
   *
   * @generated from field: bool allow_renegotiation = 3;
   */
  allowRenegotiation: boolean;

  /**
   * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
   * for TLSv1.2 and older) to store for the purpose of session resumption.
   *
   * Defaults to 1, setting this to 0 disables session resumption.
   *
   * @generated from field: google.protobuf.UInt32Value max_session_keys = 4;
   */
  maxSessionKeys?: number;

  /**
   * This field is used to control the enforcement, whereby the handshake will fail if the keyUsage extension
   * is present and incompatible with the TLS usage. Currently, the default value is false (i.e., enforcement off)
   * but it is expected to be changed to true by default in a future release.
   * ``ssl.was_key_usage_invalid`` in :ref:`listener metrics <config_listener_stats>` will be set for certificate
   * configurations that would fail if this option were set to true.
   *
   * @generated from field: google.protobuf.BoolValue enforce_rsa_key_usage = 5;
   */
  enforceRsaKeyUsage?: boolean;

  constructor(data?: PartialMessage<UpstreamTlsContext>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamTlsContext;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamTlsContext;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamTlsContext;

  static equals(a: UpstreamTlsContext | PlainMessage<UpstreamTlsContext> | undefined, b: UpstreamTlsContext | PlainMessage<UpstreamTlsContext> | undefined): boolean;
}

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
 */
export declare class DownstreamTlsContext extends Message<DownstreamTlsContext> {
  /**
   * Common TLS context settings.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
   */
  commonTlsContext?: CommonTlsContext;

  /**
   * If specified, Envoy will reject connections without a valid client
   * certificate.
   *
   * @generated from field: google.protobuf.BoolValue require_client_certificate = 2;
   */
  requireClientCertificate?: boolean;

  /**
   * If specified, Envoy will reject connections without a valid and matching SNI.
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.BoolValue require_sni = 3;
   */
  requireSni?: boolean;

  /**
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_type
   */
  sessionTicketKeysType: {
    /**
     * TLS session ticket key settings.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys session_ticket_keys = 4;
     */
    value: TlsSessionTicketKeys;
    case: "sessionTicketKeys";
  } | {
    /**
     * Config for fetching TLS session ticket keys via SDS API.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;
     */
    value: SdsSecretConfig;
    case: "sessionTicketKeysSdsSecretConfig";
  } | {
    /**
     * Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
     * server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
     * If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
     * the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
     * or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
     * If this config is set to false and no keys are explicitly configured, the TLS server will issue
     * TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
     * implication that sessions cannot be resumed across hot restarts or on different hosts.
     *
     * @generated from field: bool disable_stateless_session_resumption = 7;
     */
    value: boolean;
    case: "disableStatelessSessionResumption";
  } | { case: undefined; value?: undefined };

  /**
   * If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
   * Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
   * Only seconds can be specified (fractional seconds are ignored).
   *
   * @generated from field: google.protobuf.Duration session_timeout = 6;
   */
  sessionTimeout?: Duration;

  /**
   * Config for whether to use certificates if they do not have
   * an accompanying OCSP response or if the response expires at runtime.
   * Defaults to LENIENT_STAPLING
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy ocsp_staple_policy = 8;
   */
  ocspStaplePolicy: DownstreamTlsContext_OcspStaplePolicy;

  /**
   * Multiple certificates are allowed in Downstream transport socket to serve different SNI.
   * If the client provides SNI but no such cert matched, it will decide to full scan certificates or not based on this config.
   * Defaults to false. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
   *
   * @generated from field: google.protobuf.BoolValue full_scan_certs_on_sni_mismatch = 9;
   */
  fullScanCertsOnSniMismatch?: boolean;

  constructor(data?: PartialMessage<DownstreamTlsContext>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownstreamTlsContext;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownstreamTlsContext;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownstreamTlsContext;

  static equals(a: DownstreamTlsContext | PlainMessage<DownstreamTlsContext> | undefined, b: DownstreamTlsContext | PlainMessage<DownstreamTlsContext> | undefined): boolean;
}

/**
 * @generated from enum envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy
 */
export declare enum DownstreamTlsContext_OcspStaplePolicy {
  /**
   * OCSP responses are optional. If an OCSP response is absent
   * or expired, the associated certificate will be used for
   * connections without an OCSP staple.
   *
   * @generated from enum value: LENIENT_STAPLING = 0;
   */
  LENIENT_STAPLING = 0,

  /**
   * OCSP responses are optional. If an OCSP response is absent,
   * the associated certificate will be used without an
   * OCSP staple. If a response is provided but is expired,
   * the associated certificate will not be used for
   * subsequent connections. If no suitable certificate is found,
   * the connection is rejected.
   *
   * @generated from enum value: STRICT_STAPLING = 1;
   */
  STRICT_STAPLING = 1,

  /**
   * OCSP responses are required. Configuration will fail if
   * a certificate is provided without an OCSP response. If a
   * response expires, the associated certificate will not be
   * used connections. If no suitable certificate is found, the
   * connection is rejected.
   *
   * @generated from enum value: MUST_STAPLE = 2;
   */
  MUST_STAPLE = 2,
}

/**
 * TLS key log configuration.
 * The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.TlsKeyLog
 */
export declare class TlsKeyLog extends Message<TlsKeyLog> {
  /**
   * The path to save the TLS key log.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * The local IP address that will be used to filter the connection which should save the TLS key log
   * If it is not set, any local IP address  will be matched.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange local_address_range = 2;
   */
  localAddressRange: CidrRange[];

  /**
   * The remote IP address that will be used to filter the connection which should save the TLS key log
   * If it is not set, any remote IP address will be matched.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange remote_address_range = 3;
   */
  remoteAddressRange: CidrRange[];

  constructor(data?: PartialMessage<TlsKeyLog>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.TlsKeyLog";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TlsKeyLog;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TlsKeyLog;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TlsKeyLog;

  static equals(a: TlsKeyLog | PlainMessage<TlsKeyLog> | undefined, b: TlsKeyLog | PlainMessage<TlsKeyLog> | undefined): boolean;
}

/**
 * TLS context shared by both client and server TLS contexts.
 * [#next-free-field: 16]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext
 */
export declare class CommonTlsContext extends Message<CommonTlsContext> {
  /**
   * TLS protocol versions, cipher suites etc.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;
   */
  tlsParams?: TlsParameters;

  /**
   * Only a single TLS certificate is supported in client contexts. In server contexts,
   * :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
   * same context to allow both RSA and ECDSA certificates and support SNI-based selection.
   *
   * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
   * and ``tls_certificate_provider_instance`` may be used.
   * [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
   * not legal to put a repeated field in a oneof. In the next major version, we should rework
   * this to avoid this problem.]
   *
   * @generated from field: repeated envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;
   */
  tlsCertificates: TlsCertificate[];

  /**
   * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   *
   * The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
   * are valid in the the certificates fetched through this setting.
   *
   * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
   * and ``tls_certificate_provider_instance`` may be used.
   * [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
   * not legal to put a repeated field in a oneof. In the next major version, we should rework
   * this to avoid this problem.]
   *
   * @generated from field: repeated envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6;
   */
  tlsCertificateSdsSecretConfigs: SdsSecretConfig[];

  /**
   * Certificate provider instance for fetching TLS certs.
   *
   * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
   * and ``tls_certificate_provider_instance`` may be used.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance tls_certificate_provider_instance = 14;
   */
  tlsCertificateProviderInstance?: CertificateProviderPluginInstance;

  /**
   * Certificate provider for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9 [deprecated = true];
   * @deprecated
   */
  tlsCertificateCertificateProvider?: CommonTlsContext_CertificateProvider;

  /**
   * Certificate provider instance for fetching TLS certificates.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11 [deprecated = true];
   * @deprecated
   */
  tlsCertificateCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;

  /**
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.validation_context_type
   */
  validationContextType: {
    /**
     * How to validate peer certificates.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;
     */
    value: CertificateValidationContext;
    case: "validationContext";
  } | {
    /**
     * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
     * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;
     */
    value: SdsSecretConfig;
    case: "validationContextSdsSecretConfig";
  } | {
    /**
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;
     */
    value: CommonTlsContext_CombinedCertificateValidationContext;
    case: "combinedValidationContext";
  } | {
    /**
     * Certificate provider for fetching validation context.
     * [#not-implemented-hide:]
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10 [deprecated = true];
     * @deprecated
     */
    value: CommonTlsContext_CertificateProvider;
    case: "validationContextCertificateProvider";
  } | {
    /**
     * Certificate provider instance for fetching validation context.
     * [#not-implemented-hide:]
     *
     * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12 [deprecated = true];
     * @deprecated
     */
    value: CommonTlsContext_CertificateProviderInstance;
    case: "validationContextCertificateProviderInstance";
  } | { case: undefined; value?: undefined };

  /**
   * Supplies the list of ALPN protocols that the listener should expose. In
   * practice this is likely to be set to one of two values (see the
   * :ref:`codec_type
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
   * parameter in the HTTP connection manager for more information):
   *
   * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
   * * "http/1.1" If the listener is only going to support HTTP/1.1.
   *
   * There is no default for this parameter. If empty, Envoy will not expose ALPN.
   *
   * @generated from field: repeated string alpn_protocols = 4;
   */
  alpnProtocols: string[];

  /**
   * Custom TLS handshaker. If empty, defaults to native TLS handshaking
   * behavior.
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;
   */
  customHandshaker?: TypedExtensionConfig;

  /**
   * TLS key log configuration
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.TlsKeyLog key_log = 15;
   */
  keyLog?: TlsKeyLog;

  constructor(data?: PartialMessage<CommonTlsContext>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommonTlsContext;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommonTlsContext;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommonTlsContext;

  static equals(a: CommonTlsContext | PlainMessage<CommonTlsContext> | undefined, b: CommonTlsContext | PlainMessage<CommonTlsContext> | undefined): boolean;
}

/**
 * Config for Certificate provider to get certificates. This provider should allow certificates to be
 * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
 *
 * DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
 * move it out of CommonTlsContext and into common.proto, similar to the existing
 * CertificateProviderPluginInstance message.
 *
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider
 */
export declare class CommonTlsContext_CertificateProvider extends Message<CommonTlsContext_CertificateProvider> {
  /**
   * opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Provider specific config.
   * Note: an implementation is expected to dedup multiple instances of the same config
   * to maintain a single certificate-provider instance. The sharing can happen, for
   * example, among multiple clusters or between the tls_certificate and validation_context
   * certificate providers of a cluster.
   * This config could be supplied inline or (in future) a named xDS resource.
   *
   * @generated from oneof envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider.config
   */
  config: {
    /**
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig typed_config = 2;
     */
    value: TypedExtensionConfig;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<CommonTlsContext_CertificateProvider>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommonTlsContext_CertificateProvider;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommonTlsContext_CertificateProvider;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommonTlsContext_CertificateProvider;

  static equals(a: CommonTlsContext_CertificateProvider | PlainMessage<CommonTlsContext_CertificateProvider> | undefined, b: CommonTlsContext_CertificateProvider | PlainMessage<CommonTlsContext_CertificateProvider> | undefined): boolean;
}

/**
 * Similar to CertificateProvider above, but allows the provider instances to be configured on
 * the client side instead of being sent from the control plane.
 *
 * DEPRECATED: This message was moved outside of CommonTlsContext
 * and now lives in common.proto.
 *
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance
 */
export declare class CommonTlsContext_CertificateProviderInstance extends Message<CommonTlsContext_CertificateProviderInstance> {
  /**
   * Provider instance name. This name must be defined in the client's configuration (e.g., a
   * bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
   * field that would be sent in the CertificateProvider message if the config was sent by the
   * control plane). If not present, defaults to "default".
   *
   * Instance names should generally be defined not in terms of the underlying provider
   * implementation (e.g., "file_watcher") but rather in terms of the function of the
   * certificates (e.g., "foo_deployment_identity").
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName: string;

  /**
   * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
   * a root-certificate (validation context) or "example.com" to specify a certificate for a
   * particular domain. Not all provider instances will actually use this field, so the value
   * defaults to the empty string.
   *
   * @generated from field: string certificate_name = 2;
   */
  certificateName: string;

  constructor(data?: PartialMessage<CommonTlsContext_CertificateProviderInstance>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommonTlsContext_CertificateProviderInstance;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommonTlsContext_CertificateProviderInstance;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommonTlsContext_CertificateProviderInstance;

  static equals(a: CommonTlsContext_CertificateProviderInstance | PlainMessage<CommonTlsContext_CertificateProviderInstance> | undefined, b: CommonTlsContext_CertificateProviderInstance | PlainMessage<CommonTlsContext_CertificateProviderInstance> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext
 */
export declare class CommonTlsContext_CombinedCertificateValidationContext extends Message<CommonTlsContext_CombinedCertificateValidationContext> {
  /**
   * How to validate peer certificates.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext default_validation_context = 1;
   */
  defaultValidationContext?: CertificateValidationContext;

  /**
   * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
   * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 2;
   */
  validationContextSdsSecretConfig?: SdsSecretConfig;

  /**
   * Certificate provider for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 3 [deprecated = true];
   * @deprecated
   */
  validationContextCertificateProvider?: CommonTlsContext_CertificateProvider;

  /**
   * Certificate provider instance for fetching CA certs. This will populate the
   * ``default_validation_context.trusted_ca`` field.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 4 [deprecated = true];
   * @deprecated
   */
  validationContextCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;

  constructor(data?: PartialMessage<CommonTlsContext_CombinedCertificateValidationContext>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommonTlsContext_CombinedCertificateValidationContext;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommonTlsContext_CombinedCertificateValidationContext;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommonTlsContext_CombinedCertificateValidationContext;

  static equals(a: CommonTlsContext_CombinedCertificateValidationContext | PlainMessage<CommonTlsContext_CombinedCertificateValidationContext> | undefined, b: CommonTlsContext_CombinedCertificateValidationContext | PlainMessage<CommonTlsContext_CombinedCertificateValidationContext> | undefined): boolean;
}

