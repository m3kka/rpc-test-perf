// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/transport_sockets/tls/v3/tls.proto" (package "envoy.extensions.transport_sockets.tls.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import { CertificateValidationContext } from "./common";
import { CertificateProviderPluginInstance } from "./common";
import { TlsCertificate } from "./common";
import { TlsParameters } from "./common";
import { CidrRange } from "../../../../config/core/v3/address";
import { Duration } from "../../../../../google/protobuf/duration";
import { SdsSecretConfig } from "./secret";
import { TlsSessionTicketKeys } from "./common";
import { BoolValue } from "../../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../../google/protobuf/wrappers";
// [#protodoc-title: TLS transport socket]
// [#extension: envoy.transport_sockets.tls]
// The TLS contexts below provide the transport socket configuration for upstream/downstream TLS.

/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
 */
export interface UpstreamTlsContext {
    /**
     * Common TLS context settings.
     *
     * .. attention::
     *
     *   Server certificate verification is not enabled by default. Configure
     *   :ref:`trusted_ca<envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
     *   verification.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
     */
    commonTlsContext?: CommonTlsContext;
    /**
     * SNI string to use when creating TLS backend connections.
     *
     * @generated from protobuf field: string sni = 2;
     */
    sni: string;
    /**
     * If true, server-initiated TLS renegotiation will be allowed.
     *
     * .. attention::
     *
     *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
     *
     * @generated from protobuf field: bool allow_renegotiation = 3;
     */
    allowRenegotiation: boolean;
    /**
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     *
     * Defaults to 1, setting this to 0 disables session resumption.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_session_keys = 4;
     */
    maxSessionKeys?: UInt32Value;
    /**
     * This field is used to control the enforcement, whereby the handshake will fail if the keyUsage extension
     * is present and incompatible with the TLS usage. Currently, the default value is false (i.e., enforcement off)
     * but it is expected to be changed to true by default in a future release.
     * ``ssl.was_key_usage_invalid`` in :ref:`listener metrics <config_listener_stats>` will be set for certificate
     * configurations that would fail if this option were set to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue enforce_rsa_key_usage = 5;
     */
    enforceRsaKeyUsage?: BoolValue;
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
 */
export interface DownstreamTlsContext {
    /**
     * Common TLS context settings.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1;
     */
    commonTlsContext?: CommonTlsContext;
    /**
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     *
     * @generated from protobuf field: google.protobuf.BoolValue require_client_certificate = 2;
     */
    requireClientCertificate?: BoolValue;
    /**
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.BoolValue require_sni = 3;
     */
    requireSni?: BoolValue;
    /**
     * @generated from protobuf oneof: session_ticket_keys_type
     */
    sessionTicketKeysType: {
        oneofKind: "sessionTicketKeys";
        /**
         * TLS session ticket key settings.
         *
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys session_ticket_keys = 4;
         */
        sessionTicketKeys: TlsSessionTicketKeys;
    } | {
        oneofKind: "sessionTicketKeysSdsSecretConfig";
        /**
         * Config for fetching TLS session ticket keys via SDS API.
         *
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;
         */
        sessionTicketKeysSdsSecretConfig: SdsSecretConfig;
    } | {
        oneofKind: "disableStatelessSessionResumption";
        /**
         * Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
         * server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
         * If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
         * the keys specified through either :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
         * or :ref:`session_ticket_keys_sds_secret_config <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
         * If this config is set to false and no keys are explicitly configured, the TLS server will issue
         * TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
         * implication that sessions cannot be resumed across hot restarts or on different hosts.
         *
         * @generated from protobuf field: bool disable_stateless_session_resumption = 7;
         */
        disableStatelessSessionResumption: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * If specified, ``session_timeout`` will change the maximum lifetime (in seconds) of the TLS session.
     * Currently this value is used as a hint for the `TLS session ticket lifetime (for TLSv1.2) <https://tools.ietf.org/html/rfc5077#section-5.6>`_.
     * Only seconds can be specified (fractional seconds are ignored).
     *
     * @generated from protobuf field: google.protobuf.Duration session_timeout = 6;
     */
    sessionTimeout?: Duration;
    /**
     * Config for whether to use certificates if they do not have
     * an accompanying OCSP response or if the response expires at runtime.
     * Defaults to LENIENT_STAPLING
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy ocsp_staple_policy = 8;
     */
    ocspStaplePolicy: DownstreamTlsContext_OcspStaplePolicy;
    /**
     * Multiple certificates are allowed in Downstream transport socket to serve different SNI.
     * If the client provides SNI but no such cert matched, it will decide to full scan certificates or not based on this config.
     * Defaults to false. See more details in :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>`.
     *
     * @generated from protobuf field: google.protobuf.BoolValue full_scan_certs_on_sni_mismatch = 9;
     */
    fullScanCertsOnSniMismatch?: BoolValue;
}
/**
 * @generated from protobuf enum envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy
 */
export enum DownstreamTlsContext_OcspStaplePolicy {
    /**
     * OCSP responses are optional. If an OCSP response is absent
     * or expired, the associated certificate will be used for
     * connections without an OCSP staple.
     *
     * @generated from protobuf enum value: LENIENT_STAPLING = 0;
     */
    LENIENT_STAPLING = 0,
    /**
     * OCSP responses are optional. If an OCSP response is absent,
     * the associated certificate will be used without an
     * OCSP staple. If a response is provided but is expired,
     * the associated certificate will not be used for
     * subsequent connections. If no suitable certificate is found,
     * the connection is rejected.
     *
     * @generated from protobuf enum value: STRICT_STAPLING = 1;
     */
    STRICT_STAPLING = 1,
    /**
     * OCSP responses are required. Configuration will fail if
     * a certificate is provided without an OCSP response. If a
     * response expires, the associated certificate will not be
     * used connections. If no suitable certificate is found, the
     * connection is rejected.
     *
     * @generated from protobuf enum value: MUST_STAPLE = 2;
     */
    MUST_STAPLE = 2
}
/**
 * TLS key log configuration.
 * The key log file format is "format used by NSS for its SSLKEYLOGFILE debugging output" (text taken from openssl man page)
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.TlsKeyLog
 */
export interface TlsKeyLog {
    /**
     * The path to save the TLS key log.
     *
     * @generated from protobuf field: string path = 1;
     */
    path: string;
    /**
     * The local IP address that will be used to filter the connection which should save the TLS key log
     * If it is not set, any local IP address  will be matched.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange local_address_range = 2;
     */
    localAddressRange: CidrRange[];
    /**
     * The remote IP address that will be used to filter the connection which should save the TLS key log
     * If it is not set, any remote IP address will be matched.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange remote_address_range = 3;
     */
    remoteAddressRange: CidrRange[];
}
/**
 * TLS context shared by both client and server TLS contexts.
 * [#next-free-field: 16]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext
 */
export interface CommonTlsContext {
    /**
     * TLS protocol versions, cipher suites etc.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1;
     */
    tlsParams?: TlsParameters;
    /**
     * Only a single TLS certificate is supported in client contexts. In server contexts,
     * :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
     * same context to allow both RSA and ECDSA certificates and support SNI-based selection.
     *
     * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
     * and ``tls_certificate_provider_instance`` may be used.
     * [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
     * not legal to put a repeated field in a oneof. In the next major version, we should rework
     * this to avoid this problem.]
     *
     * @generated from protobuf field: repeated envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2;
     */
    tlsCertificates: TlsCertificate[];
    /**
     * Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
     * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
     *
     * The same number and types of certificates as :ref:`tls_certificates <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.tls_certificates>`
     * are valid in the the certificates fetched through this setting.
     *
     * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
     * and ``tls_certificate_provider_instance`` may be used.
     * [#next-major-version: These mutually exclusive fields should ideally be in a oneof, but it's
     * not legal to put a repeated field in a oneof. In the next major version, we should rework
     * this to avoid this problem.]
     *
     * @generated from protobuf field: repeated envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6;
     */
    tlsCertificateSdsSecretConfigs: SdsSecretConfig[];
    /**
     * Certificate provider instance for fetching TLS certs.
     *
     * Only one of ``tls_certificates``, ``tls_certificate_sds_secret_configs``,
     * and ``tls_certificate_provider_instance`` may be used.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance tls_certificate_provider_instance = 14;
     */
    tlsCertificateProviderInstance?: CertificateProviderPluginInstance;
    /**
     * Certificate provider for fetching TLS certificates.
     * [#not-implemented-hide:]
     *
     * @deprecated
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9 [deprecated = true];
     */
    tlsCertificateCertificateProvider?: CommonTlsContext_CertificateProvider;
    /**
     * Certificate provider instance for fetching TLS certificates.
     * [#not-implemented-hide:]
     *
     * @deprecated
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11 [deprecated = true];
     */
    tlsCertificateCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;
    /**
     * @generated from protobuf oneof: validation_context_type
     */
    validationContextType: {
        oneofKind: "validationContext";
        /**
         * How to validate peer certificates.
         *
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3;
         */
        validationContext: CertificateValidationContext;
    } | {
        oneofKind: "validationContextSdsSecretConfig";
        /**
         * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
         * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
         *
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7;
         */
        validationContextSdsSecretConfig: SdsSecretConfig;
    } | {
        oneofKind: "combinedValidationContext";
        /**
         * Combined certificate validation context holds a default CertificateValidationContext
         * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
         * and default CertificateValidationContext are merged into a new CertificateValidationContext
         * for validation. This merge is done by Message::MergeFrom(), so dynamic
         * CertificateValidationContext overwrites singular fields in default
         * CertificateValidationContext, and concatenates repeated fields to default
         * CertificateValidationContext, and logical OR is applied to boolean fields.
         *
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;
         */
        combinedValidationContext: CommonTlsContext_CombinedCertificateValidationContext;
    } | {
        oneofKind: "validationContextCertificateProvider";
        /**
         * Certificate provider for fetching validation context.
         * [#not-implemented-hide:]
         *
         * @deprecated
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10 [deprecated = true];
         */
        validationContextCertificateProvider: CommonTlsContext_CertificateProvider;
    } | {
        oneofKind: "validationContextCertificateProviderInstance";
        /**
         * Certificate provider instance for fetching validation context.
         * [#not-implemented-hide:]
         *
         * @deprecated
         * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12 [deprecated = true];
         */
        validationContextCertificateProviderInstance: CommonTlsContext_CertificateProviderInstance;
    } | {
        oneofKind: undefined;
    };
    /**
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
     * parameter in the HTTP connection manager for more information):
     *
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     *
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     *
     * @generated from protobuf field: repeated string alpn_protocols = 4;
     */
    alpnProtocols: string[];
    /**
     * Custom TLS handshaker. If empty, defaults to native TLS handshaking
     * behavior.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13;
     */
    customHandshaker?: TypedExtensionConfig;
    /**
     * TLS key log configuration
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.TlsKeyLog key_log = 15;
     */
    keyLog?: TlsKeyLog;
}
/**
 * Config for Certificate provider to get certificates. This provider should allow certificates to be
 * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
 *
 * DEPRECATED: This message is not currently used, but if we ever do need it, we will want to
 * move it out of CommonTlsContext and into common.proto, similar to the existing
 * CertificateProviderPluginInstance message.
 *
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider
 */
export interface CommonTlsContext_CertificateProvider {
    /**
     * opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
     * a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config
     */
    config: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_config = 2;
         */
        typedConfig: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Similar to CertificateProvider above, but allows the provider instances to be configured on
 * the client side instead of being sent from the control plane.
 *
 * DEPRECATED: This message was moved outside of CommonTlsContext
 * and now lives in common.proto.
 *
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance
 */
export interface CommonTlsContext_CertificateProviderInstance {
    /**
     * Provider instance name. This name must be defined in the client's configuration (e.g., a
     * bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
     * field that would be sent in the CertificateProvider message if the config was sent by the
     * control plane). If not present, defaults to "default".
     *
     * Instance names should generally be defined not in terms of the underlying provider
     * implementation (e.g., "file_watcher") but rather in terms of the function of the
     * certificates (e.g., "foo_deployment_identity").
     *
     * @generated from protobuf field: string instance_name = 1;
     */
    instanceName: string;
    /**
     * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
     * a root-certificate (validation context) or "example.com" to specify a certificate for a
     * particular domain. Not all provider instances will actually use this field, so the value
     * defaults to the empty string.
     *
     * @generated from protobuf field: string certificate_name = 2;
     */
    certificateName: string;
}
/**
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext
 */
export interface CommonTlsContext_CombinedCertificateValidationContext {
    /**
     * How to validate peer certificates.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext default_validation_context = 1;
     */
    defaultValidationContext?: CertificateValidationContext;
    /**
     * Config for fetching validation context via SDS API. Note SDS API allows certificates to be
     * fetched/refreshed over the network asynchronously with respect to the TLS handshake.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 2;
     */
    validationContextSdsSecretConfig?: SdsSecretConfig;
    /**
     * Certificate provider for fetching CA certs. This will populate the
     * ``default_validation_context.trusted_ca`` field.
     * [#not-implemented-hide:]
     *
     * @deprecated
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 3 [deprecated = true];
     */
    validationContextCertificateProvider?: CommonTlsContext_CertificateProvider;
    /**
     * Certificate provider instance for fetching CA certs. This will populate the
     * ``default_validation_context.trusted_ca`` field.
     * [#not-implemented-hide:]
     *
     * @deprecated
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 4 [deprecated = true];
     */
    validationContextCertificateProviderInstance?: CommonTlsContext_CertificateProviderInstance;
}
// @generated message type with reflection information, may provide speed optimized methods
class UpstreamTlsContext$Type extends MessageType<UpstreamTlsContext> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext", [
            { no: 1, name: "common_tls_context", kind: "message", T: () => CommonTlsContext },
            { no: 2, name: "sni", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "255" } } } },
            { no: 3, name: "allow_renegotiation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "max_session_keys", kind: "message", T: () => UInt32Value },
            { no: 5, name: "enforce_rsa_key_usage", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.UpstreamTlsContext" } });
    }
    create(value?: PartialMessage<UpstreamTlsContext>): UpstreamTlsContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sni = "";
        message.allowRenegotiation = false;
        if (value !== undefined)
            reflectionMergePartial<UpstreamTlsContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpstreamTlsContext): UpstreamTlsContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context */ 1:
                    message.commonTlsContext = CommonTlsContext.internalBinaryRead(reader, reader.uint32(), options, message.commonTlsContext);
                    break;
                case /* string sni */ 2:
                    message.sni = reader.string();
                    break;
                case /* bool allow_renegotiation */ 3:
                    message.allowRenegotiation = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value max_session_keys */ 4:
                    message.maxSessionKeys = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxSessionKeys);
                    break;
                case /* google.protobuf.BoolValue enforce_rsa_key_usage */ 5:
                    message.enforceRsaKeyUsage = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enforceRsaKeyUsage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpstreamTlsContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1; */
        if (message.commonTlsContext)
            CommonTlsContext.internalBinaryWrite(message.commonTlsContext, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string sni = 2; */
        if (message.sni !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sni);
        /* bool allow_renegotiation = 3; */
        if (message.allowRenegotiation !== false)
            writer.tag(3, WireType.Varint).bool(message.allowRenegotiation);
        /* google.protobuf.UInt32Value max_session_keys = 4; */
        if (message.maxSessionKeys)
            UInt32Value.internalBinaryWrite(message.maxSessionKeys, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue enforce_rsa_key_usage = 5; */
        if (message.enforceRsaKeyUsage)
            BoolValue.internalBinaryWrite(message.enforceRsaKeyUsage, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
 */
export const UpstreamTlsContext = new UpstreamTlsContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownstreamTlsContext$Type extends MessageType<DownstreamTlsContext> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext", [
            { no: 1, name: "common_tls_context", kind: "message", T: () => CommonTlsContext },
            { no: 2, name: "require_client_certificate", kind: "message", T: () => BoolValue },
            { no: 3, name: "require_sni", kind: "message", T: () => BoolValue },
            { no: 4, name: "session_ticket_keys", kind: "message", oneof: "sessionTicketKeysType", T: () => TlsSessionTicketKeys },
            { no: 5, name: "session_ticket_keys_sds_secret_config", kind: "message", oneof: "sessionTicketKeysType", T: () => SdsSecretConfig },
            { no: 7, name: "disable_stateless_session_resumption", kind: "scalar", oneof: "sessionTicketKeysType", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "session_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lt: { seconds: "4294967296" }, gte: {} } } } },
            { no: 8, name: "ocsp_staple_policy", kind: "enum", T: () => ["envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy", DownstreamTlsContext_OcspStaplePolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 9, name: "full_scan_certs_on_sni_mismatch", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.DownstreamTlsContext" } });
    }
    create(value?: PartialMessage<DownstreamTlsContext>): DownstreamTlsContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionTicketKeysType = { oneofKind: undefined };
        message.ocspStaplePolicy = 0;
        if (value !== undefined)
            reflectionMergePartial<DownstreamTlsContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownstreamTlsContext): DownstreamTlsContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context */ 1:
                    message.commonTlsContext = CommonTlsContext.internalBinaryRead(reader, reader.uint32(), options, message.commonTlsContext);
                    break;
                case /* google.protobuf.BoolValue require_client_certificate */ 2:
                    message.requireClientCertificate = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.requireClientCertificate);
                    break;
                case /* google.protobuf.BoolValue require_sni */ 3:
                    message.requireSni = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.requireSni);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys session_ticket_keys */ 4:
                    message.sessionTicketKeysType = {
                        oneofKind: "sessionTicketKeys",
                        sessionTicketKeys: TlsSessionTicketKeys.internalBinaryRead(reader, reader.uint32(), options, (message.sessionTicketKeysType as any).sessionTicketKeys)
                    };
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig session_ticket_keys_sds_secret_config */ 5:
                    message.sessionTicketKeysType = {
                        oneofKind: "sessionTicketKeysSdsSecretConfig",
                        sessionTicketKeysSdsSecretConfig: SdsSecretConfig.internalBinaryRead(reader, reader.uint32(), options, (message.sessionTicketKeysType as any).sessionTicketKeysSdsSecretConfig)
                    };
                    break;
                case /* bool disable_stateless_session_resumption */ 7:
                    message.sessionTicketKeysType = {
                        oneofKind: "disableStatelessSessionResumption",
                        disableStatelessSessionResumption: reader.bool()
                    };
                    break;
                case /* google.protobuf.Duration session_timeout */ 6:
                    message.sessionTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.sessionTimeout);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy ocsp_staple_policy */ 8:
                    message.ocspStaplePolicy = reader.int32();
                    break;
                case /* google.protobuf.BoolValue full_scan_certs_on_sni_mismatch */ 9:
                    message.fullScanCertsOnSniMismatch = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.fullScanCertsOnSniMismatch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownstreamTlsContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext common_tls_context = 1; */
        if (message.commonTlsContext)
            CommonTlsContext.internalBinaryWrite(message.commonTlsContext, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue require_client_certificate = 2; */
        if (message.requireClientCertificate)
            BoolValue.internalBinaryWrite(message.requireClientCertificate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue require_sni = 3; */
        if (message.requireSni)
            BoolValue.internalBinaryWrite(message.requireSni, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys session_ticket_keys = 4; */
        if (message.sessionTicketKeysType.oneofKind === "sessionTicketKeys")
            TlsSessionTicketKeys.internalBinaryWrite(message.sessionTicketKeysType.sessionTicketKeys, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig session_ticket_keys_sds_secret_config = 5; */
        if (message.sessionTicketKeysType.oneofKind === "sessionTicketKeysSdsSecretConfig")
            SdsSecretConfig.internalBinaryWrite(message.sessionTicketKeysType.sessionTicketKeysSdsSecretConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool disable_stateless_session_resumption = 7; */
        if (message.sessionTicketKeysType.oneofKind === "disableStatelessSessionResumption")
            writer.tag(7, WireType.Varint).bool(message.sessionTicketKeysType.disableStatelessSessionResumption);
        /* google.protobuf.Duration session_timeout = 6; */
        if (message.sessionTimeout)
            Duration.internalBinaryWrite(message.sessionTimeout, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext.OcspStaplePolicy ocsp_staple_policy = 8; */
        if (message.ocspStaplePolicy !== 0)
            writer.tag(8, WireType.Varint).int32(message.ocspStaplePolicy);
        /* google.protobuf.BoolValue full_scan_certs_on_sni_mismatch = 9; */
        if (message.fullScanCertsOnSniMismatch)
            BoolValue.internalBinaryWrite(message.fullScanCertsOnSniMismatch, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext
 */
export const DownstreamTlsContext = new DownstreamTlsContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TlsKeyLog$Type extends MessageType<TlsKeyLog> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.TlsKeyLog", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "local_address_range", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 3, name: "remote_address_range", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange }
        ]);
    }
    create(value?: PartialMessage<TlsKeyLog>): TlsKeyLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.localAddressRange = [];
        message.remoteAddressRange = [];
        if (value !== undefined)
            reflectionMergePartial<TlsKeyLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsKeyLog): TlsKeyLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* repeated envoy.config.core.v3.CidrRange local_address_range */ 2:
                    message.localAddressRange.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.CidrRange remote_address_range */ 3:
                    message.remoteAddressRange.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsKeyLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* repeated envoy.config.core.v3.CidrRange local_address_range = 2; */
        for (let i = 0; i < message.localAddressRange.length; i++)
            CidrRange.internalBinaryWrite(message.localAddressRange[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.CidrRange remote_address_range = 3; */
        for (let i = 0; i < message.remoteAddressRange.length; i++)
            CidrRange.internalBinaryWrite(message.remoteAddressRange[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.TlsKeyLog
 */
export const TlsKeyLog = new TlsKeyLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonTlsContext$Type extends MessageType<CommonTlsContext> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CommonTlsContext", [
            { no: 1, name: "tls_params", kind: "message", T: () => TlsParameters },
            { no: 2, name: "tls_certificates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TlsCertificate },
            { no: 6, name: "tls_certificate_sds_secret_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SdsSecretConfig },
            { no: 14, name: "tls_certificate_provider_instance", kind: "message", T: () => CertificateProviderPluginInstance },
            { no: 9, name: "tls_certificate_certificate_provider", kind: "message", T: () => CommonTlsContext_CertificateProvider, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 11, name: "tls_certificate_certificate_provider_instance", kind: "message", T: () => CommonTlsContext_CertificateProviderInstance, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 3, name: "validation_context", kind: "message", oneof: "validationContextType", T: () => CertificateValidationContext },
            { no: 7, name: "validation_context_sds_secret_config", kind: "message", oneof: "validationContextType", T: () => SdsSecretConfig },
            { no: 8, name: "combined_validation_context", kind: "message", oneof: "validationContextType", T: () => CommonTlsContext_CombinedCertificateValidationContext },
            { no: 10, name: "validation_context_certificate_provider", kind: "message", oneof: "validationContextType", T: () => CommonTlsContext_CertificateProvider, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 12, name: "validation_context_certificate_provider_instance", kind: "message", oneof: "validationContextType", T: () => CommonTlsContext_CertificateProviderInstance, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "alpn_protocols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "custom_handshaker", kind: "message", T: () => TypedExtensionConfig },
            { no: 15, name: "key_log", kind: "message", T: () => TlsKeyLog }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.CommonTlsContext" } });
    }
    create(value?: PartialMessage<CommonTlsContext>): CommonTlsContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tlsCertificates = [];
        message.tlsCertificateSdsSecretConfigs = [];
        message.validationContextType = { oneofKind: undefined };
        message.alpnProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<CommonTlsContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonTlsContext): CommonTlsContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params */ 1:
                    message.tlsParams = TlsParameters.internalBinaryRead(reader, reader.uint32(), options, message.tlsParams);
                    break;
                case /* repeated envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates */ 2:
                    message.tlsCertificates.push(TlsCertificate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs */ 6:
                    message.tlsCertificateSdsSecretConfigs.push(SdsSecretConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance tls_certificate_provider_instance */ 14:
                    message.tlsCertificateProviderInstance = CertificateProviderPluginInstance.internalBinaryRead(reader, reader.uint32(), options, message.tlsCertificateProviderInstance);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9 [deprecated = true];*/ 9:
                    message.tlsCertificateCertificateProvider = CommonTlsContext_CertificateProvider.internalBinaryRead(reader, reader.uint32(), options, message.tlsCertificateCertificateProvider);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11 [deprecated = true];*/ 11:
                    message.tlsCertificateCertificateProviderInstance = CommonTlsContext_CertificateProviderInstance.internalBinaryRead(reader, reader.uint32(), options, message.tlsCertificateCertificateProviderInstance);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context */ 3:
                    message.validationContextType = {
                        oneofKind: "validationContext",
                        validationContext: CertificateValidationContext.internalBinaryRead(reader, reader.uint32(), options, (message.validationContextType as any).validationContext)
                    };
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config */ 7:
                    message.validationContextType = {
                        oneofKind: "validationContextSdsSecretConfig",
                        validationContextSdsSecretConfig: SdsSecretConfig.internalBinaryRead(reader, reader.uint32(), options, (message.validationContextType as any).validationContextSdsSecretConfig)
                    };
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context */ 8:
                    message.validationContextType = {
                        oneofKind: "combinedValidationContext",
                        combinedValidationContext: CommonTlsContext_CombinedCertificateValidationContext.internalBinaryRead(reader, reader.uint32(), options, (message.validationContextType as any).combinedValidationContext)
                    };
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10 [deprecated = true];*/ 10:
                    message.validationContextType = {
                        oneofKind: "validationContextCertificateProvider",
                        validationContextCertificateProvider: CommonTlsContext_CertificateProvider.internalBinaryRead(reader, reader.uint32(), options, (message.validationContextType as any).validationContextCertificateProvider)
                    };
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12 [deprecated = true];*/ 12:
                    message.validationContextType = {
                        oneofKind: "validationContextCertificateProviderInstance",
                        validationContextCertificateProviderInstance: CommonTlsContext_CertificateProviderInstance.internalBinaryRead(reader, reader.uint32(), options, (message.validationContextType as any).validationContextCertificateProviderInstance)
                    };
                    break;
                case /* repeated string alpn_protocols */ 4:
                    message.alpnProtocols.push(reader.string());
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig custom_handshaker */ 13:
                    message.customHandshaker = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.customHandshaker);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.TlsKeyLog key_log */ 15:
                    message.keyLog = TlsKeyLog.internalBinaryRead(reader, reader.uint32(), options, message.keyLog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonTlsContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.TlsParameters tls_params = 1; */
        if (message.tlsParams)
            TlsParameters.internalBinaryWrite(message.tlsParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.transport_sockets.tls.v3.TlsCertificate tls_certificates = 2; */
        for (let i = 0; i < message.tlsCertificates.length; i++)
            TlsCertificate.internalBinaryWrite(message.tlsCertificates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig tls_certificate_sds_secret_configs = 6; */
        for (let i = 0; i < message.tlsCertificateSdsSecretConfigs.length; i++)
            SdsSecretConfig.internalBinaryWrite(message.tlsCertificateSdsSecretConfigs[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance tls_certificate_provider_instance = 14; */
        if (message.tlsCertificateProviderInstance)
            CertificateProviderPluginInstance.internalBinaryWrite(message.tlsCertificateProviderInstance, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider tls_certificate_certificate_provider = 9 [deprecated = true]; */
        if (message.tlsCertificateCertificateProvider)
            CommonTlsContext_CertificateProvider.internalBinaryWrite(message.tlsCertificateCertificateProvider, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance tls_certificate_certificate_provider_instance = 11 [deprecated = true]; */
        if (message.tlsCertificateCertificateProviderInstance)
            CommonTlsContext_CertificateProviderInstance.internalBinaryWrite(message.tlsCertificateCertificateProviderInstance, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext validation_context = 3; */
        if (message.validationContextType.oneofKind === "validationContext")
            CertificateValidationContext.internalBinaryWrite(message.validationContextType.validationContext, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 7; */
        if (message.validationContextType.oneofKind === "validationContextSdsSecretConfig")
            SdsSecretConfig.internalBinaryWrite(message.validationContextType.validationContextSdsSecretConfig, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8; */
        if (message.validationContextType.oneofKind === "combinedValidationContext")
            CommonTlsContext_CombinedCertificateValidationContext.internalBinaryWrite(message.validationContextType.combinedValidationContext, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 10 [deprecated = true]; */
        if (message.validationContextType.oneofKind === "validationContextCertificateProvider")
            CommonTlsContext_CertificateProvider.internalBinaryWrite(message.validationContextType.validationContextCertificateProvider, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 12 [deprecated = true]; */
        if (message.validationContextType.oneofKind === "validationContextCertificateProviderInstance")
            CommonTlsContext_CertificateProviderInstance.internalBinaryWrite(message.validationContextType.validationContextCertificateProviderInstance, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string alpn_protocols = 4; */
        for (let i = 0; i < message.alpnProtocols.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.alpnProtocols[i]);
        /* envoy.config.core.v3.TypedExtensionConfig custom_handshaker = 13; */
        if (message.customHandshaker)
            TypedExtensionConfig.internalBinaryWrite(message.customHandshaker, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.TlsKeyLog key_log = 15; */
        if (message.keyLog)
            TlsKeyLog.internalBinaryWrite(message.keyLog, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext
 */
export const CommonTlsContext = new CommonTlsContext$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonTlsContext_CertificateProvider$Type extends MessageType<CommonTlsContext_CertificateProvider> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "typed_config", kind: "message", oneof: "config", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<CommonTlsContext_CertificateProvider>): CommonTlsContext_CertificateProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.config = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CommonTlsContext_CertificateProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonTlsContext_CertificateProvider): CommonTlsContext_CertificateProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig typed_config */ 2:
                    message.config = {
                        oneofKind: "typedConfig",
                        typedConfig: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.config as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonTlsContext_CertificateProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.config.core.v3.TypedExtensionConfig typed_config = 2; */
        if (message.config.oneofKind === "typedConfig")
            TypedExtensionConfig.internalBinaryWrite(message.config.typedConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider
 */
export const CommonTlsContext_CertificateProvider = new CommonTlsContext_CertificateProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonTlsContext_CertificateProviderInstance$Type extends MessageType<CommonTlsContext_CertificateProviderInstance> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance", [
            { no: 1, name: "instance_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "certificate_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CommonTlsContext_CertificateProviderInstance>): CommonTlsContext_CertificateProviderInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.certificateName = "";
        if (value !== undefined)
            reflectionMergePartial<CommonTlsContext_CertificateProviderInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonTlsContext_CertificateProviderInstance): CommonTlsContext_CertificateProviderInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance_name */ 1:
                    message.instanceName = reader.string();
                    break;
                case /* string certificate_name */ 2:
                    message.certificateName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonTlsContext_CertificateProviderInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance_name = 1; */
        if (message.instanceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instanceName);
        /* string certificate_name = 2; */
        if (message.certificateName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certificateName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance
 */
export const CommonTlsContext_CertificateProviderInstance = new CommonTlsContext_CertificateProviderInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonTlsContext_CombinedCertificateValidationContext$Type extends MessageType<CommonTlsContext_CombinedCertificateValidationContext> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext", [
            { no: 1, name: "default_validation_context", kind: "message", T: () => CertificateValidationContext, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "validation_context_sds_secret_config", kind: "message", T: () => SdsSecretConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "validation_context_certificate_provider", kind: "message", T: () => CommonTlsContext_CertificateProvider, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "validation_context_certificate_provider_instance", kind: "message", T: () => CommonTlsContext_CertificateProviderInstance, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext" } });
    }
    create(value?: PartialMessage<CommonTlsContext_CombinedCertificateValidationContext>): CommonTlsContext_CombinedCertificateValidationContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CommonTlsContext_CombinedCertificateValidationContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonTlsContext_CombinedCertificateValidationContext): CommonTlsContext_CombinedCertificateValidationContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext default_validation_context */ 1:
                    message.defaultValidationContext = CertificateValidationContext.internalBinaryRead(reader, reader.uint32(), options, message.defaultValidationContext);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config */ 2:
                    message.validationContextSdsSecretConfig = SdsSecretConfig.internalBinaryRead(reader, reader.uint32(), options, message.validationContextSdsSecretConfig);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 3 [deprecated = true];*/ 3:
                    message.validationContextCertificateProvider = CommonTlsContext_CertificateProvider.internalBinaryRead(reader, reader.uint32(), options, message.validationContextCertificateProvider);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 4 [deprecated = true];*/ 4:
                    message.validationContextCertificateProviderInstance = CommonTlsContext_CertificateProviderInstance.internalBinaryRead(reader, reader.uint32(), options, message.validationContextCertificateProviderInstance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonTlsContext_CombinedCertificateValidationContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext default_validation_context = 1; */
        if (message.defaultValidationContext)
            CertificateValidationContext.internalBinaryWrite(message.defaultValidationContext, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig validation_context_sds_secret_config = 2; */
        if (message.validationContextSdsSecretConfig)
            SdsSecretConfig.internalBinaryWrite(message.validationContextSdsSecretConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProvider validation_context_certificate_provider = 3 [deprecated = true]; */
        if (message.validationContextCertificateProvider)
            CommonTlsContext_CertificateProvider.internalBinaryWrite(message.validationContextCertificateProvider, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance validation_context_certificate_provider_instance = 4 [deprecated = true]; */
        if (message.validationContextCertificateProviderInstance)
            CommonTlsContext_CertificateProviderInstance.internalBinaryWrite(message.validationContextCertificateProviderInstance, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CommonTlsContext.CombinedCertificateValidationContext
 */
export const CommonTlsContext_CombinedCertificateValidationContext = new CommonTlsContext_CombinedCertificateValidationContext$Type();
