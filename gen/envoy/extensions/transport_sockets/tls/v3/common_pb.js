// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/transport_sockets/tls/v3/common.proto (package envoy.extensions.transport_sockets.tls.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, proto3, UInt32Value } from "@bufbuild/protobuf";
import { DataSource, WatchedDirectory } from "../../../../config/core/v3/base_pb.js";
import { StringMatcher } from "../../../../type/matcher/v3/string_pb.js";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.TlsParameters
 */
export const TlsParameters = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.TlsParameters",
  () => [
    { no: 1, name: "tls_minimum_protocol_version", kind: "enum", T: proto3.getEnumType(TlsParameters_TlsProtocol) },
    { no: 2, name: "tls_maximum_protocol_version", kind: "enum", T: proto3.getEnumType(TlsParameters_TlsProtocol) },
    { no: 3, name: "cipher_suites", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "ecdh_curves", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "signature_algorithms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
);

/**
 * @generated from enum envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol
 */
export const TlsParameters_TlsProtocol = proto3.makeEnum(
  "envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol",
  [
    {no: 0, name: "TLS_AUTO"},
    {no: 1, name: "TLSv1_0"},
    {no: 2, name: "TLSv1_1"},
    {no: 3, name: "TLSv1_2"},
    {no: 4, name: "TLSv1_3"},
  ],
);

/**
 * BoringSSL private key method configuration. The private key methods are used for external
 * (potentially asynchronous) signing and decryption operations. Some use cases for private key
 * methods would be TPM support and TLS acceleration.
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider
 */
export const PrivateKeyProvider = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider",
  () => [
    { no: 1, name: "provider_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
);

/**
 * [#not-implemented-hide:]
 * Provides a list of private key providers. Envoy will find out an available private
 * key provider from the list on order. If there is none of available private key provider,
 * it may fallback to BoringSSL default implementation based on the `fallback` fallback.
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList
 */
export const PrivateKeyProviderList = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList",
  () => [
    { no: 1, name: "private_key_provider", kind: "message", T: PrivateKeyProvider, repeated: true },
    { no: 2, name: "fallback", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.TlsCertificate
 */
export const TlsCertificate = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.TlsCertificate",
  () => [
    { no: 1, name: "certificate_chain", kind: "message", T: DataSource },
    { no: 2, name: "private_key", kind: "message", T: DataSource },
    { no: 8, name: "pkcs12", kind: "message", T: DataSource },
    { no: 7, name: "watched_directory", kind: "message", T: WatchedDirectory },
    { no: 6, name: "private_key_provider", kind: "message", T: PrivateKeyProvider },
    { no: 9, name: "private_key_provider_list", kind: "message", T: PrivateKeyProviderList },
    { no: 3, name: "password", kind: "message", T: DataSource },
    { no: 4, name: "ocsp_staple", kind: "message", T: DataSource },
    { no: 5, name: "signed_certificate_timestamp", kind: "message", T: DataSource, repeated: true },
  ],
);

/**
 * @generated from message envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys
 */
export const TlsSessionTicketKeys = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys",
  () => [
    { no: 1, name: "keys", kind: "message", T: DataSource, repeated: true },
  ],
);

/**
 * Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
 * The plugin instances are defined in the client's bootstrap file.
 * The plugin allows certificates to be fetched/refreshed over the network asynchronously with
 * respect to the TLS handshake.
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance
 */
export const CertificateProviderPluginInstance = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance",
  () => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "certificate_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Matcher for subject alternative names, to match both type and value of the SAN.
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher
 */
export const SubjectAltNameMatcher = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher",
  () => [
    { no: 1, name: "san_type", kind: "enum", T: proto3.getEnumType(SubjectAltNameMatcher_SanType) },
    { no: 2, name: "matcher", kind: "message", T: StringMatcher },
  ],
);

/**
 * Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
 * against.
 *
 * @generated from enum envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType
 */
export const SubjectAltNameMatcher_SanType = proto3.makeEnum(
  "envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType",
  [
    {no: 0, name: "SAN_TYPE_UNSPECIFIED"},
    {no: 1, name: "EMAIL"},
    {no: 2, name: "DNS"},
    {no: 3, name: "URI"},
    {no: 4, name: "IP_ADDRESS"},
  ],
);

/**
 * [#next-free-field: 17]
 *
 * @generated from message envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext
 */
export const CertificateValidationContext = proto3.makeMessageType(
  "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext",
  () => [
    { no: 1, name: "trusted_ca", kind: "message", T: DataSource },
    { no: 13, name: "ca_certificate_provider_instance", kind: "message", T: CertificateProviderPluginInstance },
    { no: 11, name: "watched_directory", kind: "message", T: WatchedDirectory },
    { no: 3, name: "verify_certificate_spki", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "verify_certificate_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "match_typed_subject_alt_names", kind: "message", T: SubjectAltNameMatcher, repeated: true },
    { no: 9, name: "match_subject_alt_names", kind: "message", T: StringMatcher, repeated: true },
    { no: 6, name: "require_signed_certificate_timestamp", kind: "message", T: BoolValue },
    { no: 7, name: "crl", kind: "message", T: DataSource },
    { no: 8, name: "allow_expired_certificate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "trust_chain_verification", kind: "enum", T: proto3.getEnumType(CertificateValidationContext_TrustChainVerification) },
    { no: 12, name: "custom_validator_config", kind: "message", T: TypedExtensionConfig },
    { no: 14, name: "only_verify_leaf_cert_crl", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "max_verify_depth", kind: "message", T: UInt32Value },
  ],
);

/**
 * Peer certificate verification mode.
 *
 * @generated from enum envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification
 */
export const CertificateValidationContext_TrustChainVerification = proto3.makeEnum(
  "envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification",
  [
    {no: 0, name: "VERIFY_TRUST_CHAIN"},
    {no: 1, name: "ACCEPT_UNTRUSTED"},
  ],
);

