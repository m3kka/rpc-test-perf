// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/transport_sockets/tls/v3/common.proto" (package "envoy.extensions.transport_sockets.tls.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt32Value } from "../../../../../google/protobuf/wrappers";
import { TypedExtensionConfig } from "../../../../config/core/v3/extension";
import { BoolValue } from "../../../../../google/protobuf/wrappers";
import { StringMatcher } from "../../../../type/matcher/v3/string";
import { WatchedDirectory } from "../../../../config/core/v3/base";
import { DataSource } from "../../../../config/core/v3/base";
import { Any } from "../../../../../google/protobuf/any";
// [#protodoc-title: Common TLS configuration]

/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.TlsParameters
 */
export interface TlsParameters {
    /**
     * Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
     *
     * TLS protocol versions below TLSv1_2 require setting compatible ciphers with the
     * ``cipher_suites`` setting as the default ciphers no longer include compatible ciphers.
     *
     * .. attention::
     *
     *   Using TLS protocol versions below TLSv1_2 has serious security considerations and risks.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1;
     */
    tlsMinimumProtocolVersion: TlsParameters_TlsProtocol;
    /**
     * Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
     * servers.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2;
     */
    tlsMaximumProtocolVersion: TlsParameters_TlsProtocol;
    /**
     * If specified, the TLS listener will only support the specified `cipher list
     * <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
     * when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3).
     *
     * If not specified, a default list will be used. Defaults are different for server (downstream) and
     * client (upstream) TLS configurations.
     * Defaults will change over time in response to security considerations; If you care, configure
     * it instead of using the default.
     *
     * In non-FIPS builds, the default server cipher list is:
     *
     * .. code-block:: none
     *
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *
     * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default server cipher list is:
     *
     * .. code-block:: none
     *
     *   ECDHE-ECDSA-AES128-GCM-SHA256
     *   ECDHE-RSA-AES128-GCM-SHA256
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *
     * In non-FIPS builds, the default client cipher list is:
     *
     * .. code-block:: none
     *
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *
     * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default client cipher list is:
     *
     * .. code-block:: none
     *
     *   ECDHE-ECDSA-AES128-GCM-SHA256
     *   ECDHE-RSA-AES128-GCM-SHA256
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *
     * @generated from protobuf field: repeated string cipher_suites = 3;
     */
    cipherSuites: string[];
    /**
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves will be used.
     *
     * In non-FIPS builds, the default curves are:
     *
     * .. code-block:: none
     *
     *   X25519
     *   P-256
     *
     * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
     *
     * .. code-block:: none
     *
     *   P-256
     *
     * @generated from protobuf field: repeated string ecdh_curves = 4;
     */
    ecdhCurves: string[];
    /**
     * If specified, the TLS connection will only support the specified signature algorithms.
     * The list is ordered by preference.
     * If not specified, the default signature algorithms defined by BoringSSL will be used.
     *
     * Default signature algorithms selected by BoringSSL (may be out of date):
     *
     * .. code-block:: none
     *
     *   ecdsa_secp256r1_sha256
     *   rsa_pss_rsae_sha256
     *   rsa_pkcs1_sha256
     *   ecdsa_secp384r1_sha384
     *   rsa_pss_rsae_sha384
     *   rsa_pkcs1_sha384
     *   rsa_pss_rsae_sha512
     *   rsa_pkcs1_sha512
     *   rsa_pkcs1_sha1
     *
     * Signature algorithms supported by BoringSSL (may be out of date):
     *
     * .. code-block:: none
     *
     *   rsa_pkcs1_sha256
     *   rsa_pkcs1_sha384
     *   rsa_pkcs1_sha512
     *   ecdsa_secp256r1_sha256
     *   ecdsa_secp384r1_sha384
     *   ecdsa_secp521r1_sha512
     *   rsa_pss_rsae_sha256
     *   rsa_pss_rsae_sha384
     *   rsa_pss_rsae_sha512
     *   ed25519
     *   rsa_pkcs1_sha1
     *   ecdsa_sha1
     *
     * @generated from protobuf field: repeated string signature_algorithms = 5;
     */
    signatureAlgorithms: string[];
}
/**
 * @generated from protobuf enum envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol
 */
export enum TlsParameters_TlsProtocol {
    /**
     * Envoy will choose the optimal TLS version.
     *
     * @generated from protobuf enum value: TLS_AUTO = 0;
     */
    TLS_AUTO = 0,
    /**
     * TLS 1.0
     *
     * @generated from protobuf enum value: TLSv1_0 = 1;
     */
    TLSv1_0 = 1,
    /**
     * TLS 1.1
     *
     * @generated from protobuf enum value: TLSv1_1 = 2;
     */
    TLSv1_1 = 2,
    /**
     * TLS 1.2
     *
     * @generated from protobuf enum value: TLSv1_2 = 3;
     */
    TLSv1_2 = 3,
    /**
     * TLS 1.3
     *
     * @generated from protobuf enum value: TLSv1_3 = 4;
     */
    TLSv1_3 = 4
}
/**
 * BoringSSL private key method configuration. The private key methods are used for external
 * (potentially asynchronous) signing and decryption operations. Some use cases for private key
 * methods would be TPM support and TLS acceleration.
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider
 */
export interface PrivateKeyProvider {
    /**
     * Private key method provider name. The name must match a
     * supported private key method provider type.
     *
     * @generated from protobuf field: string provider_name = 1;
     */
    providerName: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#not-implemented-hide:]
 * Provides a list of private key providers. Envoy will find out an available private
 * key provider from the list on order. If there is none of available private key provider,
 * it may fallback to BoringSSL default implementation based on the `fallback` fallback.
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList
 */
export interface PrivateKeyProviderList {
    /**
     * A list of private key providers, and at least one private key provider provided.
     *
     * @generated from protobuf field: repeated envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider = 1;
     */
    privateKeyProvider: PrivateKeyProvider[];
    /**
     * If there is no available private key provider from the list, Envoy will fallback to
     * the BoringSSL default implementation when the `fallback` is true. The default value
     * is `false`.
     *
     * @generated from protobuf field: bool fallback = 2;
     */
    fallback: boolean;
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.TlsCertificate
 */
export interface TlsCertificate {
    /**
     * The TLS certificate chain.
     *
     * If ``certificate_chain`` is a filesystem path, a watch will be added to the
     * parent directory for any file moves to support rotation. This currently
     * only applies to dynamic secrets, when the ``TlsCertificate`` is delivered via
     * SDS.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource certificate_chain = 1;
     */
    certificateChain?: DataSource;
    /**
     * The TLS private key.
     *
     * If ``private_key`` is a filesystem path, a watch will be added to the parent
     * directory for any file moves to support rotation. This currently only
     * applies to dynamic secrets, when the ``TlsCertificate`` is delivered via SDS.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource private_key = 2;
     */
    privateKey?: DataSource;
    /**
     * ``Pkcs12`` data containing TLS certificate, chain, and private key.
     *
     * If ``pkcs12`` is a filesystem path, the file will be read, but no watch will
     * be added to the parent directory, since ``pkcs12`` isn't used by SDS.
     * This field is mutually exclusive with ``certificate_chain``, ``private_key`` and ``private_key_provider``.
     * This can't be marked as ``oneof`` due to API compatibility reasons. Setting
     * both :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>`,
     * :ref:`certificate_chain <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.certificate_chain>`,
     * or :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
     * and :ref:`pkcs12 <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.pkcs12>`
     * fields will result in an error. Use :ref:`password
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.password>`
     * to specify the password to unprotect the ``PKCS12`` data, if necessary.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource pkcs12 = 8;
     */
    pkcs12?: DataSource;
    /**
     * If specified, updates of file-based ``certificate_chain`` and ``private_key``
     * sources will be triggered by this watch. The certificate/key pair will be
     * read together and validated for atomic read consistency (i.e. no
     * intervening modification occurred between cert/key read, verified by file
     * hash comparisons). This allows explicit control over the path watched, by
     * default the parent directories of the filesystem paths in
     * ``certificate_chain`` and ``private_key`` are watched if this field is not
     * specified. This only applies when a ``TlsCertificate`` is delivered by SDS
     * with references to filesystem paths. See the :ref:`SDS key rotation
     * <sds_key_rotation>` documentation for further details.
     *
     * @generated from protobuf field: envoy.config.core.v3.WatchedDirectory watched_directory = 7;
     */
    watchedDirectory?: WatchedDirectory;
    /**
     * BoringSSL private key method provider. This is an alternative to :ref:`private_key
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field. This can't be
     * marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
     * :ref:`private_key_provider
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields will result in an
     * error.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider = 6;
     */
    privateKeyProvider?: PrivateKeyProvider;
    /**
     * [#not-implemented-hide:]
     * This provides a list of BoringSSL private key method provider. Envoy will find out
     * an available private key method provider. It may fallback to BoringSSL default implementation
     * when there is no available one. All the private key provider will share the same private key
     * in the :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field,
     * so the :ref:`private_key <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field
     * must be specified when the `proviate_key_provider_list` field is used. The old :ref:`private_key_provider
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` field will be
     * deprecated. If both :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>`
     * and `private_key_provider_list` are provided, the old
     * :ref:`private_key_provider <envoy_v3_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` will be ignored.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList private_key_provider_list = 9;
     */
    privateKeyProviderList?: PrivateKeyProviderList;
    /**
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource password = 3;
     */
    password?: DataSource;
    /**
     * The OCSP response to be stapled with this certificate during the handshake.
     * The response must be DER-encoded and may only be  provided via ``filename`` or
     * ``inline_bytes``. The response may pertain to only one certificate.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource ocsp_staple = 4;
     */
    ocspStaple?: DataSource;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.DataSource signed_certificate_timestamp = 5;
     */
    signedCertificateTimestamp: DataSource[];
}
/**
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys
 */
export interface TlsSessionTicketKeys {
    /**
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     *
     * If :ref:`session_ticket_keys <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     *
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     *
     * .. attention::
     *
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.DataSource keys = 1;
     */
    keys: DataSource[];
}
/**
 * Indicates a certificate to be obtained from a named CertificateProvider plugin instance.
 * The plugin instances are defined in the client's bootstrap file.
 * The plugin allows certificates to be fetched/refreshed over the network asynchronously with
 * respect to the TLS handshake.
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance
 */
export interface CertificateProviderPluginInstance {
    /**
     * Provider instance name. If not present, defaults to "default".
     *
     * Instance names should generally be defined not in terms of the underlying provider
     * implementation (e.g., "file_watcher") but rather in terms of the function of the
     * certificates (e.g., "foo_deployment_identity").
     *
     * @generated from protobuf field: string instance_name = 1;
     */
    instanceName: string;
    /**
     * Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
     * a root-certificate (validation context) or "example.com" to specify a certificate for a
     * particular domain. Not all provider instances will actually use this field, so the value
     * defaults to the empty string.
     *
     * @generated from protobuf field: string certificate_name = 2;
     */
    certificateName: string;
}
/**
 * Matcher for subject alternative names, to match both type and value of the SAN.
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher
 */
export interface SubjectAltNameMatcher {
    /**
     * Specification of type of SAN. Note that the default enum value is an invalid choice.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType san_type = 1;
     */
    sanType: SubjectAltNameMatcher_SanType;
    /**
     * Matcher for SAN value.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher matcher = 2;
     */
    matcher?: StringMatcher;
}
/**
 * Indicates the choice of GeneralName as defined in section 4.2.1.5 of RFC 5280 to match
 * against.
 *
 * @generated from protobuf enum envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType
 */
export enum SubjectAltNameMatcher_SanType {
    /**
     * @generated from protobuf enum value: SAN_TYPE_UNSPECIFIED = 0;
     */
    SAN_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: EMAIL = 1;
     */
    EMAIL = 1,
    /**
     * @generated from protobuf enum value: DNS = 2;
     */
    DNS = 2,
    /**
     * @generated from protobuf enum value: URI = 3;
     */
    URI = 3,
    /**
     * @generated from protobuf enum value: IP_ADDRESS = 4;
     */
    IP_ADDRESS = 4
}
/**
 * [#next-free-field: 17]
 *
 * @generated from protobuf message envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext
 */
export interface CertificateValidationContext {
    /**
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
     * :ref:`verify_certificate_spki
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
     * :ref:`verify_certificate_hash
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
     * :ref:`match_typed_subject_alt_names
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`) is also
     * specified.
     *
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs. Note
     * that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
     * provided for all certificate authorities in that chain. Failure to do so will result in
     * verification failure for both revoked and unrevoked certificates from that chain.
     * The behavior of requiring all certificates to contain CRLs can be altered by
     * setting :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>`
     * true. If set to true, only the final certificate in the chain undergoes CRL verification.
     *
     * See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
     * system CA locations.
     *
     * If ``trusted_ca`` is a filesystem path, a watch will be added to the parent
     * directory for any file moves to support rotation. This currently only
     * applies to dynamic secrets, when the ``CertificateValidationContext`` is
     * delivered via SDS.
     *
     * X509_V_FLAG_PARTIAL_CHAIN is set by default, so non-root/intermediate ca certificate in ``trusted_ca``
     * can be treated as trust anchor as well. It allows verification with building valid partial chain instead
     * of a full chain.
     *
     * Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
     *
     * [#next-major-version: This field and watched_directory below should ideally be moved into a
     * separate sub-message, since there's no point in specifying the latter field without this one.]
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource trusted_ca = 1;
     */
    trustedCa?: DataSource;
    /**
     * Certificate provider instance for fetching TLS certificates.
     *
     * Only one of ``trusted_ca`` and ``ca_certificate_provider_instance`` may be specified.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance ca_certificate_provider_instance = 13;
     */
    caCertificateProviderInstance?: CertificateProviderPluginInstance;
    /**
     * If specified, updates of a file-based ``trusted_ca`` source will be triggered
     * by this watch. This allows explicit control over the path watched, by
     * default the parent directory of the filesystem path in ``trusted_ca`` is
     * watched if this field is not specified. This only applies when a
     * ``CertificateValidationContext`` is delivered by SDS with references to
     * filesystem paths. See the :ref:`SDS key rotation <sds_key_rotation>`
     * documentation for further details.
     *
     * @generated from protobuf field: envoy.config.core.v3.WatchedDirectory watched_directory = 11;
     */
    watchedDirectory?: WatchedDirectory;
    /**
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     *
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey
     *     | openssl pkey -pubin -outform DER
     *     | openssl dgst -sha256 -binary
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     *
     * This is the format used in HTTP Public Key Pinning.
     *
     * When both:
     * :ref:`verify_certificate_hash
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
     * :ref:`verify_certificate_spki
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     *
     * .. attention::
     *
     *   This option is preferred over :ref:`verify_certificate_hash
     *   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     *
     * @generated from protobuf field: repeated string verify_certificate_spki = 3;
     */
    verifyCertificateSpki: string[];
    /**
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     *
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     *
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     *
     * Both of those formats are acceptable.
     *
     * When both:
     * :ref:`verify_certificate_hash
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
     * :ref:`verify_certificate_spki
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     *
     * @generated from protobuf field: repeated string verify_certificate_hash = 2;
     */
    verifyCertificateHash: string[];
    /**
     * An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified matchers.
     * The matching uses "any" semantics, that is to say, the SAN is verified if at least one matcher is
     * matched.
     *
     * When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
     * configured with exact match type in the :ref:`string matcher <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`.
     * For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
     * it should be configured as shown below.
     *
     * .. code-block:: yaml
     *
     *  match_typed_subject_alt_names:
     *  - san_type: DNS
     *    matcher:
     *      exact: "api.example.com"
     *
     * .. attention::
     *
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
     *
     * @generated from protobuf field: repeated envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher match_typed_subject_alt_names = 15;
     */
    matchTypedSubjectAltNames: SubjectAltNameMatcher[];
    /**
     * This field is deprecated in favor of
     * :ref:`match_typed_subject_alt_names
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`.
     * Note that if both this field and :ref:`match_typed_subject_alt_names
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_typed_subject_alt_names>`
     * are specified, the former (deprecated field) is ignored.
     *
     * @deprecated
     * @generated from protobuf field: repeated envoy.type.matcher.v3.StringMatcher match_subject_alt_names = 9 [deprecated = true];
     */
    matchSubjectAltNames: StringMatcher[];
    /**
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     *
     * @generated from protobuf field: google.protobuf.BoolValue require_signed_certificate_timestamp = 6;
     */
    requireSignedCertificateTimestamp?: BoolValue;
    /**
     * An optional `certificate revocation list
     * <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used. Note that if a CRL is provided
     * for any certificate authority in a trust chain, a CRL must be provided
     * for all certificate authorities in that chain. Failure to do so will
     * result in verification failure for both revoked and unrevoked certificates
     * from that chain. This default behavior can be altered by setting
     * :ref:`only_verify_leaf_cert_crl <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.only_verify_leaf_cert_crl>` to
     * true.
     *
     * If ``crl`` is a filesystem path, a watch will be added to the parent
     * directory for any file moves to support rotation. This currently only
     * applies to dynamic secrets, when the ``CertificateValidationContext`` is
     * delivered via SDS.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource crl = 7;
     */
    crl?: DataSource;
    /**
     * If specified, Envoy will not reject expired certificates.
     *
     * @generated from protobuf field: bool allow_expired_certificate = 8;
     */
    allowExpiredCertificate: boolean;
    /**
     * Certificate trust chain verification mode.
     *
     * @generated from protobuf field: envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification trust_chain_verification = 10;
     */
    trustChainVerification: CertificateValidationContext_TrustChainVerification;
    /**
     * The configuration of an extension specific certificate validator.
     * If specified, all validation is done by the specified validator,
     * and the behavior of all other validation settings is defined by the specified validator (and may be entirely ignored, unused, and unvalidated).
     * Refer to the documentation for the specified validator. If you do not want a custom validation algorithm, do not set this field.
     * [#extension-category: envoy.tls.cert_validator]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig custom_validator_config = 12;
     */
    customValidatorConfig?: TypedExtensionConfig;
    /**
     * If this option is set to true, only the certificate at the end of the
     * certificate chain will be subject to validation by :ref:`CRL <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.crl>`.
     *
     * @generated from protobuf field: bool only_verify_leaf_cert_crl = 14;
     */
    onlyVerifyLeafCertCrl: boolean;
    /**
     * Defines maximum depth of a certificate chain accepted in verification, the default limit is 100, though this can be system-dependent.
     * This number does not include the leaf, so a depth of 1 allows the leaf and one CA certificate. If a trusted issuer appears in the chain,
     * but in a depth larger than configured, the certificate validation will fail.
     * See `BoringSSL SSL_CTX_set_verify_depth <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_CTX_set_verify_depth>`
     * If you use OpenSSL, its behavior is different from BoringSSL, this will define a limit on the number of certificates between the end-entity and trust-anchor certificates.
     * Neither the end-entity nor the trust-anchor certificates count against depth.
     * See `OpenSSL SSL set_verify_depth <https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_verify_depth.html>`_.
     * Trusted issues are specified by setting :ref:`trusted_ca <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_verify_depth = 16;
     */
    maxVerifyDepth?: UInt32Value;
}
/**
 * Peer certificate verification mode.
 *
 * @generated from protobuf enum envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification
 */
export enum CertificateValidationContext_TrustChainVerification {
    /**
     * Perform default certificate verification (e.g., against CA / verification lists)
     *
     * @generated from protobuf enum value: VERIFY_TRUST_CHAIN = 0;
     */
    VERIFY_TRUST_CHAIN = 0,
    /**
     * Connections where the certificate fails verification will be permitted.
     * For HTTP connections, the result of certificate verification can be used in route matching. (
     * see :ref:`validated <envoy_v3_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
     *
     * @generated from protobuf enum value: ACCEPT_UNTRUSTED = 1;
     */
    ACCEPT_UNTRUSTED = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class TlsParameters$Type extends MessageType<TlsParameters> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.TlsParameters", [
            { no: 1, name: "tls_minimum_protocol_version", kind: "enum", T: () => ["envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol", TlsParameters_TlsProtocol], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "tls_maximum_protocol_version", kind: "enum", T: () => ["envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol", TlsParameters_TlsProtocol], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "cipher_suites", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ecdh_curves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "signature_algorithms", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.TlsParameters" } });
    }
    create(value?: PartialMessage<TlsParameters>): TlsParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tlsMinimumProtocolVersion = 0;
        message.tlsMaximumProtocolVersion = 0;
        message.cipherSuites = [];
        message.ecdhCurves = [];
        message.signatureAlgorithms = [];
        if (value !== undefined)
            reflectionMergePartial<TlsParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsParameters): TlsParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_minimum_protocol_version */ 1:
                    message.tlsMinimumProtocolVersion = reader.int32();
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_maximum_protocol_version */ 2:
                    message.tlsMaximumProtocolVersion = reader.int32();
                    break;
                case /* repeated string cipher_suites */ 3:
                    message.cipherSuites.push(reader.string());
                    break;
                case /* repeated string ecdh_curves */ 4:
                    message.ecdhCurves.push(reader.string());
                    break;
                case /* repeated string signature_algorithms */ 5:
                    message.signatureAlgorithms.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1; */
        if (message.tlsMinimumProtocolVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.tlsMinimumProtocolVersion);
        /* envoy.extensions.transport_sockets.tls.v3.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2; */
        if (message.tlsMaximumProtocolVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.tlsMaximumProtocolVersion);
        /* repeated string cipher_suites = 3; */
        for (let i = 0; i < message.cipherSuites.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cipherSuites[i]);
        /* repeated string ecdh_curves = 4; */
        for (let i = 0; i < message.ecdhCurves.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.ecdhCurves[i]);
        /* repeated string signature_algorithms = 5; */
        for (let i = 0; i < message.signatureAlgorithms.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.signatureAlgorithms[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.TlsParameters
 */
export const TlsParameters = new TlsParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateKeyProvider$Type extends MessageType<PrivateKeyProvider> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider", [
            { no: 1, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any, options: { "udpa.annotations.sensitive": true } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.PrivateKeyProvider" } });
    }
    create(value?: PartialMessage<PrivateKeyProvider>): PrivateKeyProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerName = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PrivateKeyProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateKeyProvider): PrivateKeyProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_name */ 1:
                    message.providerName = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateKeyProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_name = 1; */
        if (message.providerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.providerName);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider
 */
export const PrivateKeyProvider = new PrivateKeyProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateKeyProviderList$Type extends MessageType<PrivateKeyProviderList> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList", [
            { no: 1, name: "private_key_provider", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PrivateKeyProvider, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 2, name: "fallback", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PrivateKeyProviderList>): PrivateKeyProviderList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.privateKeyProvider = [];
        message.fallback = false;
        if (value !== undefined)
            reflectionMergePartial<PrivateKeyProviderList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateKeyProviderList): PrivateKeyProviderList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider */ 1:
                    message.privateKeyProvider.push(PrivateKeyProvider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool fallback */ 2:
                    message.fallback = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateKeyProviderList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider = 1; */
        for (let i = 0; i < message.privateKeyProvider.length; i++)
            PrivateKeyProvider.internalBinaryWrite(message.privateKeyProvider[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool fallback = 2; */
        if (message.fallback !== false)
            writer.tag(2, WireType.Varint).bool(message.fallback);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList
 */
export const PrivateKeyProviderList = new PrivateKeyProviderList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TlsCertificate$Type extends MessageType<TlsCertificate> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.TlsCertificate", [
            { no: 1, name: "certificate_chain", kind: "message", T: () => DataSource },
            { no: 2, name: "private_key", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 8, name: "pkcs12", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 7, name: "watched_directory", kind: "message", T: () => WatchedDirectory },
            { no: 6, name: "private_key_provider", kind: "message", T: () => PrivateKeyProvider },
            { no: 9, name: "private_key_provider_list", kind: "message", T: () => PrivateKeyProviderList },
            { no: 3, name: "password", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 4, name: "ocsp_staple", kind: "message", T: () => DataSource },
            { no: 5, name: "signed_certificate_timestamp", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.TlsCertificate" } });
    }
    create(value?: PartialMessage<TlsCertificate>): TlsCertificate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signedCertificateTimestamp = [];
        if (value !== undefined)
            reflectionMergePartial<TlsCertificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsCertificate): TlsCertificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.DataSource certificate_chain */ 1:
                    message.certificateChain = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.certificateChain);
                    break;
                case /* envoy.config.core.v3.DataSource private_key */ 2:
                    message.privateKey = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.privateKey);
                    break;
                case /* envoy.config.core.v3.DataSource pkcs12 */ 8:
                    message.pkcs12 = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.pkcs12);
                    break;
                case /* envoy.config.core.v3.WatchedDirectory watched_directory */ 7:
                    message.watchedDirectory = WatchedDirectory.internalBinaryRead(reader, reader.uint32(), options, message.watchedDirectory);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider */ 6:
                    message.privateKeyProvider = PrivateKeyProvider.internalBinaryRead(reader, reader.uint32(), options, message.privateKeyProvider);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList private_key_provider_list */ 9:
                    message.privateKeyProviderList = PrivateKeyProviderList.internalBinaryRead(reader, reader.uint32(), options, message.privateKeyProviderList);
                    break;
                case /* envoy.config.core.v3.DataSource password */ 3:
                    message.password = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.password);
                    break;
                case /* envoy.config.core.v3.DataSource ocsp_staple */ 4:
                    message.ocspStaple = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.ocspStaple);
                    break;
                case /* repeated envoy.config.core.v3.DataSource signed_certificate_timestamp */ 5:
                    message.signedCertificateTimestamp.push(DataSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsCertificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.DataSource certificate_chain = 1; */
        if (message.certificateChain)
            DataSource.internalBinaryWrite(message.certificateChain, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource private_key = 2; */
        if (message.privateKey)
            DataSource.internalBinaryWrite(message.privateKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource pkcs12 = 8; */
        if (message.pkcs12)
            DataSource.internalBinaryWrite(message.pkcs12, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.WatchedDirectory watched_directory = 7; */
        if (message.watchedDirectory)
            WatchedDirectory.internalBinaryWrite(message.watchedDirectory, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.PrivateKeyProvider private_key_provider = 6; */
        if (message.privateKeyProvider)
            PrivateKeyProvider.internalBinaryWrite(message.privateKeyProvider, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.PrivateKeyProviderList private_key_provider_list = 9; */
        if (message.privateKeyProviderList)
            PrivateKeyProviderList.internalBinaryWrite(message.privateKeyProviderList, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource password = 3; */
        if (message.password)
            DataSource.internalBinaryWrite(message.password, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource ocsp_staple = 4; */
        if (message.ocspStaple)
            DataSource.internalBinaryWrite(message.ocspStaple, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.DataSource signed_certificate_timestamp = 5; */
        for (let i = 0; i < message.signedCertificateTimestamp.length; i++)
            DataSource.internalBinaryWrite(message.signedCertificateTimestamp[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.TlsCertificate
 */
export const TlsCertificate = new TlsCertificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TlsSessionTicketKeys$Type extends MessageType<TlsSessionTicketKeys> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys", [
            { no: 1, name: "keys", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataSource, options: { "validate.rules": { repeated: { minItems: "1" } }, "udpa.annotations.sensitive": true } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.TlsSessionTicketKeys" } });
    }
    create(value?: PartialMessage<TlsSessionTicketKeys>): TlsSessionTicketKeys {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<TlsSessionTicketKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsSessionTicketKeys): TlsSessionTicketKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.core.v3.DataSource keys */ 1:
                    message.keys.push(DataSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsSessionTicketKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.core.v3.DataSource keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            DataSource.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.TlsSessionTicketKeys
 */
export const TlsSessionTicketKeys = new TlsSessionTicketKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateProviderPluginInstance$Type extends MessageType<CertificateProviderPluginInstance> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance", [
            { no: 1, name: "instance_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "certificate_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CertificateProviderPluginInstance>): CertificateProviderPluginInstance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instanceName = "";
        message.certificateName = "";
        if (value !== undefined)
            reflectionMergePartial<CertificateProviderPluginInstance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateProviderPluginInstance): CertificateProviderPluginInstance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string instance_name */ 1:
                    message.instanceName = reader.string();
                    break;
                case /* string certificate_name */ 2:
                    message.certificateName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateProviderPluginInstance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string instance_name = 1; */
        if (message.instanceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.instanceName);
        /* string certificate_name = 2; */
        if (message.certificateName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.certificateName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance
 */
export const CertificateProviderPluginInstance = new CertificateProviderPluginInstance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectAltNameMatcher$Type extends MessageType<SubjectAltNameMatcher> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher", [
            { no: 1, name: "san_type", kind: "enum", T: () => ["envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType", SubjectAltNameMatcher_SanType], options: { "validate.rules": { enum: { definedOnly: true, notIn: [0] } } } },
            { no: 2, name: "matcher", kind: "message", T: () => StringMatcher, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<SubjectAltNameMatcher>): SubjectAltNameMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sanType = 0;
        if (value !== undefined)
            reflectionMergePartial<SubjectAltNameMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectAltNameMatcher): SubjectAltNameMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType san_type */ 1:
                    message.sanType = reader.int32();
                    break;
                case /* envoy.type.matcher.v3.StringMatcher matcher */ 2:
                    message.matcher = StringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.matcher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectAltNameMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher.SanType san_type = 1; */
        if (message.sanType !== 0)
            writer.tag(1, WireType.Varint).int32(message.sanType);
        /* envoy.type.matcher.v3.StringMatcher matcher = 2; */
        if (message.matcher)
            StringMatcher.internalBinaryWrite(message.matcher, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher
 */
export const SubjectAltNameMatcher = new SubjectAltNameMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateValidationContext$Type extends MessageType<CertificateValidationContext> {
    constructor() {
        super("envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext", [
            { no: 1, name: "trusted_ca", kind: "message", T: () => DataSource, options: { "udpa.annotations.field_migrate": { oneofPromotion: "ca_cert_source" } } },
            { no: 13, name: "ca_certificate_provider_instance", kind: "message", T: () => CertificateProviderPluginInstance, options: { "udpa.annotations.field_migrate": { oneofPromotion: "ca_cert_source" } } },
            { no: 11, name: "watched_directory", kind: "message", T: () => WatchedDirectory },
            { no: 3, name: "verify_certificate_spki", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "44", maxBytes: "44" } } } } } },
            { no: 2, name: "verify_certificate_hash", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "64", maxBytes: "95" } } } } } },
            { no: 15, name: "match_typed_subject_alt_names", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SubjectAltNameMatcher },
            { no: 9, name: "match_subject_alt_names", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringMatcher, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 6, name: "require_signed_certificate_timestamp", kind: "message", T: () => BoolValue },
            { no: 7, name: "crl", kind: "message", T: () => DataSource },
            { no: 8, name: "allow_expired_certificate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "trust_chain_verification", kind: "enum", T: () => ["envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification", CertificateValidationContext_TrustChainVerification], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 12, name: "custom_validator_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 14, name: "only_verify_leaf_cert_crl", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "max_verify_depth", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.auth.CertificateValidationContext" } });
    }
    create(value?: PartialMessage<CertificateValidationContext>): CertificateValidationContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.verifyCertificateSpki = [];
        message.verifyCertificateHash = [];
        message.matchTypedSubjectAltNames = [];
        message.matchSubjectAltNames = [];
        message.allowExpiredCertificate = false;
        message.trustChainVerification = 0;
        message.onlyVerifyLeafCertCrl = false;
        if (value !== undefined)
            reflectionMergePartial<CertificateValidationContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateValidationContext): CertificateValidationContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.DataSource trusted_ca */ 1:
                    message.trustedCa = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.trustedCa);
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance ca_certificate_provider_instance */ 13:
                    message.caCertificateProviderInstance = CertificateProviderPluginInstance.internalBinaryRead(reader, reader.uint32(), options, message.caCertificateProviderInstance);
                    break;
                case /* envoy.config.core.v3.WatchedDirectory watched_directory */ 11:
                    message.watchedDirectory = WatchedDirectory.internalBinaryRead(reader, reader.uint32(), options, message.watchedDirectory);
                    break;
                case /* repeated string verify_certificate_spki */ 3:
                    message.verifyCertificateSpki.push(reader.string());
                    break;
                case /* repeated string verify_certificate_hash */ 2:
                    message.verifyCertificateHash.push(reader.string());
                    break;
                case /* repeated envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher match_typed_subject_alt_names */ 15:
                    message.matchTypedSubjectAltNames.push(SubjectAltNameMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.type.matcher.v3.StringMatcher match_subject_alt_names = 9 [deprecated = true];*/ 9:
                    message.matchSubjectAltNames.push(StringMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue require_signed_certificate_timestamp */ 6:
                    message.requireSignedCertificateTimestamp = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.requireSignedCertificateTimestamp);
                    break;
                case /* envoy.config.core.v3.DataSource crl */ 7:
                    message.crl = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.crl);
                    break;
                case /* bool allow_expired_certificate */ 8:
                    message.allowExpiredCertificate = reader.bool();
                    break;
                case /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification trust_chain_verification */ 10:
                    message.trustChainVerification = reader.int32();
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig custom_validator_config */ 12:
                    message.customValidatorConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.customValidatorConfig);
                    break;
                case /* bool only_verify_leaf_cert_crl */ 14:
                    message.onlyVerifyLeafCertCrl = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value max_verify_depth */ 16:
                    message.maxVerifyDepth = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxVerifyDepth);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateValidationContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.DataSource trusted_ca = 1; */
        if (message.trustedCa)
            DataSource.internalBinaryWrite(message.trustedCa, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.transport_sockets.tls.v3.CertificateProviderPluginInstance ca_certificate_provider_instance = 13; */
        if (message.caCertificateProviderInstance)
            CertificateProviderPluginInstance.internalBinaryWrite(message.caCertificateProviderInstance, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.WatchedDirectory watched_directory = 11; */
        if (message.watchedDirectory)
            WatchedDirectory.internalBinaryWrite(message.watchedDirectory, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated string verify_certificate_spki = 3; */
        for (let i = 0; i < message.verifyCertificateSpki.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.verifyCertificateSpki[i]);
        /* repeated string verify_certificate_hash = 2; */
        for (let i = 0; i < message.verifyCertificateHash.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.verifyCertificateHash[i]);
        /* repeated envoy.extensions.transport_sockets.tls.v3.SubjectAltNameMatcher match_typed_subject_alt_names = 15; */
        for (let i = 0; i < message.matchTypedSubjectAltNames.length; i++)
            SubjectAltNameMatcher.internalBinaryWrite(message.matchTypedSubjectAltNames[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.matcher.v3.StringMatcher match_subject_alt_names = 9 [deprecated = true]; */
        for (let i = 0; i < message.matchSubjectAltNames.length; i++)
            StringMatcher.internalBinaryWrite(message.matchSubjectAltNames[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue require_signed_certificate_timestamp = 6; */
        if (message.requireSignedCertificateTimestamp)
            BoolValue.internalBinaryWrite(message.requireSignedCertificateTimestamp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource crl = 7; */
        if (message.crl)
            DataSource.internalBinaryWrite(message.crl, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_expired_certificate = 8; */
        if (message.allowExpiredCertificate !== false)
            writer.tag(8, WireType.Varint).bool(message.allowExpiredCertificate);
        /* envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext.TrustChainVerification trust_chain_verification = 10; */
        if (message.trustChainVerification !== 0)
            writer.tag(10, WireType.Varint).int32(message.trustChainVerification);
        /* envoy.config.core.v3.TypedExtensionConfig custom_validator_config = 12; */
        if (message.customValidatorConfig)
            TypedExtensionConfig.internalBinaryWrite(message.customValidatorConfig, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bool only_verify_leaf_cert_crl = 14; */
        if (message.onlyVerifyLeafCertCrl !== false)
            writer.tag(14, WireType.Varint).bool(message.onlyVerifyLeafCertCrl);
        /* google.protobuf.UInt32Value max_verify_depth = 16; */
        if (message.maxVerifyDepth)
            UInt32Value.internalBinaryWrite(message.maxVerifyDepth, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.transport_sockets.tls.v3.CertificateValidationContext
 */
export const CertificateValidationContext = new CertificateValidationContext$Type();
