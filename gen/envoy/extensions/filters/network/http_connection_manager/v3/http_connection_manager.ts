// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto" (package "envoy.extensions.filters.network.http_connection_manager.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ExtensionConfigSource } from "../../../../../config/core/v3/config_source";
import { Any } from "../../../../../../google/protobuf/any";
import { ScopedRouteConfiguration } from "../../../../../config/route/v3/scoped_route";
import { ConfigSource } from "../../../../../config/core/v3/config_source";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { DataSource } from "../../../../../config/core/v3/base";
import { AccessLogFilter } from "../../../../../config/accesslog/v3/accesslog";
import { SubstitutionFormatString } from "../../../../../config/core/v3/substitution_format_string";
import { PathTransformation } from "../../../../../type/http/v3/path_transformation";
import { CidrRange } from "../../../../../config/core/v3/address";
import { Tracing_Http } from "../../../../../config/trace/v3/http_tracer";
import { CustomTag } from "../../../../../type/tracing/v3/custom_tag";
import { Percent } from "../../../../../type/v3/percent";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { SchemeHeaderTransformation } from "../../../../../config/core/v3/protocol";
import { Http3ProtocolOptions } from "../../../../../config/core/v3/protocol";
import { Http2ProtocolOptions } from "../../../../../config/core/v3/protocol";
import { Http1ProtocolOptions } from "../../../../../config/core/v3/protocol";
import { HttpProtocolOptions } from "../../../../../config/core/v3/protocol";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { RouteConfiguration } from "../../../../../config/route/v3/route";
// [#protodoc-title: HTTP connection manager]
// HTTP connection manager :ref:`configuration overview <config_http_conn_man>`.
// [#extension: envoy.filters.network.http_connection_manager]

/**
 * [#next-free-field: 57]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
 */
export interface HttpConnectionManager {
    /**
     * Supplies the type of codec that the connection manager should use.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1;
     */
    codecType: HttpConnectionManager_CodecType;
    /**
     * The human readable prefix to use when emitting statistics for the
     * connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
     * more information.
     *
     * @generated from protobuf field: string stat_prefix = 2;
     */
    statPrefix: string;
    /**
     * @generated from protobuf oneof: route_specifier
     */
    routeSpecifier: {
        oneofKind: "rds";
        /**
         * The connection manager’s route table will be dynamically loaded via the RDS API.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3;
         */
        rds: Rds;
    } | {
        oneofKind: "routeConfig";
        /**
         * The route table for the connection manager is static and is specified in this property.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteConfiguration route_config = 4;
         */
        routeConfig: RouteConfiguration;
    } | {
        oneofKind: "scopedRoutes";
        /**
         * A route table will be dynamically assigned to each request based on request attributes
         * (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
         * specified in this message.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31;
         */
        scopedRoutes: ScopedRoutes;
    } | {
        oneofKind: undefined;
    };
    /**
     * A list of individual HTTP filters that make up the filter chain for
     * requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
     * as the filters are processed sequentially as request events happen.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5;
     */
    httpFilters: HttpFilter[];
    /**
     * Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
     * and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
     * documentation for more information. Defaults to false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue add_user_agent = 6;
     */
    addUserAgent?: BoolValue;
    /**
     * Presence of the object defines whether the connection manager
     * emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
     * <envoy_v3_api_msg_config.trace.v3.Tracing>`.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7;
     */
    tracing?: HttpConnectionManager_Tracing;
    /**
     * Additional settings for HTTP requests handled by the connection manager. These will be
     * applicable to both HTTP1 and HTTP2 requests.
     *
     * @generated from protobuf field: envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35;
     */
    commonHttpProtocolOptions?: HttpProtocolOptions;
    /**
     * Additional HTTP/1 settings that are passed to the HTTP/1 codec.
     * [#comment:TODO: The following fields are ignored when the
     * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
     * is present:
     * 1. :ref:`allow_chunked_length <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.allow_chunked_length>`]
     *
     * @generated from protobuf field: envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8;
     */
    httpProtocolOptions?: Http1ProtocolOptions;
    /**
     * Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
     *
     * @generated from protobuf field: envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9;
     */
    http2ProtocolOptions?: Http2ProtocolOptions;
    /**
     * Additional HTTP/3 settings that are passed directly to the HTTP/3 codec.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44;
     */
    http3ProtocolOptions?: Http3ProtocolOptions;
    /**
     * An optional override that the connection manager will write to the server
     * header in responses. If not set, the default is ``envoy``.
     *
     * @generated from protobuf field: string server_name = 10;
     */
    serverName: string;
    /**
     * Defines the action to be applied to the Server header on the response path.
     * By default, Envoy will overwrite the header with the value specified in
     * server_name.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34;
     */
    serverHeaderTransformation: HttpConnectionManager_ServerHeaderTransformation;
    /**
     * Allows for explicit transformation of the :scheme header on the request path.
     * If not set, Envoy's default :ref:`scheme  <config_http_conn_man_headers_scheme>`
     * handling applies.
     *
     * @generated from protobuf field: envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48;
     */
    schemeHeaderTransformation?: SchemeHeaderTransformation;
    /**
     * The maximum request headers size for incoming connections.
     * If unconfigured, the default max request headers allowed is 60 KiB.
     * Requests that exceed this limit will receive a 431 response.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_request_headers_kb = 29;
     */
    maxRequestHeadersKb?: UInt32Value;
    /**
     * The stream idle timeout for connections managed by the connection manager.
     * If not specified, this defaults to 5 minutes. The default value was selected
     * so as not to interfere with any smaller configured timeouts that may have
     * existed in configurations prior to the introduction of this feature, while
     * introducing robustness to TCP connections that terminate without a FIN.
     *
     * This idle timeout applies to new streams and is overridable by the
     * :ref:`route-level idle_timeout
     * <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>`. Even on a stream in
     * which the override applies, prior to receipt of the initial request
     * headers, the :ref:`stream_idle_timeout
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
     * applies. Each time an encode/decode event for headers or data is processed
     * for the stream, the timer will be reset. If the timeout fires, the stream
     * is terminated with a 408 Request Timeout error code if no upstream response
     * header has been received, otherwise a stream reset occurs.
     *
     * This timeout also specifies the amount of time that Envoy will wait for the peer to open enough
     * window to write any remaining stream data once the entirety of stream data (local end stream is
     * true) has been buffered pending available window. In other words, this timeout defends against
     * a peer that does not release enough window to completely write the stream, even though all
     * data has been proxied within available flow control windows. If the timeout is hit in this
     * case, the :ref:`tx_flush_timeout <config_http_conn_man_stats_per_codec>` counter will be
     * incremented. Note that :ref:`max_stream_duration
     * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` does not apply to
     * this corner case.
     *
     * If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
     *
     * Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
     * to the granularity of events presented to the connection manager. For example, while receiving
     * very large request headers, it may be the case that there is traffic regularly arriving on the
     * wire while the connection manage is only able to observe the end-of-headers event, hence the
     * stream may still idle timeout.
     *
     * A value of 0 will completely disable the connection manager stream idle
     * timeout, although per-route idle timeout overrides will continue to apply.
     *
     * @generated from protobuf field: google.protobuf.Duration stream_idle_timeout = 24;
     */
    streamIdleTimeout?: Duration;
    /**
     * The amount of time that Envoy will wait for the entire request to be received.
     * The timer is activated when the request is initiated, and is disarmed when the last byte of the
     * request is sent upstream (i.e. all decoding filters have processed the request), OR when the
     * response is initiated. If not specified or set to 0, this timeout is disabled.
     *
     * @generated from protobuf field: google.protobuf.Duration request_timeout = 28;
     */
    requestTimeout?: Duration;
    /**
     * The amount of time that Envoy will wait for the request headers to be received. The timer is
     * activated when the first byte of the headers is received, and is disarmed when the last byte of
     * the headers has been received. If not specified or set to 0, this timeout is disabled.
     *
     * @generated from protobuf field: google.protobuf.Duration request_headers_timeout = 41;
     */
    requestHeadersTimeout?: Duration;
    /**
     * The time that Envoy will wait between sending an HTTP/2 “shutdown
     * notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
     * This is used so that Envoy provides a grace period for new streams that
     * race with the final GOAWAY frame. During this grace period, Envoy will
     * continue to accept new streams. After the grace period, a final GOAWAY
     * frame is sent and Envoy will start refusing new streams. Draining occurs
     * both when a connection hits the idle timeout or during general server
     * draining. The default grace period is 5000 milliseconds (5 seconds) if this
     * option is not specified.
     *
     * @generated from protobuf field: google.protobuf.Duration drain_timeout = 12;
     */
    drainTimeout?: Duration;
    /**
     * The delayed close timeout is for downstream connections managed by the HTTP connection manager.
     * It is defined as a grace period after connection close processing has been locally initiated
     * during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
     * from the downstream connection) prior to Envoy closing the socket associated with that
     * connection.
     * NOTE: This timeout is enforced even when the socket associated with the downstream connection
     * is pending a flush of the write buffer. However, any progress made writing data to the socket
     * will restart the timer associated with this timeout. This means that the total grace period for
     * a socket in this state will be
     * <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
     *
     * Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
     * sequence mitigates a race condition that exists when downstream clients do not drain/process
     * data in a connection's receive buffer after a remote close has been detected via a socket
     * write(). This race leads to such clients failing to process the response code sent by Envoy,
     * which could result in erroneous downstream processing.
     *
     * If the timeout triggers, Envoy will close the connection's socket.
     *
     * The default timeout is 1000 ms if this option is not specified.
     *
     * .. NOTE::
     *    To be useful in avoiding the race condition described above, this timeout must be set
     *    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
     *    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
     *
     * .. WARNING::
     *    A value of 0 will completely disable delayed close processing. When disabled, the downstream
     *    connection's socket will be closed immediately after the write flush is completed or will
     *    never close if the write flush does not complete.
     *
     * @generated from protobuf field: google.protobuf.Duration delayed_close_timeout = 26;
     */
    delayedCloseTimeout?: Duration;
    /**
     * Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
     * emitted by the connection manager.
     *
     * @generated from protobuf field: repeated envoy.config.accesslog.v3.AccessLog access_log = 13;
     */
    accessLog: AccessLog[];
    /**
     * .. attention::
     * This field is deprecated in favor of
     * :ref:`access_log_flush_interval
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`.
     * Note that if both this field and :ref:`access_log_flush_interval
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.access_log_flush_interval>`
     * are specified, the former (deprecated field) is ignored.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.Duration access_log_flush_interval = 54 [deprecated = true];
     */
    accessLogFlushInterval?: Duration;
    /**
     * .. attention::
     * This field is deprecated in favor of
     * :ref:`flush_access_log_on_new_request
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`.
     * Note that if both this field and :ref:`flush_access_log_on_new_request
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions.flush_access_log_on_new_request>`
     * are specified, the former (deprecated field) is ignored.
     *
     * @deprecated
     * @generated from protobuf field: bool flush_access_log_on_new_request = 55 [deprecated = true];
     */
    flushAccessLogOnNewRequest: boolean;
    /**
     * Additional access log options for HTTP connection manager.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions access_log_options = 56;
     */
    accessLogOptions?: HttpConnectionManager_HcmAccessLogOptions;
    /**
     * If set to true, the connection manager will use the real remote address
     * of the client connection when determining internal versus external origin and manipulating
     * various headers. If set to false or absent, the connection manager will use the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for`,
     * :ref:`config_http_conn_man_headers_x-envoy-internal`, and
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
     *
     * @generated from protobuf field: google.protobuf.BoolValue use_remote_address = 14;
     */
    useRemoteAddress?: BoolValue;
    /**
     * The number of additional ingress proxy hops from the right side of the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
     * determining the origin client's IP address. The default is zero if this option
     * is not specified. See the documentation for
     * :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
     *
     * @generated from protobuf field: uint32 xff_num_trusted_hops = 19;
     */
    xffNumTrustedHops: number;
    /**
     * The configuration for the original IP detection extensions.
     *
     * When configured the extensions will be called along with the request headers
     * and information about the downstream connection, such as the directly connected address.
     * Each extension will then use these parameters to decide the request's effective remote address.
     * If an extension fails to detect the original IP address and isn't configured to reject
     * the request, the HCM will try the remaining extensions until one succeeds or rejects
     * the request. If the request isn't rejected nor any extension succeeds, the HCM will
     * fallback to using the remote address.
     *
     * .. WARNING::
     *    Extensions cannot be used in conjunction with :ref:`use_remote_address
     *    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
     *    nor :ref:`xff_num_trusted_hops
     *    <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.xff_num_trusted_hops>`.
     *
     * [#extension-category: envoy.http.original_ip_detection]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46;
     */
    originalIpDetectionExtensions: TypedExtensionConfig[];
    /**
     * The configuration for the early header mutation extensions.
     *
     * When configured the extensions will be called before any routing, tracing, or any filter processing.
     * Each extension will be applied in the order they are configured.
     * If the same header is mutated by multiple extensions, then the last extension will win.
     *
     * [#extension-category: envoy.http.early_header_mutation]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52;
     */
    earlyHeaderMutationExtensions: TypedExtensionConfig[];
    /**
     * Configures what network addresses are considered internal for stats and header sanitation
     * purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
     * See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
     * information about internal/external addresses.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25;
     */
    internalAddressConfig?: HttpConnectionManager_InternalAddressConfig;
    /**
     * If set, Envoy will not append the remote address to the
     * :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
     * conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
     * has mutated the request headers. While :ref:`use_remote_address
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
     * will also suppress XFF addition, it has consequences for logging and other
     * Envoy uses of the remote address, so ``skip_xff_append`` should be used
     * when only an elision of XFF addition is intended.
     *
     * @generated from protobuf field: bool skip_xff_append = 21;
     */
    skipXffAppend: boolean;
    /**
     * Via header value to append to request and response headers. If this is
     * empty, no via header will be appended.
     *
     * @generated from protobuf field: string via = 22;
     */
    via: string;
    /**
     * Whether the connection manager will generate the :ref:`x-request-id
     * <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
     * true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
     * is not desired it can be disabled.
     *
     * @generated from protobuf field: google.protobuf.BoolValue generate_request_id = 15;
     */
    generateRequestId?: BoolValue;
    /**
     * Whether the connection manager will keep the :ref:`x-request-id
     * <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
     * (Edge request is the request from external clients to front Envoy) and not reset it, which
     * is the current Envoy behaviour. This defaults to false.
     *
     * @generated from protobuf field: bool preserve_external_request_id = 32;
     */
    preserveExternalRequestId: boolean;
    /**
     * If set, Envoy will always set :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` header in response.
     * If this is false or not set, the request ID is returned in responses only if tracing is forced using
     * :ref:`x-envoy-force-trace <config_http_conn_man_headers_x-envoy-force-trace>` header.
     *
     * @generated from protobuf field: bool always_set_request_id_in_response = 37;
     */
    alwaysSetRequestIdInResponse: boolean;
    /**
     * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
     * header.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16;
     */
    forwardClientCertDetails: HttpConnectionManager_ForwardClientCertDetails;
    /**
     * This field is valid only when :ref:`forward_client_cert_details
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.forward_client_cert_details>`
     * is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
     * the client certificate to be forwarded. Note that in the
     * :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, ``Hash`` is always set, and
     * ``By`` is always set when the client certificate presents the URI type Subject Alternative Name
     * value.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17;
     */
    setCurrentClientCertDetails?: HttpConnectionManager_SetCurrentClientCertDetails;
    /**
     * If proxy_100_continue is true, Envoy will proxy incoming "Expect:
     * 100-continue" headers upstream, and forward "100 Continue" responses
     * downstream. If this is false or not set, Envoy will instead strip the
     * "Expect: 100-continue" header, and send a "100 Continue" response itself.
     *
     * @generated from protobuf field: bool proxy_100_continue = 18;
     */
    proxy100Continue: boolean;
    /**
     * If
     * :ref:`use_remote_address
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.use_remote_address>`
     * is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
     * an IPv4 address, the address will be mapped to IPv6 before it is appended to ``x-forwarded-for``.
     * This is useful for testing compatibility of upstream services that parse the header value. For
     * example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
     * <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
     * :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
     * :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
     * <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
     * control.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20;
     */
    representIpv4RemoteAddressAsIpv4MappedIpv6: boolean;
    /**
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23;
     */
    upgradeConfigs: HttpConnectionManager_UpgradeConfig[];
    /**
     * Should paths be normalized according to RFC 3986 before any processing of
     * requests by HTTP filters or routing? This affects the upstream ``:path`` header
     * as well. For paths that fail this check, Envoy will respond with 400 to
     * paths that are malformed. This defaults to false currently but will default
     * true in the future. When not specified, this value may be overridden by the
     * runtime variable
     * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
     * See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`_
     * for details of normalization.
     * Note that Envoy does not perform
     * `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`_
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
     * is present.]
     *
     * @generated from protobuf field: google.protobuf.BoolValue normalize_path = 30;
     */
    normalizePath?: BoolValue;
    /**
     * Determines if adjacent slashes in the path are merged into one before any processing of
     * requests by HTTP filters or routing. This affects the upstream ``:path`` header as well. Without
     * setting this option, incoming requests with path ``//dir///file`` will not match against route
     * with ``prefix`` match set to ``/dir``. Defaults to ``false``. Note that slash merging is not part of
     * `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
     * is present.]
     *
     * @generated from protobuf field: bool merge_slashes = 33;
     */
    mergeSlashes: boolean;
    /**
     * Action to take when request URL path contains escaped slash sequences (%2F, %2f, %5C and %5c).
     * The default value can be overridden by the :ref:`http_connection_manager.path_with_escaped_slashes_action<config_http_conn_man_runtime_path_with_escaped_slashes_action>`
     * runtime variable.
     * The :ref:`http_connection_manager.path_with_escaped_slashes_action_sampling<config_http_conn_man_runtime_path_with_escaped_slashes_action_enabled>` runtime
     * variable can be used to apply the action to a portion of all requests.
     * [#comment:TODO: This field is ignored when the
     * :ref:`header validation configuration <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.typed_header_validation_config>`
     * is present.]
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45;
     */
    pathWithEscapedSlashesAction: HttpConnectionManager_PathWithEscapedSlashesAction;
    /**
     * The configuration of the request ID extension. This includes operations such as
     * generation, validation, and associated tracing operations. If empty, the
     * :ref:`UuidRequestIdConfig <envoy_v3_api_msg_extensions.request_id.uuid.v3.UuidRequestIdConfig>`
     * default extension is used with default parameters. See the documentation for that extension
     * for details on what it does. Customizing the configuration for the default extension can be
     * achieved by configuring it explicitly here. For example, to disable trace reason packing,
     * the following configuration can be used:
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
     *
     *   typed_config:
     *     "@type": type.googleapis.com/envoy.extensions.request_id.uuid.v3.UuidRequestIdConfig
     *     pack_trace_reason: false
     *
     * [#extension-category: envoy.request_id]
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36;
     */
    requestIdExtension?: RequestIDExtension;
    /**
     * The configuration to customize local reply returned by Envoy. It can customize status code,
     * body text and response content type. If not specified, status code and text body are hard
     * coded in Envoy, the response content type is plain text.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38;
     */
    localReplyConfig?: LocalReplyConfig;
    /**
     * Determines if the port part should be removed from host/authority header before any processing
     * of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's<envoy_v3_api_field_config.listener.v3.Listener.address>`
     * local port. This affects the upstream host header unless the method is
     * CONNECT in which case if no filter adds a port the original port will be restored before headers are
     * sent upstream.
     * Without setting this option, incoming requests with host ``example:443`` will not match against
     * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
     * of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
     * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
     *
     * @generated from protobuf field: bool strip_matching_host_port = 39;
     */
    stripMatchingHostPort: boolean;
    /**
     * @generated from protobuf oneof: strip_port_mode
     */
    stripPortMode: {
        oneofKind: "stripAnyHostPort";
        /**
         * Determines if the port part should be removed from host/authority header before any processing
         * of request by HTTP filters or routing.
         * This affects the upstream host header unless the method is CONNECT in
         * which case if no filter adds a port the original port will be restored before headers are sent upstream.
         * Without setting this option, incoming requests with host ``example:443`` will not match against
         * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example``. Defaults to ``false``. Note that port removal is not part
         * of `HTTP spec <https://tools.ietf.org/html/rfc3986>`_ and is provided for convenience.
         * Only one of ``strip_matching_host_port`` or ``strip_any_host_port`` can be set.
         *
         * @generated from protobuf field: bool strip_any_host_port = 42;
         */
        stripAnyHostPort: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * Governs Envoy's behavior when receiving invalid HTTP from downstream.
     * If this option is false (default), Envoy will err on the conservative side handling HTTP
     * errors, terminating both HTTP/1.1 and HTTP/2 connections when receiving an invalid request.
     * If this option is set to true, Envoy will be more permissive, only resetting the invalid
     * stream in the case of HTTP/2 and leaving the connection open where possible (if the entire
     * request is read for HTTP/1.1)
     * In general this should be true for deployments receiving trusted traffic (L2 Envoys,
     * company-internal mesh) and false when receiving untrusted traffic (edge deployments).
     *
     * If different behaviors for invalid_http_message for HTTP/1 and HTTP/2 are
     * desired, one should use the new HTTP/1 option :ref:`override_stream_error_on_invalid_http_message
     * <envoy_v3_api_field_config.core.v3.Http1ProtocolOptions.override_stream_error_on_invalid_http_message>` or the new HTTP/2 option
     * :ref:`override_stream_error_on_invalid_http_message
     * <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
     * ``not`` the deprecated but similarly named :ref:`stream_error_on_invalid_http_messaging
     * <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.stream_error_on_invalid_http_messaging>`
     *
     * @generated from protobuf field: google.protobuf.BoolValue stream_error_on_invalid_http_message = 40;
     */
    streamErrorOnInvalidHttpMessage?: BoolValue;
    /**
     * [#not-implemented-hide:] Path normalization configuration. This includes
     * configurations for transformations (e.g. RFC 3986 normalization or merge
     * adjacent slashes) and the policy to apply them. The policy determines
     * whether transformations affect the forwarded ``:path`` header. RFC 3986 path
     * normalization is enabled by default and the default policy is that the
     * normalized header will be forwarded. See :ref:`PathNormalizationOptions
     * <envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.PathNormalizationOptions>`
     * for details.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43;
     */
    pathNormalizationOptions?: HttpConnectionManager_PathNormalizationOptions;
    /**
     * Determines if trailing dot of the host should be removed from host/authority header before any
     * processing of request by HTTP filters or routing.
     * This affects the upstream host header.
     * Without setting this option, incoming requests with host ``example.com.`` will not match against
     * route with :ref:`domains<envoy_v3_api_field_config.route.v3.VirtualHost.domains>` match set to ``example.com``. Defaults to ``false``.
     * When the incoming request contains a host/authority header that includes a port number,
     * setting this option will strip a trailing dot, if present, from the host section,
     * leaving the port as is (e.g. host value ``example.com.:443`` will be updated to ``example.com:443``).
     *
     * @generated from protobuf field: bool strip_trailing_host_dot = 47;
     */
    stripTrailingHostDot: boolean;
    /**
     * Proxy-Status HTTP response header configuration.
     * If this config is set, the Proxy-Status HTTP response header field is
     * populated. By default, it is not.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49;
     */
    proxyStatusConfig?: HttpConnectionManager_ProxyStatusConfig;
    /**
     * Configuration options for Header Validation (UHV).
     * UHV is an extensible mechanism for checking validity of HTTP requests as well as providing
     * normalization for request attributes, such as URI path.
     * If the typed_header_validation_config is present it overrides the following options:
     * ``normalize_path``, ``merge_slashes``, ``path_with_escaped_slashes_action``
     * ``http_protocol_options.allow_chunked_length``, ``common_http_protocol_options.headers_with_underscores_action``.
     *
     * The default UHV checks the following:
     *
     * #. HTTP/1 header map validity according to `RFC 7230 section 3.2<https://datatracker.ietf.org/doc/html/rfc7230#section-3.2>`_
     * #. Syntax of HTTP/1 request target URI and response status
     * #. HTTP/2 header map validity according to `RFC 7540 section 8.1.2<https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2`_
     * #. Syntax of HTTP/2 pseudo headers
     * #. HTTP/3 header map validity according to `RFC 9114 section 4.3 <https://www.rfc-editor.org/rfc/rfc9114.html>`_
     * #. Syntax of HTTP/3 pseudo headers
     * #. Syntax of ``Content-Length`` and ``Transfer-Encoding``
     * #. Validation of HTTP/1 requests with both ``Content-Length`` and ``Transfer-Encoding`` headers
     * #. Normalization of the URI path according to `Normalization and Comparison <https://datatracker.ietf.org/doc/html/rfc3986#section-6>`_
     *    without `case normalization <https://datatracker.ietf.org/doc/html/rfc3986#section-6.2.2.1>`_
     *
     * [#not-implemented-hide:]
     * [#extension-category: envoy.http.header_validators]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50;
     */
    typedHeaderValidationConfig?: TypedExtensionConfig;
    /**
     * Append the `x-forwarded-port` header with the port value client used to connect to Envoy. It
     * will be ignored if the `x-forwarded-port` header has been set by any trusted proxy in front of Envoy.
     *
     * @generated from protobuf field: bool append_x_forwarded_port = 51;
     */
    appendXForwardedPort: boolean;
    /**
     * Whether the HCM will add ProxyProtocolFilterState to the Connection lifetime filter state. Defaults to `true`.
     * This should be set to `false` in cases where Envoy's view of the downstream address may not correspond to the
     * actual client address, for example, if there's another proxy in front of the Envoy.
     *
     * @generated from protobuf field: google.protobuf.BoolValue add_proxy_protocol_connection_state = 53;
     */
    addProxyProtocolConnectionState?: BoolValue;
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing
 */
export interface HttpConnectionManager_Tracing {
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
     * <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.Percent client_sampling = 3;
     */
    clientSampling?: Percent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.Percent random_sampling = 4;
     */
    randomSampling?: Percent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.Percent overall_sampling = 5;
     */
    overallSampling?: Percent;
    /**
     * Whether to annotate spans with additional data. If true, spans will include logs for stream
     * events.
     *
     * @generated from protobuf field: bool verbose = 6;
     */
    verbose: boolean;
    /**
     * Maximum length of the request path to extract and include in the HttpUrl tag. Used to
     * truncate lengthy request paths to meet the needs of a tracing backend.
     * Default: 256
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_path_tag_length = 7;
     */
    maxPathTagLength?: UInt32Value;
    /**
     * A list of custom tags with unique tag name to create tags for the active span.
     *
     * @generated from protobuf field: repeated envoy.type.tracing.v3.CustomTag custom_tags = 8;
     */
    customTags: CustomTag[];
    /**
     * Configuration for an external tracing provider.
     * If not specified, no tracing will be performed.
     *
     * .. attention::
     *   Please be aware that ``envoy.tracers.opencensus`` provider can only be configured once
     *   in Envoy lifetime.
     *   Any attempts to reconfigure it or to use different configurations for different HCM filters
     *   will be rejected.
     *   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
     *   on OpenCensus side.
     *
     * @generated from protobuf field: envoy.config.trace.v3.Tracing.Http provider = 9;
     */
    provider?: Tracing_Http;
}
/**
 * @generated from protobuf enum envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.OperationName
 */
export enum HttpConnectionManager_Tracing_OperationName {
    /**
     * The HTTP listener is used for ingress/incoming requests.
     *
     * @generated from protobuf enum value: INGRESS = 0;
     */
    INGRESS = 0,
    /**
     * The HTTP listener is used for egress/outgoing requests.
     *
     * @generated from protobuf enum value: EGRESS = 1;
     */
    EGRESS = 1
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig
 */
export interface HttpConnectionManager_InternalAddressConfig {
    /**
     * Whether unix socket addresses should be considered internal.
     *
     * @generated from protobuf field: bool unix_sockets = 1;
     */
    unixSockets: boolean;
    /**
     * List of CIDR ranges that are treated as internal. If unset, then RFC1918 / RFC4193
     * IP addresses will be considered internal.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange cidr_ranges = 2;
     */
    cidrRanges: CidrRange[];
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails
 */
export interface HttpConnectionManager_SetCurrentClientCertDetails {
    /**
     * Whether to forward the subject of the client cert. Defaults to false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue subject = 1;
     */
    subject?: BoolValue;
    /**
     * Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
     * XFCC header comma separated from other values with the value Cert="PEM".
     * Defaults to false.
     *
     * @generated from protobuf field: bool cert = 3;
     */
    cert: boolean;
    /**
     * Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
     * format. This will appear in the XFCC header comma separated from other values with the value
     * Chain="PEM".
     * Defaults to false.
     *
     * @generated from protobuf field: bool chain = 6;
     */
    chain: boolean;
    /**
     * Whether to forward the DNS type Subject Alternative Names of the client cert.
     * Defaults to false.
     *
     * @generated from protobuf field: bool dns = 4;
     */
    dns: boolean;
    /**
     * Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
     * false.
     *
     * @generated from protobuf field: bool uri = 5;
     */
    uri: boolean;
}
/**
 * The configuration for HTTP upgrades.
 * For each upgrade type desired, an UpgradeConfig must be added.
 *
 * .. warning::
 *
 *    The current implementation of upgrade headers does not handle
 *    multi-valued upgrade headers. Support for multi-valued headers may be
 *    added in the future if needed.
 *
 * .. warning::
 *    The current implementation of upgrade headers does not work with HTTP/2
 *    upstreams.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig
 */
export interface HttpConnectionManager_UpgradeConfig {
    /**
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type]
     * will be proxied upstream.
     *
     * @generated from protobuf field: string upgrade_type = 1;
     */
    upgradeType: string;
    /**
     * If present, this represents the filter chain which will be created for
     * this type of upgrade. If no filters are present, the filter chain for
     * HTTP connections will be used for this upgrade type.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2;
     */
    filters: HttpFilter[];
    /**
     * Determines if upgrades are enabled or disabled by default. Defaults to true.
     * This can be overridden on a per-route basis with :ref:`cluster
     * <envoy_v3_api_field_config.route.v3.RouteAction.upgrade_configs>` as documented in the
     * :ref:`upgrade documentation <arch_overview_upgrades>`.
     *
     * @generated from protobuf field: google.protobuf.BoolValue enabled = 3;
     */
    enabled?: BoolValue;
}
/**
 * [#not-implemented-hide:] Transformations that apply to path headers. Transformations are applied
 * before any processing of requests by HTTP filters, routing, and matching. Only the normalized
 * path will be visible internally if a transformation is enabled. Any path rewrites that the
 * router performs (e.g. :ref:`regex_rewrite
 * <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>` or :ref:`prefix_rewrite
 * <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`) will apply to the ``:path`` header
 * destined for the upstream.
 *
 * Note: access logging and tracing will show the original ``:path`` header.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions
 */
export interface HttpConnectionManager_PathNormalizationOptions {
    /**
     * [#not-implemented-hide:] Normalization applies internally before any processing of requests by
     * HTTP filters, routing, and matching *and* will affect the forwarded ``:path`` header. Defaults
     * to :ref:`NormalizePathRFC3986
     * <envoy_v3_api_msg_type.http.v3.PathTransformation.Operation.NormalizePathRFC3986>`. When not
     * specified, this value may be overridden by the runtime variable
     * :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
     * Envoy will respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     *
     * @generated from protobuf field: envoy.type.http.v3.PathTransformation forwarding_transformation = 1;
     */
    forwardingTransformation?: PathTransformation;
    /**
     * [#not-implemented-hide:] Normalization only applies internally before any processing of
     * requests by HTTP filters, routing, and matching. These will be applied after full
     * transformation is applied. The ``:path`` header before this transformation will be restored in
     * the router filter and sent upstream unless it was mutated by a filter. Defaults to no
     * transformations.
     * Multiple actions can be applied in the same Transformation, forming a sequential
     * pipeline. The transformations will be performed in the order that they appear. Envoy will
     * respond with 400 to paths that are malformed (e.g. for paths that fail RFC 3986
     * normalization due to disallowed characters.)
     *
     * @generated from protobuf field: envoy.type.http.v3.PathTransformation http_filter_transformation = 2;
     */
    httpFilterTransformation?: PathTransformation;
}
/**
 * Configures the manner in which the Proxy-Status HTTP response header is
 * populated.
 *
 * See the [Proxy-Status
 * RFC](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-proxy-status-08).
 * [#comment:TODO: Update this with the non-draft URL when finalized.]
 *
 * The Proxy-Status header is a string of the form:
 *
 *   "<server_name>; error=<error_type>; details=<details>"
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig
 */
export interface HttpConnectionManager_ProxyStatusConfig {
    /**
     * If true, the details field of the Proxy-Status header is not populated with stream_info.response_code_details.
     * This value defaults to ``false``, i.e. the ``details`` field is populated by default.
     *
     * @generated from protobuf field: bool remove_details = 1;
     */
    removeDetails: boolean;
    /**
     * If true, the details field of the Proxy-Status header will not contain
     * connection termination details. This value defaults to ``false``, i.e. the
     * ``details`` field will contain connection termination details by default.
     *
     * @generated from protobuf field: bool remove_connection_termination_details = 2;
     */
    removeConnectionTerminationDetails: boolean;
    /**
     * If true, the details field of the Proxy-Status header will not contain an
     * enumeration of the Envoy ResponseFlags. This value defaults to ``false``,
     * i.e. the ``details`` field will contain a list of ResponseFlags by default.
     *
     * @generated from protobuf field: bool remove_response_flags = 3;
     */
    removeResponseFlags: boolean;
    /**
     * If true, overwrites the existing Status header with the response code
     * recommended by the Proxy-Status spec.
     * This value defaults to ``false``, i.e. the HTTP response code is not
     * overwritten.
     *
     * @generated from protobuf field: bool set_recommended_response_code = 4;
     */
    setRecommendedResponseCode: boolean;
    /**
     * @generated from protobuf oneof: proxy_name
     */
    proxyName: {
        oneofKind: "useNodeId";
        /**
         * If ``use_node_id`` is set, Proxy-Status headers will use the Envoy's node
         * ID as the name of the proxy.
         *
         * @generated from protobuf field: bool use_node_id = 5;
         */
        useNodeId: boolean;
    } | {
        oneofKind: "literalProxyName";
        /**
         * If ``literal_proxy_name`` is set, Proxy-Status headers will use this
         * value as the name of the proxy.
         *
         * @generated from protobuf field: string literal_proxy_name = 6;
         */
        literalProxyName: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions
 */
export interface HttpConnectionManager_HcmAccessLogOptions {
    /**
     * The interval to flush the above access logs. By default, the HCM will flush exactly one access log
     * on stream close, when the HTTP request is complete. If this field is set, the HCM will flush access
     * logs periodically at the specified interval. This is especially useful in the case of long-lived
     * requests, such as CONNECT and Websockets. Final access logs can be detected via the
     * `requestComplete()` method of `StreamInfo` in access log filters, or thru the `%DURATION%` substitution
     * string.
     * The interval must be at least 1 millisecond.
     *
     * @generated from protobuf field: google.protobuf.Duration access_log_flush_interval = 1;
     */
    accessLogFlushInterval?: Duration;
    /**
     * If set to true, HCM will flush an access log when a new HTTP request is received, after request
     * headers have been evaluated, before iterating through the HTTP filter chain.
     * This log record, if enabled, does not depend on periodic log records or request completion log.
     * Details related to upstream cluster, such as upstream host, will not be available for this log.
     *
     * @generated from protobuf field: bool flush_access_log_on_new_request = 2;
     */
    flushAccessLogOnNewRequest: boolean;
    /**
     * If true, the HCM will flush an access log when a tunnel is successfully established. For example,
     * this could be when an upstream has successfully returned 101 Switching Protocols, or when the proxy
     * has returned 200 to a CONNECT request.
     *
     * @generated from protobuf field: bool flush_log_on_tunnel_successfully_established = 3;
     */
    flushLogOnTunnelSuccessfullyEstablished: boolean;
}
/**
 * @generated from protobuf enum envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType
 */
export enum HttpConnectionManager_CodecType {
    /**
     * For every new connection, the connection manager will determine which
     * codec to use. This mode supports both ALPN for TLS listeners as well as
     * protocol inference for plaintext listeners. If ALPN data is available, it
     * is preferred, otherwise protocol inference is used. In almost all cases,
     * this is the right option to choose for this setting.
     *
     * @generated from protobuf enum value: AUTO = 0;
     */
    AUTO = 0,
    /**
     * The connection manager will assume that the client is speaking HTTP/1.1.
     *
     * @generated from protobuf enum value: HTTP1 = 1;
     */
    HTTP1 = 1,
    /**
     * The connection manager will assume that the client is speaking HTTP/2
     * (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
     * Prior knowledge is allowed).
     *
     * @generated from protobuf enum value: HTTP2 = 2;
     */
    HTTP2 = 2,
    /**
     * [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
     * caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
     * to distinguish HTTP1 and HTTP2 traffic.
     *
     * @generated from protobuf enum value: HTTP3 = 3;
     */
    HTTP3 = 3
}
/**
 * @generated from protobuf enum envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation
 */
export enum HttpConnectionManager_ServerHeaderTransformation {
    /**
     * Overwrite any Server header with the contents of server_name.
     *
     * @generated from protobuf enum value: OVERWRITE = 0;
     */
    OVERWRITE = 0,
    /**
     * If no Server header is present, append Server server_name
     * If a Server header is present, pass it through.
     *
     * @generated from protobuf enum value: APPEND_IF_ABSENT = 1;
     */
    APPEND_IF_ABSENT = 1,
    /**
     * Pass through the value of the server header, and do not append a header
     * if none is present.
     *
     * @generated from protobuf enum value: PASS_THROUGH = 2;
     */
    PASS_THROUGH = 2
}
/**
 * How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
 * header.
 *
 * @generated from protobuf enum envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails
 */
export enum HttpConnectionManager_ForwardClientCertDetails {
    /**
     * Do not send the XFCC header to the next hop. This is the default value.
     *
     * @generated from protobuf enum value: SANITIZE = 0;
     */
    SANITIZE = 0,
    /**
     * When the client connection is mTLS (Mutual TLS), forward the XFCC header
     * in the request.
     *
     * @generated from protobuf enum value: FORWARD_ONLY = 1;
     */
    FORWARD_ONLY = 1,
    /**
     * When the client connection is mTLS, append the client certificate
     * information to the request’s XFCC header and forward it.
     *
     * @generated from protobuf enum value: APPEND_FORWARD = 2;
     */
    APPEND_FORWARD = 2,
    /**
     * When the client connection is mTLS, reset the XFCC header with the client
     * certificate information and send it to the next hop.
     *
     * @generated from protobuf enum value: SANITIZE_SET = 3;
     */
    SANITIZE_SET = 3,
    /**
     * Always forward the XFCC header in the request, regardless of whether the
     * client connection is mTLS.
     *
     * @generated from protobuf enum value: ALWAYS_FORWARD_ONLY = 4;
     */
    ALWAYS_FORWARD_ONLY = 4
}
/**
 * Determines the action for request that contain %2F, %2f, %5C or %5c sequences in the URI path.
 * This operation occurs before URL normalization and the merge slashes transformations if they were enabled.
 *
 * @generated from protobuf enum envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction
 */
export enum HttpConnectionManager_PathWithEscapedSlashesAction {
    /**
     * Default behavior specific to implementation (i.e. Envoy) of this configuration option.
     * Envoy, by default, takes the KEEP_UNCHANGED action.
     * NOTE: the implementation may change the default behavior at-will.
     *
     * @generated from protobuf enum value: IMPLEMENTATION_SPECIFIC_DEFAULT = 0;
     */
    IMPLEMENTATION_SPECIFIC_DEFAULT = 0,
    /**
     * Keep escaped slashes.
     *
     * @generated from protobuf enum value: KEEP_UNCHANGED = 1;
     */
    KEEP_UNCHANGED = 1,
    /**
     * Reject client request with the 400 status. gRPC requests will be rejected with the INTERNAL (13) error code.
     * The "httpN.downstream_rq_failed_path_normalization" counter is incremented for each rejected request.
     *
     * @generated from protobuf enum value: REJECT_REQUEST = 2;
     */
    REJECT_REQUEST = 2,
    /**
     * Unescape %2F and %5C sequences and redirect request to the new path if these sequences were present.
     * Redirect occurs after path normalization and merge slashes transformations if they were configured.
     * NOTE: gRPC requests will be rejected with the INTERNAL (13) error code.
     * This option minimizes possibility of path confusion exploits by forcing request with unescaped slashes to
     * traverse all parties: downstream client, intermediate proxies, Envoy and upstream server.
     * The "httpN.downstream_rq_redirected_with_normalized_path" counter is incremented for each
     * redirected request.
     *
     * @generated from protobuf enum value: UNESCAPE_AND_REDIRECT = 3;
     */
    UNESCAPE_AND_REDIRECT = 3,
    /**
     * Unescape %2F and %5C sequences.
     * Note: this option should not be enabled if intermediaries perform path based access control as
     * it may lead to path confusion vulnerabilities.
     *
     * @generated from protobuf enum value: UNESCAPE_AND_FORWARD = 4;
     */
    UNESCAPE_AND_FORWARD = 4
}
/**
 * The configuration to customize local reply returned by Envoy.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig
 */
export interface LocalReplyConfig {
    /**
     * Configuration of list of mappers which allows to filter and change local response.
     * The mappers will be checked by the specified order until one is matched.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper mappers = 1;
     */
    mappers: ResponseMapper[];
    /**
     * The configuration to form response body from the :ref:`command operators <config_access_log_command_operators>`
     * and to specify response content type as one of: plain/text or application/json.
     *
     * Example one: "plain/text" ``body_format``.
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.config.core.v3.SubstitutionFormatString
     *
     *   text_format: "%LOCAL_REPLY_BODY%:%RESPONSE_CODE%:path=%REQ(:path)%\n"
     *
     * The following response body in "plain/text" format will be generated for a request with
     * local reply body of "upstream connection error", response_code=503 and path=/foo.
     *
     * .. code-block:: text
     *
     *   upstream connect error:503:path=/foo
     *
     * Example two: "application/json" ``body_format``.
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.config.core.v3.SubstitutionFormatString
     *
     *   json_format:
     *     status: "%RESPONSE_CODE%"
     *     message: "%LOCAL_REPLY_BODY%"
     *     path: "%REQ(:path)%"
     *
     * The following response body in "application/json" format would be generated for a request with
     * local reply body of "upstream connection error", response_code=503 and path=/foo.
     *
     * .. code-block:: json
     *
     *  {
     *    "status": 503,
     *    "message": "upstream connection error",
     *    "path": "/foo"
     *  }
     *
     *
     * @generated from protobuf field: envoy.config.core.v3.SubstitutionFormatString body_format = 2;
     */
    bodyFormat?: SubstitutionFormatString;
}
/**
 * The configuration to filter and change local response.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper
 */
export interface ResponseMapper {
    /**
     * Filter to determine if this mapper should apply.
     *
     * @generated from protobuf field: envoy.config.accesslog.v3.AccessLogFilter filter = 1;
     */
    filter?: AccessLogFilter;
    /**
     * The new response status code if specified.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value status_code = 2;
     */
    statusCode?: UInt32Value;
    /**
     * The new local reply body text if specified. It will be used in the ``%LOCAL_REPLY_BODY%``
     * command operator in the ``body_format``.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource body = 3;
     */
    body?: DataSource;
    /**
     * A per mapper ``body_format`` to override the :ref:`body_format <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.LocalReplyConfig.body_format>`.
     * It will be used when this mapper is matched.
     *
     * @generated from protobuf field: envoy.config.core.v3.SubstitutionFormatString body_format_override = 4;
     */
    bodyFormatOverride?: SubstitutionFormatString;
    /**
     * HTTP headers to add to a local reply. This allows the response mapper to append, to add
     * or to override headers of any local reply before it is sent to a downstream client.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 5;
     */
    headersToAdd: HeaderValueOption[];
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.Rds
 */
export interface Rds {
    /**
     * Configuration source specifier for RDS.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource config_source = 1;
     */
    configSource?: ConfigSource;
    /**
     * The name of the route configuration. This name will be passed to the RDS
     * API. This allows an Envoy configuration with multiple HTTP listeners (and
     * associated HTTP connection manager filters) to use different route
     * configurations.
     *
     * @generated from protobuf field: string route_config_name = 2;
     */
    routeConfigName: string;
}
/**
 * This message is used to work around the limitations with 'oneof' and repeated fields.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList
 */
export interface ScopedRouteConfigurationsList {
    /**
     * @generated from protobuf field: repeated envoy.config.route.v3.ScopedRouteConfiguration scoped_route_configurations = 1;
     */
    scopedRouteConfigurations: ScopedRouteConfiguration[];
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes
 */
export interface ScopedRoutes {
    /**
     * The name assigned to the scoped routing configuration.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The algorithm to use for constructing a scope key for each request.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder scope_key_builder = 2;
     */
    scopeKeyBuilder?: ScopedRoutes_ScopeKeyBuilder;
    /**
     * Configuration source specifier for RDS.
     * This config source is used to subscribe to RouteConfiguration resources specified in
     * ScopedRouteConfiguration messages.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource rds_config_source = 3;
     */
    rdsConfigSource?: ConfigSource;
    /**
     * @generated from protobuf oneof: config_specifier
     */
    configSpecifier: {
        oneofKind: "scopedRouteConfigurationsList";
        /**
         * The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
         * matching a key constructed from the request's attributes according to the algorithm specified
         * by the
         * :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
         * in this message.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList scoped_route_configurations_list = 4;
         */
        scopedRouteConfigurationsList: ScopedRouteConfigurationsList;
    } | {
        oneofKind: "scopedRds";
        /**
         * The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
         * API. A scope is assigned to a request by matching a key constructed from the request's
         * attributes according to the algorithm specified by the
         * :ref:`ScopeKeyBuilder<envoy_v3_api_msg_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder>`
         * in this message.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds scoped_rds = 5;
         */
        scopedRds: ScopedRds;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
 * keys are matched against a set of :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>`
 * objects assembled from :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`
 * messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
 * :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`.
 *
 * Upon receiving a request's headers, the Router will build a key using the algorithm specified
 * by this message. This key will be used to look up the routing table (i.e., the
 * :ref:`RouteConfiguration<envoy_v3_api_msg_config.route.v3.RouteConfiguration>`) to use for the request.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder
 */
export interface ScopedRoutes_ScopeKeyBuilder {
    /**
     * The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
     * fragments of a :ref:`ScopedRouteConfiguration<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration>`.
     * A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder fragments = 1;
     */
    fragments: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder[];
}
/**
 * Specifies the mechanism for constructing key fragments which are composed into scope keys.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder
 */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "headerValueExtractor";
        /**
         * Specifies how a header field's value should be extracted.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor header_value_extractor = 1;
         */
        headerValueExtractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies how the value of a header should be extracted.
 * The following example maps the structure of a header to the fields in this message.
 *
 * .. code::
 *
 *              <0> <1>   <-- index
 *    X-Header: a=b;c=d
 *    |         || |
 *    |         || \----> <element_separator>
 *    |         ||
 *    |         |\----> <element.separator>
 *    |         |
 *    |         \----> <element.key>
 *    |
 *    \----> <name>
 *
 *    Each 'a=b' key-value pair constitutes an 'element' of the header field.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor
 */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
    /**
     * The name of the header field to extract the value from.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The element separator (e.g., ';' separates 'a;b;c;d').
     * Default: empty string. This causes the entirety of the header field to be extracted.
     * If this field is set to an empty string and 'index' is used in the oneof below, 'index'
     * must be set to 0.
     *
     * @generated from protobuf field: string element_separator = 2;
     */
    elementSeparator: string;
    /**
     * @generated from protobuf oneof: extract_type
     */
    extractType: {
        oneofKind: "index";
        /**
         * Specifies the zero based index of the element to extract.
         * Note Envoy concatenates multiple values of the same header key into a comma separated
         * string, the splitting always happens after the concatenation.
         *
         * @generated from protobuf field: uint32 index = 3;
         */
        index: number;
    } | {
        oneofKind: "element";
        /**
         * Specifies the key value pair to extract the value from.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement element = 4;
         */
        element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies a header field's key value pair to match on.
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement
 */
export interface ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
    /**
     * The separator between key and value (e.g., '=' separates 'k=v;...').
     * If an element is an empty string, the element is ignored.
     * If an element contains no separator, the whole element is parsed as key and the
     * fragment value is an empty string.
     * If there are multiple values for a matched key, the first value is returned.
     *
     * @generated from protobuf field: string separator = 1;
     */
    separator: string;
    /**
     * The key to match on.
     *
     * @generated from protobuf field: string key = 2;
     */
    key: string;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds
 */
export interface ScopedRds {
    /**
     * Configuration source specifier for scoped RDS.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource scoped_rds_config_source = 1;
     */
    scopedRdsConfigSource?: ConfigSource;
    /**
     * xdstp:// resource locator for scoped RDS collection.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string srds_resources_locator = 2;
     */
    srdsResourcesLocator: string;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter
 */
export interface HttpFilter {
    /**
     * The name of the filter configuration. It also serves as a resource name in ExtensionConfigDS.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * Filter specific configuration which depends on the filter being instantiated. See the supported
         * filters for further documentation.
         *
         * To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
         * :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
         * with the desired HTTP filter.
         * [#extension-category: envoy.filters.http]
         *
         * @generated from protobuf field: google.protobuf.Any typed_config = 4;
         */
        typedConfig: Any;
    } | {
        oneofKind: "configDiscovery";
        /**
         * Configuration source specifier for an extension configuration discovery service.
         * In case of a failure and without the default configuration, the HTTP listener responds with code 500.
         * Extension configs delivered through this mechanism are not expected to require warming (see https://github.com/envoyproxy/envoy/issues/12061).
         *
         * To support configuring a :ref:`match tree <arch_overview_matching_api>`, use an
         * :ref:`ExtensionWithMatcher <envoy_v3_api_msg_extensions.common.matching.v3.ExtensionWithMatcher>`
         * with the desired HTTP filter. This works for both the default filter configuration as well
         * as for filters provided via the API.
         *
         * @generated from protobuf field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 5;
         */
        configDiscovery: ExtensionConfigSource;
    } | {
        oneofKind: undefined;
    };
    /**
     * If true, clients that do not support this filter may ignore the
     * filter but otherwise accept the config.
     * Otherwise, clients that do not support this filter must reject the config.
     *
     * @generated from protobuf field: bool is_optional = 6;
     */
    isOptional: boolean;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
 */
export interface RequestIDExtension {
    /**
     * Request ID extension specific configuration.
     *
     * @generated from protobuf field: google.protobuf.Any typed_config = 1;
     */
    typedConfig?: Any;
}
/**
 * [#protodoc-title: Envoy Mobile HTTP connection manager]
 * HTTP connection manager for use in Envoy mobile.
 * [#extension: envoy.filters.network.envoy_mobile_http_connection_manager]
 *
 * @generated from protobuf message envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager
 */
export interface EnvoyMobileHttpConnectionManager {
    /**
     * The configuration for the underlying HttpConnectionManager which will be
     * instantiated for Envoy mobile.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager config = 1;
     */
    config?: HttpConnectionManager;
}
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager$Type extends MessageType<HttpConnectionManager> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager", [
            { no: 1, name: "codec_type", kind: "enum", T: () => ["envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType", HttpConnectionManager_CodecType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "rds", kind: "message", oneof: "routeSpecifier", T: () => Rds },
            { no: 4, name: "route_config", kind: "message", oneof: "routeSpecifier", T: () => RouteConfiguration },
            { no: 31, name: "scoped_routes", kind: "message", oneof: "routeSpecifier", T: () => ScopedRoutes },
            { no: 5, name: "http_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpFilter },
            { no: 6, name: "add_user_agent", kind: "message", T: () => BoolValue },
            { no: 7, name: "tracing", kind: "message", T: () => HttpConnectionManager_Tracing },
            { no: 35, name: "common_http_protocol_options", kind: "message", T: () => HttpProtocolOptions, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 8, name: "http_protocol_options", kind: "message", T: () => Http1ProtocolOptions },
            { no: 9, name: "http2_protocol_options", kind: "message", T: () => Http2ProtocolOptions, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 44, name: "http3_protocol_options", kind: "message", T: () => Http3ProtocolOptions },
            { no: 10, name: "server_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 34, name: "server_header_transformation", kind: "enum", T: () => ["envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation", HttpConnectionManager_ServerHeaderTransformation], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 48, name: "scheme_header_transformation", kind: "message", T: () => SchemeHeaderTransformation },
            { no: 29, name: "max_request_headers_kb", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 8192, gt: 0 } } } },
            { no: 24, name: "stream_idle_timeout", kind: "message", T: () => Duration, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 28, name: "request_timeout", kind: "message", T: () => Duration, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 41, name: "request_headers_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: {} } }, "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 12, name: "drain_timeout", kind: "message", T: () => Duration },
            { no: 26, name: "delayed_close_timeout", kind: "message", T: () => Duration },
            { no: 13, name: "access_log", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLog },
            { no: 54, name: "access_log_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } }, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 55, name: "flush_access_log_on_new_request", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 56, name: "access_log_options", kind: "message", T: () => HttpConnectionManager_HcmAccessLogOptions },
            { no: 14, name: "use_remote_address", kind: "message", T: () => BoolValue, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true } } },
            { no: 19, name: "xff_num_trusted_hops", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 46, name: "original_ip_detection_extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 52, name: "early_header_mutation_extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 25, name: "internal_address_config", kind: "message", T: () => HttpConnectionManager_InternalAddressConfig },
            { no: 21, name: "skip_xff_append", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "via", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 15, name: "generate_request_id", kind: "message", T: () => BoolValue },
            { no: 32, name: "preserve_external_request_id", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 37, name: "always_set_request_id_in_response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "forward_client_cert_details", kind: "enum", T: () => ["envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails", HttpConnectionManager_ForwardClientCertDetails], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 17, name: "set_current_client_cert_details", kind: "message", T: () => HttpConnectionManager_SetCurrentClientCertDetails },
            { no: 18, name: "proxy_100_continue", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 20, name: "represent_ipv4_remote_address_as_ipv4_mapped_ipv6", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "upgrade_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpConnectionManager_UpgradeConfig },
            { no: 30, name: "normalize_path", kind: "message", T: () => BoolValue },
            { no: 33, name: "merge_slashes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 45, name: "path_with_escaped_slashes_action", kind: "enum", T: () => ["envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction", HttpConnectionManager_PathWithEscapedSlashesAction] },
            { no: 36, name: "request_id_extension", kind: "message", T: () => RequestIDExtension },
            { no: 38, name: "local_reply_config", kind: "message", T: () => LocalReplyConfig },
            { no: 39, name: "strip_matching_host_port", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "udpa.annotations.field_migrate": { oneofPromotion: "strip_port_mode" } } },
            { no: 42, name: "strip_any_host_port", kind: "scalar", oneof: "stripPortMode", T: 8 /*ScalarType.BOOL*/ },
            { no: 40, name: "stream_error_on_invalid_http_message", kind: "message", T: () => BoolValue },
            { no: 43, name: "path_normalization_options", kind: "message", T: () => HttpConnectionManager_PathNormalizationOptions },
            { no: 47, name: "strip_trailing_host_dot", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 49, name: "proxy_status_config", kind: "message", T: () => HttpConnectionManager_ProxyStatusConfig },
            { no: 50, name: "typed_header_validation_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 51, name: "append_x_forwarded_port", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 53, name: "add_proxy_protocol_connection_state", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager" } });
    }
    create(value?: PartialMessage<HttpConnectionManager>): HttpConnectionManager {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.codecType = 0;
        message.statPrefix = "";
        message.routeSpecifier = { oneofKind: undefined };
        message.httpFilters = [];
        message.serverName = "";
        message.serverHeaderTransformation = 0;
        message.accessLog = [];
        message.flushAccessLogOnNewRequest = false;
        message.xffNumTrustedHops = 0;
        message.originalIpDetectionExtensions = [];
        message.earlyHeaderMutationExtensions = [];
        message.skipXffAppend = false;
        message.via = "";
        message.preserveExternalRequestId = false;
        message.alwaysSetRequestIdInResponse = false;
        message.forwardClientCertDetails = 0;
        message.proxy100Continue = false;
        message.representIpv4RemoteAddressAsIpv4MappedIpv6 = false;
        message.upgradeConfigs = [];
        message.mergeSlashes = false;
        message.pathWithEscapedSlashesAction = 0;
        message.stripMatchingHostPort = false;
        message.stripPortMode = { oneofKind: undefined };
        message.stripTrailingHostDot = false;
        message.appendXForwardedPort = false;
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager): HttpConnectionManager {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type */ 1:
                    message.codecType = reader.int32();
                    break;
                case /* string stat_prefix */ 2:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.Rds rds */ 3:
                    message.routeSpecifier = {
                        oneofKind: "rds",
                        rds: Rds.internalBinaryRead(reader, reader.uint32(), options, (message.routeSpecifier as any).rds)
                    };
                    break;
                case /* envoy.config.route.v3.RouteConfiguration route_config */ 4:
                    message.routeSpecifier = {
                        oneofKind: "routeConfig",
                        routeConfig: RouteConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.routeSpecifier as any).routeConfig)
                    };
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes */ 31:
                    message.routeSpecifier = {
                        oneofKind: "scopedRoutes",
                        scopedRoutes: ScopedRoutes.internalBinaryRead(reader, reader.uint32(), options, (message.routeSpecifier as any).scopedRoutes)
                    };
                    break;
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters */ 5:
                    message.httpFilters.push(HttpFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue add_user_agent */ 6:
                    message.addUserAgent = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.addUserAgent);
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing */ 7:
                    message.tracing = HttpConnectionManager_Tracing.internalBinaryRead(reader, reader.uint32(), options, message.tracing);
                    break;
                case /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options */ 35:
                    message.commonHttpProtocolOptions = HttpProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.commonHttpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options */ 8:
                    message.httpProtocolOptions = Http1ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.httpProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options */ 9:
                    message.http2ProtocolOptions = Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http2ProtocolOptions);
                    break;
                case /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options */ 44:
                    message.http3ProtocolOptions = Http3ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http3ProtocolOptions);
                    break;
                case /* string server_name */ 10:
                    message.serverName = reader.string();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation */ 34:
                    message.serverHeaderTransformation = reader.int32();
                    break;
                case /* envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation */ 48:
                    message.schemeHeaderTransformation = SchemeHeaderTransformation.internalBinaryRead(reader, reader.uint32(), options, message.schemeHeaderTransformation);
                    break;
                case /* google.protobuf.UInt32Value max_request_headers_kb */ 29:
                    message.maxRequestHeadersKb = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxRequestHeadersKb);
                    break;
                case /* google.protobuf.Duration stream_idle_timeout */ 24:
                    message.streamIdleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.streamIdleTimeout);
                    break;
                case /* google.protobuf.Duration request_timeout */ 28:
                    message.requestTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.requestTimeout);
                    break;
                case /* google.protobuf.Duration request_headers_timeout */ 41:
                    message.requestHeadersTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.requestHeadersTimeout);
                    break;
                case /* google.protobuf.Duration drain_timeout */ 12:
                    message.drainTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.drainTimeout);
                    break;
                case /* google.protobuf.Duration delayed_close_timeout */ 26:
                    message.delayedCloseTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.delayedCloseTimeout);
                    break;
                case /* repeated envoy.config.accesslog.v3.AccessLog access_log */ 13:
                    message.accessLog.push(AccessLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration access_log_flush_interval = 54 [deprecated = true];*/ 54:
                    message.accessLogFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.accessLogFlushInterval);
                    break;
                case /* bool flush_access_log_on_new_request = 55 [deprecated = true];*/ 55:
                    message.flushAccessLogOnNewRequest = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions access_log_options */ 56:
                    message.accessLogOptions = HttpConnectionManager_HcmAccessLogOptions.internalBinaryRead(reader, reader.uint32(), options, message.accessLogOptions);
                    break;
                case /* google.protobuf.BoolValue use_remote_address */ 14:
                    message.useRemoteAddress = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.useRemoteAddress);
                    break;
                case /* uint32 xff_num_trusted_hops */ 19:
                    message.xffNumTrustedHops = reader.uint32();
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions */ 46:
                    message.originalIpDetectionExtensions.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions */ 52:
                    message.earlyHeaderMutationExtensions.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config */ 25:
                    message.internalAddressConfig = HttpConnectionManager_InternalAddressConfig.internalBinaryRead(reader, reader.uint32(), options, message.internalAddressConfig);
                    break;
                case /* bool skip_xff_append */ 21:
                    message.skipXffAppend = reader.bool();
                    break;
                case /* string via */ 22:
                    message.via = reader.string();
                    break;
                case /* google.protobuf.BoolValue generate_request_id */ 15:
                    message.generateRequestId = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.generateRequestId);
                    break;
                case /* bool preserve_external_request_id */ 32:
                    message.preserveExternalRequestId = reader.bool();
                    break;
                case /* bool always_set_request_id_in_response */ 37:
                    message.alwaysSetRequestIdInResponse = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details */ 16:
                    message.forwardClientCertDetails = reader.int32();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details */ 17:
                    message.setCurrentClientCertDetails = HttpConnectionManager_SetCurrentClientCertDetails.internalBinaryRead(reader, reader.uint32(), options, message.setCurrentClientCertDetails);
                    break;
                case /* bool proxy_100_continue */ 18:
                    message.proxy100Continue = reader.bool();
                    break;
                case /* bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 */ 20:
                    message.representIpv4RemoteAddressAsIpv4MappedIpv6 = reader.bool();
                    break;
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs */ 23:
                    message.upgradeConfigs.push(HttpConnectionManager_UpgradeConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue normalize_path */ 30:
                    message.normalizePath = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.normalizePath);
                    break;
                case /* bool merge_slashes */ 33:
                    message.mergeSlashes = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action */ 45:
                    message.pathWithEscapedSlashesAction = reader.int32();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension */ 36:
                    message.requestIdExtension = RequestIDExtension.internalBinaryRead(reader, reader.uint32(), options, message.requestIdExtension);
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config */ 38:
                    message.localReplyConfig = LocalReplyConfig.internalBinaryRead(reader, reader.uint32(), options, message.localReplyConfig);
                    break;
                case /* bool strip_matching_host_port */ 39:
                    message.stripMatchingHostPort = reader.bool();
                    break;
                case /* bool strip_any_host_port */ 42:
                    message.stripPortMode = {
                        oneofKind: "stripAnyHostPort",
                        stripAnyHostPort: reader.bool()
                    };
                    break;
                case /* google.protobuf.BoolValue stream_error_on_invalid_http_message */ 40:
                    message.streamErrorOnInvalidHttpMessage = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.streamErrorOnInvalidHttpMessage);
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options */ 43:
                    message.pathNormalizationOptions = HttpConnectionManager_PathNormalizationOptions.internalBinaryRead(reader, reader.uint32(), options, message.pathNormalizationOptions);
                    break;
                case /* bool strip_trailing_host_dot */ 47:
                    message.stripTrailingHostDot = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config */ 49:
                    message.proxyStatusConfig = HttpConnectionManager_ProxyStatusConfig.internalBinaryRead(reader, reader.uint32(), options, message.proxyStatusConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config */ 50:
                    message.typedHeaderValidationConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.typedHeaderValidationConfig);
                    break;
                case /* bool append_x_forwarded_port */ 51:
                    message.appendXForwardedPort = reader.bool();
                    break;
                case /* google.protobuf.BoolValue add_proxy_protocol_connection_state */ 53:
                    message.addProxyProtocolConnectionState = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.addProxyProtocolConnectionState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.CodecType codec_type = 1; */
        if (message.codecType !== 0)
            writer.tag(1, WireType.Varint).int32(message.codecType);
        /* string stat_prefix = 2; */
        if (message.statPrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.extensions.filters.network.http_connection_manager.v3.Rds rds = 3; */
        if (message.routeSpecifier.oneofKind === "rds")
            Rds.internalBinaryWrite(message.routeSpecifier.rds, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteConfiguration route_config = 4; */
        if (message.routeSpecifier.oneofKind === "routeConfig")
            RouteConfiguration.internalBinaryWrite(message.routeSpecifier.routeConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes scoped_routes = 31; */
        if (message.routeSpecifier.oneofKind === "scopedRoutes")
            ScopedRoutes.internalBinaryWrite(message.routeSpecifier.scopedRoutes, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter http_filters = 5; */
        for (let i = 0; i < message.httpFilters.length; i++)
            HttpFilter.internalBinaryWrite(message.httpFilters[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue add_user_agent = 6; */
        if (message.addUserAgent)
            BoolValue.internalBinaryWrite(message.addUserAgent, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing tracing = 7; */
        if (message.tracing)
            HttpConnectionManager_Tracing.internalBinaryWrite(message.tracing, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HttpProtocolOptions common_http_protocol_options = 35; */
        if (message.commonHttpProtocolOptions)
            HttpProtocolOptions.internalBinaryWrite(message.commonHttpProtocolOptions, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http1ProtocolOptions http_protocol_options = 8; */
        if (message.httpProtocolOptions)
            Http1ProtocolOptions.internalBinaryWrite(message.httpProtocolOptions, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http2ProtocolOptions http2_protocol_options = 9; */
        if (message.http2ProtocolOptions)
            Http2ProtocolOptions.internalBinaryWrite(message.http2ProtocolOptions, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Http3ProtocolOptions http3_protocol_options = 44; */
        if (message.http3ProtocolOptions)
            Http3ProtocolOptions.internalBinaryWrite(message.http3ProtocolOptions, writer.tag(44, WireType.LengthDelimited).fork(), options).join();
        /* string server_name = 10; */
        if (message.serverName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.serverName);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ServerHeaderTransformation server_header_transformation = 34; */
        if (message.serverHeaderTransformation !== 0)
            writer.tag(34, WireType.Varint).int32(message.serverHeaderTransformation);
        /* envoy.config.core.v3.SchemeHeaderTransformation scheme_header_transformation = 48; */
        if (message.schemeHeaderTransformation)
            SchemeHeaderTransformation.internalBinaryWrite(message.schemeHeaderTransformation, writer.tag(48, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_request_headers_kb = 29; */
        if (message.maxRequestHeadersKb)
            UInt32Value.internalBinaryWrite(message.maxRequestHeadersKb, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration stream_idle_timeout = 24; */
        if (message.streamIdleTimeout)
            Duration.internalBinaryWrite(message.streamIdleTimeout, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration request_timeout = 28; */
        if (message.requestTimeout)
            Duration.internalBinaryWrite(message.requestTimeout, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration request_headers_timeout = 41; */
        if (message.requestHeadersTimeout)
            Duration.internalBinaryWrite(message.requestHeadersTimeout, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration drain_timeout = 12; */
        if (message.drainTimeout)
            Duration.internalBinaryWrite(message.drainTimeout, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration delayed_close_timeout = 26; */
        if (message.delayedCloseTimeout)
            Duration.internalBinaryWrite(message.delayedCloseTimeout, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.accesslog.v3.AccessLog access_log = 13; */
        for (let i = 0; i < message.accessLog.length; i++)
            AccessLog.internalBinaryWrite(message.accessLog[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration access_log_flush_interval = 54 [deprecated = true]; */
        if (message.accessLogFlushInterval)
            Duration.internalBinaryWrite(message.accessLogFlushInterval, writer.tag(54, WireType.LengthDelimited).fork(), options).join();
        /* bool flush_access_log_on_new_request = 55 [deprecated = true]; */
        if (message.flushAccessLogOnNewRequest !== false)
            writer.tag(55, WireType.Varint).bool(message.flushAccessLogOnNewRequest);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions access_log_options = 56; */
        if (message.accessLogOptions)
            HttpConnectionManager_HcmAccessLogOptions.internalBinaryWrite(message.accessLogOptions, writer.tag(56, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue use_remote_address = 14; */
        if (message.useRemoteAddress)
            BoolValue.internalBinaryWrite(message.useRemoteAddress, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* uint32 xff_num_trusted_hops = 19; */
        if (message.xffNumTrustedHops !== 0)
            writer.tag(19, WireType.Varint).uint32(message.xffNumTrustedHops);
        /* repeated envoy.config.core.v3.TypedExtensionConfig original_ip_detection_extensions = 46; */
        for (let i = 0; i < message.originalIpDetectionExtensions.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.originalIpDetectionExtensions[i], writer.tag(46, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.TypedExtensionConfig early_header_mutation_extensions = 52; */
        for (let i = 0; i < message.earlyHeaderMutationExtensions.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.earlyHeaderMutationExtensions[i], writer.tag(52, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig internal_address_config = 25; */
        if (message.internalAddressConfig)
            HttpConnectionManager_InternalAddressConfig.internalBinaryWrite(message.internalAddressConfig, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* bool skip_xff_append = 21; */
        if (message.skipXffAppend !== false)
            writer.tag(21, WireType.Varint).bool(message.skipXffAppend);
        /* string via = 22; */
        if (message.via !== "")
            writer.tag(22, WireType.LengthDelimited).string(message.via);
        /* google.protobuf.BoolValue generate_request_id = 15; */
        if (message.generateRequestId)
            BoolValue.internalBinaryWrite(message.generateRequestId, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* bool preserve_external_request_id = 32; */
        if (message.preserveExternalRequestId !== false)
            writer.tag(32, WireType.Varint).bool(message.preserveExternalRequestId);
        /* bool always_set_request_id_in_response = 37; */
        if (message.alwaysSetRequestIdInResponse !== false)
            writer.tag(37, WireType.Varint).bool(message.alwaysSetRequestIdInResponse);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ForwardClientCertDetails forward_client_cert_details = 16; */
        if (message.forwardClientCertDetails !== 0)
            writer.tag(16, WireType.Varint).int32(message.forwardClientCertDetails);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails set_current_client_cert_details = 17; */
        if (message.setCurrentClientCertDetails)
            HttpConnectionManager_SetCurrentClientCertDetails.internalBinaryWrite(message.setCurrentClientCertDetails, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* bool proxy_100_continue = 18; */
        if (message.proxy100Continue !== false)
            writer.tag(18, WireType.Varint).bool(message.proxy100Continue);
        /* bool represent_ipv4_remote_address_as_ipv4_mapped_ipv6 = 20; */
        if (message.representIpv4RemoteAddressAsIpv4MappedIpv6 !== false)
            writer.tag(20, WireType.Varint).bool(message.representIpv4RemoteAddressAsIpv4MappedIpv6);
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig upgrade_configs = 23; */
        for (let i = 0; i < message.upgradeConfigs.length; i++)
            HttpConnectionManager_UpgradeConfig.internalBinaryWrite(message.upgradeConfigs[i], writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue normalize_path = 30; */
        if (message.normalizePath)
            BoolValue.internalBinaryWrite(message.normalizePath, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* bool merge_slashes = 33; */
        if (message.mergeSlashes !== false)
            writer.tag(33, WireType.Varint).bool(message.mergeSlashes);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathWithEscapedSlashesAction path_with_escaped_slashes_action = 45; */
        if (message.pathWithEscapedSlashesAction !== 0)
            writer.tag(45, WireType.Varint).int32(message.pathWithEscapedSlashesAction);
        /* envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension request_id_extension = 36; */
        if (message.requestIdExtension)
            RequestIDExtension.internalBinaryWrite(message.requestIdExtension, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig local_reply_config = 38; */
        if (message.localReplyConfig)
            LocalReplyConfig.internalBinaryWrite(message.localReplyConfig, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* bool strip_matching_host_port = 39; */
        if (message.stripMatchingHostPort !== false)
            writer.tag(39, WireType.Varint).bool(message.stripMatchingHostPort);
        /* bool strip_any_host_port = 42; */
        if (message.stripPortMode.oneofKind === "stripAnyHostPort")
            writer.tag(42, WireType.Varint).bool(message.stripPortMode.stripAnyHostPort);
        /* google.protobuf.BoolValue stream_error_on_invalid_http_message = 40; */
        if (message.streamErrorOnInvalidHttpMessage)
            BoolValue.internalBinaryWrite(message.streamErrorOnInvalidHttpMessage, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions path_normalization_options = 43; */
        if (message.pathNormalizationOptions)
            HttpConnectionManager_PathNormalizationOptions.internalBinaryWrite(message.pathNormalizationOptions, writer.tag(43, WireType.LengthDelimited).fork(), options).join();
        /* bool strip_trailing_host_dot = 47; */
        if (message.stripTrailingHostDot !== false)
            writer.tag(47, WireType.Varint).bool(message.stripTrailingHostDot);
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig proxy_status_config = 49; */
        if (message.proxyStatusConfig)
            HttpConnectionManager_ProxyStatusConfig.internalBinaryWrite(message.proxyStatusConfig, writer.tag(49, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig typed_header_validation_config = 50; */
        if (message.typedHeaderValidationConfig)
            TypedExtensionConfig.internalBinaryWrite(message.typedHeaderValidationConfig, writer.tag(50, WireType.LengthDelimited).fork(), options).join();
        /* bool append_x_forwarded_port = 51; */
        if (message.appendXForwardedPort !== false)
            writer.tag(51, WireType.Varint).bool(message.appendXForwardedPort);
        /* google.protobuf.BoolValue add_proxy_protocol_connection_state = 53; */
        if (message.addProxyProtocolConnectionState)
            BoolValue.internalBinaryWrite(message.addProxyProtocolConnectionState, writer.tag(53, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
 */
export const HttpConnectionManager = new HttpConnectionManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_Tracing$Type extends MessageType<HttpConnectionManager_Tracing> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing", [
            { no: 3, name: "client_sampling", kind: "message", T: () => Percent },
            { no: 4, name: "random_sampling", kind: "message", T: () => Percent },
            { no: 5, name: "overall_sampling", kind: "message", T: () => Percent },
            { no: 6, name: "verbose", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "max_path_tag_length", kind: "message", T: () => UInt32Value },
            { no: 8, name: "custom_tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomTag },
            { no: 9, name: "provider", kind: "message", T: () => Tracing_Http }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing" } });
    }
    create(value?: PartialMessage<HttpConnectionManager_Tracing>): HttpConnectionManager_Tracing {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.verbose = false;
        message.customTags = [];
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_Tracing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_Tracing): HttpConnectionManager_Tracing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent client_sampling */ 3:
                    message.clientSampling = Percent.internalBinaryRead(reader, reader.uint32(), options, message.clientSampling);
                    break;
                case /* envoy.type.v3.Percent random_sampling */ 4:
                    message.randomSampling = Percent.internalBinaryRead(reader, reader.uint32(), options, message.randomSampling);
                    break;
                case /* envoy.type.v3.Percent overall_sampling */ 5:
                    message.overallSampling = Percent.internalBinaryRead(reader, reader.uint32(), options, message.overallSampling);
                    break;
                case /* bool verbose */ 6:
                    message.verbose = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value max_path_tag_length */ 7:
                    message.maxPathTagLength = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxPathTagLength);
                    break;
                case /* repeated envoy.type.tracing.v3.CustomTag custom_tags */ 8:
                    message.customTags.push(CustomTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.trace.v3.Tracing.Http provider */ 9:
                    message.provider = Tracing_Http.internalBinaryRead(reader, reader.uint32(), options, message.provider);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_Tracing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent client_sampling = 3; */
        if (message.clientSampling)
            Percent.internalBinaryWrite(message.clientSampling, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent random_sampling = 4; */
        if (message.randomSampling)
            Percent.internalBinaryWrite(message.randomSampling, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent overall_sampling = 5; */
        if (message.overallSampling)
            Percent.internalBinaryWrite(message.overallSampling, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool verbose = 6; */
        if (message.verbose !== false)
            writer.tag(6, WireType.Varint).bool(message.verbose);
        /* google.protobuf.UInt32Value max_path_tag_length = 7; */
        if (message.maxPathTagLength)
            UInt32Value.internalBinaryWrite(message.maxPathTagLength, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.tracing.v3.CustomTag custom_tags = 8; */
        for (let i = 0; i < message.customTags.length; i++)
            CustomTag.internalBinaryWrite(message.customTags[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.trace.v3.Tracing.Http provider = 9; */
        if (message.provider)
            Tracing_Http.internalBinaryWrite(message.provider, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing
 */
export const HttpConnectionManager_Tracing = new HttpConnectionManager_Tracing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_InternalAddressConfig$Type extends MessageType<HttpConnectionManager_InternalAddressConfig> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig", [
            { no: 1, name: "unix_sockets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "cidr_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.InternalAddressConfig" } });
    }
    create(value?: PartialMessage<HttpConnectionManager_InternalAddressConfig>): HttpConnectionManager_InternalAddressConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unixSockets = false;
        message.cidrRanges = [];
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_InternalAddressConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_InternalAddressConfig): HttpConnectionManager_InternalAddressConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool unix_sockets */ 1:
                    message.unixSockets = reader.bool();
                    break;
                case /* repeated envoy.config.core.v3.CidrRange cidr_ranges */ 2:
                    message.cidrRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_InternalAddressConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool unix_sockets = 1; */
        if (message.unixSockets !== false)
            writer.tag(1, WireType.Varint).bool(message.unixSockets);
        /* repeated envoy.config.core.v3.CidrRange cidr_ranges = 2; */
        for (let i = 0; i < message.cidrRanges.length; i++)
            CidrRange.internalBinaryWrite(message.cidrRanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.InternalAddressConfig
 */
export const HttpConnectionManager_InternalAddressConfig = new HttpConnectionManager_InternalAddressConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_SetCurrentClientCertDetails$Type extends MessageType<HttpConnectionManager_SetCurrentClientCertDetails> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails", [
            { no: 1, name: "subject", kind: "message", T: () => BoolValue },
            { no: 3, name: "cert", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "chain", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "dns", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "uri", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.SetCurrentClientCertDetails" } });
    }
    create(value?: PartialMessage<HttpConnectionManager_SetCurrentClientCertDetails>): HttpConnectionManager_SetCurrentClientCertDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cert = false;
        message.chain = false;
        message.dns = false;
        message.uri = false;
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_SetCurrentClientCertDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_SetCurrentClientCertDetails): HttpConnectionManager_SetCurrentClientCertDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue subject */ 1:
                    message.subject = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* bool cert */ 3:
                    message.cert = reader.bool();
                    break;
                case /* bool chain */ 6:
                    message.chain = reader.bool();
                    break;
                case /* bool dns */ 4:
                    message.dns = reader.bool();
                    break;
                case /* bool uri */ 5:
                    message.uri = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_SetCurrentClientCertDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue subject = 1; */
        if (message.subject)
            BoolValue.internalBinaryWrite(message.subject, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool cert = 3; */
        if (message.cert !== false)
            writer.tag(3, WireType.Varint).bool(message.cert);
        /* bool chain = 6; */
        if (message.chain !== false)
            writer.tag(6, WireType.Varint).bool(message.chain);
        /* bool dns = 4; */
        if (message.dns !== false)
            writer.tag(4, WireType.Varint).bool(message.dns);
        /* bool uri = 5; */
        if (message.uri !== false)
            writer.tag(5, WireType.Varint).bool(message.uri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.SetCurrentClientCertDetails
 */
export const HttpConnectionManager_SetCurrentClientCertDetails = new HttpConnectionManager_SetCurrentClientCertDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_UpgradeConfig$Type extends MessageType<HttpConnectionManager_UpgradeConfig> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig", [
            { no: 1, name: "upgrade_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpFilter },
            { no: 3, name: "enabled", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager.UpgradeConfig" } });
    }
    create(value?: PartialMessage<HttpConnectionManager_UpgradeConfig>): HttpConnectionManager_UpgradeConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upgradeType = "";
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_UpgradeConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_UpgradeConfig): HttpConnectionManager_UpgradeConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string upgrade_type */ 1:
                    message.upgradeType = reader.string();
                    break;
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters */ 2:
                    message.filters.push(HttpFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue enabled */ 3:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_UpgradeConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string upgrade_type = 1; */
        if (message.upgradeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.upgradeType);
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            HttpFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue enabled = 3; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.UpgradeConfig
 */
export const HttpConnectionManager_UpgradeConfig = new HttpConnectionManager_UpgradeConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_PathNormalizationOptions$Type extends MessageType<HttpConnectionManager_PathNormalizationOptions> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions", [
            { no: 1, name: "forwarding_transformation", kind: "message", T: () => PathTransformation },
            { no: 2, name: "http_filter_transformation", kind: "message", T: () => PathTransformation }
        ]);
    }
    create(value?: PartialMessage<HttpConnectionManager_PathNormalizationOptions>): HttpConnectionManager_PathNormalizationOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_PathNormalizationOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_PathNormalizationOptions): HttpConnectionManager_PathNormalizationOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.http.v3.PathTransformation forwarding_transformation */ 1:
                    message.forwardingTransformation = PathTransformation.internalBinaryRead(reader, reader.uint32(), options, message.forwardingTransformation);
                    break;
                case /* envoy.type.http.v3.PathTransformation http_filter_transformation */ 2:
                    message.httpFilterTransformation = PathTransformation.internalBinaryRead(reader, reader.uint32(), options, message.httpFilterTransformation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_PathNormalizationOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.http.v3.PathTransformation forwarding_transformation = 1; */
        if (message.forwardingTransformation)
            PathTransformation.internalBinaryWrite(message.forwardingTransformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.http.v3.PathTransformation http_filter_transformation = 2; */
        if (message.httpFilterTransformation)
            PathTransformation.internalBinaryWrite(message.httpFilterTransformation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.PathNormalizationOptions
 */
export const HttpConnectionManager_PathNormalizationOptions = new HttpConnectionManager_PathNormalizationOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_ProxyStatusConfig$Type extends MessageType<HttpConnectionManager_ProxyStatusConfig> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig", [
            { no: 1, name: "remove_details", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "remove_connection_termination_details", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "remove_response_flags", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "set_recommended_response_code", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "use_node_id", kind: "scalar", oneof: "proxyName", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "literal_proxy_name", kind: "scalar", oneof: "proxyName", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HttpConnectionManager_ProxyStatusConfig>): HttpConnectionManager_ProxyStatusConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.removeDetails = false;
        message.removeConnectionTerminationDetails = false;
        message.removeResponseFlags = false;
        message.setRecommendedResponseCode = false;
        message.proxyName = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_ProxyStatusConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_ProxyStatusConfig): HttpConnectionManager_ProxyStatusConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool remove_details */ 1:
                    message.removeDetails = reader.bool();
                    break;
                case /* bool remove_connection_termination_details */ 2:
                    message.removeConnectionTerminationDetails = reader.bool();
                    break;
                case /* bool remove_response_flags */ 3:
                    message.removeResponseFlags = reader.bool();
                    break;
                case /* bool set_recommended_response_code */ 4:
                    message.setRecommendedResponseCode = reader.bool();
                    break;
                case /* bool use_node_id */ 5:
                    message.proxyName = {
                        oneofKind: "useNodeId",
                        useNodeId: reader.bool()
                    };
                    break;
                case /* string literal_proxy_name */ 6:
                    message.proxyName = {
                        oneofKind: "literalProxyName",
                        literalProxyName: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_ProxyStatusConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool remove_details = 1; */
        if (message.removeDetails !== false)
            writer.tag(1, WireType.Varint).bool(message.removeDetails);
        /* bool remove_connection_termination_details = 2; */
        if (message.removeConnectionTerminationDetails !== false)
            writer.tag(2, WireType.Varint).bool(message.removeConnectionTerminationDetails);
        /* bool remove_response_flags = 3; */
        if (message.removeResponseFlags !== false)
            writer.tag(3, WireType.Varint).bool(message.removeResponseFlags);
        /* bool set_recommended_response_code = 4; */
        if (message.setRecommendedResponseCode !== false)
            writer.tag(4, WireType.Varint).bool(message.setRecommendedResponseCode);
        /* bool use_node_id = 5; */
        if (message.proxyName.oneofKind === "useNodeId")
            writer.tag(5, WireType.Varint).bool(message.proxyName.useNodeId);
        /* string literal_proxy_name = 6; */
        if (message.proxyName.oneofKind === "literalProxyName")
            writer.tag(6, WireType.LengthDelimited).string(message.proxyName.literalProxyName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.ProxyStatusConfig
 */
export const HttpConnectionManager_ProxyStatusConfig = new HttpConnectionManager_ProxyStatusConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpConnectionManager_HcmAccessLogOptions$Type extends MessageType<HttpConnectionManager_HcmAccessLogOptions> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions", [
            { no: 1, name: "access_log_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } } } },
            { no: 2, name: "flush_access_log_on_new_request", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "flush_log_on_tunnel_successfully_established", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HttpConnectionManager_HcmAccessLogOptions>): HttpConnectionManager_HcmAccessLogOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flushAccessLogOnNewRequest = false;
        message.flushLogOnTunnelSuccessfullyEstablished = false;
        if (value !== undefined)
            reflectionMergePartial<HttpConnectionManager_HcmAccessLogOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpConnectionManager_HcmAccessLogOptions): HttpConnectionManager_HcmAccessLogOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration access_log_flush_interval */ 1:
                    message.accessLogFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.accessLogFlushInterval);
                    break;
                case /* bool flush_access_log_on_new_request */ 2:
                    message.flushAccessLogOnNewRequest = reader.bool();
                    break;
                case /* bool flush_log_on_tunnel_successfully_established */ 3:
                    message.flushLogOnTunnelSuccessfullyEstablished = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpConnectionManager_HcmAccessLogOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration access_log_flush_interval = 1; */
        if (message.accessLogFlushInterval)
            Duration.internalBinaryWrite(message.accessLogFlushInterval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool flush_access_log_on_new_request = 2; */
        if (message.flushAccessLogOnNewRequest !== false)
            writer.tag(2, WireType.Varint).bool(message.flushAccessLogOnNewRequest);
        /* bool flush_log_on_tunnel_successfully_established = 3; */
        if (message.flushLogOnTunnelSuccessfullyEstablished !== false)
            writer.tag(3, WireType.Varint).bool(message.flushLogOnTunnelSuccessfullyEstablished);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.HcmAccessLogOptions
 */
export const HttpConnectionManager_HcmAccessLogOptions = new HttpConnectionManager_HcmAccessLogOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalReplyConfig$Type extends MessageType<LocalReplyConfig> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig", [
            { no: 1, name: "mappers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResponseMapper },
            { no: 2, name: "body_format", kind: "message", T: () => SubstitutionFormatString }
        ]);
    }
    create(value?: PartialMessage<LocalReplyConfig>): LocalReplyConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mappers = [];
        if (value !== undefined)
            reflectionMergePartial<LocalReplyConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalReplyConfig): LocalReplyConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper mappers */ 1:
                    message.mappers.push(ResponseMapper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.SubstitutionFormatString body_format */ 2:
                    message.bodyFormat = SubstitutionFormatString.internalBinaryRead(reader, reader.uint32(), options, message.bodyFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalReplyConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper mappers = 1; */
        for (let i = 0; i < message.mappers.length; i++)
            ResponseMapper.internalBinaryWrite(message.mappers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.SubstitutionFormatString body_format = 2; */
        if (message.bodyFormat)
            SubstitutionFormatString.internalBinaryWrite(message.bodyFormat, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.LocalReplyConfig
 */
export const LocalReplyConfig = new LocalReplyConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseMapper$Type extends MessageType<ResponseMapper> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper", [
            { no: 1, name: "filter", kind: "message", T: () => AccessLogFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "status_code", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lt: 600, gte: 200 } } } },
            { no: 3, name: "body", kind: "message", T: () => DataSource },
            { no: 4, name: "body_format_override", kind: "message", T: () => SubstitutionFormatString },
            { no: 5, name: "headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } }
        ]);
    }
    create(value?: PartialMessage<ResponseMapper>): ResponseMapper {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<ResponseMapper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseMapper): ResponseMapper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.accesslog.v3.AccessLogFilter filter */ 1:
                    message.filter = AccessLogFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* google.protobuf.UInt32Value status_code */ 2:
                    message.statusCode = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.statusCode);
                    break;
                case /* envoy.config.core.v3.DataSource body */ 3:
                    message.body = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                case /* envoy.config.core.v3.SubstitutionFormatString body_format_override */ 4:
                    message.bodyFormatOverride = SubstitutionFormatString.internalBinaryRead(reader, reader.uint32(), options, message.bodyFormatOverride);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption headers_to_add */ 5:
                    message.headersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseMapper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.accesslog.v3.AccessLogFilter filter = 1; */
        if (message.filter)
            AccessLogFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value status_code = 2; */
        if (message.statusCode)
            UInt32Value.internalBinaryWrite(message.statusCode, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource body = 3; */
        if (message.body)
            DataSource.internalBinaryWrite(message.body, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.SubstitutionFormatString body_format_override = 4; */
        if (message.bodyFormatOverride)
            SubstitutionFormatString.internalBinaryWrite(message.bodyFormatOverride, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 5; */
        for (let i = 0; i < message.headersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.headersToAdd[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ResponseMapper
 */
export const ResponseMapper = new ResponseMapper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rds$Type extends MessageType<Rds> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.Rds", [
            { no: 1, name: "config_source", kind: "message", T: () => ConfigSource, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "route_config_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.Rds" } });
    }
    create(value?: PartialMessage<Rds>): Rds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routeConfigName = "";
        if (value !== undefined)
            reflectionMergePartial<Rds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rds): Rds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource config_source */ 1:
                    message.configSource = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.configSource);
                    break;
                case /* string route_config_name */ 2:
                    message.routeConfigName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource config_source = 1; */
        if (message.configSource)
            ConfigSource.internalBinaryWrite(message.configSource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string route_config_name = 2; */
        if (message.routeConfigName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.routeConfigName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.Rds
 */
export const Rds = new Rds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRouteConfigurationsList$Type extends MessageType<ScopedRouteConfigurationsList> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList", [
            { no: 1, name: "scoped_route_configurations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRouteConfiguration, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRouteConfigurationsList" } });
    }
    create(value?: PartialMessage<ScopedRouteConfigurationsList>): ScopedRouteConfigurationsList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scopedRouteConfigurations = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRouteConfigurationsList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRouteConfigurationsList): ScopedRouteConfigurationsList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.ScopedRouteConfiguration scoped_route_configurations */ 1:
                    message.scopedRouteConfigurations.push(ScopedRouteConfiguration.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRouteConfigurationsList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.ScopedRouteConfiguration scoped_route_configurations = 1; */
        for (let i = 0; i < message.scopedRouteConfigurations.length; i++)
            ScopedRouteConfiguration.internalBinaryWrite(message.scopedRouteConfigurations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList
 */
export const ScopedRouteConfigurationsList = new ScopedRouteConfigurationsList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutes$Type extends MessageType<ScopedRoutes> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "scope_key_builder", kind: "message", T: () => ScopedRoutes_ScopeKeyBuilder, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "rds_config_source", kind: "message", T: () => ConfigSource },
            { no: 4, name: "scoped_route_configurations_list", kind: "message", oneof: "configSpecifier", T: () => ScopedRouteConfigurationsList },
            { no: 5, name: "scoped_rds", kind: "message", oneof: "configSpecifier", T: () => ScopedRds }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes" } });
    }
    create(value?: PartialMessage<ScopedRoutes>): ScopedRoutes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutes): ScopedRoutes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder scope_key_builder */ 2:
                    message.scopeKeyBuilder = ScopedRoutes_ScopeKeyBuilder.internalBinaryRead(reader, reader.uint32(), options, message.scopeKeyBuilder);
                    break;
                case /* envoy.config.core.v3.ConfigSource rds_config_source */ 3:
                    message.rdsConfigSource = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.rdsConfigSource);
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList scoped_route_configurations_list */ 4:
                    message.configSpecifier = {
                        oneofKind: "scopedRouteConfigurationsList",
                        scopedRouteConfigurationsList: ScopedRouteConfigurationsList.internalBinaryRead(reader, reader.uint32(), options, (message.configSpecifier as any).scopedRouteConfigurationsList)
                    };
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds scoped_rds */ 5:
                    message.configSpecifier = {
                        oneofKind: "scopedRds",
                        scopedRds: ScopedRds.internalBinaryRead(reader, reader.uint32(), options, (message.configSpecifier as any).scopedRds)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder scope_key_builder = 2; */
        if (message.scopeKeyBuilder)
            ScopedRoutes_ScopeKeyBuilder.internalBinaryWrite(message.scopeKeyBuilder, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ConfigSource rds_config_source = 3; */
        if (message.rdsConfigSource)
            ConfigSource.internalBinaryWrite(message.rdsConfigSource, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRouteConfigurationsList scoped_route_configurations_list = 4; */
        if (message.configSpecifier.oneofKind === "scopedRouteConfigurationsList")
            ScopedRouteConfigurationsList.internalBinaryWrite(message.configSpecifier.scopedRouteConfigurationsList, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds scoped_rds = 5; */
        if (message.configSpecifier.oneofKind === "scopedRds")
            ScopedRds.internalBinaryWrite(message.configSpecifier.scopedRds, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes
 */
export const ScopedRoutes = new ScopedRoutes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutes_ScopeKeyBuilder$Type extends MessageType<ScopedRoutes_ScopeKeyBuilder> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder", [
            { no: 1, name: "fragments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder" } });
    }
    create(value?: PartialMessage<ScopedRoutes_ScopeKeyBuilder>): ScopedRoutes_ScopeKeyBuilder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fragments = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutes_ScopeKeyBuilder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutes_ScopeKeyBuilder): ScopedRoutes_ScopeKeyBuilder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder fragments */ 1:
                    message.fragments.push(ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutes_ScopeKeyBuilder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder fragments = 1; */
        for (let i = 0; i < message.fragments.length; i++)
            ScopedRoutes_ScopeKeyBuilder_FragmentBuilder.internalBinaryWrite(message.fragments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder
 */
export const ScopedRoutes_ScopeKeyBuilder = new ScopedRoutes_ScopeKeyBuilder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutes_ScopeKeyBuilder_FragmentBuilder$Type extends MessageType<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder", [
            { no: 1, name: "header_value_extractor", kind: "message", oneof: "type", T: () => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder" } });
    }
    create(value?: PartialMessage<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor header_value_extractor */ 1:
                    message.type = {
                        oneofKind: "headerValueExtractor",
                        headerValueExtractor: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).headerValueExtractor)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor header_value_extractor = 1; */
        if (message.type.oneofKind === "headerValueExtractor")
            ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor.internalBinaryWrite(message.type.headerValueExtractor, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder
 */
export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder = new ScopedRoutes_ScopeKeyBuilder_FragmentBuilder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor$Type extends MessageType<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "element_separator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "index", kind: "scalar", oneof: "extractType", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "element", kind: "message", oneof: "extractType", T: () => ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor" } });
    }
    create(value?: PartialMessage<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.elementSeparator = "";
        message.extractType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string element_separator */ 2:
                    message.elementSeparator = reader.string();
                    break;
                case /* uint32 index */ 3:
                    message.extractType = {
                        oneofKind: "index",
                        index: reader.uint32()
                    };
                    break;
                case /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement element */ 4:
                    message.extractType = {
                        oneofKind: "element",
                        element: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.internalBinaryRead(reader, reader.uint32(), options, (message.extractType as any).element)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string element_separator = 2; */
        if (message.elementSeparator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.elementSeparator);
        /* uint32 index = 3; */
        if (message.extractType.oneofKind === "index")
            writer.tag(3, WireType.Varint).uint32(message.extractType.index);
        /* envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement element = 4; */
        if (message.extractType.oneofKind === "element")
            ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement.internalBinaryWrite(message.extractType.element, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor
 */
export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor = new ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement$Type extends MessageType<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement", [
            { no: 1, name: "separator", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement" } });
    }
    create(value?: PartialMessage<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.separator = "";
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement): ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string separator */ 1:
                    message.separator = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string separator = 1; */
        if (message.separator !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.separator);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement
 */
export const ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement = new ScopedRoutes_ScopeKeyBuilder_FragmentBuilder_HeaderValueExtractor_KvElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRds$Type extends MessageType<ScopedRds> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds", [
            { no: 1, name: "scoped_rds_config_source", kind: "message", T: () => ConfigSource, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "srds_resources_locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.ScopedRds" } });
    }
    create(value?: PartialMessage<ScopedRds>): ScopedRds {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.srdsResourcesLocator = "";
        if (value !== undefined)
            reflectionMergePartial<ScopedRds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRds): ScopedRds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource scoped_rds_config_source */ 1:
                    message.scopedRdsConfigSource = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.scopedRdsConfigSource);
                    break;
                case /* string srds_resources_locator */ 2:
                    message.srdsResourcesLocator = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource scoped_rds_config_source = 1; */
        if (message.scopedRdsConfigSource)
            ConfigSource.internalBinaryWrite(message.scopedRdsConfigSource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string srds_resources_locator = 2; */
        if (message.srdsResourcesLocator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.srdsResourcesLocator);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.ScopedRds
 */
export const ScopedRds = new ScopedRds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpFilter$Type extends MessageType<HttpFilter> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "typed_config", kind: "message", oneof: "configType", T: () => Any },
            { no: 5, name: "config_discovery", kind: "message", oneof: "configType", T: () => ExtensionConfigSource },
            { no: 6, name: "is_optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.HttpFilter" } });
    }
    create(value?: PartialMessage<HttpFilter>): HttpFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        message.isOptional = false;
        if (value !== undefined)
            reflectionMergePartial<HttpFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpFilter): HttpFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 4:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                case /* envoy.config.core.v3.ExtensionConfigSource config_discovery */ 5:
                    message.configType = {
                        oneofKind: "configDiscovery",
                        configDiscovery: ExtensionConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).configDiscovery)
                    };
                    break;
                case /* bool is_optional */ 6:
                    message.isOptional = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 4; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ExtensionConfigSource config_discovery = 5; */
        if (message.configType.oneofKind === "configDiscovery")
            ExtensionConfigSource.internalBinaryWrite(message.configType.configDiscovery, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool is_optional = 6; */
        if (message.isOptional !== false)
            writer.tag(6, WireType.Varint).bool(message.isOptional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter
 */
export const HttpFilter = new HttpFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestIDExtension$Type extends MessageType<RequestIDExtension> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension", [
            { no: 1, name: "typed_config", kind: "message", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.http_connection_manager.v2.RequestIDExtension" } });
    }
    create(value?: PartialMessage<RequestIDExtension>): RequestIDExtension {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestIDExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestIDExtension): RequestIDExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any typed_config */ 1:
                    message.typedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.typedConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestIDExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any typed_config = 1; */
        if (message.typedConfig)
            Any.internalBinaryWrite(message.typedConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.RequestIDExtension
 */
export const RequestIDExtension = new RequestIDExtension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnvoyMobileHttpConnectionManager$Type extends MessageType<EnvoyMobileHttpConnectionManager> {
    constructor() {
        super("envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager", [
            { no: 1, name: "config", kind: "message", T: () => HttpConnectionManager }
        ]);
    }
    create(value?: PartialMessage<EnvoyMobileHttpConnectionManager>): EnvoyMobileHttpConnectionManager {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EnvoyMobileHttpConnectionManager>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnvoyMobileHttpConnectionManager): EnvoyMobileHttpConnectionManager {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager config */ 1:
                    message.config = HttpConnectionManager.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnvoyMobileHttpConnectionManager, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager config = 1; */
        if (message.config)
            HttpConnectionManager.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.http_connection_manager.v3.EnvoyMobileHttpConnectionManager
 */
export const EnvoyMobileHttpConnectionManager = new EnvoyMobileHttpConnectionManager$Type();
