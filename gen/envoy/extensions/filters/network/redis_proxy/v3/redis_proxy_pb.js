// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto (package envoy.extensions.filters.network.redis_proxy.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Duration, proto3, UInt32Value } from "@bufbuild/protobuf";
import { DataSource, RuntimeFractionalPercent } from "../../../../../config/core/v3/base_pb.js";
import { DnsCacheConfig } from "../../../../common/dynamic_forward_proxy/v3/dns_cache_pb.js";

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy
 */
export const RedisProxy = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy",
  () => [
    { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "settings", kind: "message", T: RedisProxy_ConnPoolSettings },
    { no: 4, name: "latency_in_micros", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "prefix_routes", kind: "message", T: RedisProxy_PrefixRoutes },
    { no: 6, name: "downstream_auth_password", kind: "message", T: DataSource },
    { no: 9, name: "downstream_auth_passwords", kind: "message", T: DataSource, repeated: true },
    { no: 8, name: "faults", kind: "message", T: RedisProxy_RedisFault, repeated: true },
    { no: 7, name: "downstream_auth_username", kind: "message", T: DataSource },
  ],
);

/**
 * Redis connection pool settings.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings
 */
export const RedisProxy_ConnPoolSettings = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings",
  () => [
    { no: 1, name: "op_timeout", kind: "message", T: Duration },
    { no: 2, name: "enable_hashtagging", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "enable_redirection", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "dns_cache_config", kind: "message", T: DnsCacheConfig },
    { no: 4, name: "max_buffer_size_before_flush", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "buffer_flush_timeout", kind: "message", T: Duration },
    { no: 6, name: "max_upstream_unknown_connections", kind: "message", T: UInt32Value },
    { no: 8, name: "enable_command_stats", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "read_policy", kind: "enum", T: proto3.getEnumType(RedisProxy_ConnPoolSettings_ReadPolicy) },
    { no: 10, name: "connection_rate_limit", kind: "message", T: RedisProxy_ConnectionRateLimit },
  ],
  {localName: "RedisProxy_ConnPoolSettings"},
);

/**
 * ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
 * supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
 * because replication is asynchronous and requires some delay. You need to ensure that your
 * application can tolerate stale data.
 *
 * @generated from enum envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy
 */
export const RedisProxy_ConnPoolSettings_ReadPolicy = proto3.makeEnum(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy",
  [
    {no: 0, name: "MASTER"},
    {no: 1, name: "PREFER_MASTER"},
    {no: 2, name: "REPLICA"},
    {no: 3, name: "PREFER_REPLICA"},
    {no: 4, name: "ANY"},
  ],
);

/**
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes
 */
export const RedisProxy_PrefixRoutes = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes",
  () => [
    { no: 1, name: "routes", kind: "message", T: RedisProxy_PrefixRoutes_Route, repeated: true },
    { no: 2, name: "case_insensitive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "catch_all_route", kind: "message", T: RedisProxy_PrefixRoutes_Route },
  ],
  {localName: "RedisProxy_PrefixRoutes"},
);

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route
 */
export const RedisProxy_PrefixRoutes_Route = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route",
  () => [
    { no: 1, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "remove_prefix", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "request_mirror_policy", kind: "message", T: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy, repeated: true },
    { no: 5, name: "key_formatter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RedisProxy_PrefixRoutes_Route"},
);

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
 */
export const RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy",
  () => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "runtime_fraction", kind: "message", T: RuntimeFractionalPercent },
    { no: 3, name: "exclude_read_commands", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy"},
);

/**
 * RedisFault defines faults used for fault injection.
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault
 */
export const RedisProxy_RedisFault = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault",
  () => [
    { no: 1, name: "fault_type", kind: "enum", T: proto3.getEnumType(RedisProxy_RedisFault_RedisFaultType) },
    { no: 2, name: "fault_enabled", kind: "message", T: RuntimeFractionalPercent },
    { no: 3, name: "delay", kind: "message", T: Duration },
    { no: 4, name: "commands", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
  {localName: "RedisProxy_RedisFault"},
);

/**
 * @generated from enum envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType
 */
export const RedisProxy_RedisFault_RedisFaultType = proto3.makeEnum(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType",
  [
    {no: 0, name: "DELAY"},
    {no: 1, name: "ERROR"},
  ],
);

/**
 * Configuration to limit reconnection rate to redis server to protect redis server
 * from client reconnection storm.
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit
 */
export const RedisProxy_ConnectionRateLimit = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit",
  () => [
    { no: 1, name: "connection_rate_limit_per_sec", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ],
  {localName: "RedisProxy_ConnectionRateLimit"},
);

/**
 * RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.filters.network.redis_proxy``.
 *
 * @generated from message envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions
 */
export const RedisProtocolOptions = proto3.makeMessageType(
  "envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions",
  () => [
    { no: 1, name: "auth_password", kind: "message", T: DataSource },
    { no: 2, name: "auth_username", kind: "message", T: DataSource },
  ],
);

