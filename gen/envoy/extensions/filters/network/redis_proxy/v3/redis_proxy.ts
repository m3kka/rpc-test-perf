// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto" (package "envoy.extensions.filters.network.redis_proxy.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { DnsCacheConfig } from "../../../../common/dynamic_forward_proxy/v3/dns_cache";
import { Duration } from "../../../../../../google/protobuf/duration";
import { DataSource } from "../../../../../config/core/v3/base";
// [#protodoc-title: Redis Proxy]
// Redis Proxy :ref:`configuration overview <config_network_filters_redis_proxy>`.
// [#extension: envoy.filters.network.redis_proxy]

/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy
 */
export interface RedisProxy {
    /**
     * The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * Network settings for the connection pool to the upstream clusters.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings settings = 3;
     */
    settings?: RedisProxy_ConnPoolSettings;
    /**
     * Indicates that latency stat should be computed in microseconds. By default it is computed in
     * milliseconds. This does not apply to upstream command stats currently.
     *
     * @generated from protobuf field: bool latency_in_micros = 4;
     */
    latencyInMicros: boolean;
    /**
     * List of **unique** prefixes used to separate keys from different workloads to different
     * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
     * cluster can be used to forward commands when there is no match. Time complexity of the
     * lookups are in O(min(longest key prefix, key length)).
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    prefix_routes:
     *      routes:
     *        - prefix: "ab"
     *          cluster: "cluster_a"
     *        - prefix: "abc"
     *          cluster: "cluster_b"
     *
     * When using the above routes, the following prefixes would be sent to:
     *
     * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
     * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
     * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
     *   route<envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.catch_all_route>`
     *   would have retrieved the key from that cluster instead.
     *
     * See the :ref:`configuration section
     * <arch_overview_redis_configuration>` of the architecture overview for recommendations on
     * configuring the backing clusters.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes prefix_routes = 5;
     */
    prefixRoutes?: RedisProxy_PrefixRoutes;
    /**
     * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
     * AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
     * command. If an AUTH command's password matches this password, an "OK" response will be returned
     * to the client. If the AUTH command password does not match this password, then an "ERR invalid
     * password" error will be returned. If any other command is received before AUTH when this
     * password is set, then a "NOAUTH Authentication required." error response will be sent to the
     * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
     * AUTH, but no password is set" error will be returned.
     *
     * .. attention::
     *   This field is deprecated. Use :ref:`downstream_auth_passwords
     *   <envoy_v3_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.downstream_auth_passwords>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.DataSource downstream_auth_password = 6 [deprecated = true];
     */
    downstreamAuthPassword?: DataSource;
    /**
     * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
     * AUTH command <https://redis.io/commands/auth>`_ with one of these passwords before enabling any other
     * command. If an AUTH command's password matches one of these passwords, an "OK" response will be returned
     * to the client. If the AUTH command password does not match, then an "ERR invalid
     * password" error will be returned. If any other command is received before AUTH when the
     * password(s) are set, then a "NOAUTH Authentication required." error response will be sent to the
     * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
     * AUTH, but no password is set" error will be returned.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.DataSource downstream_auth_passwords = 9;
     */
    downstreamAuthPasswords: DataSource[];
    /**
     * List of faults to inject. Faults currently come in two flavors:
     * - Delay, which delays a request.
     * - Error, which responds to a request with an error. Errors can also have delays attached.
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    faults:
     *    - fault_type: ERROR
     *      fault_enabled:
     *        default_value:
     *          numerator: 10
     *          denominator: HUNDRED
     *        runtime_key: "bogus_key"
     *        commands:
     *        - GET
     *      - fault_type: DELAY
     *        fault_enabled:
     *          default_value:
     *            numerator: 10
     *            denominator: HUNDRED
     *          runtime_key: "bogus_key"
     *        delay: 2s
     *
     * See the :ref:`fault injection section
     * <config_network_filters_redis_proxy_fault_injection>` for more information on how to configure this.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault faults = 8;
     */
    faults: RedisProxy_RedisFault[];
    /**
     * If a username is provided an ACL style AUTH command will be required with a username and password.
     * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
     * AUTH command <https://redis.io/commands/auth>`_ with this username and the ``downstream_auth_password``
     * before enabling any other command. If an AUTH command's username and password matches this username
     * and the ``downstream_auth_password`` , an "OK" response will be returned to the client. If the AUTH
     * command username or password does not match this username or the ``downstream_auth_password``, then an
     * "WRONGPASS invalid username-password pair" error will be returned. If any other command is received before AUTH when this
     * password is set, then a "NOAUTH Authentication required." error response will be sent to the
     * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
     * AUTH, but no ACL is set" error will be returned.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource downstream_auth_username = 7;
     */
    downstreamAuthUsername?: DataSource;
}
/**
 * Redis connection pool settings.
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings
 */
export interface RedisProxy_ConnPoolSettings {
    /**
     * Per-operation timeout in milliseconds. The timer starts when the first
     * command of a pipeline is written to the backend connection. Each response received from Redis
     * resets the timer since it signifies that the next command is being processed by the backend.
     * The only exception to this behavior is when a connection to a backend is not yet established.
     * In that case, the connect timeout on the cluster will govern the timeout until the connection
     * is ready.
     *
     * @generated from protobuf field: google.protobuf.Duration op_timeout = 1;
     */
    opTimeout?: Duration;
    /**
     * Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
     * forwarded to the same upstream. The hash key used for determining the upstream in a
     * consistent hash ring configuration will be computed from the hash tagged key instead of the
     * whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
     * implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
     *
     * Examples:
     *
     * * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
     * * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
     *
     * @generated from protobuf field: bool enable_hashtagging = 2;
     */
    enableHashtagging: boolean;
    /**
     * Accept `moved and ask redirection
     * <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
     * redis servers, and retry commands to the specified target server. The target server does not
     * need to be known to the cluster manager. If the command cannot be redirected, then the
     * original error is passed downstream unchanged. By default, this support is not enabled.
     *
     * @generated from protobuf field: bool enable_redirection = 3;
     */
    enableRedirection: boolean;
    /**
     * If ``enable_redirection`` is set to true this option configures the DNS cache that the
     * connection pool will use to resolve hostnames that are returned with MOVED and ASK responses.
     * If no configuration is provided, DNS lookups will not be performed (and thus the MOVED/ASK errors
     * will be propagated verbatim to the user).
     *
     * @generated from protobuf field: envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 9;
     */
    dnsCacheConfig?: DnsCacheConfig;
    /**
     * Maximum size of encoded request buffer before flush is triggered and encoded requests
     * are sent upstream. If this is unset, the buffer flushes whenever it receives data
     * and performs no batching.
     * This feature makes it possible for multiple clients to send requests to Envoy and have
     * them batched- for example if one is running several worker processes, each with its own
     * Redis connection. There is no benefit to using this with a single downstream process.
     * Recommended size (if enabled) is 1024 bytes.
     *
     * @generated from protobuf field: uint32 max_buffer_size_before_flush = 4;
     */
    maxBufferSizeBeforeFlush: number;
    /**
     * The encoded request buffer is flushed N milliseconds after the first request has been
     * encoded, unless the buffer size has already exceeded ``max_buffer_size_before_flush``.
     * If ``max_buffer_size_before_flush`` is not set, this flush timer is not used. Otherwise,
     * the timer should be set according to the number of clients, overall request rate and
     * desired maximum latency for a single command. For example, if there are many requests
     * being batched together at a high rate, the buffer will likely be filled before the timer
     * fires. Alternatively, if the request rate is lower the buffer will not be filled as often
     * before the timer fires.
     * If ``max_buffer_size_before_flush`` is set, but ``buffer_flush_timeout`` is not, the latter
     * defaults to 3ms.
     *
     * @generated from protobuf field: google.protobuf.Duration buffer_flush_timeout = 5;
     */
    bufferFlushTimeout?: Duration;
    /**
     * ``max_upstream_unknown_connections`` controls how many upstream connections to unknown hosts
     * can be created at any given time by any given worker thread (see ``enable_redirection`` for
     * more details). If the host is unknown and a connection cannot be created due to enforcing
     * this limit, then redirection will fail and the original redirection error will be passed
     * downstream unchanged. This limit defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_upstream_unknown_connections = 6;
     */
    maxUpstreamUnknownConnections?: UInt32Value;
    /**
     * Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
     * count. These commands are measured in microseconds.
     *
     * @generated from protobuf field: bool enable_command_stats = 8;
     */
    enableCommandStats: boolean;
    /**
     * Read policy. The default is to read from the primary.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy read_policy = 7;
     */
    readPolicy: RedisProxy_ConnPoolSettings_ReadPolicy;
    /**
     * Ops or connection timeout triggers reconnection to redis server which could result in reconnection
     * storm to busy redis server. This config is a protection to rate limit reconnection rate.
     * If not set, there will be no rate limiting on the reconnection.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit connection_rate_limit = 10;
     */
    connectionRateLimit?: RedisProxy_ConnectionRateLimit;
}
/**
 * ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
 * supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
 * because replication is asynchronous and requires some delay. You need to ensure that your
 * application can tolerate stale data.
 *
 * @generated from protobuf enum envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy
 */
export enum RedisProxy_ConnPoolSettings_ReadPolicy {
    /**
     * Default mode. Read from the current primary node.
     *
     * @generated from protobuf enum value: MASTER = 0;
     */
    MASTER = 0,
    /**
     * Read from the primary, but if it is unavailable, read from replica nodes.
     *
     * @generated from protobuf enum value: PREFER_MASTER = 1;
     */
    PREFER_MASTER = 1,
    /**
     * Read from replica nodes. If multiple replica nodes are present within a shard, a random
     * node is selected. Healthy nodes have precedent over unhealthy nodes.
     *
     * @generated from protobuf enum value: REPLICA = 2;
     */
    REPLICA = 2,
    /**
     * Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
     * present or unhealthy), read from the primary.
     *
     * @generated from protobuf enum value: PREFER_REPLICA = 3;
     */
    PREFER_REPLICA = 3,
    /**
     * Read from any node of the cluster. A random node is selected among the primary and
     * replicas, healthy nodes have precedent over unhealthy nodes.
     *
     * @generated from protobuf enum value: ANY = 4;
     */
    ANY = 4
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes
 */
export interface RedisProxy_PrefixRoutes {
    /**
     * List of prefix routes.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route routes = 1;
     */
    routes: RedisProxy_PrefixRoutes_Route[];
    /**
     * Indicates that prefix matching should be case insensitive.
     *
     * @generated from protobuf field: bool case_insensitive = 2;
     */
    caseInsensitive: boolean;
    /**
     * Optional catch-all route to forward commands that doesn't match any of the routes. The
     * catch-all route becomes required when no routes are specified.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route catch_all_route = 4;
     */
    catchAllRoute?: RedisProxy_PrefixRoutes_Route;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route
 */
export interface RedisProxy_PrefixRoutes_Route {
    /**
     * String prefix that must match the beginning of the keys. Envoy will always favor the
     * longest match.
     *
     * @generated from protobuf field: string prefix = 1;
     */
    prefix: string;
    /**
     * Indicates if the prefix needs to be removed from the key when forwarded.
     *
     * @generated from protobuf field: bool remove_prefix = 2;
     */
    removePrefix: boolean;
    /**
     * Upstream cluster to forward the command to.
     *
     * @generated from protobuf field: string cluster = 3;
     */
    cluster: string;
    /**
     * Indicates that the route has a request mirroring policy.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy = 4;
     */
    requestMirrorPolicy: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy[];
    /**
     * Indicates how redis key should be formatted. To substitute redis key into the formatting
     * expression, use %KEY% as a string replacement command.
     *
     * @generated from protobuf field: string key_formatter = 5;
     */
    keyFormatter: string;
}
/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
 */
export interface RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    /**
     * Specifies the cluster that requests will be mirrored to. The cluster must
     * exist in the cluster manager configuration.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * If not specified or the runtime key is not present, all requests to the target cluster
     * will be mirrored.
     *
     * If specified, Envoy will lookup the runtime key to get the percentage of requests to the
     * mirror.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 2;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Set this to TRUE to only mirror write commands, this is effectively replicating the
     * writes in a "fire and forget" manner.
     *
     * @generated from protobuf field: bool exclude_read_commands = 3;
     */
    excludeReadCommands: boolean;
}
/**
 * RedisFault defines faults used for fault injection.
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault
 */
export interface RedisProxy_RedisFault {
    /**
     * Fault type.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType fault_type = 1;
     */
    faultType: RedisProxy_RedisFault_RedisFaultType;
    /**
     * Percentage of requests fault applies to.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent fault_enabled = 2;
     */
    faultEnabled?: RuntimeFractionalPercent;
    /**
     * Delay for all faults. If not set, defaults to zero
     *
     * @generated from protobuf field: google.protobuf.Duration delay = 3;
     */
    delay?: Duration;
    /**
     * Commands fault is restricted to, if any. If not set, fault applies to all commands
     * other than auth and ping (due to special handling of those commands in Envoy).
     *
     * @generated from protobuf field: repeated string commands = 4;
     */
    commands: string[];
}
/**
 * @generated from protobuf enum envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType
 */
export enum RedisProxy_RedisFault_RedisFaultType {
    /**
     * Delays requests. This is the base fault; other faults can have delays added.
     *
     * @generated from protobuf enum value: DELAY = 0;
     */
    DELAY = 0,
    /**
     * Returns errors on requests.
     *
     * @generated from protobuf enum value: ERROR = 1;
     */
    ERROR = 1
}
/**
 * Configuration to limit reconnection rate to redis server to protect redis server
 * from client reconnection storm.
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit
 */
export interface RedisProxy_ConnectionRateLimit {
    /**
     * Reconnection rate per sec. Rate limiting is implemented with TokenBucket.
     *
     * @generated from protobuf field: uint32 connection_rate_limit_per_sec = 1;
     */
    connectionRateLimitPerSec: number;
}
/**
 * RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.filters.network.redis_proxy``.
 *
 * @generated from protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions
 */
export interface RedisProtocolOptions {
    /**
     * Upstream server password as defined by the ``requirepass`` directive
     * `<https://redis.io/topics/config>`_ in the server's configuration file.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource auth_password = 1;
     */
    authPassword?: DataSource;
    /**
     * Upstream server username as defined by the ``user`` directive
     * `<https://redis.io/topics/acl>`_ in the server's configuration file.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource auth_username = 2;
     */
    authUsername?: DataSource;
}
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy$Type extends MessageType<RedisProxy> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "settings", kind: "message", T: () => RedisProxy_ConnPoolSettings, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "latency_in_micros", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "prefix_routes", kind: "message", T: () => RedisProxy_PrefixRoutes },
            { no: 6, name: "downstream_auth_password", kind: "message", T: () => DataSource, options: { "envoy.annotations.deprecated_at_minor_version": "3.0", "udpa.annotations.sensitive": true } },
            { no: 9, name: "downstream_auth_passwords", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 8, name: "faults", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RedisProxy_RedisFault },
            { no: 7, name: "downstream_auth_username", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProxy" } });
    }
    create(value?: PartialMessage<RedisProxy>): RedisProxy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        message.latencyInMicros = false;
        message.downstreamAuthPasswords = [];
        message.faults = [];
        if (value !== undefined)
            reflectionMergePartial<RedisProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy): RedisProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings settings */ 3:
                    message.settings = RedisProxy_ConnPoolSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* bool latency_in_micros */ 4:
                    message.latencyInMicros = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes prefix_routes */ 5:
                    message.prefixRoutes = RedisProxy_PrefixRoutes.internalBinaryRead(reader, reader.uint32(), options, message.prefixRoutes);
                    break;
                case /* envoy.config.core.v3.DataSource downstream_auth_password = 6 [deprecated = true];*/ 6:
                    message.downstreamAuthPassword = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.downstreamAuthPassword);
                    break;
                case /* repeated envoy.config.core.v3.DataSource downstream_auth_passwords */ 9:
                    message.downstreamAuthPasswords.push(DataSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault faults */ 8:
                    message.faults.push(RedisProxy_RedisFault.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.DataSource downstream_auth_username */ 7:
                    message.downstreamAuthUsername = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.downstreamAuthUsername);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings settings = 3; */
        if (message.settings)
            RedisProxy_ConnPoolSettings.internalBinaryWrite(message.settings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool latency_in_micros = 4; */
        if (message.latencyInMicros !== false)
            writer.tag(4, WireType.Varint).bool(message.latencyInMicros);
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes prefix_routes = 5; */
        if (message.prefixRoutes)
            RedisProxy_PrefixRoutes.internalBinaryWrite(message.prefixRoutes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource downstream_auth_password = 6 [deprecated = true]; */
        if (message.downstreamAuthPassword)
            DataSource.internalBinaryWrite(message.downstreamAuthPassword, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.DataSource downstream_auth_passwords = 9; */
        for (let i = 0; i < message.downstreamAuthPasswords.length; i++)
            DataSource.internalBinaryWrite(message.downstreamAuthPasswords[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault faults = 8; */
        for (let i = 0; i < message.faults.length; i++)
            RedisProxy_RedisFault.internalBinaryWrite(message.faults[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource downstream_auth_username = 7; */
        if (message.downstreamAuthUsername)
            DataSource.internalBinaryWrite(message.downstreamAuthUsername, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy
 */
export const RedisProxy = new RedisProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_ConnPoolSettings$Type extends MessageType<RedisProxy_ConnPoolSettings> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings", [
            { no: 1, name: "op_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true } } } },
            { no: 2, name: "enable_hashtagging", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "enable_redirection", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "dns_cache_config", kind: "message", T: () => DnsCacheConfig },
            { no: 4, name: "max_buffer_size_before_flush", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "buffer_flush_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "max_upstream_unknown_connections", kind: "message", T: () => UInt32Value },
            { no: 8, name: "enable_command_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "read_policy", kind: "enum", T: () => ["envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy", RedisProxy_ConnPoolSettings_ReadPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 10, name: "connection_rate_limit", kind: "message", T: () => RedisProxy_ConnectionRateLimit }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings" } });
    }
    create(value?: PartialMessage<RedisProxy_ConnPoolSettings>): RedisProxy_ConnPoolSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableHashtagging = false;
        message.enableRedirection = false;
        message.maxBufferSizeBeforeFlush = 0;
        message.enableCommandStats = false;
        message.readPolicy = 0;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_ConnPoolSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_ConnPoolSettings): RedisProxy_ConnPoolSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration op_timeout */ 1:
                    message.opTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.opTimeout);
                    break;
                case /* bool enable_hashtagging */ 2:
                    message.enableHashtagging = reader.bool();
                    break;
                case /* bool enable_redirection */ 3:
                    message.enableRedirection = reader.bool();
                    break;
                case /* envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config */ 9:
                    message.dnsCacheConfig = DnsCacheConfig.internalBinaryRead(reader, reader.uint32(), options, message.dnsCacheConfig);
                    break;
                case /* uint32 max_buffer_size_before_flush */ 4:
                    message.maxBufferSizeBeforeFlush = reader.uint32();
                    break;
                case /* google.protobuf.Duration buffer_flush_timeout */ 5:
                    message.bufferFlushTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.bufferFlushTimeout);
                    break;
                case /* google.protobuf.UInt32Value max_upstream_unknown_connections */ 6:
                    message.maxUpstreamUnknownConnections = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxUpstreamUnknownConnections);
                    break;
                case /* bool enable_command_stats */ 8:
                    message.enableCommandStats = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy read_policy */ 7:
                    message.readPolicy = reader.int32();
                    break;
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit connection_rate_limit */ 10:
                    message.connectionRateLimit = RedisProxy_ConnectionRateLimit.internalBinaryRead(reader, reader.uint32(), options, message.connectionRateLimit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_ConnPoolSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration op_timeout = 1; */
        if (message.opTimeout)
            Duration.internalBinaryWrite(message.opTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_hashtagging = 2; */
        if (message.enableHashtagging !== false)
            writer.tag(2, WireType.Varint).bool(message.enableHashtagging);
        /* bool enable_redirection = 3; */
        if (message.enableRedirection !== false)
            writer.tag(3, WireType.Varint).bool(message.enableRedirection);
        /* envoy.extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig dns_cache_config = 9; */
        if (message.dnsCacheConfig)
            DnsCacheConfig.internalBinaryWrite(message.dnsCacheConfig, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 max_buffer_size_before_flush = 4; */
        if (message.maxBufferSizeBeforeFlush !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxBufferSizeBeforeFlush);
        /* google.protobuf.Duration buffer_flush_timeout = 5; */
        if (message.bufferFlushTimeout)
            Duration.internalBinaryWrite(message.bufferFlushTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_upstream_unknown_connections = 6; */
        if (message.maxUpstreamUnknownConnections)
            UInt32Value.internalBinaryWrite(message.maxUpstreamUnknownConnections, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_command_stats = 8; */
        if (message.enableCommandStats !== false)
            writer.tag(8, WireType.Varint).bool(message.enableCommandStats);
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings.ReadPolicy read_policy = 7; */
        if (message.readPolicy !== 0)
            writer.tag(7, WireType.Varint).int32(message.readPolicy);
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit connection_rate_limit = 10; */
        if (message.connectionRateLimit)
            RedisProxy_ConnectionRateLimit.internalBinaryWrite(message.connectionRateLimit, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnPoolSettings
 */
export const RedisProxy_ConnPoolSettings = new RedisProxy_ConnPoolSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes$Type extends MessageType<RedisProxy_PrefixRoutes> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RedisProxy_PrefixRoutes_Route },
            { no: 2, name: "case_insensitive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "catch_all_route", kind: "message", T: () => RedisProxy_PrefixRoutes_Route }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes" } });
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes>): RedisProxy_PrefixRoutes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routes = [];
        message.caseInsensitive = false;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes): RedisProxy_PrefixRoutes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route routes */ 1:
                    message.routes.push(RedisProxy_PrefixRoutes_Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool case_insensitive */ 2:
                    message.caseInsensitive = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route catch_all_route */ 4:
                    message.catchAllRoute = RedisProxy_PrefixRoutes_Route.internalBinaryRead(reader, reader.uint32(), options, message.catchAllRoute);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            RedisProxy_PrefixRoutes_Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool case_insensitive = 2; */
        if (message.caseInsensitive !== false)
            writer.tag(2, WireType.Varint).bool(message.caseInsensitive);
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route catch_all_route = 4; */
        if (message.catchAllRoute)
            RedisProxy_PrefixRoutes_Route.internalBinaryWrite(message.catchAllRoute, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes
 */
export const RedisProxy_PrefixRoutes = new RedisProxy_PrefixRoutes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes_Route$Type extends MessageType<RedisProxy_PrefixRoutes_Route> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route", [
            { no: 1, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1000" } } } },
            { no: 2, name: "remove_prefix", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "request_mirror_policy", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy },
            { no: 5, name: "key_formatter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route" } });
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes_Route>): RedisProxy_PrefixRoutes_Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefix = "";
        message.removePrefix = false;
        message.cluster = "";
        message.requestMirrorPolicy = [];
        message.keyFormatter = "";
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes_Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes_Route): RedisProxy_PrefixRoutes_Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prefix */ 1:
                    message.prefix = reader.string();
                    break;
                case /* bool remove_prefix */ 2:
                    message.removePrefix = reader.bool();
                    break;
                case /* string cluster */ 3:
                    message.cluster = reader.string();
                    break;
                case /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy */ 4:
                    message.requestMirrorPolicy.push(RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string key_formatter */ 5:
                    message.keyFormatter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes_Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prefix = 1; */
        if (message.prefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prefix);
        /* bool remove_prefix = 2; */
        if (message.removePrefix !== false)
            writer.tag(2, WireType.Varint).bool(message.removePrefix);
        /* string cluster = 3; */
        if (message.cluster !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cluster);
        /* repeated envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy = 4; */
        for (let i = 0; i < message.requestMirrorPolicy.length; i++)
            RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicy[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string key_formatter = 5; */
        if (message.keyFormatter !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.keyFormatter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route
 */
export const RedisProxy_PrefixRoutes_Route = new RedisProxy_PrefixRoutes_Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy$Type extends MessageType<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 3, name: "exclude_read_commands", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy" } });
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.excludeReadCommands = false;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction */ 2:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* bool exclude_read_commands */ 3:
                    message.excludeReadCommands = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 2; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool exclude_read_commands = 3; */
        if (message.excludeReadCommands !== false)
            writer.tag(3, WireType.Varint).bool(message.excludeReadCommands);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
 */
export const RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy = new RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_RedisFault$Type extends MessageType<RedisProxy_RedisFault> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault", [
            { no: 1, name: "fault_type", kind: "enum", T: () => ["envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType", RedisProxy_RedisFault_RedisFaultType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "fault_enabled", kind: "message", T: () => RuntimeFractionalPercent, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "delay", kind: "message", T: () => Duration },
            { no: 4, name: "commands", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_RedisFault>): RedisProxy_RedisFault {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.faultType = 0;
        message.commands = [];
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_RedisFault>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_RedisFault): RedisProxy_RedisFault {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType fault_type */ 1:
                    message.faultType = reader.int32();
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent fault_enabled */ 2:
                    message.faultEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.faultEnabled);
                    break;
                case /* google.protobuf.Duration delay */ 3:
                    message.delay = Duration.internalBinaryRead(reader, reader.uint32(), options, message.delay);
                    break;
                case /* repeated string commands */ 4:
                    message.commands.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_RedisFault, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault.RedisFaultType fault_type = 1; */
        if (message.faultType !== 0)
            writer.tag(1, WireType.Varint).int32(message.faultType);
        /* envoy.config.core.v3.RuntimeFractionalPercent fault_enabled = 2; */
        if (message.faultEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.faultEnabled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration delay = 3; */
        if (message.delay)
            Duration.internalBinaryWrite(message.delay, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated string commands = 4; */
        for (let i = 0; i < message.commands.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.commands[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.RedisFault
 */
export const RedisProxy_RedisFault = new RedisProxy_RedisFault$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_ConnectionRateLimit$Type extends MessageType<RedisProxy_ConnectionRateLimit> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit", [
            { no: 1, name: "connection_rate_limit_per_sec", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_ConnectionRateLimit>): RedisProxy_ConnectionRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.connectionRateLimitPerSec = 0;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_ConnectionRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_ConnectionRateLimit): RedisProxy_ConnectionRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 connection_rate_limit_per_sec */ 1:
                    message.connectionRateLimitPerSec = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_ConnectionRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 connection_rate_limit_per_sec = 1; */
        if (message.connectionRateLimitPerSec !== 0)
            writer.tag(1, WireType.Varint).uint32(message.connectionRateLimitPerSec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProxy.ConnectionRateLimit
 */
export const RedisProxy_ConnectionRateLimit = new RedisProxy_ConnectionRateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProtocolOptions$Type extends MessageType<RedisProtocolOptions> {
    constructor() {
        super("envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions", [
            { no: 1, name: "auth_password", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 2, name: "auth_username", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions" } });
    }
    create(value?: PartialMessage<RedisProtocolOptions>): RedisProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RedisProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProtocolOptions): RedisProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.DataSource auth_password */ 1:
                    message.authPassword = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.authPassword);
                    break;
                case /* envoy.config.core.v3.DataSource auth_username */ 2:
                    message.authUsername = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.authUsername);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.DataSource auth_password = 1; */
        if (message.authPassword)
            DataSource.internalBinaryWrite(message.authPassword, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource auth_username = 2; */
        if (message.authUsername)
            DataSource.internalBinaryWrite(message.authUsername, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.redis_proxy.v3.RedisProtocolOptions
 */
export const RedisProtocolOptions = new RedisProtocolOptions$Type();
