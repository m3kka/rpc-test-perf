// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/filters/network/dubbo_proxy/v3/route.proto (package envoy.extensions.filters.network.dubbo_proxy.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { HeaderMatcher, WeightedCluster } from "../../../../../config/route/v3/route_components_pb.js";
import type { Metadata } from "../../../../../config/core/v3/base_pb.js";
import type { StringMatcher } from "../../../../../type/matcher/v3/string_pb.js";
import type { Int64Range } from "../../../../../type/v3/range_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration
 */
export declare class RouteConfiguration extends Message<RouteConfiguration> {
  /**
   * The name of the route configuration. Reserved for future use in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The interface name of the service. Wildcard interface are supported in the suffix or prefix form.
   * e.g. ``*.methods.add`` will match ``com.dev.methods.add``, ``com.prod.methods.add``, etc.
   * ``com.dev.methods.*`` will match ``com.dev.methods.add``, ``com.dev.methods.update``, etc.
   * Special wildcard ``*`` matching any interface.
   *
   * .. note::
   *
   *  The wildcard will not match the empty string.
   *  e.g. ``*.methods.add`` will match ``com.dev.methods.add`` but not ``.methods.add``.
   *
   * @generated from field: string interface = 2;
   */
  interface: string;

  /**
   * Which group does the interface belong to.
   *
   * @generated from field: string group = 3;
   */
  group: string;

  /**
   * The version number of the interface.
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * The list of routes that will be matched, in order, against incoming requests. The first route
   * that matches will be used.
   *
   * @generated from field: repeated envoy.extensions.filters.network.dubbo_proxy.v3.Route routes = 5;
   */
  routes: Route[];

  constructor(data?: PartialMessage<RouteConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteConfiguration;

  static equals(a: RouteConfiguration | PlainMessage<RouteConfiguration> | undefined, b: RouteConfiguration | PlainMessage<RouteConfiguration> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.Route
 */
export declare class Route extends Message<Route> {
  /**
   * Route matching parameters.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * Route request to some upstream cluster.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction route = 2;
   */
  route?: RouteAction;

  constructor(data?: PartialMessage<Route>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.Route";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Route;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Route;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Route;

  static equals(a: Route | PlainMessage<Route> | undefined, b: Route | PlainMessage<Route> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch
 */
export declare class RouteMatch extends Message<RouteMatch> {
  /**
   * Method level routing matching.
   *
   * @generated from field: envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch method = 1;
   */
  method?: MethodMatch;

  /**
   * Specifies a set of headers that the route should match on. The router will check the requestâ€™s
   * headers against all the specified headers in the route config. A match will happen if all the
   * headers in the route are present in the request with the same values (or based on presence if
   * the value field is not in the config).
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 2;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<RouteMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.RouteMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatch;

  static equals(a: RouteMatch | PlainMessage<RouteMatch> | undefined, b: RouteMatch | PlainMessage<RouteMatch> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction
 */
export declare class RouteAction extends Message<RouteAction> {
  /**
   * @generated from oneof envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * Indicates the upstream cluster to which the request should be routed.
     *
     * @generated from field: string cluster = 1;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     * Currently ClusterWeight only supports the name and weight fields.
     *
     * @generated from field: envoy.config.route.v3.WeightedCluster weighted_clusters = 2;
     */
    value: WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };

  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
   * the upstream cluster with metadata matching what is set in this field will be considered for
   * load balancing. The filter name should be specified as ``envoy.lb``.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata_match = 3;
   */
  metadataMatch?: Metadata;

  constructor(data?: PartialMessage<RouteAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.RouteAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction;

  static equals(a: RouteAction | PlainMessage<RouteAction> | undefined, b: RouteAction | PlainMessage<RouteAction> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch
 */
export declare class MethodMatch extends Message<MethodMatch> {
  /**
   * The name of the method.
   *
   * @generated from field: envoy.type.matcher.v3.StringMatcher name = 1;
   */
  name?: StringMatcher;

  /**
   * Method parameter definition.
   * The key is the parameter index, starting from 0.
   * The value is the parameter matching type.
   *
   * @generated from field: map<uint32, envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier> params_match = 2;
   */
  paramsMatch: { [key: number]: MethodMatch_ParameterMatchSpecifier };

  constructor(data?: PartialMessage<MethodMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodMatch;

  static equals(a: MethodMatch | PlainMessage<MethodMatch> | undefined, b: MethodMatch | PlainMessage<MethodMatch> | undefined): boolean;
}

/**
 * The parameter matching type.
 *
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier
 */
export declare class MethodMatch_ParameterMatchSpecifier extends Message<MethodMatch_ParameterMatchSpecifier> {
  /**
   * @generated from oneof envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier.parameter_match_specifier
   */
  parameterMatchSpecifier: {
    /**
     * If specified, header match will be performed based on the value of the header.
     *
     * @generated from field: string exact_match = 3;
     */
    value: string;
    case: "exactMatch";
  } | {
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting
     * of an optional plus or minus sign followed by a sequence of digits. The rule will not match
     * if the header value does not represent an integer. Match will fail for empty values,
     * floating point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0,
     *   "somestring", 10.9, "-1somestring"
     *
     * @generated from field: envoy.type.v3.Int64Range range_match = 4;
     */
    value: Int64Range;
    case: "rangeMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<MethodMatch_ParameterMatchSpecifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.MethodMatch.ParameterMatchSpecifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static equals(a: MethodMatch_ParameterMatchSpecifier | PlainMessage<MethodMatch_ParameterMatchSpecifier> | undefined, b: MethodMatch_ParameterMatchSpecifier | PlainMessage<MethodMatch_ParameterMatchSpecifier> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.dubbo_proxy.v3.MultipleRouteConfiguration
 */
export declare class MultipleRouteConfiguration extends Message<MultipleRouteConfiguration> {
  /**
   * The name of the named route configurations. This name is used in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The route table of the dubbo connection manager.
   *
   * @generated from field: repeated envoy.extensions.filters.network.dubbo_proxy.v3.RouteConfiguration route_config = 4;
   */
  routeConfig: RouteConfiguration[];

  constructor(data?: PartialMessage<MultipleRouteConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.dubbo_proxy.v3.MultipleRouteConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MultipleRouteConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MultipleRouteConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MultipleRouteConfiguration;

  static equals(a: MultipleRouteConfiguration | PlainMessage<MultipleRouteConfiguration> | undefined, b: MultipleRouteConfiguration | PlainMessage<MultipleRouteConfiguration> | undefined): boolean;
}

