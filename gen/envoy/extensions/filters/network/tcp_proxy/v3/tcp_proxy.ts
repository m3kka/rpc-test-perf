// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto" (package "envoy.extensions.filters.network.tcp_proxy.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ConfigSource } from "../../../../../config/core/v3/config_source";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { HashPolicy } from "../../../../../type/v3/hash_policy";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { Duration } from "../../../../../../google/protobuf/duration";
import { Metadata } from "../../../../../config/core/v3/base";
// [#protodoc-title: TCP Proxy]
// TCP Proxy :ref:`configuration overview <config_network_filters_tcp_proxy>`.
// [#extension: envoy.filters.network.tcp_proxy]

/**
 * [#next-free-field: 18]
 *
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
 */
export interface TcpProxy {
    /**
     * The prefix to use when emitting :ref:`statistics
     * <config_network_filters_tcp_proxy_stats>`.
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * @generated from protobuf oneof: cluster_specifier
     */
    clusterSpecifier: {
        oneofKind: "cluster";
        /**
         * The upstream cluster to connect to.
         *
         * @generated from protobuf field: string cluster = 2;
         */
        cluster: string;
    } | {
        oneofKind: "weightedClusters";
        /**
         * Multiple upstream clusters can be specified for a given route. The
         * request is routed to one of the upstream clusters based on weights
         * assigned to each cluster.
         *
         * @generated from protobuf field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster weighted_clusters = 10;
         */
        weightedClusters: TcpProxy_WeightedCluster;
    } | {
        oneofKind: undefined;
    };
    /**
     * The on demand policy for the upstream cluster.
     * It applies to both
     * :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
     * and
     * :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand on_demand = 14;
     */
    onDemand?: TcpProxy_OnDemand;
    /**
     * Optional endpoint metadata match criteria. Only endpoints in the upstream
     * cluster with metadata matching that set in metadata_match will be
     * considered. The filter name should be specified as ``envoy.lb``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata_match = 9;
     */
    metadataMatch?: Metadata;
    /**
     * The idle timeout for connections managed by the TCP proxy filter. The idle timeout
     * is defined as the period in which there are no bytes sent or received on either
     * the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
     * to 0s, the timeout will be disabled.
     *
     * .. warning::
     *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
     *   FIN packets, etc.
     *
     * @generated from protobuf field: google.protobuf.Duration idle_timeout = 8;
     */
    idleTimeout?: Duration;
    /**
     * [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
     * filter. The idle timeout is defined as the period in which there is no
     * active traffic. If not set, there is no idle timeout. When the idle timeout
     * is reached the connection will be closed. The distinction between
     * downstream_idle_timeout/upstream_idle_timeout provides a means to set
     * timeout based on the last byte sent on the downstream/upstream connection.
     *
     * @generated from protobuf field: google.protobuf.Duration downstream_idle_timeout = 3;
     */
    downstreamIdleTimeout?: Duration;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.Duration upstream_idle_timeout = 4;
     */
    upstreamIdleTimeout?: Duration;
    /**
     * Configuration for :ref:`access logs <arch_overview_access_logs>`
     * emitted by the this tcp_proxy.
     *
     * @generated from protobuf field: repeated envoy.config.accesslog.v3.AccessLog access_log = 5;
     */
    accessLog: AccessLog[];
    /**
     * The maximum number of unsuccessful connection attempts that will be made before
     * giving up. If the parameter is not specified, 1 connection attempt will be made.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_connect_attempts = 7;
     */
    maxConnectAttempts?: UInt32Value;
    /**
     * Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
     * load balancing algorithms will select a host randomly. Currently the number of hash policies is
     * limited to 1.
     *
     * @generated from protobuf field: repeated envoy.type.v3.HashPolicy hash_policy = 11;
     */
    hashPolicy: HashPolicy[];
    /**
     * If set, this configures tunneling, e.g. configuration options to tunnel TCP payload over
     * HTTP CONNECT. If this message is absent, the payload will be proxied upstream as per usual.
     * It is possible to dynamically override this configuration and disable tunneling per connection,
     * by setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig tunneling_config = 12;
     */
    tunnelingConfig?: TcpProxy_TunnelingConfig;
    /**
     * The maximum duration of a connection. The duration is defined as the period since a connection
     * was established. If not set, there is no max duration. When max_downstream_connection_duration
     * is reached the connection will be closed. Duration must be at least 1ms.
     *
     * @generated from protobuf field: google.protobuf.Duration max_downstream_connection_duration = 13;
     */
    maxDownstreamConnectionDuration?: Duration;
    /**
     * .. attention::
     * This field is deprecated in favor of
     * :ref:`access_log_flush_interval
     * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
     * Note that if both this field and :ref:`access_log_flush_interval
     * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
     * are specified, the former (deprecated field) is ignored.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.Duration access_log_flush_interval = 15 [deprecated = true];
     */
    accessLogFlushInterval?: Duration;
    /**
     * .. attention::
     * This field is deprecated in favor of
     * :ref:`flush_access_log_on_connected
     * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
     * Note that if both this field and :ref:`flush_access_log_on_connected
     * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
     * are specified, the former (deprecated field) is ignored.
     *
     * @deprecated
     * @generated from protobuf field: bool flush_access_log_on_connected = 16 [deprecated = true];
     */
    flushAccessLogOnConnected: boolean;
    /**
     * Additional access log options for TCP Proxy.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions access_log_options = 17;
     */
    accessLogOptions?: TcpProxy_TcpAccessLogOptions;
}
/**
 * Allows for specification of multiple upstream clusters along with weights
 * that indicate the percentage of traffic to be forwarded to each cluster.
 * The router selects an upstream cluster based on these weights.
 *
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster
 */
export interface TcpProxy_WeightedCluster {
    /**
     * Specifies one or more upstream clusters associated with the route.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight clusters = 1;
     */
    clusters: TcpProxy_WeightedCluster_ClusterWeight[];
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight
 */
export interface TcpProxy_WeightedCluster_ClusterWeight {
    /**
     * Name of the upstream cluster.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * When a request matches the route, the choice of an upstream cluster is
     * determined by its weight. The sum of weights across all entries in the
     * clusters array determines the total weight.
     *
     * @generated from protobuf field: uint32 weight = 2;
     */
    weight: number;
    /**
     * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
     * in the upstream cluster with metadata matching what is set in this field will be considered
     * for load balancing. Note that this will be merged with what's provided in
     * :ref:`TcpProxy.metadata_match
     * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
     * here taking precedence. The filter name should be specified as ``envoy.lb``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata_match = 3;
     */
    metadataMatch?: Metadata;
}
/**
 * Configuration for tunneling TCP over other transports or application layers.
 * Tunneling is supported over both HTTP/1.1 and HTTP/2. Upstream protocol is
 * determined by the cluster configuration.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig
 */
export interface TcpProxy_TunnelingConfig {
    /**
     * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
     * This field evaluates command operators if set, otherwise returns hostname as is.
     *
     * Example: dynamically set hostname using downstream SNI
     *
     * .. code-block:: yaml
     *
     *    tunneling_config:
     *      hostname: "%REQUESTED_SERVER_NAME%:443"
     *
     * Example: dynamically set hostname using dynamic metadata
     *
     * .. code-block:: yaml
     *
     *    tunneling_config:
     *      hostname: "%DYNAMIC_METADATA(tunnel:address)%"
     *
     *
     * @generated from protobuf field: string hostname = 1;
     */
    hostname: string;
    /**
     * Use POST method instead of CONNECT method to tunnel the TCP stream.
     * The 'protocol: bytestream' header is also NOT set for HTTP/2 to comply with the spec.
     *
     * The upstream proxy is expected to convert POST payload as raw TCP.
     *
     * @generated from protobuf field: bool use_post = 2;
     */
    usePost: boolean;
    /**
     * Additional request headers to upstream proxy. This is mainly used to
     * trigger upstream to convert POST requests back to CONNECT requests.
     *
     * Neither ``:-prefixed`` pseudo-headers nor the Host: header can be overridden.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 3;
     */
    headersToAdd: HeaderValueOption[];
    /**
     * Save the response headers to the downstream info filter state for consumption
     * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
     *
     * @generated from protobuf field: bool propagate_response_headers = 4;
     */
    propagateResponseHeaders: boolean;
    /**
     * The path used with POST method. Default path is ``/``. If post path is specified and
     * :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
     * isn't true, it will be rejected.
     *
     * @generated from protobuf field: string post_path = 5;
     */
    postPath: string;
    /**
     * Save the response trailers to the downstream info filter state for consumption
     * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
     *
     * @generated from protobuf field: bool propagate_response_trailers = 6;
     */
    propagateResponseTrailers: boolean;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand
 */
export interface TcpProxy_OnDemand {
    /**
     * An optional configuration for on-demand cluster discovery
     * service. If not specified, the on-demand cluster discovery will
     * be disabled. When it's specified, the filter will pause a request
     * to an unknown cluster and will begin a cluster discovery
     * process. When the discovery is finished (successfully or not),
     * the request will be resumed.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource odcds_config = 1;
     */
    odcdsConfig?: ConfigSource;
    /**
     * xdstp:// resource locator for on-demand cluster collection.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string resources_locator = 2;
     */
    resourcesLocator: string;
    /**
     * The timeout for on demand cluster lookup. If the CDS cannot return the required cluster,
     * the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 3;
     */
    timeout?: Duration;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions
 */
export interface TcpProxy_TcpAccessLogOptions {
    /**
     * The interval to flush access log. The TCP proxy will flush only one access log when the connection
     * is closed by default. If this field is set, the TCP proxy will flush access log periodically with
     * the specified interval.
     * The interval must be at least 1ms.
     *
     * @generated from protobuf field: google.protobuf.Duration access_log_flush_interval = 1;
     */
    accessLogFlushInterval?: Duration;
    /**
     * If set to true, access log will be flushed when the TCP proxy has successfully established a
     * connection with the upstream. If the connection failed, the access log will not be flushed.
     *
     * @generated from protobuf field: bool flush_access_log_on_connected = 2;
     */
    flushAccessLogOnConnected: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy$Type extends MessageType<TcpProxy> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "cluster", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "weighted_clusters", kind: "message", oneof: "clusterSpecifier", T: () => TcpProxy_WeightedCluster },
            { no: 14, name: "on_demand", kind: "message", T: () => TcpProxy_OnDemand },
            { no: 9, name: "metadata_match", kind: "message", T: () => Metadata },
            { no: 8, name: "idle_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "downstream_idle_timeout", kind: "message", T: () => Duration },
            { no: 4, name: "upstream_idle_timeout", kind: "message", T: () => Duration },
            { no: 5, name: "access_log", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLog },
            { no: 7, name: "max_connect_attempts", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 11, name: "hash_policy", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HashPolicy, options: { "validate.rules": { repeated: { maxItems: "1" } } } },
            { no: 12, name: "tunneling_config", kind: "message", T: () => TcpProxy_TunnelingConfig },
            { no: 13, name: "max_downstream_connection_duration", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } } } },
            { no: 15, name: "access_log_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } }, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 16, name: "flush_access_log_on_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 17, name: "access_log_options", kind: "message", T: () => TcpProxy_TcpAccessLogOptions }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy" } });
    }
    create(value?: PartialMessage<TcpProxy>): TcpProxy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        message.clusterSpecifier = { oneofKind: undefined };
        message.accessLog = [];
        message.hashPolicy = [];
        message.flushAccessLogOnConnected = false;
        if (value !== undefined)
            reflectionMergePartial<TcpProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy): TcpProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* string cluster */ 2:
                    message.clusterSpecifier = {
                        oneofKind: "cluster",
                        cluster: reader.string()
                    };
                    break;
                case /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster weighted_clusters */ 10:
                    message.clusterSpecifier = {
                        oneofKind: "weightedClusters",
                        weightedClusters: TcpProxy_WeightedCluster.internalBinaryRead(reader, reader.uint32(), options, (message.clusterSpecifier as any).weightedClusters)
                    };
                    break;
                case /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand on_demand */ 14:
                    message.onDemand = TcpProxy_OnDemand.internalBinaryRead(reader, reader.uint32(), options, message.onDemand);
                    break;
                case /* envoy.config.core.v3.Metadata metadata_match */ 9:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                case /* google.protobuf.Duration idle_timeout */ 8:
                    message.idleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.idleTimeout);
                    break;
                case /* google.protobuf.Duration downstream_idle_timeout */ 3:
                    message.downstreamIdleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.downstreamIdleTimeout);
                    break;
                case /* google.protobuf.Duration upstream_idle_timeout */ 4:
                    message.upstreamIdleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.upstreamIdleTimeout);
                    break;
                case /* repeated envoy.config.accesslog.v3.AccessLog access_log */ 5:
                    message.accessLog.push(AccessLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value max_connect_attempts */ 7:
                    message.maxConnectAttempts = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxConnectAttempts);
                    break;
                case /* repeated envoy.type.v3.HashPolicy hash_policy */ 11:
                    message.hashPolicy.push(HashPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig tunneling_config */ 12:
                    message.tunnelingConfig = TcpProxy_TunnelingConfig.internalBinaryRead(reader, reader.uint32(), options, message.tunnelingConfig);
                    break;
                case /* google.protobuf.Duration max_downstream_connection_duration */ 13:
                    message.maxDownstreamConnectionDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxDownstreamConnectionDuration);
                    break;
                case /* google.protobuf.Duration access_log_flush_interval = 15 [deprecated = true];*/ 15:
                    message.accessLogFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.accessLogFlushInterval);
                    break;
                case /* bool flush_access_log_on_connected = 16 [deprecated = true];*/ 16:
                    message.flushAccessLogOnConnected = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions access_log_options */ 17:
                    message.accessLogOptions = TcpProxy_TcpAccessLogOptions.internalBinaryRead(reader, reader.uint32(), options, message.accessLogOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* string cluster = 2; */
        if (message.clusterSpecifier.oneofKind === "cluster")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterSpecifier.cluster);
        /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster weighted_clusters = 10; */
        if (message.clusterSpecifier.oneofKind === "weightedClusters")
            TcpProxy_WeightedCluster.internalBinaryWrite(message.clusterSpecifier.weightedClusters, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand on_demand = 14; */
        if (message.onDemand)
            TcpProxy_OnDemand.internalBinaryWrite(message.onDemand, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata_match = 9; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration idle_timeout = 8; */
        if (message.idleTimeout)
            Duration.internalBinaryWrite(message.idleTimeout, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration downstream_idle_timeout = 3; */
        if (message.downstreamIdleTimeout)
            Duration.internalBinaryWrite(message.downstreamIdleTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration upstream_idle_timeout = 4; */
        if (message.upstreamIdleTimeout)
            Duration.internalBinaryWrite(message.upstreamIdleTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.accesslog.v3.AccessLog access_log = 5; */
        for (let i = 0; i < message.accessLog.length; i++)
            AccessLog.internalBinaryWrite(message.accessLog[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_connect_attempts = 7; */
        if (message.maxConnectAttempts)
            UInt32Value.internalBinaryWrite(message.maxConnectAttempts, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.v3.HashPolicy hash_policy = 11; */
        for (let i = 0; i < message.hashPolicy.length; i++)
            HashPolicy.internalBinaryWrite(message.hashPolicy[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig tunneling_config = 12; */
        if (message.tunnelingConfig)
            TcpProxy_TunnelingConfig.internalBinaryWrite(message.tunnelingConfig, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_downstream_connection_duration = 13; */
        if (message.maxDownstreamConnectionDuration)
            Duration.internalBinaryWrite(message.maxDownstreamConnectionDuration, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration access_log_flush_interval = 15 [deprecated = true]; */
        if (message.accessLogFlushInterval)
            Duration.internalBinaryWrite(message.accessLogFlushInterval, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* bool flush_access_log_on_connected = 16 [deprecated = true]; */
        if (message.flushAccessLogOnConnected !== false)
            writer.tag(16, WireType.Varint).bool(message.flushAccessLogOnConnected);
        /* envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions access_log_options = 17; */
        if (message.accessLogOptions)
            TcpProxy_TcpAccessLogOptions.internalBinaryWrite(message.accessLogOptions, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
 */
export const TcpProxy = new TcpProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy_WeightedCluster$Type extends MessageType<TcpProxy_WeightedCluster> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TcpProxy_WeightedCluster_ClusterWeight, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster" } });
    }
    create(value?: PartialMessage<TcpProxy_WeightedCluster>): TcpProxy_WeightedCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        if (value !== undefined)
            reflectionMergePartial<TcpProxy_WeightedCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy_WeightedCluster): TcpProxy_WeightedCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight clusters */ 1:
                    message.clusters.push(TcpProxy_WeightedCluster_ClusterWeight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy_WeightedCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            TcpProxy_WeightedCluster_ClusterWeight.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster
 */
export const TcpProxy_WeightedCluster = new TcpProxy_WeightedCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy_WeightedCluster_ClusterWeight$Type extends MessageType<TcpProxy_WeightedCluster_ClusterWeight> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "weight", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 3, name: "metadata_match", kind: "message", T: () => Metadata }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.WeightedCluster.ClusterWeight" } });
    }
    create(value?: PartialMessage<TcpProxy_WeightedCluster_ClusterWeight>): TcpProxy_WeightedCluster_ClusterWeight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.weight = 0;
        if (value !== undefined)
            reflectionMergePartial<TcpProxy_WeightedCluster_ClusterWeight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy_WeightedCluster_ClusterWeight): TcpProxy_WeightedCluster_ClusterWeight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint32 weight */ 2:
                    message.weight = reader.uint32();
                    break;
                case /* envoy.config.core.v3.Metadata metadata_match */ 3:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy_WeightedCluster_ClusterWeight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint32 weight = 2; */
        if (message.weight !== 0)
            writer.tag(2, WireType.Varint).uint32(message.weight);
        /* envoy.config.core.v3.Metadata metadata_match = 3; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight
 */
export const TcpProxy_WeightedCluster_ClusterWeight = new TcpProxy_WeightedCluster_ClusterWeight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy_TunnelingConfig$Type extends MessageType<TcpProxy_TunnelingConfig> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig", [
            { no: 1, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "use_post", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 4, name: "propagate_response_headers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "post_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "propagate_response_trailers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.network.tcp_proxy.v2.TcpProxy.TunnelingConfig" } });
    }
    create(value?: PartialMessage<TcpProxy_TunnelingConfig>): TcpProxy_TunnelingConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        message.usePost = false;
        message.headersToAdd = [];
        message.propagateResponseHeaders = false;
        message.postPath = "";
        message.propagateResponseTrailers = false;
        if (value !== undefined)
            reflectionMergePartial<TcpProxy_TunnelingConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy_TunnelingConfig): TcpProxy_TunnelingConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hostname */ 1:
                    message.hostname = reader.string();
                    break;
                case /* bool use_post */ 2:
                    message.usePost = reader.bool();
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption headers_to_add */ 3:
                    message.headersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool propagate_response_headers */ 4:
                    message.propagateResponseHeaders = reader.bool();
                    break;
                case /* string post_path */ 5:
                    message.postPath = reader.string();
                    break;
                case /* bool propagate_response_trailers */ 6:
                    message.propagateResponseTrailers = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy_TunnelingConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hostname = 1; */
        if (message.hostname !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostname);
        /* bool use_post = 2; */
        if (message.usePost !== false)
            writer.tag(2, WireType.Varint).bool(message.usePost);
        /* repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 3; */
        for (let i = 0; i < message.headersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.headersToAdd[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool propagate_response_headers = 4; */
        if (message.propagateResponseHeaders !== false)
            writer.tag(4, WireType.Varint).bool(message.propagateResponseHeaders);
        /* string post_path = 5; */
        if (message.postPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.postPath);
        /* bool propagate_response_trailers = 6; */
        if (message.propagateResponseTrailers !== false)
            writer.tag(6, WireType.Varint).bool(message.propagateResponseTrailers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig
 */
export const TcpProxy_TunnelingConfig = new TcpProxy_TunnelingConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy_OnDemand$Type extends MessageType<TcpProxy_OnDemand> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand", [
            { no: 1, name: "odcds_config", kind: "message", T: () => ConfigSource },
            { no: 2, name: "resources_locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<TcpProxy_OnDemand>): TcpProxy_OnDemand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resourcesLocator = "";
        if (value !== undefined)
            reflectionMergePartial<TcpProxy_OnDemand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy_OnDemand): TcpProxy_OnDemand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource odcds_config */ 1:
                    message.odcdsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.odcdsConfig);
                    break;
                case /* string resources_locator */ 2:
                    message.resourcesLocator = reader.string();
                    break;
                case /* google.protobuf.Duration timeout */ 3:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy_OnDemand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource odcds_config = 1; */
        if (message.odcdsConfig)
            ConfigSource.internalBinaryWrite(message.odcdsConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string resources_locator = 2; */
        if (message.resourcesLocator !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourcesLocator);
        /* google.protobuf.Duration timeout = 3; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand
 */
export const TcpProxy_OnDemand = new TcpProxy_OnDemand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TcpProxy_TcpAccessLogOptions$Type extends MessageType<TcpProxy_TcpAccessLogOptions> {
    constructor() {
        super("envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions", [
            { no: 1, name: "access_log_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } } } },
            { no: 2, name: "flush_access_log_on_connected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TcpProxy_TcpAccessLogOptions>): TcpProxy_TcpAccessLogOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flushAccessLogOnConnected = false;
        if (value !== undefined)
            reflectionMergePartial<TcpProxy_TcpAccessLogOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProxy_TcpAccessLogOptions): TcpProxy_TcpAccessLogOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration access_log_flush_interval */ 1:
                    message.accessLogFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.accessLogFlushInterval);
                    break;
                case /* bool flush_access_log_on_connected */ 2:
                    message.flushAccessLogOnConnected = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TcpProxy_TcpAccessLogOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration access_log_flush_interval = 1; */
        if (message.accessLogFlushInterval)
            Duration.internalBinaryWrite(message.accessLogFlushInterval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool flush_access_log_on_connected = 2; */
        if (message.flushAccessLogOnConnected !== false)
            writer.tag(2, WireType.Varint).bool(message.flushAccessLogOnConnected);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions
 */
export const TcpProxy_TcpAccessLogOptions = new TcpProxy_TcpAccessLogOptions$Type();
