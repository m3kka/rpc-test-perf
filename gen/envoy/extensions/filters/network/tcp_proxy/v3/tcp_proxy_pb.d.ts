// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto (package envoy.extensions.filters.network.tcp_proxy.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { HeaderValueOption, Metadata } from "../../../../../config/core/v3/base_pb.js";
import type { AccessLog } from "../../../../../config/accesslog/v3/accesslog_pb.js";
import type { HashPolicy } from "../../../../../type/v3/hash_policy_pb.js";
import type { ConfigSource } from "../../../../../config/core/v3/config_source_pb.js";

/**
 * [#next-free-field: 18]
 *
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
 */
export declare class TcpProxy extends Message<TcpProxy> {
  /**
   * The prefix to use when emitting :ref:`statistics
   * <config_network_filters_tcp_proxy_stats>`.
   *
   * @generated from field: string stat_prefix = 1;
   */
  statPrefix: string;

  /**
   * @generated from oneof envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * The upstream cluster to connect to.
     *
     * @generated from field: string cluster = 2;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     *
     * @generated from field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster weighted_clusters = 10;
     */
    value: TcpProxy_WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };

  /**
   * The on demand policy for the upstream cluster.
   * It applies to both
   * :ref:`TcpProxy.cluster <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.cluster>`
   * and
   * :ref:`TcpProxy.weighted_clusters <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.weighted_clusters>`.
   *
   * @generated from field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand on_demand = 14;
   */
  onDemand?: TcpProxy_OnDemand;

  /**
   * Optional endpoint metadata match criteria. Only endpoints in the upstream
   * cluster with metadata matching that set in metadata_match will be
   * considered. The filter name should be specified as ``envoy.lb``.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata_match = 9;
   */
  metadataMatch?: Metadata;

  /**
   * The idle timeout for connections managed by the TCP proxy filter. The idle timeout
   * is defined as the period in which there are no bytes sent or received on either
   * the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
   * to 0s, the timeout will be disabled.
   *
   * .. warning::
   *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
   *   FIN packets, etc.
   *
   * @generated from field: google.protobuf.Duration idle_timeout = 8;
   */
  idleTimeout?: Duration;

  /**
   * [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
   * filter. The idle timeout is defined as the period in which there is no
   * active traffic. If not set, there is no idle timeout. When the idle timeout
   * is reached the connection will be closed. The distinction between
   * downstream_idle_timeout/upstream_idle_timeout provides a means to set
   * timeout based on the last byte sent on the downstream/upstream connection.
   *
   * @generated from field: google.protobuf.Duration downstream_idle_timeout = 3;
   */
  downstreamIdleTimeout?: Duration;

  /**
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.Duration upstream_idle_timeout = 4;
   */
  upstreamIdleTimeout?: Duration;

  /**
   * Configuration for :ref:`access logs <arch_overview_access_logs>`
   * emitted by the this tcp_proxy.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLog access_log = 5;
   */
  accessLog: AccessLog[];

  /**
   * The maximum number of unsuccessful connection attempts that will be made before
   * giving up. If the parameter is not specified, 1 connection attempt will be made.
   *
   * @generated from field: google.protobuf.UInt32Value max_connect_attempts = 7;
   */
  maxConnectAttempts?: number;

  /**
   * Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   *
   * @generated from field: repeated envoy.type.v3.HashPolicy hash_policy = 11;
   */
  hashPolicy: HashPolicy[];

  /**
   * If set, this configures tunneling, e.g. configuration options to tunnel TCP payload over
   * HTTP CONNECT. If this message is absent, the payload will be proxied upstream as per usual.
   * It is possible to dynamically override this configuration and disable tunneling per connection,
   * by setting a per-connection filter state object for the key ``envoy.tcp_proxy.disable_tunneling``.
   *
   * @generated from field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig tunneling_config = 12;
   */
  tunnelingConfig?: TcpProxy_TunnelingConfig;

  /**
   * The maximum duration of a connection. The duration is defined as the period since a connection
   * was established. If not set, there is no max duration. When max_downstream_connection_duration
   * is reached the connection will be closed. Duration must be at least 1ms.
   *
   * @generated from field: google.protobuf.Duration max_downstream_connection_duration = 13;
   */
  maxDownstreamConnectionDuration?: Duration;

  /**
   * .. attention::
   * This field is deprecated in favor of
   * :ref:`access_log_flush_interval
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`.
   * Note that if both this field and :ref:`access_log_flush_interval
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.access_log_flush_interval>`
   * are specified, the former (deprecated field) is ignored.
   *
   * @generated from field: google.protobuf.Duration access_log_flush_interval = 15 [deprecated = true];
   * @deprecated
   */
  accessLogFlushInterval?: Duration;

  /**
   * .. attention::
   * This field is deprecated in favor of
   * :ref:`flush_access_log_on_connected
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`.
   * Note that if both this field and :ref:`flush_access_log_on_connected
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions.flush_access_log_on_connected>`
   * are specified, the former (deprecated field) is ignored.
   *
   * @generated from field: bool flush_access_log_on_connected = 16 [deprecated = true];
   * @deprecated
   */
  flushAccessLogOnConnected: boolean;

  /**
   * Additional access log options for TCP Proxy.
   *
   * @generated from field: envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions access_log_options = 17;
   */
  accessLogOptions?: TcpProxy_TcpAccessLogOptions;

  constructor(data?: PartialMessage<TcpProxy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy;

  static equals(a: TcpProxy | PlainMessage<TcpProxy> | undefined, b: TcpProxy | PlainMessage<TcpProxy> | undefined): boolean;
}

/**
 * Allows for specification of multiple upstream clusters along with weights
 * that indicate the percentage of traffic to be forwarded to each cluster.
 * The router selects an upstream cluster based on these weights.
 *
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster
 */
export declare class TcpProxy_WeightedCluster extends Message<TcpProxy_WeightedCluster> {
  /**
   * Specifies one or more upstream clusters associated with the route.
   *
   * @generated from field: repeated envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight clusters = 1;
   */
  clusters: TcpProxy_WeightedCluster_ClusterWeight[];

  constructor(data?: PartialMessage<TcpProxy_WeightedCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy_WeightedCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy_WeightedCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy_WeightedCluster;

  static equals(a: TcpProxy_WeightedCluster | PlainMessage<TcpProxy_WeightedCluster> | undefined, b: TcpProxy_WeightedCluster | PlainMessage<TcpProxy_WeightedCluster> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight
 */
export declare class TcpProxy_WeightedCluster_ClusterWeight extends Message<TcpProxy_WeightedCluster_ClusterWeight> {
  /**
   * Name of the upstream cluster.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * When a request matches the route, the choice of an upstream cluster is
   * determined by its weight. The sum of weights across all entries in the
   * clusters array determines the total weight.
   *
   * @generated from field: uint32 weight = 2;
   */
  weight: number;

  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what is set in this field will be considered
   * for load balancing. Note that this will be merged with what's provided in
   * :ref:`TcpProxy.metadata_match
   * <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
   * here taking precedence. The filter name should be specified as ``envoy.lb``.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata_match = 3;
   */
  metadataMatch?: Metadata;

  constructor(data?: PartialMessage<TcpProxy_WeightedCluster_ClusterWeight>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.WeightedCluster.ClusterWeight";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy_WeightedCluster_ClusterWeight;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy_WeightedCluster_ClusterWeight;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy_WeightedCluster_ClusterWeight;

  static equals(a: TcpProxy_WeightedCluster_ClusterWeight | PlainMessage<TcpProxy_WeightedCluster_ClusterWeight> | undefined, b: TcpProxy_WeightedCluster_ClusterWeight | PlainMessage<TcpProxy_WeightedCluster_ClusterWeight> | undefined): boolean;
}

/**
 * Configuration for tunneling TCP over other transports or application layers.
 * Tunneling is supported over both HTTP/1.1 and HTTP/2. Upstream protocol is
 * determined by the cluster configuration.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig
 */
export declare class TcpProxy_TunnelingConfig extends Message<TcpProxy_TunnelingConfig> {
  /**
   * The hostname to send in the synthesized CONNECT headers to the upstream proxy.
   * This field evaluates command operators if set, otherwise returns hostname as is.
   *
   * Example: dynamically set hostname using downstream SNI
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%REQUESTED_SERVER_NAME%:443"
   *
   * Example: dynamically set hostname using dynamic metadata
   *
   * .. code-block:: yaml
   *
   *    tunneling_config:
   *      hostname: "%DYNAMIC_METADATA(tunnel:address)%"
   *
   *
   * @generated from field: string hostname = 1;
   */
  hostname: string;

  /**
   * Use POST method instead of CONNECT method to tunnel the TCP stream.
   * The 'protocol: bytestream' header is also NOT set for HTTP/2 to comply with the spec.
   *
   * The upstream proxy is expected to convert POST payload as raw TCP.
   *
   * @generated from field: bool use_post = 2;
   */
  usePost: boolean;

  /**
   * Additional request headers to upstream proxy. This is mainly used to
   * trigger upstream to convert POST requests back to CONNECT requests.
   *
   * Neither ``:-prefixed`` pseudo-headers nor the Host: header can be overridden.
   *
   * @generated from field: repeated envoy.config.core.v3.HeaderValueOption headers_to_add = 3;
   */
  headersToAdd: HeaderValueOption[];

  /**
   * Save the response headers to the downstream info filter state for consumption
   * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_headers``.
   *
   * @generated from field: bool propagate_response_headers = 4;
   */
  propagateResponseHeaders: boolean;

  /**
   * The path used with POST method. Default path is ``/``. If post path is specified and
   * :ref:`use_post field <envoy_v3_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig.use_post>`
   * isn't true, it will be rejected.
   *
   * @generated from field: string post_path = 5;
   */
  postPath: string;

  /**
   * Save the response trailers to the downstream info filter state for consumption
   * by the network filters. The filter state key is ``envoy.tcp_proxy.propagate_response_trailers``.
   *
   * @generated from field: bool propagate_response_trailers = 6;
   */
  propagateResponseTrailers: boolean;

  constructor(data?: PartialMessage<TcpProxy_TunnelingConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TunnelingConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy_TunnelingConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy_TunnelingConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy_TunnelingConfig;

  static equals(a: TcpProxy_TunnelingConfig | PlainMessage<TcpProxy_TunnelingConfig> | undefined, b: TcpProxy_TunnelingConfig | PlainMessage<TcpProxy_TunnelingConfig> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand
 */
export declare class TcpProxy_OnDemand extends Message<TcpProxy_OnDemand> {
  /**
   * An optional configuration for on-demand cluster discovery
   * service. If not specified, the on-demand cluster discovery will
   * be disabled. When it's specified, the filter will pause a request
   * to an unknown cluster and will begin a cluster discovery
   * process. When the discovery is finished (successfully or not),
   * the request will be resumed.
   *
   * @generated from field: envoy.config.core.v3.ConfigSource odcds_config = 1;
   */
  odcdsConfig?: ConfigSource;

  /**
   * xdstp:// resource locator for on-demand cluster collection.
   * [#not-implemented-hide:]
   *
   * @generated from field: string resources_locator = 2;
   */
  resourcesLocator: string;

  /**
   * The timeout for on demand cluster lookup. If the CDS cannot return the required cluster,
   * the downstream request will be closed with the error code detail NO_CLUSTER_FOUND.
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.Duration timeout = 3;
   */
  timeout?: Duration;

  constructor(data?: PartialMessage<TcpProxy_OnDemand>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.OnDemand";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy_OnDemand;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy_OnDemand;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy_OnDemand;

  static equals(a: TcpProxy_OnDemand | PlainMessage<TcpProxy_OnDemand> | undefined, b: TcpProxy_OnDemand | PlainMessage<TcpProxy_OnDemand> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions
 */
export declare class TcpProxy_TcpAccessLogOptions extends Message<TcpProxy_TcpAccessLogOptions> {
  /**
   * The interval to flush access log. The TCP proxy will flush only one access log when the connection
   * is closed by default. If this field is set, the TCP proxy will flush access log periodically with
   * the specified interval.
   * The interval must be at least 1ms.
   *
   * @generated from field: google.protobuf.Duration access_log_flush_interval = 1;
   */
  accessLogFlushInterval?: Duration;

  /**
   * If set to true, access log will be flushed when the TCP proxy has successfully established a
   * connection with the upstream. If the connection failed, the access log will not be flushed.
   *
   * @generated from field: bool flush_access_log_on_connected = 2;
   */
  flushAccessLogOnConnected: boolean;

  constructor(data?: PartialMessage<TcpProxy_TcpAccessLogOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy.TcpAccessLogOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProxy_TcpAccessLogOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProxy_TcpAccessLogOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProxy_TcpAccessLogOptions;

  static equals(a: TcpProxy_TcpAccessLogOptions | PlainMessage<TcpProxy_TcpAccessLogOptions> | undefined, b: TcpProxy_TcpAccessLogOptions | PlainMessage<TcpProxy_TcpAccessLogOptions> | undefined): boolean;
}

