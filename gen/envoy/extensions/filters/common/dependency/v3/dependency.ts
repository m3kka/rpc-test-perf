// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/common/dependency/v3/dependency.proto" (package "envoy.extensions.filters.common.dependency.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// [#protodoc-title: Filter dependency specification]

/**
 * Dependency specification and string identifier.
 *
 * @generated from protobuf message envoy.extensions.filters.common.dependency.v3.Dependency
 */
export interface Dependency {
    /**
     * The kind of dependency.
     *
     * @generated from protobuf field: envoy.extensions.filters.common.dependency.v3.Dependency.DependencyType type = 1;
     */
    type: Dependency_DependencyType;
    /**
     * The string identifier for the dependency.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf enum envoy.extensions.filters.common.dependency.v3.Dependency.DependencyType
 */
export enum Dependency_DependencyType {
    /**
     * @generated from protobuf enum value: HEADER = 0;
     */
    HEADER = 0,
    /**
     * @generated from protobuf enum value: FILTER_STATE_KEY = 1;
     */
    FILTER_STATE_KEY = 1,
    /**
     * @generated from protobuf enum value: DYNAMIC_METADATA = 2;
     */
    DYNAMIC_METADATA = 2
}
/**
 * Dependency specification for a filter. For a filter chain to be valid, any
 * dependency that is required must be provided by an earlier filter.
 *
 * @generated from protobuf message envoy.extensions.filters.common.dependency.v3.FilterDependencies
 */
export interface FilterDependencies {
    /**
     * A list of dependencies required on the decode path.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_required = 1;
     */
    decodeRequired: Dependency[];
    /**
     * A list of dependencies provided on the encode path.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_provided = 2;
     */
    decodeProvided: Dependency[];
    /**
     * A list of dependencies required on the decode path.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_required = 3;
     */
    encodeRequired: Dependency[];
    /**
     * A list of dependencies provided on the encode path.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_provided = 4;
     */
    encodeProvided: Dependency[];
}
/**
 * Matching requirements for a filter. For a match tree to be used with a filter, the match
 * requirements must be satisfied.
 *
 * This protobuf is provided by the filter implementation as a way to communicate the matching
 * requirements to the filter factories, allowing for config rejection if the requirements are
 * not satisfied.
 *
 * @generated from protobuf message envoy.extensions.filters.common.dependency.v3.MatchingRequirements
 */
export interface MatchingRequirements {
    /**
     * @generated from protobuf field: envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList data_input_allow_list = 1;
     */
    dataInputAllowList?: MatchingRequirements_DataInputAllowList;
}
/**
 * @generated from protobuf message envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList
 */
export interface MatchingRequirements_DataInputAllowList {
    /**
     * An explicit list of data inputs that are allowed to be used with this filter.
     *
     * @generated from protobuf field: repeated string type_url = 1;
     */
    typeUrl: string[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Dependency$Type extends MessageType<Dependency> {
    constructor() {
        super("envoy.extensions.filters.common.dependency.v3.Dependency", [
            { no: 1, name: "type", kind: "enum", T: () => ["envoy.extensions.filters.common.dependency.v3.Dependency.DependencyType", Dependency_DependencyType] },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Dependency>): Dependency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Dependency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dependency): Dependency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.common.dependency.v3.Dependency.DependencyType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Dependency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.common.dependency.v3.Dependency.DependencyType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.common.dependency.v3.Dependency
 */
export const Dependency = new Dependency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterDependencies$Type extends MessageType<FilterDependencies> {
    constructor() {
        super("envoy.extensions.filters.common.dependency.v3.FilterDependencies", [
            { no: 1, name: "decode_required", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Dependency },
            { no: 2, name: "decode_provided", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Dependency },
            { no: 3, name: "encode_required", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Dependency },
            { no: 4, name: "encode_provided", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Dependency }
        ]);
    }
    create(value?: PartialMessage<FilterDependencies>): FilterDependencies {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.decodeRequired = [];
        message.decodeProvided = [];
        message.encodeRequired = [];
        message.encodeProvided = [];
        if (value !== undefined)
            reflectionMergePartial<FilterDependencies>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterDependencies): FilterDependencies {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_required */ 1:
                    message.decodeRequired.push(Dependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_provided */ 2:
                    message.decodeProvided.push(Dependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_required */ 3:
                    message.encodeRequired.push(Dependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_provided */ 4:
                    message.encodeProvided.push(Dependency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterDependencies, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_required = 1; */
        for (let i = 0; i < message.decodeRequired.length; i++)
            Dependency.internalBinaryWrite(message.decodeRequired[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.common.dependency.v3.Dependency decode_provided = 2; */
        for (let i = 0; i < message.decodeProvided.length; i++)
            Dependency.internalBinaryWrite(message.decodeProvided[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_required = 3; */
        for (let i = 0; i < message.encodeRequired.length; i++)
            Dependency.internalBinaryWrite(message.encodeRequired[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.common.dependency.v3.Dependency encode_provided = 4; */
        for (let i = 0; i < message.encodeProvided.length; i++)
            Dependency.internalBinaryWrite(message.encodeProvided[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.common.dependency.v3.FilterDependencies
 */
export const FilterDependencies = new FilterDependencies$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchingRequirements$Type extends MessageType<MatchingRequirements> {
    constructor() {
        super("envoy.extensions.filters.common.dependency.v3.MatchingRequirements", [
            { no: 1, name: "data_input_allow_list", kind: "message", T: () => MatchingRequirements_DataInputAllowList }
        ]);
    }
    create(value?: PartialMessage<MatchingRequirements>): MatchingRequirements {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MatchingRequirements>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchingRequirements): MatchingRequirements {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList data_input_allow_list */ 1:
                    message.dataInputAllowList = MatchingRequirements_DataInputAllowList.internalBinaryRead(reader, reader.uint32(), options, message.dataInputAllowList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchingRequirements, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList data_input_allow_list = 1; */
        if (message.dataInputAllowList)
            MatchingRequirements_DataInputAllowList.internalBinaryWrite(message.dataInputAllowList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.common.dependency.v3.MatchingRequirements
 */
export const MatchingRequirements = new MatchingRequirements$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchingRequirements_DataInputAllowList$Type extends MessageType<MatchingRequirements_DataInputAllowList> {
    constructor() {
        super("envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList", [
            { no: 1, name: "type_url", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MatchingRequirements_DataInputAllowList>): MatchingRequirements_DataInputAllowList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeUrl = [];
        if (value !== undefined)
            reflectionMergePartial<MatchingRequirements_DataInputAllowList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchingRequirements_DataInputAllowList): MatchingRequirements_DataInputAllowList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string type_url */ 1:
                    message.typeUrl.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchingRequirements_DataInputAllowList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string type_url = 1; */
        for (let i = 0; i < message.typeUrl.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.typeUrl[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.common.dependency.v3.MatchingRequirements.DataInputAllowList
 */
export const MatchingRequirements_DataInputAllowList = new MatchingRequirements_DataInputAllowList$Type();
