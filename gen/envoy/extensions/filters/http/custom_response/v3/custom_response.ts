// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/custom_response/v3/custom_response.proto" (package "envoy.extensions.filters.http.custom_response.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Matcher } from "../../../../../../xds/type/matcher/v3/matcher";
// [#protodoc-title: Custom Response Filter]
// [#extension: envoy.filters.http.custom_response]

// The Custom Response Filter allows for replacing upstream responses.

/**
 * The filter configuration is a collection of custom response
 * policies in a matcher tree. The configuration can be defined at the filter,
 * virtual host or route level. The response will be matched against the most
 * specific to the least specific config, till a match is found.
 *
 * @generated from protobuf message envoy.extensions.filters.http.custom_response.v3.CustomResponse
 */
export interface CustomResponse {
    /**
     * Matcher to match against the original response to select a
     * :ref:`Custom Response Policy <extension_category_envoy.http.custom_response>`
     * that will override the original response. The matching is done by matching
     * against :ref:`response header values<extension_category_envoy.matching.http.input>`
     * Example:
     *
     * .. validated-code-block:: yaml
     *   :type-name: xds.type.matcher.v3.Matcher
     *
     *   matcher_list:
     *     matchers:
     *       # Apply a locally stored custom response to any 4xx response.
     *     - predicate:
     *         single_predicate:
     *           input:
     *             name: 4xx_response
     *             typed_config:
     *               "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeClassMatchInput
     *           value_match:
     *             exact: "4xx"
     *       on_match:
     *         action:
     *           name: action
     *           typed_config:
     *             "@type": type.googleapis.com/envoy.extensions.http.custom_response.local_response_policy.v3.LocalResponsePolicy
     *             status_code: 499
     *             body:
     *               inline_string: "not allowed"
     *             body_format:
     *               json_format:
     *                 status: "%RESPONSE_CODE%"
     *                 message: "%LOCAL_REPLY_BODY%"
     *             response_headers_to_add:
     *             - header:
     *                 key: "foo"
     *                 value: "x-bar"
     *       # Redirect to different upstream if the status code is one of 502, 503 or 504.
     *     - predicate:
     *         or_matcher:
     *           predicate:
     *           - single_predicate:
     *               input:
     *                 name: "502_response"
     *                 typed_config:
     *                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
     *               value_match:
     *                 exact: "502"
     *           - single_predicate:
     *               input:
     *                 name: "503_response"
     *                 typed_config:
     *                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
     *               value_match:
     *                 exact: "503"
     *           - single_predicate:
     *               input:
     *                 name: "504_response"
     *                 typed_config:
     *                   "@type": type.googleapis.com/envoy.type.matcher.v3.HttpResponseStatusCodeMatchInput
     *               value_match:
     *                 exact: "504"
     *       on_match:
     *         action:
     *           name: action
     *           typed_config:
     *             "@type": type.googleapis.com/envoy.extensions.http.custom_response.redirect_policy.v3.RedirectPolicy
     *             status_code: 299
     *             uri: "https://foo.example/gateway_error"
     *             response_headers_to_add:
     *             - header:
     *                 key: "foo2"
     *                 value: "x-bar2"
     *
     * -- attention::
     *  The first matched policy wins. Once the response is matched, matcher
     *  evaluations end.
     *
     * Refer to :ref:`Unified Matcher API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
     * documentation for more information on the matcher trees.
     * [#extension-category: envoy.http.custom_response]
     *
     * @generated from protobuf field: xds.type.matcher.v3.Matcher custom_response_matcher = 1;
     */
    customResponseMatcher?: Matcher;
}
// @generated message type with reflection information, may provide speed optimized methods
class CustomResponse$Type extends MessageType<CustomResponse> {
    constructor() {
        super("envoy.extensions.filters.http.custom_response.v3.CustomResponse", [
            { no: 1, name: "custom_response_matcher", kind: "message", T: () => Matcher }
        ]);
    }
    create(value?: PartialMessage<CustomResponse>): CustomResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CustomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomResponse): CustomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xds.type.matcher.v3.Matcher custom_response_matcher */ 1:
                    message.customResponseMatcher = Matcher.internalBinaryRead(reader, reader.uint32(), options, message.customResponseMatcher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xds.type.matcher.v3.Matcher custom_response_matcher = 1; */
        if (message.customResponseMatcher)
            Matcher.internalBinaryWrite(message.customResponseMatcher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.custom_response.v3.CustomResponse
 */
export const CustomResponse = new CustomResponse$Type();
