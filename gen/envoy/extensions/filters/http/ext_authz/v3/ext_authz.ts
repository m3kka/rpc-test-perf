// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto" (package "envoy.extensions.filters.http.ext_authz.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderValue } from "../../../../../config/core/v3/base";
import { HttpUri } from "../../../../../config/core/v3/http_uri";
import { ListStringMatcher } from "../../../../../type/matcher/v3/string";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
import { MetadataMatcher } from "../../../../../type/matcher/v3/metadata";
import { RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { ApiVersion } from "../../../../../config/core/v3/config_source";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
// [#protodoc-title: External Authorization]
// External Authorization :ref:`configuration overview <config_http_filters_ext_authz>`.
// [#extension: envoy.filters.http.ext_authz]

/**
 * [#next-free-field: 19]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
 */
export interface ExtAuthz {
    /**
     * @generated from protobuf oneof: services
     */
    services: {
        oneofKind: "grpcService";
        /**
         * gRPC service configuration (default timeout: 200ms).
         *
         * @generated from protobuf field: envoy.config.core.v3.GrpcService grpc_service = 1;
         */
        grpcService: GrpcService;
    } | {
        oneofKind: "httpService";
        /**
         * HTTP service configuration (default timeout: 200ms).
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ext_authz.v3.HttpService http_service = 3;
         */
        httpService: HttpService;
    } | {
        oneofKind: undefined;
    };
    /**
     * API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
     * version of messages used on the wire.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiVersion transport_api_version = 12;
     */
    transportApiVersion: ApiVersion;
    /**
     *  Changes filter's behaviour on errors:
     *
     *  1. When set to true, the filter will ``accept`` client request even if the communication with
     *  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
     *  error.
     *
     *  2. When set to false, ext-authz will ``reject`` client requests and return a ``Forbidden``
     *  response if the communication with the authorization service has failed, or if the
     *  authorization service has returned a HTTP 5xx error.
     *
     * Note that errors can be ``always`` tracked in the :ref:`stats
     * <config_http_filters_ext_authz_stats>`.
     *
     * @generated from protobuf field: bool failure_mode_allow = 2;
     */
    failureModeAllow: boolean;
    /**
     * Enables filter to buffer the client request body and send it within the authorization request.
     * A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
     * request message indicating if the body data is partial.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_authz.v3.BufferSettings with_request_body = 5;
     */
    withRequestBody?: BufferSettings;
    /**
     * Clears route cache in order to allow the external authorization service to correctly affect
     * routing decisions. Filter clears all cached routes when:
     *
     * 1. The field is set to ``true``.
     *
     * 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
     *
     * 3. At least one ``authorization response header`` is added to the client request, or is used for
     * altering another client request header.
     *
     *
     * @generated from protobuf field: bool clear_route_cache = 6;
     */
    clearRouteCache: boolean;
    /**
     * Sets the HTTP status that is returned to the client when the authorization server returns an error
     * or cannot be reached. The default status is HTTP 403 Forbidden.
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus status_on_error = 7;
     */
    statusOnError?: HttpStatus;
    /**
     * Specifies a list of metadata namespaces whose values, if present, will be passed to the
     * ext_authz service. :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>` is passed as an opaque ``protobuf::Struct``.
     *
     * For example, if the ``jwt_authn`` filter is used and :ref:`payload_in_metadata
     * <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtProvider.payload_in_metadata>` is set,
     * then the following will pass the jwt payload to the authorization server.
     *
     * .. code-block:: yaml
     *
     *    metadata_context_namespaces:
     *    - envoy.filters.http.jwt_authn
     *
     *
     * @generated from protobuf field: repeated string metadata_context_namespaces = 8;
     */
    metadataContextNamespaces: string[];
    /**
     * Specifies a list of metadata namespaces whose values, if present, will be passed to the
     * ext_authz service. :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>` is passed as an ``protobuf::Any``.
     *
     * It works in a way similar to ``metadata_context_namespaces`` but allows envoy and external authz server to share the protobuf message definition
     * in order to do a safe parsing.
     *
     *
     * @generated from protobuf field: repeated string typed_metadata_context_namespaces = 16;
     */
    typedMetadataContextNamespaces: string[];
    /**
     * Specifies if the filter is enabled.
     *
     * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
     * Envoy will lookup the runtime key to get the percentage of requests to filter.
     *
     * If this field is not specified, the filter will be enabled for all requests.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9;
     */
    filterEnabled?: RuntimeFractionalPercent;
    /**
     * Specifies if the filter is enabled with metadata matcher.
     * If this field is not specified, the filter will be enabled for all requests.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.MetadataMatcher filter_enabled_metadata = 14;
     */
    filterEnabledMetadata?: MetadataMatcher;
    /**
     * Specifies whether to deny the requests, when the filter is disabled.
     * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFeatureFlag.runtime_key>` is specified,
     * Envoy will lookup the runtime key to determine whether to deny request for
     * filter protected path at filter disabling. If filter is disabled in
     * typed_per_filter_config for the path, requests will not be denied.
     *
     * If this field is not specified, all requests will be allowed when disabled.
     *
     * If a request is denied due to this setting, the response code in :ref:`status_on_error
     * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.status_on_error>` will
     * be returned.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag deny_at_disable = 11;
     */
    denyAtDisable?: RuntimeFeatureFlag;
    /**
     * Specifies if the peer certificate is sent to the external service.
     *
     * When this field is true, Envoy will include the peer X.509 certificate, if available, in the
     * :ref:`certificate<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.certificate>`.
     *
     * @generated from protobuf field: bool include_peer_certificate = 10;
     */
    includePeerCertificate: boolean;
    /**
     * Optional additional prefix to use when emitting statistics. This allows to distinguish
     * emitted statistics between configured ``ext_authz`` filters in an HTTP filter chain. For example:
     *
     * .. code-block:: yaml
     *
     *   http_filters:
     *     - name: envoy.filters.http.ext_authz
     *       typed_config:
     *         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
     *         stat_prefix: waf # This emits ext_authz.waf.ok, ext_authz.waf.denied, etc.
     *     - name: envoy.filters.http.ext_authz
     *       typed_config:
     *         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
     *         stat_prefix: blocker # This emits ext_authz.blocker.ok, ext_authz.blocker.denied, etc.
     *
     *
     * @generated from protobuf field: string stat_prefix = 13;
     */
    statPrefix: string;
    /**
     * Optional labels that will be passed to :ref:`labels<envoy_v3_api_field_service.auth.v3.AttributeContext.Peer.labels>` in
     * :ref:`destination<envoy_v3_api_field_service.auth.v3.AttributeContext.destination>`.
     * The labels will be read from :ref:`metadata<envoy_v3_api_msg_config.core.v3.Node>` with the specified key.
     *
     * @generated from protobuf field: string bootstrap_metadata_labels_key = 15;
     */
    bootstrapMetadataLabelsKey: string;
    /**
     * Check request to authorization server will include the client request headers that have a correspondent match
     * in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`. If this option isn't specified, then
     * all client request headers are included in the check request to a gRPC authorization server, whereas no client request headers
     * (besides the ones allowed by default - see note below) are included in the check request to an HTTP authorization server.
     * This inconsistency between gRPC and HTTP servers is to maintain backwards compatibility with legacy behavior.
     *
     * .. note::
     *
     *  1. For requests to an HTTP authorization server: in addition to the the user's supplied matchers, ``Host``, ``Method``, ``Path``,
     *     ``Content-Length``, and ``Authorization`` are **additionally included** in the list.
     *
     * .. note::
     *
     *  2. For requests to an HTTP authorization server: *Content-Length* will be set to 0 and the request to the
     *  authorization server will not have a message body. However, the check request can include the buffered
     *  client request body (controlled by :ref:`with_request_body
     *  <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` setting),
     *  consequently the value of *Content-Length* of the authorization request reflects the size of
     *  its payload size.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_headers = 17;
     */
    allowedHeaders?: ListStringMatcher;
    /**
     * Specifies if the TLS session level details like SNI are sent to the external service.
     *
     * When this field is true, Envoy will include the SNI name used for TLSClientHello, if available, in the
     * :ref:`tls_session<envoy_v3_api_field_service.auth.v3.AttributeContext.tls_session>`.
     *
     * @generated from protobuf field: bool include_tls_session = 18;
     */
    includeTlsSession: boolean;
}
/**
 * Configuration for buffering the request data.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.BufferSettings
 */
export interface BufferSettings {
    /**
     * Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
     * ``HTTP 413`` and will *not* initiate the authorization process when buffer reaches the number
     * set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
     * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.failure_mode_allow>`.
     *
     * @generated from protobuf field: uint32 max_request_bytes = 1;
     */
    maxRequestBytes: number;
    /**
     * When this field is true, Envoy will buffer the message until ``max_request_bytes`` is reached.
     * The authorization request will be dispatched and no 413 HTTP error will be returned by the
     * filter.
     *
     * @generated from protobuf field: bool allow_partial_message = 2;
     */
    allowPartialMessage: boolean;
    /**
     * If true, the body sent to the external authorization service is set with raw bytes, it sets
     * the :ref:`raw_body<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>`
     * field of HTTP request attribute context. Otherwise, :ref:`body
     * <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` will be filled
     * with UTF-8 string request body.
     *
     * This field only affects configurations using a :ref:`grpc_service
     * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`. In configurations that use
     * an :ref:`http_service <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.http_service>`, this
     * has no effect.
     *
     * @generated from protobuf field: bool pack_as_bytes = 3;
     */
    packAsBytes: boolean;
}
/**
 * HttpService is used for raw HTTP communication between the filter and the authorization service.
 * When configured, the filter will parse the client request and use these attributes to call the
 * authorization server. Depending on the response, the filter may reject or accept the client
 * request. Note that in any of these events, metadata can be added, removed or overridden by the
 * filter:
 *
 * *On authorization request*, a list of allowed request headers may be supplied. See
 * :ref:`allowed_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.allowed_headers>`
 * for details. Additional headers metadata may be added to the authorization request. See
 * :ref:`headers_to_add
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationRequest.headers_to_add>` for
 * details.
 *
 * On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
 * additional headers metadata may be added to the original client request. See
 * :ref:`allowed_upstream_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_upstream_headers>`
 * for details. Additionally, the filter may add additional headers to the client's response. See
 * :ref:`allowed_client_headers_on_success
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers_on_success>`
 * for details.
 *
 * On other authorization response statuses, the filter will not allow traffic. Additional headers
 * metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
 * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.AuthorizationResponse.allowed_client_headers>`
 * for details.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.HttpService
 */
export interface HttpService {
    /**
     * Sets the HTTP server URI which the authorization requests must be sent to.
     *
     * @generated from protobuf field: envoy.config.core.v3.HttpUri server_uri = 1;
     */
    serverUri?: HttpUri;
    /**
     * Sets a prefix to the value of authorization request header ``Path``.
     *
     * @generated from protobuf field: string path_prefix = 2;
     */
    pathPrefix: string;
    /**
     * Settings used for controlling authorization request metadata.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest authorization_request = 7;
     */
    authorizationRequest?: AuthorizationRequest;
    /**
     * Settings used for controlling authorization response metadata.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse authorization_response = 8;
     */
    authorizationResponse?: AuthorizationResponse;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest
 */
export interface AuthorizationRequest {
    /**
     * Authorization request includes the client request headers that have a correspondent match
     * in the :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>`.
     * This field has been deprecated in favor of :ref:`allowed_headers
     * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.allowed_headers>`.
     *
     * .. note::
     *
     *   In addition to the the user's supplied matchers, ``Host``, ``Method``, ``Path``,
     *   ``Content-Length``, and ``Authorization`` are **automatically included** to the list.
     *
     * .. note::
     *
     *   By default, ``Content-Length`` header is set to ``0`` and the request to the authorization
     *   service has no message body. However, the authorization request *may* include the buffered
     *   client request body (controlled by :ref:`with_request_body
     *   <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>`
     *   setting) hence the value of its ``Content-Length`` reflects the size of its payload size.
     *
     *
     * @deprecated
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1 [deprecated = true];
     */
    allowedHeaders?: ListStringMatcher;
    /**
     * Sets a list of headers that will be included to the request to authorization service. Note that
     * client request of the same key will be overridden.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValue headers_to_add = 2;
     */
    headersToAdd: HeaderValue[];
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse
 */
export interface AuthorizationResponse {
    /**
     * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the original client request.
     * Note that coexistent headers will be overridden.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers = 1;
     */
    allowedUpstreamHeaders?: ListStringMatcher;
    /**
     * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the client's response. Note
     * that coexistent headers will be appended.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers_to_append = 3;
     */
    allowedUpstreamHeadersToAppend?: ListStringMatcher;
    /**
     * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the client's response. Note
     * that when this list is *not* set, all the authorization response headers, except ``Authority
     * (Host)`` will be in the response to the client. When a header is included in this list, ``Path``,
     * ``Status``, ``Content-Length``, ``WWWAuthenticate`` and ``Location`` are automatically added.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_client_headers = 2;
     */
    allowedClientHeaders?: ListStringMatcher;
    /**
     * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the client's response when
     * the authorization response itself is successful, i.e. not failed or denied. When this list is
     * *not* set, no additional headers will be added to the client's response on success.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_client_headers_on_success = 4;
     */
    allowedClientHeadersOnSuccess?: ListStringMatcher;
    /**
     * When this :ref:`list <envoy_v3_api_msg_type.matcher.v3.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be emitted as dynamic metadata to be consumed
     * by the next filter. This metadata lives in a namespace specified by the canonical name of extension filter
     * that requires it:
     *
     * - :ref:`envoy.filters.http.ext_authz <config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
     * - :ref:`envoy.filters.network.ext_authz <config_network_filters_ext_authz_dynamic_metadata>` for network filter.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher dynamic_metadata_from_headers = 5;
     */
    dynamicMetadataFromHeaders?: ListStringMatcher;
}
/**
 * Extra settings on a per virtualhost/route/weighted-cluster level.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute
 */
export interface ExtAuthzPerRoute {
    /**
     * @generated from protobuf oneof: override
     */
    override: {
        oneofKind: "disabled";
        /**
         * Disable the ext auth filter for this particular vhost or route.
         * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
         *
         * @generated from protobuf field: bool disabled = 1;
         */
        disabled: boolean;
    } | {
        oneofKind: "checkSettings";
        /**
         * Check request settings for this route.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ext_authz.v3.CheckSettings check_settings = 2;
         */
        checkSettings: CheckSettings;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Extra settings for the check request.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_authz.v3.CheckSettings
 */
export interface CheckSettings {
    /**
     * Context extensions to set on the CheckRequest's
     * :ref:`AttributeContext.context_extensions<envoy_v3_api_field_service.auth.v3.AttributeContext.context_extensions>`
     *
     * You can use this to provide extra context for the external authorization server on specific
     * virtual hosts/routes. For example, adding a context extension on the virtual host level can
     * give the ext-authz server information on what virtual host is used without needing to parse the
     * host header. If CheckSettings is specified in multiple per-filter-configs, they will be merged
     * in order, and the result will be used.
     *
     * Merge semantics for this field are such that keys from more specific configs override.
     *
     * .. note::
     *
     *   These settings are only applied to a filter configured with a
     *   :ref:`grpc_service<envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.grpc_service>`.
     *
     * @generated from protobuf field: map<string, string> context_extensions = 1;
     */
    contextExtensions: {
        [key: string]: string;
    };
    /**
     * When set to true, disable the configured :ref:`with_request_body
     * <envoy_v3_api_field_extensions.filters.http.ext_authz.v3.ExtAuthz.with_request_body>` for a route.
     *
     * @generated from protobuf field: bool disable_request_body_buffering = 2;
     */
    disableRequestBodyBuffering: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class ExtAuthz$Type extends MessageType<ExtAuthz> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.ExtAuthz", [
            { no: 1, name: "grpc_service", kind: "message", oneof: "services", T: () => GrpcService },
            { no: 3, name: "http_service", kind: "message", oneof: "services", T: () => HttpService },
            { no: 12, name: "transport_api_version", kind: "enum", T: () => ["envoy.config.core.v3.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "failure_mode_allow", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "with_request_body", kind: "message", T: () => BufferSettings },
            { no: 6, name: "clear_route_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "status_on_error", kind: "message", T: () => HttpStatus },
            { no: 8, name: "metadata_context_namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "typed_metadata_context_namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "filter_enabled", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 14, name: "filter_enabled_metadata", kind: "message", T: () => MetadataMatcher },
            { no: 11, name: "deny_at_disable", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 10, name: "include_peer_certificate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "bootstrap_metadata_labels_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "allowed_headers", kind: "message", T: () => ListStringMatcher },
            { no: 18, name: "include_tls_session", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.ExtAuthz" } });
    }
    create(value?: PartialMessage<ExtAuthz>): ExtAuthz {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.services = { oneofKind: undefined };
        message.transportApiVersion = 0;
        message.failureModeAllow = false;
        message.clearRouteCache = false;
        message.metadataContextNamespaces = [];
        message.typedMetadataContextNamespaces = [];
        message.includePeerCertificate = false;
        message.statPrefix = "";
        message.bootstrapMetadataLabelsKey = "";
        message.includeTlsSession = false;
        if (value !== undefined)
            reflectionMergePartial<ExtAuthz>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtAuthz): ExtAuthz {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.GrpcService grpc_service */ 1:
                    message.services = {
                        oneofKind: "grpcService",
                        grpcService: GrpcService.internalBinaryRead(reader, reader.uint32(), options, (message.services as any).grpcService)
                    };
                    break;
                case /* envoy.extensions.filters.http.ext_authz.v3.HttpService http_service */ 3:
                    message.services = {
                        oneofKind: "httpService",
                        httpService: HttpService.internalBinaryRead(reader, reader.uint32(), options, (message.services as any).httpService)
                    };
                    break;
                case /* envoy.config.core.v3.ApiVersion transport_api_version */ 12:
                    message.transportApiVersion = reader.int32();
                    break;
                case /* bool failure_mode_allow */ 2:
                    message.failureModeAllow = reader.bool();
                    break;
                case /* envoy.extensions.filters.http.ext_authz.v3.BufferSettings with_request_body */ 5:
                    message.withRequestBody = BufferSettings.internalBinaryRead(reader, reader.uint32(), options, message.withRequestBody);
                    break;
                case /* bool clear_route_cache */ 6:
                    message.clearRouteCache = reader.bool();
                    break;
                case /* envoy.type.v3.HttpStatus status_on_error */ 7:
                    message.statusOnError = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.statusOnError);
                    break;
                case /* repeated string metadata_context_namespaces */ 8:
                    message.metadataContextNamespaces.push(reader.string());
                    break;
                case /* repeated string typed_metadata_context_namespaces */ 16:
                    message.typedMetadataContextNamespaces.push(reader.string());
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled */ 9:
                    message.filterEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnabled);
                    break;
                case /* envoy.type.matcher.v3.MetadataMatcher filter_enabled_metadata */ 14:
                    message.filterEnabledMetadata = MetadataMatcher.internalBinaryRead(reader, reader.uint32(), options, message.filterEnabledMetadata);
                    break;
                case /* envoy.config.core.v3.RuntimeFeatureFlag deny_at_disable */ 11:
                    message.denyAtDisable = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.denyAtDisable);
                    break;
                case /* bool include_peer_certificate */ 10:
                    message.includePeerCertificate = reader.bool();
                    break;
                case /* string stat_prefix */ 13:
                    message.statPrefix = reader.string();
                    break;
                case /* string bootstrap_metadata_labels_key */ 15:
                    message.bootstrapMetadataLabelsKey = reader.string();
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_headers */ 17:
                    message.allowedHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedHeaders);
                    break;
                case /* bool include_tls_session */ 18:
                    message.includeTlsSession = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtAuthz, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.GrpcService grpc_service = 1; */
        if (message.services.oneofKind === "grpcService")
            GrpcService.internalBinaryWrite(message.services.grpcService, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ext_authz.v3.HttpService http_service = 3; */
        if (message.services.oneofKind === "httpService")
            HttpService.internalBinaryWrite(message.services.httpService, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ApiVersion transport_api_version = 12; */
        if (message.transportApiVersion !== 0)
            writer.tag(12, WireType.Varint).int32(message.transportApiVersion);
        /* bool failure_mode_allow = 2; */
        if (message.failureModeAllow !== false)
            writer.tag(2, WireType.Varint).bool(message.failureModeAllow);
        /* envoy.extensions.filters.http.ext_authz.v3.BufferSettings with_request_body = 5; */
        if (message.withRequestBody)
            BufferSettings.internalBinaryWrite(message.withRequestBody, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool clear_route_cache = 6; */
        if (message.clearRouteCache !== false)
            writer.tag(6, WireType.Varint).bool(message.clearRouteCache);
        /* envoy.type.v3.HttpStatus status_on_error = 7; */
        if (message.statusOnError)
            HttpStatus.internalBinaryWrite(message.statusOnError, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string metadata_context_namespaces = 8; */
        for (let i = 0; i < message.metadataContextNamespaces.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.metadataContextNamespaces[i]);
        /* repeated string typed_metadata_context_namespaces = 16; */
        for (let i = 0; i < message.typedMetadataContextNamespaces.length; i++)
            writer.tag(16, WireType.LengthDelimited).string(message.typedMetadataContextNamespaces[i]);
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9; */
        if (message.filterEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnabled, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.MetadataMatcher filter_enabled_metadata = 14; */
        if (message.filterEnabledMetadata)
            MetadataMatcher.internalBinaryWrite(message.filterEnabledMetadata, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFeatureFlag deny_at_disable = 11; */
        if (message.denyAtDisable)
            RuntimeFeatureFlag.internalBinaryWrite(message.denyAtDisable, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool include_peer_certificate = 10; */
        if (message.includePeerCertificate !== false)
            writer.tag(10, WireType.Varint).bool(message.includePeerCertificate);
        /* string stat_prefix = 13; */
        if (message.statPrefix !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.statPrefix);
        /* string bootstrap_metadata_labels_key = 15; */
        if (message.bootstrapMetadataLabelsKey !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.bootstrapMetadataLabelsKey);
        /* envoy.type.matcher.v3.ListStringMatcher allowed_headers = 17; */
        if (message.allowedHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedHeaders, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* bool include_tls_session = 18; */
        if (message.includeTlsSession !== false)
            writer.tag(18, WireType.Varint).bool(message.includeTlsSession);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
 */
export const ExtAuthz = new ExtAuthz$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BufferSettings$Type extends MessageType<BufferSettings> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.BufferSettings", [
            { no: 1, name: "max_request_bytes", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 2, name: "allow_partial_message", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "pack_as_bytes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.BufferSettings" } });
    }
    create(value?: PartialMessage<BufferSettings>): BufferSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxRequestBytes = 0;
        message.allowPartialMessage = false;
        message.packAsBytes = false;
        if (value !== undefined)
            reflectionMergePartial<BufferSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BufferSettings): BufferSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_request_bytes */ 1:
                    message.maxRequestBytes = reader.uint32();
                    break;
                case /* bool allow_partial_message */ 2:
                    message.allowPartialMessage = reader.bool();
                    break;
                case /* bool pack_as_bytes */ 3:
                    message.packAsBytes = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BufferSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_request_bytes = 1; */
        if (message.maxRequestBytes !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxRequestBytes);
        /* bool allow_partial_message = 2; */
        if (message.allowPartialMessage !== false)
            writer.tag(2, WireType.Varint).bool(message.allowPartialMessage);
        /* bool pack_as_bytes = 3; */
        if (message.packAsBytes !== false)
            writer.tag(3, WireType.Varint).bool(message.packAsBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.BufferSettings
 */
export const BufferSettings = new BufferSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpService$Type extends MessageType<HttpService> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.HttpService", [
            { no: 1, name: "server_uri", kind: "message", T: () => HttpUri },
            { no: 2, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "authorization_request", kind: "message", T: () => AuthorizationRequest },
            { no: 8, name: "authorization_response", kind: "message", T: () => AuthorizationResponse }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.HttpService" } });
    }
    create(value?: PartialMessage<HttpService>): HttpService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<HttpService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpService): HttpService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HttpUri server_uri */ 1:
                    message.serverUri = HttpUri.internalBinaryRead(reader, reader.uint32(), options, message.serverUri);
                    break;
                case /* string path_prefix */ 2:
                    message.pathPrefix = reader.string();
                    break;
                case /* envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest authorization_request */ 7:
                    message.authorizationRequest = AuthorizationRequest.internalBinaryRead(reader, reader.uint32(), options, message.authorizationRequest);
                    break;
                case /* envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse authorization_response */ 8:
                    message.authorizationResponse = AuthorizationResponse.internalBinaryRead(reader, reader.uint32(), options, message.authorizationResponse);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HttpUri server_uri = 1; */
        if (message.serverUri)
            HttpUri.internalBinaryWrite(message.serverUri, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string path_prefix = 2; */
        if (message.pathPrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pathPrefix);
        /* envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest authorization_request = 7; */
        if (message.authorizationRequest)
            AuthorizationRequest.internalBinaryWrite(message.authorizationRequest, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse authorization_response = 8; */
        if (message.authorizationResponse)
            AuthorizationResponse.internalBinaryWrite(message.authorizationResponse, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.HttpService
 */
export const HttpService = new HttpService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationRequest$Type extends MessageType<AuthorizationRequest> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest", [
            { no: 1, name: "allowed_headers", kind: "message", T: () => ListStringMatcher, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 2, name: "headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.AuthorizationRequest" } });
    }
    create(value?: PartialMessage<AuthorizationRequest>): AuthorizationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<AuthorizationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationRequest): AuthorizationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1 [deprecated = true];*/ 1:
                    message.allowedHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedHeaders);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValue headers_to_add */ 2:
                    message.headersToAdd.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1 [deprecated = true]; */
        if (message.allowedHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValue headers_to_add = 2; */
        for (let i = 0; i < message.headersToAdd.length; i++)
            HeaderValue.internalBinaryWrite(message.headersToAdd[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest
 */
export const AuthorizationRequest = new AuthorizationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationResponse$Type extends MessageType<AuthorizationResponse> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse", [
            { no: 1, name: "allowed_upstream_headers", kind: "message", T: () => ListStringMatcher },
            { no: 3, name: "allowed_upstream_headers_to_append", kind: "message", T: () => ListStringMatcher },
            { no: 2, name: "allowed_client_headers", kind: "message", T: () => ListStringMatcher },
            { no: 4, name: "allowed_client_headers_on_success", kind: "message", T: () => ListStringMatcher },
            { no: 5, name: "dynamic_metadata_from_headers", kind: "message", T: () => ListStringMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.AuthorizationResponse" } });
    }
    create(value?: PartialMessage<AuthorizationResponse>): AuthorizationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthorizationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationResponse): AuthorizationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers */ 1:
                    message.allowedUpstreamHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedUpstreamHeaders);
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers_to_append */ 3:
                    message.allowedUpstreamHeadersToAppend = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedUpstreamHeadersToAppend);
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_client_headers */ 2:
                    message.allowedClientHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedClientHeaders);
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_client_headers_on_success */ 4:
                    message.allowedClientHeadersOnSuccess = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedClientHeadersOnSuccess);
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher dynamic_metadata_from_headers */ 5:
                    message.dynamicMetadataFromHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.dynamicMetadataFromHeaders);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers = 1; */
        if (message.allowedUpstreamHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedUpstreamHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers_to_append = 3; */
        if (message.allowedUpstreamHeadersToAppend)
            ListStringMatcher.internalBinaryWrite(message.allowedUpstreamHeadersToAppend, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher allowed_client_headers = 2; */
        if (message.allowedClientHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedClientHeaders, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher allowed_client_headers_on_success = 4; */
        if (message.allowedClientHeadersOnSuccess)
            ListStringMatcher.internalBinaryWrite(message.allowedClientHeadersOnSuccess, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher dynamic_metadata_from_headers = 5; */
        if (message.dynamicMetadataFromHeaders)
            ListStringMatcher.internalBinaryWrite(message.dynamicMetadataFromHeaders, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse
 */
export const AuthorizationResponse = new AuthorizationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtAuthzPerRoute$Type extends MessageType<ExtAuthzPerRoute> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute", [
            { no: 1, name: "disabled", kind: "scalar", oneof: "override", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "check_settings", kind: "message", oneof: "override", T: () => CheckSettings, options: { "validate.rules": { message: { required: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute" } });
    }
    create(value?: PartialMessage<ExtAuthzPerRoute>): ExtAuthzPerRoute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.override = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExtAuthzPerRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtAuthzPerRoute): ExtAuthzPerRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.override = {
                        oneofKind: "disabled",
                        disabled: reader.bool()
                    };
                    break;
                case /* envoy.extensions.filters.http.ext_authz.v3.CheckSettings check_settings */ 2:
                    message.override = {
                        oneofKind: "checkSettings",
                        checkSettings: CheckSettings.internalBinaryRead(reader, reader.uint32(), options, (message.override as any).checkSettings)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtAuthzPerRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.override.oneofKind === "disabled")
            writer.tag(1, WireType.Varint).bool(message.override.disabled);
        /* envoy.extensions.filters.http.ext_authz.v3.CheckSettings check_settings = 2; */
        if (message.override.oneofKind === "checkSettings")
            CheckSettings.internalBinaryWrite(message.override.checkSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute
 */
export const ExtAuthzPerRoute = new ExtAuthzPerRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSettings$Type extends MessageType<CheckSettings> {
    constructor() {
        super("envoy.extensions.filters.http.ext_authz.v3.CheckSettings", [
            { no: 1, name: "context_extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "udpa.annotations.sensitive": true } },
            { no: 2, name: "disable_request_body_buffering", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.ext_authz.v2.CheckSettings" } });
    }
    create(value?: PartialMessage<CheckSettings>): CheckSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contextExtensions = {};
        message.disableRequestBodyBuffering = false;
        if (value !== undefined)
            reflectionMergePartial<CheckSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckSettings): CheckSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> context_extensions */ 1:
                    this.binaryReadMap1(message.contextExtensions, reader, options);
                    break;
                case /* bool disable_request_body_buffering */ 2:
                    message.disableRequestBodyBuffering = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CheckSettings["contextExtensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CheckSettings["contextExtensions"] | undefined, val: CheckSettings["contextExtensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.filters.http.ext_authz.v3.CheckSettings.context_extensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: CheckSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> context_extensions = 1; */
        for (let k of globalThis.Object.keys(message.contextExtensions))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.contextExtensions[k]).join();
        /* bool disable_request_body_buffering = 2; */
        if (message.disableRequestBodyBuffering !== false)
            writer.tag(2, WireType.Varint).bool(message.disableRequestBodyBuffering);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_authz.v3.CheckSettings
 */
export const CheckSettings = new CheckSettings$Type();
