// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/grpc_field_extraction/v3/config.proto" (package "envoy.extensions.filters.http.grpc_field_extraction.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DataSource } from "../../../../../config/core/v3/base";
// [#protodoc-title: gRPC Field Extraction]
// 
// [#extension: envoy.filters.http.grpc_field_extraction]
// 
// Overview
// --------
// 
// This filter supports extracting the fields from the first gRPC
// request message no matter if it is unary or streaming and writing the result
// to the destination, for which currently only the static Envoy dynamic metadata `envoy.filters.http.grpc_field_extraction` is supported.
// 
// Assumptions
// -----------
// 
// This filter assumes
// 
// 1. this filter is only applicable for gRPC with Protobuf as payload.
// 2. for bi-directional and client-side gRPC streaming, the initial message from the client should not depend on receiving the server initial metadata.
// 
// Process Flow
// ------------
// 
// When a request reaches the filter, it will check
// 
// 1. if the request is the gRPC request configured for extraction, the filter tries to:
// 
//   a. block the incoming data before decoding the first complete gRPC message
//   b. look up the target field from the buffered gRPC message
//   c. write the extraction result into the dynamic metadata and resume the request propagation.
// 
// 2. otherwise, pass through the request.
// 
// If the request is a malformed one found during 1.a or 1.b, the filter will reject the request.
// 
// Config Requirements
// -------------------
// 
// Here are config requirements
// 
// 1. the target field should be among the following primitive types: `string`, `uint32`, `uint64`, `int32`, `int64`, `sint32`, `sint64`, `fixed32`, `fixed64`, `sfixed32`, `sfixed64`, `float`, `double`.
// 
// 2. the target field could be repeated.
// 
// 3. the intermediate type could also be repeated.
// 
// Output Format
// -------------
// 
// 1. the extracted field names/values will be wrapped in be ``field<StringValue>`` -> ``values<ListValue of StringValue>``, which will be added in the dynamic ``metadata<google.protobuf.Struct>``.
// 
// 2. if the field value is empty, a empty ``<ListValue>`` will be set.
// 
// Performance
// -----------
// 
// This filter should be performant as it
// 
// 1. converts between the gRPC message from EnvoyBuffer without data copy.
// 2. parse the gRPC message binary directly without deserialization.
// 
// though buffering the first message introduces some latency.
// 
// Example
// -------
// 
// We have the following request definition for the gRPC method `pkg.svc.Method`.
// 
// .. code-block:: proto
// 
// 	message MethodRequest {
// 	  string foo = 1;
// 	  Nested nested = 2;
// 	  uint32 baz = 3;
// 	  ...
// 	}
// 
// 	message Nested {
// 	 repeated string bar = 1;
// 	}
// 
// This is the filter config in JSON.
// 
// .. code-block:: json
// 
// 	{
// 	  "descriptor_set":{},
// 	  "extractions_by_method":{
// 	     "pkg.svc.Method":{
// 	        "request_field_extractions":{
// 	           "foo":{
// 	           },
// 	           "nested.bar":{
// 	           }
// 	           "baz":{
// 	           }
// 	        }
// 	     }
// 	  }
// 	}
// 
// During runtime, the filter receives the following `MethodRequest` message in JSON.
// 
// .. code-block:: json
// 
// 	{
// 	  "foo": "val_foo",
// 	  "nested": { "bar": ["val_bar1", "val_bar2"]}
// 	}
// 
// The filter will write the following dynamic metadata(`envoy.filters.http.grpc_field_extraction`) in JSON.
// 
// .. code-block:: json
// 
// 	{
// 	  "foo":[
// 	     "val_foo"
// 	  ],
// 	  "nested.bar":[
// 	     "val_bar1", "val_bar2"
// 	  ]
// 	  "baz":[
// 	  ]
// 	}

/**
 * @generated from protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig
 */
export interface GrpcFieldExtractionConfig {
    /**
     * The proto descriptor set binary for the gRPC services.
     *
     * It could be passed by a local file through `Datasource.filename` or embedded in the
     * `Datasource.inline_bytes`.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource descriptor_set = 1;
     */
    descriptorSet?: DataSource;
    /**
     * Specify the extraction info.
     * The key is the fully qualified gRPC method name.
     * `${package}.${Service}.${Method}`, like
     * `endpoints.examples.bookstore.BookStore.GetShelf`
     *
     * The value is the field extractions for individual gRPC method.
     *
     * @generated from protobuf field: map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions> extractions_by_method = 2;
     */
    extractionsByMethod: {
        [key: string]: FieldExtractions;
    };
}
/**
 * This message can be used to support per route config approach later even
 * though the Istio doesn't support that so far.
 *
 * @generated from protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions
 */
export interface FieldExtractions {
    /**
     * The field extractions for requests.
     * The key is the field path within the grpc request.
     * For example, we can define `foo.bar.name` if we want to extract
     * Request.foo.bar.name.
     *
     * .. code-block:: proto
     *
     *  message Request {
     *    Foo foo = 1;
     *  }
     *
     *  message Foo {
     *    Bar bar = 1;
     *  }
     *
     *  message Bar {
     *    string name = 1;
     *  }
     *
     * @generated from protobuf field: map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition> request_field_extractions = 1;
     */
    requestFieldExtractions: {
        [key: string]: RequestFieldValueDisposition;
    };
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition
 */
export interface RequestFieldValueDisposition {
    /**
     * @generated from protobuf oneof: disposition
     */
    disposition: {
        oneofKind: "dynamicMetadata";
        /**
         * The dynamic metadata namespace. If empty, "envoy.filters.http.grpc_field_extraction" will be used by default.
         *
         * Unimplemented. Uses "envoy.filters.http.grpc_field_extraction" for now.
         *
         * @generated from protobuf field: string dynamic_metadata = 1;
         */
        dynamicMetadata: string;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class GrpcFieldExtractionConfig$Type extends MessageType<GrpcFieldExtractionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig", [
            { no: 1, name: "descriptor_set", kind: "message", T: () => DataSource, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "extractions_by_method", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => FieldExtractions } }
        ]);
    }
    create(value?: PartialMessage<GrpcFieldExtractionConfig>): GrpcFieldExtractionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extractionsByMethod = {};
        if (value !== undefined)
            reflectionMergePartial<GrpcFieldExtractionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcFieldExtractionConfig): GrpcFieldExtractionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.DataSource descriptor_set */ 1:
                    message.descriptorSet = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.descriptorSet);
                    break;
                case /* map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions> extractions_by_method */ 2:
                    this.binaryReadMap2(message.extractionsByMethod, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GrpcFieldExtractionConfig["extractionsByMethod"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GrpcFieldExtractionConfig["extractionsByMethod"] | undefined, val: GrpcFieldExtractionConfig["extractionsByMethod"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = FieldExtractions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig.extractions_by_method");
            }
        }
        map[key ?? ""] = val ?? FieldExtractions.create();
    }
    internalBinaryWrite(message: GrpcFieldExtractionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.DataSource descriptor_set = 1; */
        if (message.descriptorSet)
            DataSource.internalBinaryWrite(message.descriptorSet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions> extractions_by_method = 2; */
        for (let k of globalThis.Object.keys(message.extractionsByMethod)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            FieldExtractions.internalBinaryWrite(message.extractionsByMethod[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.GrpcFieldExtractionConfig
 */
export const GrpcFieldExtractionConfig = new GrpcFieldExtractionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldExtractions$Type extends MessageType<FieldExtractions> {
    constructor() {
        super("envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions", [
            { no: 1, name: "request_field_extractions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => RequestFieldValueDisposition } }
        ]);
    }
    create(value?: PartialMessage<FieldExtractions>): FieldExtractions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestFieldExtractions = {};
        if (value !== undefined)
            reflectionMergePartial<FieldExtractions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldExtractions): FieldExtractions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition> request_field_extractions */ 1:
                    this.binaryReadMap1(message.requestFieldExtractions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: FieldExtractions["requestFieldExtractions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FieldExtractions["requestFieldExtractions"] | undefined, val: FieldExtractions["requestFieldExtractions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = RequestFieldValueDisposition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions.request_field_extractions");
            }
        }
        map[key ?? ""] = val ?? RequestFieldValueDisposition.create();
    }
    internalBinaryWrite(message: FieldExtractions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition> request_field_extractions = 1; */
        for (let k of globalThis.Object.keys(message.requestFieldExtractions)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            RequestFieldValueDisposition.internalBinaryWrite(message.requestFieldExtractions[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.FieldExtractions
 */
export const FieldExtractions = new FieldExtractions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFieldValueDisposition$Type extends MessageType<RequestFieldValueDisposition> {
    constructor() {
        super("envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition", [
            { no: 1, name: "dynamic_metadata", kind: "scalar", oneof: "disposition", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestFieldValueDisposition>): RequestFieldValueDisposition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disposition = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RequestFieldValueDisposition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFieldValueDisposition): RequestFieldValueDisposition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dynamic_metadata */ 1:
                    message.disposition = {
                        oneofKind: "dynamicMetadata",
                        dynamicMetadata: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFieldValueDisposition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dynamic_metadata = 1; */
        if (message.disposition.oneofKind === "dynamicMetadata")
            writer.tag(1, WireType.LengthDelimited).string(message.disposition.dynamicMetadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.grpc_field_extraction.v3.RequestFieldValueDisposition
 */
export const RequestFieldValueDisposition = new RequestFieldValueDisposition$Type();
