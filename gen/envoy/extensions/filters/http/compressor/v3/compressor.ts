// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/compressor/v3/compressor.proto" (package "envoy.extensions.filters.http.compressor.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
// [#protodoc-title: Compressor]
// Compressor :ref:`configuration overview <config_http_filters_compressor>`.
// [#extension: envoy.filters.http.compressor]

/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.Compressor
 */
export interface Compressor {
    /**
     * Minimum response length, in bytes, which will trigger compression. The default value is 30.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.UInt32Value content_length = 1 [deprecated = true];
     */
    contentLength?: UInt32Value;
    /**
     * Set of strings that allows specifying which mime-types yield compression; e.g.,
     * application/json, text/html, etc. When this field is not defined, compression will be applied
     * to the following mime-types: "application/javascript", "application/json",
     * "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
     * and their synonyms.
     *
     * @deprecated
     * @generated from protobuf field: repeated string content_type = 2 [deprecated = true];
     */
    contentType: string[];
    /**
     * If true, disables compression when the response contains an etag header. When it is false, the
     * filter will preserve weak etags and remove the ones that require strong validation.
     *
     * @deprecated
     * @generated from protobuf field: bool disable_on_etag_header = 3 [deprecated = true];
     */
    disableOnEtagHeader: boolean;
    /**
     * If true, removes accept-encoding from the request headers before dispatching it to the upstream
     * so that responses do not get compressed before reaching the filter.
     *
     * .. attention::
     *
     *    To avoid interfering with other compression filters in the same chain use this option in
     *    the filter closest to the upstream.
     *
     * @deprecated
     * @generated from protobuf field: bool remove_accept_encoding_header = 4 [deprecated = true];
     */
    removeAcceptEncodingHeader: boolean;
    /**
     * Runtime flag that controls whether the filter is enabled or not. If set to false, the
     * filter will operate as a pass-through filter, unless overridden by
     * CompressorPerRoute. If not specified, defaults to enabled.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag runtime_enabled = 5 [deprecated = true];
     */
    runtimeEnabled?: RuntimeFeatureFlag;
    /**
     * A compressor library to use for compression. Currently only
     * :ref:`envoy.compression.gzip.compressor<envoy_v3_api_msg_extensions.compression.gzip.compressor.v3.Gzip>`
     * is included in Envoy.
     * [#extension-category: envoy.compression.compressor]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig compressor_library = 6;
     */
    compressorLibrary?: TypedExtensionConfig;
    /**
     * Configuration for request compression. Compression is disabled by default if left empty.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig request_direction_config = 7;
     */
    requestDirectionConfig?: Compressor_RequestDirectionConfig;
    /**
     * Configuration for response compression. Compression is enabled by default if left empty.
     *
     * .. attention::
     *
     *    If the field is not empty then the duplicate deprecated fields of the ``Compressor`` message,
     *    such as ``content_length``, ``content_type``, ``disable_on_etag_header``,
     *    ``remove_accept_encoding_header`` and ``runtime_enabled``, are ignored.
     *
     *    Also all the statistics related to response compression will be rooted in
     *    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.response.*``
     *    instead of
     *    ``<stat_prefix>.compressor.<compressor_library.name>.<compressor_library_stat_prefix>.*``.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig response_direction_config = 8;
     */
    responseDirectionConfig?: Compressor_ResponseDirectionConfig;
    /**
     * If true, chooses this compressor first to do compression when the q-values in `Accept-Encoding` are same.
     * The last compressor which enables choose_first will be chosen if multiple compressor filters in the chain have choose_first as true.
     *
     * @generated from protobuf field: bool choose_first = 9;
     */
    chooseFirst: boolean;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig
 */
export interface Compressor_CommonDirectionConfig {
    /**
     * Runtime flag that controls whether compression is enabled or not for the direction this
     * common config is put in. If set to false, the filter will operate as a pass-through filter
     * in the chosen direction, unless overridden by CompressorPerRoute.
     * If the field is omitted, the filter will be enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag enabled = 1;
     */
    enabled?: RuntimeFeatureFlag;
    /**
     * Minimum value of Content-Length header of request or response messages (depending on the direction
     * this common config is put in), in bytes, which will trigger compression. The default value is 30.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value min_content_length = 2;
     */
    minContentLength?: UInt32Value;
    /**
     * Set of strings that allows specifying which mime-types yield compression; e.g.,
     * application/json, text/html, etc. When this field is not defined, compression will be applied
     * to the following mime-types: "application/javascript", "application/json",
     * "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
     * and their synonyms.
     *
     * @generated from protobuf field: repeated string content_type = 3;
     */
    contentType: string[];
}
/**
 * Configuration for filter behavior on the request direction.
 *
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig
 */
export interface Compressor_RequestDirectionConfig {
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config = 1;
     */
    commonConfig?: Compressor_CommonDirectionConfig;
}
/**
 * Configuration for filter behavior on the response direction.
 *
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig
 */
export interface Compressor_ResponseDirectionConfig {
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config = 1;
     */
    commonConfig?: Compressor_CommonDirectionConfig;
    /**
     * If true, disables compression when the response contains an etag header. When it is false, the
     * filter will preserve weak etags and remove the ones that require strong validation.
     *
     * @generated from protobuf field: bool disable_on_etag_header = 2;
     */
    disableOnEtagHeader: boolean;
    /**
     * If true, removes accept-encoding from the request headers before dispatching it to the upstream
     * so that responses do not get compressed before reaching the filter.
     *
     * .. attention::
     *
     *    To avoid interfering with other compression filters in the same chain use this option in
     *    the filter closest to the upstream.
     *
     * @generated from protobuf field: bool remove_accept_encoding_header = 3;
     */
    removeAcceptEncodingHeader: boolean;
}
/**
 * Per-route overrides of `ResponseDirectionConfig`. Anything added here should be optional,
 * to allow overriding arbitrary subsets of configuration. Omitted fields must have no affect.
 *
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides
 */
export interface ResponseDirectionOverrides {
}
/**
 * Per-route overrides. As per-route overrides are needed, they should be
 * added here, mirroring the structure of `Compressor`. All fields should be
 * optional, to allow overriding arbitrary subsets of configuration.
 *
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.CompressorOverrides
 */
export interface CompressorOverrides {
    /**
     * If present, response compression is enabled.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides response_direction_config = 1;
     */
    responseDirectionConfig?: ResponseDirectionOverrides;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.compressor.v3.CompressorPerRoute
 */
export interface CompressorPerRoute {
    /**
     * @generated from protobuf oneof: override
     */
    override: {
        oneofKind: "disabled";
        /**
         * If set, the filter will operate as a pass-through filter.
         * Overrides Compressor.runtime_enabled and CommonDirectionConfig.enabled.
         *
         * @generated from protobuf field: bool disabled = 1;
         */
        disabled: boolean;
    } | {
        oneofKind: "overrides";
        /**
         * Per-route overrides. Fields set here will override corresponding fields in `Compressor`.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.compressor.v3.CompressorOverrides overrides = 2;
         */
        overrides: CompressorOverrides;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class Compressor$Type extends MessageType<Compressor> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.Compressor", [
            { no: 1, name: "content_length", kind: "message", T: () => UInt32Value, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 2, name: "content_type", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 3, name: "disable_on_etag_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "remove_accept_encoding_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 5, name: "runtime_enabled", kind: "message", T: () => RuntimeFeatureFlag, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 6, name: "compressor_library", kind: "message", T: () => TypedExtensionConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 7, name: "request_direction_config", kind: "message", T: () => Compressor_RequestDirectionConfig },
            { no: 8, name: "response_direction_config", kind: "message", T: () => Compressor_ResponseDirectionConfig },
            { no: 9, name: "choose_first", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.compressor.v2.Compressor" } });
    }
    create(value?: PartialMessage<Compressor>): Compressor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contentType = [];
        message.disableOnEtagHeader = false;
        message.removeAcceptEncodingHeader = false;
        message.chooseFirst = false;
        if (value !== undefined)
            reflectionMergePartial<Compressor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Compressor): Compressor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value content_length = 1 [deprecated = true];*/ 1:
                    message.contentLength = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.contentLength);
                    break;
                case /* repeated string content_type = 2 [deprecated = true];*/ 2:
                    message.contentType.push(reader.string());
                    break;
                case /* bool disable_on_etag_header = 3 [deprecated = true];*/ 3:
                    message.disableOnEtagHeader = reader.bool();
                    break;
                case /* bool remove_accept_encoding_header = 4 [deprecated = true];*/ 4:
                    message.removeAcceptEncodingHeader = reader.bool();
                    break;
                case /* envoy.config.core.v3.RuntimeFeatureFlag runtime_enabled = 5 [deprecated = true];*/ 5:
                    message.runtimeEnabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.runtimeEnabled);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig compressor_library */ 6:
                    message.compressorLibrary = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.compressorLibrary);
                    break;
                case /* envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig request_direction_config */ 7:
                    message.requestDirectionConfig = Compressor_RequestDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.requestDirectionConfig);
                    break;
                case /* envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig response_direction_config */ 8:
                    message.responseDirectionConfig = Compressor_ResponseDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.responseDirectionConfig);
                    break;
                case /* bool choose_first */ 9:
                    message.chooseFirst = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Compressor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value content_length = 1 [deprecated = true]; */
        if (message.contentLength)
            UInt32Value.internalBinaryWrite(message.contentLength, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string content_type = 2 [deprecated = true]; */
        for (let i = 0; i < message.contentType.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.contentType[i]);
        /* bool disable_on_etag_header = 3 [deprecated = true]; */
        if (message.disableOnEtagHeader !== false)
            writer.tag(3, WireType.Varint).bool(message.disableOnEtagHeader);
        /* bool remove_accept_encoding_header = 4 [deprecated = true]; */
        if (message.removeAcceptEncodingHeader !== false)
            writer.tag(4, WireType.Varint).bool(message.removeAcceptEncodingHeader);
        /* envoy.config.core.v3.RuntimeFeatureFlag runtime_enabled = 5 [deprecated = true]; */
        if (message.runtimeEnabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.runtimeEnabled, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig compressor_library = 6; */
        if (message.compressorLibrary)
            TypedExtensionConfig.internalBinaryWrite(message.compressorLibrary, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig request_direction_config = 7; */
        if (message.requestDirectionConfig)
            Compressor_RequestDirectionConfig.internalBinaryWrite(message.requestDirectionConfig, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig response_direction_config = 8; */
        if (message.responseDirectionConfig)
            Compressor_ResponseDirectionConfig.internalBinaryWrite(message.responseDirectionConfig, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool choose_first = 9; */
        if (message.chooseFirst !== false)
            writer.tag(9, WireType.Varint).bool(message.chooseFirst);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.Compressor
 */
export const Compressor = new Compressor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Compressor_CommonDirectionConfig$Type extends MessageType<Compressor_CommonDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig", [
            { no: 1, name: "enabled", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 2, name: "min_content_length", kind: "message", T: () => UInt32Value },
            { no: 3, name: "content_type", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Compressor_CommonDirectionConfig>): Compressor_CommonDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contentType = [];
        if (value !== undefined)
            reflectionMergePartial<Compressor_CommonDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Compressor_CommonDirectionConfig): Compressor_CommonDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.RuntimeFeatureFlag enabled */ 1:
                    message.enabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* google.protobuf.UInt32Value min_content_length */ 2:
                    message.minContentLength = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minContentLength);
                    break;
                case /* repeated string content_type */ 3:
                    message.contentType.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Compressor_CommonDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.RuntimeFeatureFlag enabled = 1; */
        if (message.enabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value min_content_length = 2; */
        if (message.minContentLength)
            UInt32Value.internalBinaryWrite(message.minContentLength, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string content_type = 3; */
        for (let i = 0; i < message.contentType.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.contentType[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig
 */
export const Compressor_CommonDirectionConfig = new Compressor_CommonDirectionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Compressor_RequestDirectionConfig$Type extends MessageType<Compressor_RequestDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig", [
            { no: 1, name: "common_config", kind: "message", T: () => Compressor_CommonDirectionConfig }
        ]);
    }
    create(value?: PartialMessage<Compressor_RequestDirectionConfig>): Compressor_RequestDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Compressor_RequestDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Compressor_RequestDirectionConfig): Compressor_RequestDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config */ 1:
                    message.commonConfig = Compressor_CommonDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.commonConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Compressor_RequestDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config = 1; */
        if (message.commonConfig)
            Compressor_CommonDirectionConfig.internalBinaryWrite(message.commonConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.RequestDirectionConfig
 */
export const Compressor_RequestDirectionConfig = new Compressor_RequestDirectionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Compressor_ResponseDirectionConfig$Type extends MessageType<Compressor_ResponseDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig", [
            { no: 1, name: "common_config", kind: "message", T: () => Compressor_CommonDirectionConfig },
            { no: 2, name: "disable_on_etag_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "remove_accept_encoding_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Compressor_ResponseDirectionConfig>): Compressor_ResponseDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disableOnEtagHeader = false;
        message.removeAcceptEncodingHeader = false;
        if (value !== undefined)
            reflectionMergePartial<Compressor_ResponseDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Compressor_ResponseDirectionConfig): Compressor_ResponseDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config */ 1:
                    message.commonConfig = Compressor_CommonDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.commonConfig);
                    break;
                case /* bool disable_on_etag_header */ 2:
                    message.disableOnEtagHeader = reader.bool();
                    break;
                case /* bool remove_accept_encoding_header */ 3:
                    message.removeAcceptEncodingHeader = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Compressor_ResponseDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.compressor.v3.Compressor.CommonDirectionConfig common_config = 1; */
        if (message.commonConfig)
            Compressor_CommonDirectionConfig.internalBinaryWrite(message.commonConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool disable_on_etag_header = 2; */
        if (message.disableOnEtagHeader !== false)
            writer.tag(2, WireType.Varint).bool(message.disableOnEtagHeader);
        /* bool remove_accept_encoding_header = 3; */
        if (message.removeAcceptEncodingHeader !== false)
            writer.tag(3, WireType.Varint).bool(message.removeAcceptEncodingHeader);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.Compressor.ResponseDirectionConfig
 */
export const Compressor_ResponseDirectionConfig = new Compressor_ResponseDirectionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseDirectionOverrides$Type extends MessageType<ResponseDirectionOverrides> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides", []);
    }
    create(value?: PartialMessage<ResponseDirectionOverrides>): ResponseDirectionOverrides {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResponseDirectionOverrides>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseDirectionOverrides): ResponseDirectionOverrides {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResponseDirectionOverrides, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides
 */
export const ResponseDirectionOverrides = new ResponseDirectionOverrides$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressorOverrides$Type extends MessageType<CompressorOverrides> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.CompressorOverrides", [
            { no: 1, name: "response_direction_config", kind: "message", T: () => ResponseDirectionOverrides }
        ]);
    }
    create(value?: PartialMessage<CompressorOverrides>): CompressorOverrides {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CompressorOverrides>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressorOverrides): CompressorOverrides {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides response_direction_config */ 1:
                    message.responseDirectionConfig = ResponseDirectionOverrides.internalBinaryRead(reader, reader.uint32(), options, message.responseDirectionConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompressorOverrides, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.compressor.v3.ResponseDirectionOverrides response_direction_config = 1; */
        if (message.responseDirectionConfig)
            ResponseDirectionOverrides.internalBinaryWrite(message.responseDirectionConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.CompressorOverrides
 */
export const CompressorOverrides = new CompressorOverrides$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressorPerRoute$Type extends MessageType<CompressorPerRoute> {
    constructor() {
        super("envoy.extensions.filters.http.compressor.v3.CompressorPerRoute", [
            { no: 1, name: "disabled", kind: "scalar", oneof: "override", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "overrides", kind: "message", oneof: "override", T: () => CompressorOverrides }
        ]);
    }
    create(value?: PartialMessage<CompressorPerRoute>): CompressorPerRoute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.override = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CompressorPerRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressorPerRoute): CompressorPerRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.override = {
                        oneofKind: "disabled",
                        disabled: reader.bool()
                    };
                    break;
                case /* envoy.extensions.filters.http.compressor.v3.CompressorOverrides overrides */ 2:
                    message.override = {
                        oneofKind: "overrides",
                        overrides: CompressorOverrides.internalBinaryRead(reader, reader.uint32(), options, (message.override as any).overrides)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompressorPerRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.override.oneofKind === "disabled")
            writer.tag(1, WireType.Varint).bool(message.override.disabled);
        /* envoy.extensions.filters.http.compressor.v3.CompressorOverrides overrides = 2; */
        if (message.override.oneofKind === "overrides")
            CompressorOverrides.internalBinaryWrite(message.override.overrides, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.compressor.v3.CompressorPerRoute
 */
export const CompressorPerRoute = new CompressorPerRoute$Type();
