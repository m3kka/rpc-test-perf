// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/router/v3/router.proto" (package "envoy.extensions.filters.http.router.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../../../../google/protobuf/duration";
import { HttpFilter } from "../../../network/http_connection_manager/v3/http_connection_manager";
import { AccessLog } from "../../../../../config/accesslog/v3/accesslog";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
// [#protodoc-title: Router]
// Router :ref:`configuration overview <config_http_filters_router>`.
// [#extension: envoy.filters.http.router]

/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.filters.http.router.v3.Router
 */
export interface Router {
    /**
     * Whether the router generates dynamic cluster statistics. Defaults to
     * true. Can be disabled in high performance scenarios.
     *
     * @generated from protobuf field: google.protobuf.BoolValue dynamic_stats = 1;
     */
    dynamicStats?: BoolValue;
    /**
     * Whether to start a child span for egress routed calls. This can be
     * useful in scenarios where other filters (auth, ratelimit, etc.) make
     * outbound calls and have child spans rooted at the same ingress
     * parent. Defaults to false.
     *
     * @generated from protobuf field: bool start_child_span = 2;
     */
    startChildSpan: boolean;
    /**
     * Configuration for HTTP upstream logs emitted by the router. Upstream logs
     * are configured in the same way as access logs, but each log entry represents
     * an upstream request. Presuming retries are configured, multiple upstream
     * requests may be made for each downstream (inbound) request.
     *
     * @generated from protobuf field: repeated envoy.config.accesslog.v3.AccessLog upstream_log = 3;
     */
    upstreamLog: AccessLog[];
    /**
     * Additional upstream access log options.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions upstream_log_options = 9;
     */
    upstreamLogOptions?: Router_UpstreamAccessLogOptions;
    /**
     * Do not add any additional ``x-envoy-`` headers to requests or responses. This
     * only affects the :ref:`router filter generated x-envoy- headers
     * <config_http_filters_router_headers_set>`, other Envoy filters and the HTTP
     * connection manager may continue to set ``x-envoy-`` headers.
     *
     * @generated from protobuf field: bool suppress_envoy_headers = 4;
     */
    suppressEnvoyHeaders: boolean;
    /**
     * Specifies a list of HTTP headers to strictly validate. Envoy will reject a
     * request and respond with HTTP status 400 if the request contains an invalid
     * value for any of the headers listed in this field. Strict header checking
     * is only supported for the following headers:
     *
     * Value must be a ','-delimited list (i.e. no spaces) of supported retry
     * policy values:
     *
     * * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`
     * * :ref:`config_http_filters_router_x-envoy-retry-on`
     *
     * Value must be an integer:
     *
     * * :ref:`config_http_filters_router_x-envoy-max-retries`
     * * :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`
     * * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`
     *
     * @generated from protobuf field: repeated string strict_check_headers = 5;
     */
    strictCheckHeaders: string[];
    /**
     * If not set, ingress Envoy will ignore
     * :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress
     * Envoy, when deriving timeout for upstream cluster.
     *
     * @generated from protobuf field: bool respect_expected_rq_timeout = 6;
     */
    respectExpectedRqTimeout: boolean;
    /**
     * If set, Envoy will avoid incrementing HTTP failure code stats
     * on gRPC requests. This includes the individual status code value
     * (e.g. upstream_rq_504) and group stats (e.g. upstream_rq_5xx).
     * This field is useful if interested in relying only on the gRPC
     * stats filter to define success and failure metrics for gRPC requests
     * as not all failed gRPC requests charge HTTP status code metrics. See
     * :ref:`gRPC stats filter<config_http_filters_grpc_stats>` documentation
     * for more details.
     *
     * @generated from protobuf field: bool suppress_grpc_request_failure_code_stats = 7;
     */
    suppressGrpcRequestFailureCodeStats: boolean;
    /**
     * .. note::
     *   Upstream HTTP filters are currently in alpha.
     *
     * Optional HTTP filters for the upstream filter chain.
     *
     * These filters will be applied for all requests that pass through the router.
     * They will also be applied to shadowed requests.
     * Upstream filters cannot change route or cluster.
     * Upstream filters specified on the cluster will override these filters.
     *
     * If using upstream filters, please be aware that local errors sent by
     * upstream filters will not trigger retries, and local errors sent by
     * upstream filters will count as a final response if hedging is configured.
     * [#extension-category: envoy.filters.http.upstream]
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter upstream_http_filters = 8;
     */
    upstreamHttpFilters: HttpFilter[];
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions
 */
export interface Router_UpstreamAccessLogOptions {
    /**
     * If set to true, an upstream access log will be recorded when an upstream stream is
     * associated to an http request. Note: Each HTTP request received for an already established
     * connection will result in an upstream access log record. This includes, for example,
     * consecutive HTTP requests over the same connection or a request that is retried.
     * In case a retry is applied, an upstream access log will be recorded for each retry.
     *
     * @generated from protobuf field: bool flush_upstream_log_on_upstream_stream = 1;
     */
    flushUpstreamLogOnUpstreamStream: boolean;
    /**
     * The interval to flush the upstream access logs. By default, the router will flush an upstream
     * access log on stream close, when the HTTP request is complete. If this field is set, the router
     * will flush access logs periodically at the specified interval. This is especially useful in the
     * case of long-lived requests, such as CONNECT and Websockets.
     * The interval must be at least 1 millisecond.
     *
     * @generated from protobuf field: google.protobuf.Duration upstream_log_flush_interval = 2;
     */
    upstreamLogFlushInterval?: Duration;
}
// @generated message type with reflection information, may provide speed optimized methods
class Router$Type extends MessageType<Router> {
    constructor() {
        super("envoy.extensions.filters.http.router.v3.Router", [
            { no: 1, name: "dynamic_stats", kind: "message", T: () => BoolValue },
            { no: 2, name: "start_child_span", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "upstream_log", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLog },
            { no: 9, name: "upstream_log_options", kind: "message", T: () => Router_UpstreamAccessLogOptions },
            { no: 4, name: "suppress_envoy_headers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "strict_check_headers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { in: ["x-envoy-upstream-rq-timeout-ms", "x-envoy-upstream-rq-per-try-timeout-ms", "x-envoy-max-retries", "x-envoy-retry-grpc-on", "x-envoy-retry-on"] } } } } } },
            { no: 6, name: "respect_expected_rq_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "suppress_grpc_request_failure_code_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "upstream_http_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpFilter }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.router.v2.Router" } });
    }
    create(value?: PartialMessage<Router>): Router {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startChildSpan = false;
        message.upstreamLog = [];
        message.suppressEnvoyHeaders = false;
        message.strictCheckHeaders = [];
        message.respectExpectedRqTimeout = false;
        message.suppressGrpcRequestFailureCodeStats = false;
        message.upstreamHttpFilters = [];
        if (value !== undefined)
            reflectionMergePartial<Router>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Router): Router {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue dynamic_stats */ 1:
                    message.dynamicStats = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.dynamicStats);
                    break;
                case /* bool start_child_span */ 2:
                    message.startChildSpan = reader.bool();
                    break;
                case /* repeated envoy.config.accesslog.v3.AccessLog upstream_log */ 3:
                    message.upstreamLog.push(AccessLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions upstream_log_options */ 9:
                    message.upstreamLogOptions = Router_UpstreamAccessLogOptions.internalBinaryRead(reader, reader.uint32(), options, message.upstreamLogOptions);
                    break;
                case /* bool suppress_envoy_headers */ 4:
                    message.suppressEnvoyHeaders = reader.bool();
                    break;
                case /* repeated string strict_check_headers */ 5:
                    message.strictCheckHeaders.push(reader.string());
                    break;
                case /* bool respect_expected_rq_timeout */ 6:
                    message.respectExpectedRqTimeout = reader.bool();
                    break;
                case /* bool suppress_grpc_request_failure_code_stats */ 7:
                    message.suppressGrpcRequestFailureCodeStats = reader.bool();
                    break;
                case /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter upstream_http_filters */ 8:
                    message.upstreamHttpFilters.push(HttpFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Router, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue dynamic_stats = 1; */
        if (message.dynamicStats)
            BoolValue.internalBinaryWrite(message.dynamicStats, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool start_child_span = 2; */
        if (message.startChildSpan !== false)
            writer.tag(2, WireType.Varint).bool(message.startChildSpan);
        /* repeated envoy.config.accesslog.v3.AccessLog upstream_log = 3; */
        for (let i = 0; i < message.upstreamLog.length; i++)
            AccessLog.internalBinaryWrite(message.upstreamLog[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions upstream_log_options = 9; */
        if (message.upstreamLogOptions)
            Router_UpstreamAccessLogOptions.internalBinaryWrite(message.upstreamLogOptions, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* bool suppress_envoy_headers = 4; */
        if (message.suppressEnvoyHeaders !== false)
            writer.tag(4, WireType.Varint).bool(message.suppressEnvoyHeaders);
        /* repeated string strict_check_headers = 5; */
        for (let i = 0; i < message.strictCheckHeaders.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.strictCheckHeaders[i]);
        /* bool respect_expected_rq_timeout = 6; */
        if (message.respectExpectedRqTimeout !== false)
            writer.tag(6, WireType.Varint).bool(message.respectExpectedRqTimeout);
        /* bool suppress_grpc_request_failure_code_stats = 7; */
        if (message.suppressGrpcRequestFailureCodeStats !== false)
            writer.tag(7, WireType.Varint).bool(message.suppressGrpcRequestFailureCodeStats);
        /* repeated envoy.extensions.filters.network.http_connection_manager.v3.HttpFilter upstream_http_filters = 8; */
        for (let i = 0; i < message.upstreamHttpFilters.length; i++)
            HttpFilter.internalBinaryWrite(message.upstreamHttpFilters[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.router.v3.Router
 */
export const Router = new Router$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Router_UpstreamAccessLogOptions$Type extends MessageType<Router_UpstreamAccessLogOptions> {
    constructor() {
        super("envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions", [
            { no: 1, name: "flush_upstream_log_on_upstream_stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "upstream_log_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { nanos: 1000000 } } } } }
        ]);
    }
    create(value?: PartialMessage<Router_UpstreamAccessLogOptions>): Router_UpstreamAccessLogOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flushUpstreamLogOnUpstreamStream = false;
        if (value !== undefined)
            reflectionMergePartial<Router_UpstreamAccessLogOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Router_UpstreamAccessLogOptions): Router_UpstreamAccessLogOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool flush_upstream_log_on_upstream_stream */ 1:
                    message.flushUpstreamLogOnUpstreamStream = reader.bool();
                    break;
                case /* google.protobuf.Duration upstream_log_flush_interval */ 2:
                    message.upstreamLogFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.upstreamLogFlushInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Router_UpstreamAccessLogOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool flush_upstream_log_on_upstream_stream = 1; */
        if (message.flushUpstreamLogOnUpstreamStream !== false)
            writer.tag(1, WireType.Varint).bool(message.flushUpstreamLogOnUpstreamStream);
        /* google.protobuf.Duration upstream_log_flush_interval = 2; */
        if (message.upstreamLogFlushInterval)
            Duration.internalBinaryWrite(message.upstreamLogFlushInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.router.v3.Router.UpstreamAccessLogOptions
 */
export const Router_UpstreamAccessLogOptions = new Router_UpstreamAccessLogOptions$Type();
