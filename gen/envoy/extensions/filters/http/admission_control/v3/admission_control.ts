// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/admission_control/v3/admission_control.proto" (package "envoy.extensions.filters.http.admission_control.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int32Range } from "../../../../../type/v3/range";
import { RuntimeUInt32 } from "../../../../../config/core/v3/base";
import { RuntimePercent } from "../../../../../config/core/v3/base";
import { RuntimeDouble } from "../../../../../config/core/v3/base";
import { Duration } from "../../../../../../google/protobuf/duration";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
// [#protodoc-title: Admission Control]
// [#extension: envoy.filters.http.admission_control]

/**
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl
 */
export interface AdmissionControl {
    /**
     * If set to false, the admission control filter will operate as a pass-through filter. If the
     * message is unspecified, the filter will be enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag enabled = 1;
     */
    enabled?: RuntimeFeatureFlag;
    /**
     * @generated from protobuf oneof: evaluation_criteria
     */
    evaluationCriteria: {
        oneofKind: "successCriteria";
        /**
         * @generated from protobuf field: envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria success_criteria = 2;
         */
        successCriteria: AdmissionControl_SuccessCriteria;
    } | {
        oneofKind: undefined;
    };
    /**
     * The sliding time window over which the success rate is calculated. The window is rounded to the
     * nearest second. Defaults to 30s.
     *
     * @generated from protobuf field: google.protobuf.Duration sampling_window = 3;
     */
    samplingWindow?: Duration;
    /**
     * Rejection probability is defined by the formula::
     *
     *     max(0, (rq_count -  rq_success_count / sr_threshold) / (rq_count + 1)) ^ (1 / aggression)
     *
     * The aggression dictates how heavily the admission controller will throttle requests upon SR
     * dropping at or below the threshold. A value of 1 will result in a linear increase in
     * rejection probability as SR drops. Any values less than 1.0, will be set to 1.0. If the
     * message is unspecified, the aggression is 1.0. See `the admission control documentation
     * <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/admission_control_filter.html>`_
     * for a diagram illustrating this.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeDouble aggression = 4;
     */
    aggression?: RuntimeDouble;
    /**
     * Dictates the success rate at which the rejection probability is non-zero. As success rate drops
     * below this threshold, rejection probability will increase. Any success rate above the threshold
     * results in a rejection probability of 0. Defaults to 95%.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimePercent sr_threshold = 5;
     */
    srThreshold?: RuntimePercent;
    /**
     * If the average RPS of the sampling window is below this threshold, the request
     * will not be rejected, even if the success rate is lower than sr_threshold.
     * Defaults to 0.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeUInt32 rps_threshold = 6;
     */
    rpsThreshold?: RuntimeUInt32;
    /**
     * The probability of rejection will never exceed this value, even if the failure rate is rising.
     * Defaults to 80%.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimePercent max_rejection_probability = 7;
     */
    maxRejectionProbability?: RuntimePercent;
}
/**
 * Default method of specifying what constitutes a successful request. All status codes that
 * indicate a successful request must be explicitly specified if not relying on the default
 * values.
 *
 * @generated from protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria
 */
export interface AdmissionControl_SuccessCriteria {
    /**
     * If HTTP criteria are unspecified, all HTTP status codes below 500 are treated as successful
     * responses.
     *
     * .. note::
     *
     *    The default HTTP codes considered successful by the admission controller are done so due
     *    to the unlikelihood that sending fewer requests would change their behavior (for example:
     *    redirects, unauthorized access, or bad requests won't be alleviated by sending less
     *    traffic).
     *
     * @generated from protobuf field: envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria http_criteria = 1;
     */
    httpCriteria?: AdmissionControl_SuccessCriteria_HttpCriteria;
    /**
     * GRPC status codes to consider as request successes. If unspecified, defaults to: Ok,
     * Cancelled, Unknown, InvalidArgument, NotFound, AlreadyExists, Unauthenticated,
     * FailedPrecondition, OutOfRange, PermissionDenied, and Unimplemented.
     *
     * .. note::
     *
     *    The default gRPC codes that are considered successful by the admission controller are
     *    chosen because of the unlikelihood that sending fewer requests will change the behavior.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria grpc_criteria = 2;
     */
    grpcCriteria?: AdmissionControl_SuccessCriteria_GrpcCriteria;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria
 */
export interface AdmissionControl_SuccessCriteria_HttpCriteria {
    /**
     * Status code ranges that constitute a successful request. Configurable codes are in the
     * range [100, 600).
     *
     * @generated from protobuf field: repeated envoy.type.v3.Int32Range http_success_status = 1;
     */
    httpSuccessStatus: Int32Range[];
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria
 */
export interface AdmissionControl_SuccessCriteria_GrpcCriteria {
    /**
     * Status codes that constitute a successful request.
     * Mappings can be found at: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md.
     *
     * @generated from protobuf field: repeated uint32 grpc_success_status = 1;
     */
    grpcSuccessStatus: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class AdmissionControl$Type extends MessageType<AdmissionControl> {
    constructor() {
        super("envoy.extensions.filters.http.admission_control.v3.AdmissionControl", [
            { no: 1, name: "enabled", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 2, name: "success_criteria", kind: "message", oneof: "evaluationCriteria", T: () => AdmissionControl_SuccessCriteria },
            { no: 3, name: "sampling_window", kind: "message", T: () => Duration },
            { no: 4, name: "aggression", kind: "message", T: () => RuntimeDouble },
            { no: 5, name: "sr_threshold", kind: "message", T: () => RuntimePercent },
            { no: 6, name: "rps_threshold", kind: "message", T: () => RuntimeUInt32 },
            { no: 7, name: "max_rejection_probability", kind: "message", T: () => RuntimePercent }
        ]);
    }
    create(value?: PartialMessage<AdmissionControl>): AdmissionControl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.evaluationCriteria = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AdmissionControl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdmissionControl): AdmissionControl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.RuntimeFeatureFlag enabled */ 1:
                    message.enabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria success_criteria */ 2:
                    message.evaluationCriteria = {
                        oneofKind: "successCriteria",
                        successCriteria: AdmissionControl_SuccessCriteria.internalBinaryRead(reader, reader.uint32(), options, (message.evaluationCriteria as any).successCriteria)
                    };
                    break;
                case /* google.protobuf.Duration sampling_window */ 3:
                    message.samplingWindow = Duration.internalBinaryRead(reader, reader.uint32(), options, message.samplingWindow);
                    break;
                case /* envoy.config.core.v3.RuntimeDouble aggression */ 4:
                    message.aggression = RuntimeDouble.internalBinaryRead(reader, reader.uint32(), options, message.aggression);
                    break;
                case /* envoy.config.core.v3.RuntimePercent sr_threshold */ 5:
                    message.srThreshold = RuntimePercent.internalBinaryRead(reader, reader.uint32(), options, message.srThreshold);
                    break;
                case /* envoy.config.core.v3.RuntimeUInt32 rps_threshold */ 6:
                    message.rpsThreshold = RuntimeUInt32.internalBinaryRead(reader, reader.uint32(), options, message.rpsThreshold);
                    break;
                case /* envoy.config.core.v3.RuntimePercent max_rejection_probability */ 7:
                    message.maxRejectionProbability = RuntimePercent.internalBinaryRead(reader, reader.uint32(), options, message.maxRejectionProbability);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdmissionControl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.RuntimeFeatureFlag enabled = 1; */
        if (message.enabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria success_criteria = 2; */
        if (message.evaluationCriteria.oneofKind === "successCriteria")
            AdmissionControl_SuccessCriteria.internalBinaryWrite(message.evaluationCriteria.successCriteria, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration sampling_window = 3; */
        if (message.samplingWindow)
            Duration.internalBinaryWrite(message.samplingWindow, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeDouble aggression = 4; */
        if (message.aggression)
            RuntimeDouble.internalBinaryWrite(message.aggression, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimePercent sr_threshold = 5; */
        if (message.srThreshold)
            RuntimePercent.internalBinaryWrite(message.srThreshold, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeUInt32 rps_threshold = 6; */
        if (message.rpsThreshold)
            RuntimeUInt32.internalBinaryWrite(message.rpsThreshold, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimePercent max_rejection_probability = 7; */
        if (message.maxRejectionProbability)
            RuntimePercent.internalBinaryWrite(message.maxRejectionProbability, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl
 */
export const AdmissionControl = new AdmissionControl$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdmissionControl_SuccessCriteria$Type extends MessageType<AdmissionControl_SuccessCriteria> {
    constructor() {
        super("envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria", [
            { no: 1, name: "http_criteria", kind: "message", T: () => AdmissionControl_SuccessCriteria_HttpCriteria },
            { no: 2, name: "grpc_criteria", kind: "message", T: () => AdmissionControl_SuccessCriteria_GrpcCriteria }
        ]);
    }
    create(value?: PartialMessage<AdmissionControl_SuccessCriteria>): AdmissionControl_SuccessCriteria {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AdmissionControl_SuccessCriteria>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdmissionControl_SuccessCriteria): AdmissionControl_SuccessCriteria {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria http_criteria */ 1:
                    message.httpCriteria = AdmissionControl_SuccessCriteria_HttpCriteria.internalBinaryRead(reader, reader.uint32(), options, message.httpCriteria);
                    break;
                case /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria grpc_criteria */ 2:
                    message.grpcCriteria = AdmissionControl_SuccessCriteria_GrpcCriteria.internalBinaryRead(reader, reader.uint32(), options, message.grpcCriteria);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdmissionControl_SuccessCriteria, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria http_criteria = 1; */
        if (message.httpCriteria)
            AdmissionControl_SuccessCriteria_HttpCriteria.internalBinaryWrite(message.httpCriteria, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria grpc_criteria = 2; */
        if (message.grpcCriteria)
            AdmissionControl_SuccessCriteria_GrpcCriteria.internalBinaryWrite(message.grpcCriteria, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria
 */
export const AdmissionControl_SuccessCriteria = new AdmissionControl_SuccessCriteria$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdmissionControl_SuccessCriteria_HttpCriteria$Type extends MessageType<AdmissionControl_SuccessCriteria_HttpCriteria> {
    constructor() {
        super("envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria", [
            { no: 1, name: "http_success_status", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int32Range, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<AdmissionControl_SuccessCriteria_HttpCriteria>): AdmissionControl_SuccessCriteria_HttpCriteria {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.httpSuccessStatus = [];
        if (value !== undefined)
            reflectionMergePartial<AdmissionControl_SuccessCriteria_HttpCriteria>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdmissionControl_SuccessCriteria_HttpCriteria): AdmissionControl_SuccessCriteria_HttpCriteria {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.type.v3.Int32Range http_success_status */ 1:
                    message.httpSuccessStatus.push(Int32Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdmissionControl_SuccessCriteria_HttpCriteria, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.type.v3.Int32Range http_success_status = 1; */
        for (let i = 0; i < message.httpSuccessStatus.length; i++)
            Int32Range.internalBinaryWrite(message.httpSuccessStatus[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.HttpCriteria
 */
export const AdmissionControl_SuccessCriteria_HttpCriteria = new AdmissionControl_SuccessCriteria_HttpCriteria$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdmissionControl_SuccessCriteria_GrpcCriteria$Type extends MessageType<AdmissionControl_SuccessCriteria_GrpcCriteria> {
    constructor() {
        super("envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria", [
            { no: 1, name: "grpc_success_status", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<AdmissionControl_SuccessCriteria_GrpcCriteria>): AdmissionControl_SuccessCriteria_GrpcCriteria {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.grpcSuccessStatus = [];
        if (value !== undefined)
            reflectionMergePartial<AdmissionControl_SuccessCriteria_GrpcCriteria>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdmissionControl_SuccessCriteria_GrpcCriteria): AdmissionControl_SuccessCriteria_GrpcCriteria {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 grpc_success_status */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.grpcSuccessStatus.push(reader.uint32());
                    else
                        message.grpcSuccessStatus.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdmissionControl_SuccessCriteria_GrpcCriteria, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 grpc_success_status = 1; */
        if (message.grpcSuccessStatus.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.grpcSuccessStatus.length; i++)
                writer.uint32(message.grpcSuccessStatus[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.admission_control.v3.AdmissionControl.SuccessCriteria.GrpcCriteria
 */
export const AdmissionControl_SuccessCriteria_GrpcCriteria = new AdmissionControl_SuccessCriteria_GrpcCriteria$Type();
