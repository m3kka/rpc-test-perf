// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/local_ratelimit/v3/local_rate_limit.proto" (package "envoy.extensions.filters.http.local_ratelimit.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { VhRateLimitsOptions } from "../../../../common/ratelimit/v3/ratelimit";
import { XRateLimitHeadersRFCVersion } from "../../../../common/ratelimit/v3/ratelimit";
import { LocalRateLimitDescriptor } from "../../../../common/ratelimit/v3/ratelimit";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { TokenBucket } from "../../../../../type/v3/token_bucket";
import { HttpStatus } from "../../../../../type/v3/http_status";
// [#protodoc-title: Local Rate limit]
// Local Rate limit :ref:`configuration overview <config_http_filters_local_rate_limit>`.
// [#extension: envoy.filters.http.local_ratelimit]

/**
 * [#next-free-field: 14]
 *
 * @generated from protobuf message envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
 */
export interface LocalRateLimit {
    /**
     * The human readable prefix to use when emitting stats.
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * This field allows for a custom HTTP response status code to the downstream client when
     * the request has been rate limited.
     * Defaults to 429 (TooManyRequests).
     *
     * .. note::
     *   If this is set to < 400, 429 will be used instead.
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus status = 2;
     */
    status?: HttpStatus;
    /**
     * The token bucket configuration to use for rate limiting requests that are processed by this
     * filter. Each request processed by the filter consumes a single token. If the token is available,
     * the request will be allowed. If no tokens are available, the request will receive the configured
     * rate limit status.
     *
     * .. note::
     *   It's fine for the token bucket to be unset for the global configuration since the rate limit
     *   can be applied at a the virtual host or route level. Thus, the token bucket must be set
     *   for the per route configuration otherwise the config will be rejected.
     *
     * .. note::
     *   When using per route configuration, the bucket becomes unique to that route.
     *
     * .. note::
     *   In the current implementation the token bucket's :ref:`fill_interval
     *   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be >= 50ms to avoid too aggressive
     *   refills.
     *
     * @generated from protobuf field: envoy.type.v3.TokenBucket token_bucket = 3;
     */
    tokenBucket?: TokenBucket;
    /**
     * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
     * fraction of requests.
     * Defaults to 0% of requests for safety.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4;
     */
    filterEnabled?: RuntimeFractionalPercent;
    /**
     * If set, this will enforce the rate limit decisions for the given fraction of requests.
     *
     * Note: this only applies to the fraction of enabled requests.
     *
     * Defaults to 0% of requests for safety.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5;
     */
    filterEnforced?: RuntimeFractionalPercent;
    /**
     * Specifies a list of HTTP headers that should be added to each request that
     * has been rate limited and is also forwarded upstream. This can only occur when the
     * filter is enabled but not enforced.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10;
     */
    requestHeadersToAddWhenNotEnforced: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be added to each response for requests that
     * have been rate limited. This occurs when the filter is enabled and fully enforced.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * The rate limit descriptor list to use in the local rate limit to override
     * on. The rate limit descriptor is selected by the first full match from the
     * request descriptors.
     *
     * Example on how to use :ref:`this <config_http_filters_local_rate_limit_descriptors>`.
     *
     * .. note::
     *
     *   In the current implementation the descriptor's token bucket :ref:`fill_interval
     *   <envoy_v3_api_field_type.v3.TokenBucket.fill_interval>` must be a multiple
     *   global :ref:`token bucket's<envoy_v3_api_field_extensions.filters.http.local_ratelimit.v3.LocalRateLimit.token_bucket>` fill interval.
     *
     *   The descriptors must match verbatim for rate limiting to apply. There is no partial
     *   match by a subset of descriptor entries in the current implementation.
     *
     * @generated from protobuf field: repeated envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8;
     */
    descriptors: LocalRateLimitDescriptor[];
    /**
     * Specifies the rate limit configurations to be applied with the same
     * stage number. If not set, the default stage number is 0.
     *
     * .. note::
     *
     *  The filter supports a range of 0 - 10 inclusively for stage numbers.
     *
     * @generated from protobuf field: uint32 stage = 9;
     */
    stage: number;
    /**
     * Specifies the scope of the rate limiter's token bucket.
     * If set to false, the token bucket is shared across all worker threads,
     * thus the rate limits are applied per Envoy process.
     * If set to true, a token bucket is allocated for each connection.
     * Thus the rate limits are applied per connection thereby allowing
     * one to rate limit requests on a per connection basis.
     * If unspecified, the default value is false.
     *
     * @generated from protobuf field: bool local_rate_limit_per_downstream_connection = 11;
     */
    localRateLimitPerDownstreamConnection: boolean;
    /**
     * Defines the standard version to use for X-RateLimit headers emitted by the filter.
     *
     * Disabled by default.
     *
     * @generated from protobuf field: envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 12;
     */
    enableXRatelimitHeaders: XRateLimitHeadersRFCVersion;
    /**
     * Specifies if the local rate limit filter should include the virtual host rate limits.
     *
     * @generated from protobuf field: envoy.extensions.common.ratelimit.v3.VhRateLimitsOptions vh_rate_limits = 13;
     */
    vhRateLimits: VhRateLimitsOptions;
}
// @generated message type with reflection information, may provide speed optimized methods
class LocalRateLimit$Type extends MessageType<LocalRateLimit> {
    constructor() {
        super("envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "status", kind: "message", T: () => HttpStatus },
            { no: 3, name: "token_bucket", kind: "message", T: () => TokenBucket },
            { no: 4, name: "filter_enabled", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 5, name: "filter_enforced", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 10, name: "request_headers_to_add_when_not_enforced", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "10" } } } },
            { no: 6, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "10" } } } },
            { no: 8, name: "descriptors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocalRateLimitDescriptor },
            { no: 9, name: "stage", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 10 } } } },
            { no: 11, name: "local_rate_limit_per_downstream_connection", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "enable_x_ratelimit_headers", kind: "enum", T: () => ["envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion", XRateLimitHeadersRFCVersion], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 13, name: "vh_rate_limits", kind: "enum", T: () => ["envoy.extensions.common.ratelimit.v3.VhRateLimitsOptions", VhRateLimitsOptions], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<LocalRateLimit>): LocalRateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        message.requestHeadersToAddWhenNotEnforced = [];
        message.responseHeadersToAdd = [];
        message.descriptors = [];
        message.stage = 0;
        message.localRateLimitPerDownstreamConnection = false;
        message.enableXRatelimitHeaders = 0;
        message.vhRateLimits = 0;
        if (value !== undefined)
            reflectionMergePartial<LocalRateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalRateLimit): LocalRateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.type.v3.HttpStatus status */ 2:
                    message.status = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* envoy.type.v3.TokenBucket token_bucket */ 3:
                    message.tokenBucket = TokenBucket.internalBinaryRead(reader, reader.uint32(), options, message.tokenBucket);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled */ 4:
                    message.filterEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnabled);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enforced */ 5:
                    message.filterEnforced = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnforced);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced */ 10:
                    message.requestHeadersToAddWhenNotEnforced.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 6:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors */ 8:
                    message.descriptors.push(LocalRateLimitDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 stage */ 9:
                    message.stage = reader.uint32();
                    break;
                case /* bool local_rate_limit_per_downstream_connection */ 11:
                    message.localRateLimitPerDownstreamConnection = reader.bool();
                    break;
                case /* envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers */ 12:
                    message.enableXRatelimitHeaders = reader.int32();
                    break;
                case /* envoy.extensions.common.ratelimit.v3.VhRateLimitsOptions vh_rate_limits */ 13:
                    message.vhRateLimits = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalRateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.type.v3.HttpStatus status = 2; */
        if (message.status)
            HttpStatus.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.TokenBucket token_bucket = 3; */
        if (message.tokenBucket)
            TokenBucket.internalBinaryWrite(message.tokenBucket, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4; */
        if (message.filterEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnabled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5; */
        if (message.filterEnforced)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnforced, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 10; */
        for (let i = 0; i < message.requestHeadersToAddWhenNotEnforced.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAddWhenNotEnforced[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 6; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.common.ratelimit.v3.LocalRateLimitDescriptor descriptors = 8; */
        for (let i = 0; i < message.descriptors.length; i++)
            LocalRateLimitDescriptor.internalBinaryWrite(message.descriptors[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 stage = 9; */
        if (message.stage !== 0)
            writer.tag(9, WireType.Varint).uint32(message.stage);
        /* bool local_rate_limit_per_downstream_connection = 11; */
        if (message.localRateLimitPerDownstreamConnection !== false)
            writer.tag(11, WireType.Varint).bool(message.localRateLimitPerDownstreamConnection);
        /* envoy.extensions.common.ratelimit.v3.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 12; */
        if (message.enableXRatelimitHeaders !== 0)
            writer.tag(12, WireType.Varint).int32(message.enableXRatelimitHeaders);
        /* envoy.extensions.common.ratelimit.v3.VhRateLimitsOptions vh_rate_limits = 13; */
        if (message.vhRateLimits !== 0)
            writer.tag(13, WireType.Varint).int32(message.vhRateLimits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.local_ratelimit.v3.LocalRateLimit
 */
export const LocalRateLimit = new LocalRateLimit$Type();
