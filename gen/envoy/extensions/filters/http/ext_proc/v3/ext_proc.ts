// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/ext_proc/v3/ext_proc.proto" (package "envoy.extensions.filters.http.ext_proc.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ListStringMatcher } from "../../../../../type/matcher/v3/string";
import { Struct } from "../../../../../../google/protobuf/struct";
import { HeaderMutationRules } from "../../../../../config/common/mutation_rules/v3/mutation_rules";
import { Duration } from "../../../../../../google/protobuf/duration";
import { ProcessingMode } from "./processing_mode";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
// [#protodoc-title: External Processing Filter]
// External Processing Filter
// [#extension: envoy.filters.http.ext_proc]

// The External Processing filter allows an external service to act on HTTP traffic in a flexible way.

// **Current Implementation Status:**
// All options and processing modes are implemented except for the following:
// 
// * Request and response attributes are not sent and not processed.
// * Dynamic metadata in responses from the external processor is ignored.
// * "async mode" is not implemented.

/**
 * The filter communicates with an external gRPC service called an "external processor"
 * that can do a variety of things with the request and response:
 *
 * * Access and modify the HTTP headers on the request, response, or both
 * * Access and modify the HTTP request and response bodies
 * * Access and modify the dynamic stream metadata
 * * Immediately send an HTTP response downstream and terminate other processing
 *
 * The filter communicates with the server using a gRPC bidirectional stream. After the initial
 * request, the external server is in control over what additional data is sent to it
 * and how it should be processed.
 *
 * By implementing the protocol specified by the stream, the external server can choose:
 *
 * * Whether it receives the response message at all
 * * Whether it receives the message body at all, in separate chunks, or as a single buffer
 * * Whether subsequent HTTP requests are transmitted synchronously or whether they are
 *   sent asynchronously.
 * * To modify request or response trailers if they already exist
 * * To add request or response trailers where they are not present
 *
 * The filter supports up to six different processing steps. Each is represented by
 * a gRPC stream message that is sent to the external processor. For each message, the
 * processor must send a matching response.
 *
 * * Request headers: Contains the headers from the original HTTP request.
 * * Request body: Sent in a single message if the BUFFERED or BUFFERED_PARTIAL
 *   mode is chosen, in multiple messages if the STREAMED mode is chosen, and not
 *   at all otherwise.
 * * Request trailers: Delivered if they are present and if the trailer mode is set
 *   to SEND.
 * * Response headers: Contains the headers from the HTTP response. Keep in mind
 *   that if the upstream system sends them before processing the request body that
 *   this message may arrive before the complete body.
 * * Response body: Sent according to the processing mode like the request body.
 * * Response trailers: Delivered according to the processing mode like the
 *   request trailers.
 *
 * By default, the processor sends only the request and response headers messages.
 * This may be changed to include any of the six steps by changing the processing_mode
 * setting of the filter configuration, or by setting the mode_override of any response
 * from the external processor. The latter is only enabled if allow_mode_override is
 * set to true. This way, a processor may, for example, use information
 * in the request header to determine whether the message body must be examined, or whether
 * the proxy should simply stream it straight through.
 *
 * All of this together allows a server to process the filter traffic in fairly
 * sophisticated ways. For example:
 *
 * * A server may choose to examine all or part of the HTTP message bodies depending
 *   on the content of the headers.
 * * A server may choose to immediately reject some messages based on their HTTP
 *   headers (or other dynamic metadata) and more carefully examine others.
 * * A server may asynchronously monitor traffic coming through the filter by inspecting
 *   headers, bodies, or both, and then decide to switch to a synchronous processing
 *   mode, either permanently or temporarily.
 *
 * The protocol itself is based on a bidirectional gRPC stream. Envoy will send the
 * server
 * :ref:`ProcessingRequest <envoy_v3_api_msg_service.ext_proc.v3.ProcessingRequest>`
 * messages, and the server must reply with
 * :ref:`ProcessingResponse <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>`.
 *
 * Stats about each gRPC call are recorded in a :ref:`dynamic filter state
 * <arch_overview_advanced_filter_state_sharing>` object in a namespace matching the filter
 * name.
 *
 * [#next-free-field: 15]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor
 */
export interface ExternalProcessor {
    /**
     * Configuration for the gRPC service that the filter will communicate with.
     * The filter supports both the "Envoy" and "Google" gRPC clients.
     *
     * @generated from protobuf field: envoy.config.core.v3.GrpcService grpc_service = 1;
     */
    grpcService?: GrpcService;
    /**
     * By default, if the gRPC stream cannot be established, or if it is closed
     * prematurely with an error, the filter will fail. Specifically, if the
     * response headers have not yet been delivered, then it will return a 500
     * error downstream. If they have been delivered, then instead the HTTP stream to the
     * downstream client will be reset.
     * With this parameter set to true, however, then if the gRPC stream is prematurely closed
     * or could not be opened, processing continues without error.
     *
     * @generated from protobuf field: bool failure_mode_allow = 2;
     */
    failureModeAllow: boolean;
    /**
     * Specifies default options for how HTTP headers, trailers, and bodies are
     * sent. See ProcessingMode for details.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode = 3;
     */
    processingMode?: ProcessingMode;
    /**
     * [#not-implemented-hide:]
     * If true, send each part of the HTTP request or response specified by ProcessingMode
     * asynchronously -- in other words, send the message on the gRPC stream and then continue
     * filter processing. If false, which is the default, suspend filter execution after
     * each message is sent to the remote service and wait up to "message_timeout"
     * for a reply.
     *
     * @generated from protobuf field: bool async_mode = 4;
     */
    asyncMode: boolean;
    /**
     * [#not-implemented-hide:]
     * Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
     * for expressive policies. Each attribute name provided in this field will be
     * matched against that list and populated in the request_headers message.
     * See the :ref:`attribute documentation <arch_overview_request_attributes>`
     * for the list of supported attributes and their types.
     *
     * @generated from protobuf field: repeated string request_attributes = 5;
     */
    requestAttributes: string[];
    /**
     * [#not-implemented-hide:]
     * Envoy provides a number of :ref:`attributes <arch_overview_attributes>`
     * for expressive policies. Each attribute name provided in this field will be
     * matched against that list and populated in the response_headers message.
     * See the :ref:`attribute documentation <arch_overview_attributes>`
     * for the list of supported attributes and their types.
     *
     * @generated from protobuf field: repeated string response_attributes = 6;
     */
    responseAttributes: string[];
    /**
     * Specifies the timeout for each individual message sent on the stream and
     * when the filter is running in synchronous mode. Whenever the proxy sends
     * a message on the stream that requires a response, it will reset this timer,
     * and will stop processing and return an error (subject to the processing mode)
     * if the timer expires before a matching response is received. There is no
     * timeout when the filter is running in asynchronous mode. Zero is a valid
     * config which means the timer will be triggered immediately. If not
     * configured, default is 200 milliseconds.
     *
     * @generated from protobuf field: google.protobuf.Duration message_timeout = 7;
     */
    messageTimeout?: Duration;
    /**
     * Optional additional prefix to use when emitting statistics. This allows to distinguish
     * emitted statistics between configured *ext_proc* filters in an HTTP filter chain.
     *
     * @generated from protobuf field: string stat_prefix = 8;
     */
    statPrefix: string;
    /**
     * Rules that determine what modifications an external processing server may
     * make to message headers. If not set, all headers may be modified except
     * for "host", ":authority", ":scheme", ":method", and headers that start
     * with the header prefix set via
     * :ref:`header_prefix <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.header_prefix>`
     * (which is usually "x-envoy").
     * Note that changing headers such as "host" or ":authority" may not in itself
     * change Envoy's routing decision, as routes can be cached. To also force the
     * route to be recomputed, set the
     * :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
     * field to true in the same response.
     *
     * @generated from protobuf field: envoy.config.common.mutation_rules.v3.HeaderMutationRules mutation_rules = 9;
     */
    mutationRules?: HeaderMutationRules;
    /**
     * Specify the upper bound of
     * :ref:`override_message_timeout <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.override_message_timeout>`
     * If not specified, by default it is 0, which will effectively disable the ``override_message_timeout`` API.
     *
     * @generated from protobuf field: google.protobuf.Duration max_message_timeout = 10;
     */
    maxMessageTimeout?: Duration;
    /**
     * Prevents clearing the route-cache when the
     * :ref:`clear_route_cache <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.clear_route_cache>`
     * field is set in an external processor response.
     *
     * @generated from protobuf field: bool disable_clear_route_cache = 11;
     */
    disableClearRouteCache: boolean;
    /**
     * Allow headers matching the ``forward_rules`` to be forwarded to the external processing server.
     * If not set, all headers are forwarded to the external processing server.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules forward_rules = 12;
     */
    forwardRules?: HeaderForwardingRules;
    /**
     * Additional metadata to be added to the filter state for logging purposes. The metadata
     * will be added to StreamInfo's filter state under the namespace corresponding to the
     * ext_proc filter name.
     *
     * @generated from protobuf field: google.protobuf.Struct filter_metadata = 13;
     */
    filterMetadata?: Struct;
    /**
     * If ``allow_mode_override`` is set to true, the filter config :ref:`processing_mode
     * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.processing_mode>`
     * can be overridden by the response message from the external processing server
     * :ref:`mode_override <envoy_v3_api_field_service.ext_proc.v3.ProcessingResponse.mode_override>`.
     * If not set, ``mode_override`` API in the response message will be ignored.
     *
     * @generated from protobuf field: bool allow_mode_override = 14;
     */
    allowModeOverride: boolean;
}
/**
 * The HeaderForwardingRules structure specifies what headers are
 * allowed to be forwarded to the external processing server.
 *
 * This works as below:
 *
 *   1. If neither ``allowed_headers`` nor ``disallowed_headers`` is set, all headers are forwarded.
 *   2. If both ``allowed_headers`` and ``disallowed_headers`` are set, only headers in the
 *      ``allowed_headers`` but not in the ``disallowed_headers`` are forwarded.
 *   3. If ``allowed_headers`` is set, and ``disallowed_headers`` is not set, only headers in
 *      the ``allowed_headers`` are forwarded.
 *   4. If ``disallowed_headers`` is set, and ``allowed_headers`` is not set, all headers except
 *      headers in the ``disallowed_headers`` are forwarded.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules
 */
export interface HeaderForwardingRules {
    /**
     * If set, specifically allow any header in this list to be forwarded to the external
     * processing server. This can be overridden by the below ``disallowed_headers``.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1;
     */
    allowedHeaders?: ListStringMatcher;
    /**
     * If set, specifically disallow any header in this list to be forwarded to the external
     * processing server. This overrides the above ``allowed_headers`` if a header matches both.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher disallowed_headers = 2;
     */
    disallowedHeaders?: ListStringMatcher;
}
/**
 * Extra settings that may be added to per-route configuration for a
 * virtual host or cluster.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute
 */
export interface ExtProcPerRoute {
    /**
     * @generated from protobuf oneof: override
     */
    override: {
        oneofKind: "disabled";
        /**
         * Disable the filter for this particular vhost or route.
         * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
         *
         * @generated from protobuf field: bool disabled = 1;
         */
        disabled: boolean;
    } | {
        oneofKind: "overrides";
        /**
         * Override aspects of the configuration for this route. A set of
         * overrides in a more specific configuration will override a "disabled"
         * flag set in a less-specific one.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides overrides = 2;
         */
        overrides: ExtProcOverrides;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Overrides that may be set on a per-route basis
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides
 */
export interface ExtProcOverrides {
    /**
     * Set a different processing mode for this route than the default.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode = 1;
     */
    processingMode?: ProcessingMode;
    /**
     * [#not-implemented-hide:]
     * Set a different asynchronous processing option than the default.
     *
     * @generated from protobuf field: bool async_mode = 2;
     */
    asyncMode: boolean;
    /**
     * [#not-implemented-hide:]
     * Set different optional attributes than the default setting of the
     * ``request_attributes`` field.
     *
     * @generated from protobuf field: repeated string request_attributes = 3;
     */
    requestAttributes: string[];
    /**
     * [#not-implemented-hide:]
     * Set different optional properties than the default setting of the
     * ``response_attributes`` field.
     *
     * @generated from protobuf field: repeated string response_attributes = 4;
     */
    responseAttributes: string[];
    /**
     * Set a different gRPC service for this route than the default.
     *
     * @generated from protobuf field: envoy.config.core.v3.GrpcService grpc_service = 5;
     */
    grpcService?: GrpcService;
}
// @generated message type with reflection information, may provide speed optimized methods
class ExternalProcessor$Type extends MessageType<ExternalProcessor> {
    constructor() {
        super("envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor", [
            { no: 1, name: "grpc_service", kind: "message", T: () => GrpcService, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "failure_mode_allow", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "processing_mode", kind: "message", T: () => ProcessingMode },
            { no: 4, name: "async_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "request_attributes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "response_attributes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "message_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lte: { seconds: "3600" }, gte: {} } } } },
            { no: 8, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "mutation_rules", kind: "message", T: () => HeaderMutationRules },
            { no: 10, name: "max_message_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lte: { seconds: "3600" }, gte: {} } } } },
            { no: 11, name: "disable_clear_route_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "forward_rules", kind: "message", T: () => HeaderForwardingRules },
            { no: 13, name: "filter_metadata", kind: "message", T: () => Struct },
            { no: 14, name: "allow_mode_override", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExternalProcessor>): ExternalProcessor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failureModeAllow = false;
        message.asyncMode = false;
        message.requestAttributes = [];
        message.responseAttributes = [];
        message.statPrefix = "";
        message.disableClearRouteCache = false;
        message.allowModeOverride = false;
        if (value !== undefined)
            reflectionMergePartial<ExternalProcessor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExternalProcessor): ExternalProcessor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.GrpcService grpc_service */ 1:
                    message.grpcService = GrpcService.internalBinaryRead(reader, reader.uint32(), options, message.grpcService);
                    break;
                case /* bool failure_mode_allow */ 2:
                    message.failureModeAllow = reader.bool();
                    break;
                case /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode */ 3:
                    message.processingMode = ProcessingMode.internalBinaryRead(reader, reader.uint32(), options, message.processingMode);
                    break;
                case /* bool async_mode */ 4:
                    message.asyncMode = reader.bool();
                    break;
                case /* repeated string request_attributes */ 5:
                    message.requestAttributes.push(reader.string());
                    break;
                case /* repeated string response_attributes */ 6:
                    message.responseAttributes.push(reader.string());
                    break;
                case /* google.protobuf.Duration message_timeout */ 7:
                    message.messageTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.messageTimeout);
                    break;
                case /* string stat_prefix */ 8:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.config.common.mutation_rules.v3.HeaderMutationRules mutation_rules */ 9:
                    message.mutationRules = HeaderMutationRules.internalBinaryRead(reader, reader.uint32(), options, message.mutationRules);
                    break;
                case /* google.protobuf.Duration max_message_timeout */ 10:
                    message.maxMessageTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxMessageTimeout);
                    break;
                case /* bool disable_clear_route_cache */ 11:
                    message.disableClearRouteCache = reader.bool();
                    break;
                case /* envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules forward_rules */ 12:
                    message.forwardRules = HeaderForwardingRules.internalBinaryRead(reader, reader.uint32(), options, message.forwardRules);
                    break;
                case /* google.protobuf.Struct filter_metadata */ 13:
                    message.filterMetadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.filterMetadata);
                    break;
                case /* bool allow_mode_override */ 14:
                    message.allowModeOverride = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExternalProcessor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.GrpcService grpc_service = 1; */
        if (message.grpcService)
            GrpcService.internalBinaryWrite(message.grpcService, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool failure_mode_allow = 2; */
        if (message.failureModeAllow !== false)
            writer.tag(2, WireType.Varint).bool(message.failureModeAllow);
        /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode = 3; */
        if (message.processingMode)
            ProcessingMode.internalBinaryWrite(message.processingMode, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool async_mode = 4; */
        if (message.asyncMode !== false)
            writer.tag(4, WireType.Varint).bool(message.asyncMode);
        /* repeated string request_attributes = 5; */
        for (let i = 0; i < message.requestAttributes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.requestAttributes[i]);
        /* repeated string response_attributes = 6; */
        for (let i = 0; i < message.responseAttributes.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.responseAttributes[i]);
        /* google.protobuf.Duration message_timeout = 7; */
        if (message.messageTimeout)
            Duration.internalBinaryWrite(message.messageTimeout, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string stat_prefix = 8; */
        if (message.statPrefix !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.config.common.mutation_rules.v3.HeaderMutationRules mutation_rules = 9; */
        if (message.mutationRules)
            HeaderMutationRules.internalBinaryWrite(message.mutationRules, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_message_timeout = 10; */
        if (message.maxMessageTimeout)
            Duration.internalBinaryWrite(message.maxMessageTimeout, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* bool disable_clear_route_cache = 11; */
        if (message.disableClearRouteCache !== false)
            writer.tag(11, WireType.Varint).bool(message.disableClearRouteCache);
        /* envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules forward_rules = 12; */
        if (message.forwardRules)
            HeaderForwardingRules.internalBinaryWrite(message.forwardRules, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct filter_metadata = 13; */
        if (message.filterMetadata)
            Struct.internalBinaryWrite(message.filterMetadata, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_mode_override = 14; */
        if (message.allowModeOverride !== false)
            writer.tag(14, WireType.Varint).bool(message.allowModeOverride);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_proc.v3.ExternalProcessor
 */
export const ExternalProcessor = new ExternalProcessor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderForwardingRules$Type extends MessageType<HeaderForwardingRules> {
    constructor() {
        super("envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules", [
            { no: 1, name: "allowed_headers", kind: "message", T: () => ListStringMatcher },
            { no: 2, name: "disallowed_headers", kind: "message", T: () => ListStringMatcher }
        ]);
    }
    create(value?: PartialMessage<HeaderForwardingRules>): HeaderForwardingRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeaderForwardingRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderForwardingRules): HeaderForwardingRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.v3.ListStringMatcher allowed_headers */ 1:
                    message.allowedHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedHeaders);
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher disallowed_headers */ 2:
                    message.disallowedHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.disallowedHeaders);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderForwardingRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1; */
        if (message.allowedHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher disallowed_headers = 2; */
        if (message.disallowedHeaders)
            ListStringMatcher.internalBinaryWrite(message.disallowedHeaders, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_proc.v3.HeaderForwardingRules
 */
export const HeaderForwardingRules = new HeaderForwardingRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtProcPerRoute$Type extends MessageType<ExtProcPerRoute> {
    constructor() {
        super("envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute", [
            { no: 1, name: "disabled", kind: "scalar", oneof: "override", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "overrides", kind: "message", oneof: "override", T: () => ExtProcOverrides }
        ]);
    }
    create(value?: PartialMessage<ExtProcPerRoute>): ExtProcPerRoute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.override = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExtProcPerRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtProcPerRoute): ExtProcPerRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.override = {
                        oneofKind: "disabled",
                        disabled: reader.bool()
                    };
                    break;
                case /* envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides overrides */ 2:
                    message.override = {
                        oneofKind: "overrides",
                        overrides: ExtProcOverrides.internalBinaryRead(reader, reader.uint32(), options, (message.override as any).overrides)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtProcPerRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.override.oneofKind === "disabled")
            writer.tag(1, WireType.Varint).bool(message.override.disabled);
        /* envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides overrides = 2; */
        if (message.override.oneofKind === "overrides")
            ExtProcOverrides.internalBinaryWrite(message.override.overrides, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_proc.v3.ExtProcPerRoute
 */
export const ExtProcPerRoute = new ExtProcPerRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtProcOverrides$Type extends MessageType<ExtProcOverrides> {
    constructor() {
        super("envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides", [
            { no: 1, name: "processing_mode", kind: "message", T: () => ProcessingMode },
            { no: 2, name: "async_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "request_attributes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "response_attributes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "grpc_service", kind: "message", T: () => GrpcService }
        ]);
    }
    create(value?: PartialMessage<ExtProcOverrides>): ExtProcOverrides {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.asyncMode = false;
        message.requestAttributes = [];
        message.responseAttributes = [];
        if (value !== undefined)
            reflectionMergePartial<ExtProcOverrides>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtProcOverrides): ExtProcOverrides {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode */ 1:
                    message.processingMode = ProcessingMode.internalBinaryRead(reader, reader.uint32(), options, message.processingMode);
                    break;
                case /* bool async_mode */ 2:
                    message.asyncMode = reader.bool();
                    break;
                case /* repeated string request_attributes */ 3:
                    message.requestAttributes.push(reader.string());
                    break;
                case /* repeated string response_attributes */ 4:
                    message.responseAttributes.push(reader.string());
                    break;
                case /* envoy.config.core.v3.GrpcService grpc_service */ 5:
                    message.grpcService = GrpcService.internalBinaryRead(reader, reader.uint32(), options, message.grpcService);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtProcOverrides, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode processing_mode = 1; */
        if (message.processingMode)
            ProcessingMode.internalBinaryWrite(message.processingMode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool async_mode = 2; */
        if (message.asyncMode !== false)
            writer.tag(2, WireType.Varint).bool(message.asyncMode);
        /* repeated string request_attributes = 3; */
        for (let i = 0; i < message.requestAttributes.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.requestAttributes[i]);
        /* repeated string response_attributes = 4; */
        for (let i = 0; i < message.responseAttributes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.responseAttributes[i]);
        /* envoy.config.core.v3.GrpcService grpc_service = 5; */
        if (message.grpcService)
            GrpcService.internalBinaryWrite(message.grpcService, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ext_proc.v3.ExtProcOverrides
 */
export const ExtProcOverrides = new ExtProcOverrides$Type();
