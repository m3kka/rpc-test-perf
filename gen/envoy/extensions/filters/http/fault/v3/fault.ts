// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/fault/v3/fault.proto" (package "envoy.extensions.filters.http.fault.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "../../../../../../google/protobuf/struct";
import { FaultRateLimit } from "../../../common/fault/v3/fault";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { HeaderMatcher } from "../../../../../config/route/v3/route_components";
import { FaultDelay } from "../../../common/fault/v3/fault";
import { FractionalPercent } from "../../../../../type/v3/percent";
// [#protodoc-title: Fault Injection]
// Fault Injection :ref:`configuration overview <config_http_filters_fault_injection>`.
// [#extension: envoy.filters.http.fault]

/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.fault.v3.FaultAbort
 */
export interface FaultAbort {
    /**
     * @generated from protobuf oneof: error_type
     */
    errorType: {
        oneofKind: "httpStatus";
        /**
         * HTTP status code to use to abort the HTTP request.
         *
         * @generated from protobuf field: uint32 http_status = 2;
         */
        httpStatus: number;
    } | {
        oneofKind: "grpcStatus";
        /**
         * gRPC status code to use to abort the gRPC request.
         *
         * @generated from protobuf field: uint32 grpc_status = 5;
         */
        grpcStatus: number;
    } | {
        oneofKind: "headerAbort";
        /**
         * Fault aborts are controlled via an HTTP header (if applicable).
         *
         * @generated from protobuf field: envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort header_abort = 4;
         */
        headerAbort: FaultAbort_HeaderAbort;
    } | {
        oneofKind: undefined;
    };
    /**
     * The percentage of requests/operations/connections that will be aborted with the error code
     * provided.
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent percentage = 3;
     */
    percentage?: FractionalPercent;
}
/**
 * Fault aborts are controlled via an HTTP header (if applicable). See the
 * :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
 * more information.
 *
 * @generated from protobuf message envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort
 */
export interface FaultAbort_HeaderAbort {
}
/**
 * [#next-free-field: 17]
 *
 * @generated from protobuf message envoy.extensions.filters.http.fault.v3.HTTPFault
 */
export interface HTTPFault {
    /**
     * If specified, the filter will inject delays based on the values in the
     * object.
     *
     * @generated from protobuf field: envoy.extensions.filters.common.fault.v3.FaultDelay delay = 1;
     */
    delay?: FaultDelay;
    /**
     * If specified, the filter will abort requests based on the values in
     * the object. At least ``abort`` or ``delay`` must be specified.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.fault.v3.FaultAbort abort = 2;
     */
    abort?: FaultAbort;
    /**
     * Specifies the name of the (destination) upstream cluster that the
     * filter should match on. Fault injection will be restricted to requests
     * bound to the specific upstream cluster.
     *
     * @generated from protobuf field: string upstream_cluster = 3;
     */
    upstreamCluster: string;
    /**
     * Specifies a set of headers that the filter should match on. The fault
     * injection filter can be applied selectively to requests that match a set of
     * headers specified in the fault filter config. The chances of actual fault
     * injection further depend on the value of the :ref:`percentage
     * <envoy_v3_api_field_extensions.filters.http.fault.v3.FaultAbort.percentage>` field.
     * The filter will check the request's headers against all the specified
     * headers in the filter config. A match will happen if all the headers in the
     * config are present in the request with the same values (or based on
     * presence if the ``value`` field is not in the config).
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 4;
     */
    headers: HeaderMatcher[];
    /**
     * Faults are injected for the specified list of downstream hosts. If this
     * setting is not set, faults are injected for all downstream nodes.
     * Downstream node name is taken from :ref:`the HTTP
     * x-envoy-downstream-service-node
     * <config_http_conn_man_headers_downstream-service-node>` header and compared
     * against downstream_nodes list.
     *
     * @generated from protobuf field: repeated string downstream_nodes = 5;
     */
    downstreamNodes: string[];
    /**
     * The maximum number of faults that can be active at a single time via the configured fault
     * filter. Note that because this setting can be overridden at the route level, it's possible
     * for the number of active faults to be greater than this value (if injected via a different
     * route). If not specified, defaults to unlimited. This setting can be overridden via
     * ``runtime <config_http_filters_fault_injection_runtime>`` and any faults that are not injected
     * due to overflow will be indicated via the ``faults_overflow
     * <config_http_filters_fault_injection_stats>`` stat.
     *
     * .. attention::
     *   Like other :ref:`circuit breakers <arch_overview_circuit_break>` in Envoy, this is a fuzzy
     *   limit. It's possible for the number of active faults to rise slightly above the configured
     *   amount due to the implementation details.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_active_faults = 6;
     */
    maxActiveFaults?: UInt32Value;
    /**
     * The response rate limit to be applied to the response body of the stream. When configured,
     * the percentage can be overridden by the :ref:`fault.http.rate_limit.response_percent
     * <config_http_filters_fault_injection_runtime>` runtime key.
     *
     * .. attention::
     *  This is a per-stream limit versus a connection level limit. This means that concurrent streams
     *  will each get an independent limit.
     *
     * @generated from protobuf field: envoy.extensions.filters.common.fault.v3.FaultRateLimit response_rate_limit = 7;
     */
    responseRateLimit?: FaultRateLimit;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.delay.fixed_delay_percent
     *
     * @generated from protobuf field: string delay_percent_runtime = 8;
     */
    delayPercentRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.abort.abort_percent
     *
     * @generated from protobuf field: string abort_percent_runtime = 9;
     */
    abortPercentRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.delay.fixed_duration_ms
     *
     * @generated from protobuf field: string delay_duration_runtime = 10;
     */
    delayDurationRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.abort.http_status
     *
     * @generated from protobuf field: string abort_http_status_runtime = 11;
     */
    abortHttpStatusRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.max_active_faults
     *
     * @generated from protobuf field: string max_active_faults_runtime = 12;
     */
    maxActiveFaultsRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.rate_limit.response_percent
     *
     * @generated from protobuf field: string response_rate_limit_percent_runtime = 13;
     */
    responseRateLimitPercentRuntime: string;
    /**
     * The runtime key to override the :ref:`default <config_http_filters_fault_injection_runtime>`
     * runtime. The default is: fault.http.abort.grpc_status
     *
     * @generated from protobuf field: string abort_grpc_status_runtime = 14;
     */
    abortGrpcStatusRuntime: string;
    /**
     * To control whether stats storage is allocated dynamically for each downstream server.
     * If set to true, "x-envoy-downstream-service-cluster" field of header will be ignored by this filter.
     * If set to false, dynamic stats storage will be allocated for the downstream cluster name.
     * Default value is false.
     *
     * @generated from protobuf field: bool disable_downstream_cluster_stats = 15;
     */
    disableDownstreamClusterStats: boolean;
    /**
     * When an abort or delay fault is executed, the metadata struct provided here will be added to the
     * request's dynamic metadata under the namespace corresponding to the name of the fault filter.
     * This data can be logged as part of Access Logs using the :ref:`command operator
     * <config_access_log_command_operators>` %DYNAMIC_METADATA(NAMESPACE)%, where NAMESPACE is the name of
     * the fault filter.
     *
     * @generated from protobuf field: google.protobuf.Struct filter_metadata = 16;
     */
    filterMetadata?: Struct;
}
// @generated message type with reflection information, may provide speed optimized methods
class FaultAbort$Type extends MessageType<FaultAbort> {
    constructor() {
        super("envoy.extensions.filters.http.fault.v3.FaultAbort", [
            { no: 2, name: "http_status", kind: "scalar", oneof: "errorType", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lt: 600, gte: 200 } } } },
            { no: 5, name: "grpc_status", kind: "scalar", oneof: "errorType", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "header_abort", kind: "message", oneof: "errorType", T: () => FaultAbort_HeaderAbort },
            { no: 3, name: "percentage", kind: "message", T: () => FractionalPercent }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.fault.v2.FaultAbort" } });
    }
    create(value?: PartialMessage<FaultAbort>): FaultAbort {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FaultAbort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FaultAbort): FaultAbort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 http_status */ 2:
                    message.errorType = {
                        oneofKind: "httpStatus",
                        httpStatus: reader.uint32()
                    };
                    break;
                case /* uint32 grpc_status */ 5:
                    message.errorType = {
                        oneofKind: "grpcStatus",
                        grpcStatus: reader.uint32()
                    };
                    break;
                case /* envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort header_abort */ 4:
                    message.errorType = {
                        oneofKind: "headerAbort",
                        headerAbort: FaultAbort_HeaderAbort.internalBinaryRead(reader, reader.uint32(), options, (message.errorType as any).headerAbort)
                    };
                    break;
                case /* envoy.type.v3.FractionalPercent percentage */ 3:
                    message.percentage = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.percentage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FaultAbort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 http_status = 2; */
        if (message.errorType.oneofKind === "httpStatus")
            writer.tag(2, WireType.Varint).uint32(message.errorType.httpStatus);
        /* uint32 grpc_status = 5; */
        if (message.errorType.oneofKind === "grpcStatus")
            writer.tag(5, WireType.Varint).uint32(message.errorType.grpcStatus);
        /* envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort header_abort = 4; */
        if (message.errorType.oneofKind === "headerAbort")
            FaultAbort_HeaderAbort.internalBinaryWrite(message.errorType.headerAbort, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.FractionalPercent percentage = 3; */
        if (message.percentage)
            FractionalPercent.internalBinaryWrite(message.percentage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.fault.v3.FaultAbort
 */
export const FaultAbort = new FaultAbort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FaultAbort_HeaderAbort$Type extends MessageType<FaultAbort_HeaderAbort> {
    constructor() {
        super("envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.fault.v2.FaultAbort.HeaderAbort" } });
    }
    create(value?: PartialMessage<FaultAbort_HeaderAbort>): FaultAbort_HeaderAbort {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FaultAbort_HeaderAbort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FaultAbort_HeaderAbort): FaultAbort_HeaderAbort {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FaultAbort_HeaderAbort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.fault.v3.FaultAbort.HeaderAbort
 */
export const FaultAbort_HeaderAbort = new FaultAbort_HeaderAbort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HTTPFault$Type extends MessageType<HTTPFault> {
    constructor() {
        super("envoy.extensions.filters.http.fault.v3.HTTPFault", [
            { no: 1, name: "delay", kind: "message", T: () => FaultDelay },
            { no: 2, name: "abort", kind: "message", T: () => FaultAbort },
            { no: 3, name: "upstream_cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 5, name: "downstream_nodes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "max_active_faults", kind: "message", T: () => UInt32Value },
            { no: 7, name: "response_rate_limit", kind: "message", T: () => FaultRateLimit },
            { no: 8, name: "delay_percent_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "abort_percent_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "delay_duration_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "abort_http_status_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "max_active_faults_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "response_rate_limit_percent_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "abort_grpc_status_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "disable_downstream_cluster_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "filter_metadata", kind: "message", T: () => Struct }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.fault.v2.HTTPFault" } });
    }
    create(value?: PartialMessage<HTTPFault>): HTTPFault {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upstreamCluster = "";
        message.headers = [];
        message.downstreamNodes = [];
        message.delayPercentRuntime = "";
        message.abortPercentRuntime = "";
        message.delayDurationRuntime = "";
        message.abortHttpStatusRuntime = "";
        message.maxActiveFaultsRuntime = "";
        message.responseRateLimitPercentRuntime = "";
        message.abortGrpcStatusRuntime = "";
        message.disableDownstreamClusterStats = false;
        if (value !== undefined)
            reflectionMergePartial<HTTPFault>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HTTPFault): HTTPFault {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.common.fault.v3.FaultDelay delay */ 1:
                    message.delay = FaultDelay.internalBinaryRead(reader, reader.uint32(), options, message.delay);
                    break;
                case /* envoy.extensions.filters.http.fault.v3.FaultAbort abort */ 2:
                    message.abort = FaultAbort.internalBinaryRead(reader, reader.uint32(), options, message.abort);
                    break;
                case /* string upstream_cluster */ 3:
                    message.upstreamCluster = reader.string();
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 4:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string downstream_nodes */ 5:
                    message.downstreamNodes.push(reader.string());
                    break;
                case /* google.protobuf.UInt32Value max_active_faults */ 6:
                    message.maxActiveFaults = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxActiveFaults);
                    break;
                case /* envoy.extensions.filters.common.fault.v3.FaultRateLimit response_rate_limit */ 7:
                    message.responseRateLimit = FaultRateLimit.internalBinaryRead(reader, reader.uint32(), options, message.responseRateLimit);
                    break;
                case /* string delay_percent_runtime */ 8:
                    message.delayPercentRuntime = reader.string();
                    break;
                case /* string abort_percent_runtime */ 9:
                    message.abortPercentRuntime = reader.string();
                    break;
                case /* string delay_duration_runtime */ 10:
                    message.delayDurationRuntime = reader.string();
                    break;
                case /* string abort_http_status_runtime */ 11:
                    message.abortHttpStatusRuntime = reader.string();
                    break;
                case /* string max_active_faults_runtime */ 12:
                    message.maxActiveFaultsRuntime = reader.string();
                    break;
                case /* string response_rate_limit_percent_runtime */ 13:
                    message.responseRateLimitPercentRuntime = reader.string();
                    break;
                case /* string abort_grpc_status_runtime */ 14:
                    message.abortGrpcStatusRuntime = reader.string();
                    break;
                case /* bool disable_downstream_cluster_stats */ 15:
                    message.disableDownstreamClusterStats = reader.bool();
                    break;
                case /* google.protobuf.Struct filter_metadata */ 16:
                    message.filterMetadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.filterMetadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HTTPFault, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.common.fault.v3.FaultDelay delay = 1; */
        if (message.delay)
            FaultDelay.internalBinaryWrite(message.delay, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.fault.v3.FaultAbort abort = 2; */
        if (message.abort)
            FaultAbort.internalBinaryWrite(message.abort, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string upstream_cluster = 3; */
        if (message.upstreamCluster !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.upstreamCluster);
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 4; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string downstream_nodes = 5; */
        for (let i = 0; i < message.downstreamNodes.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.downstreamNodes[i]);
        /* google.protobuf.UInt32Value max_active_faults = 6; */
        if (message.maxActiveFaults)
            UInt32Value.internalBinaryWrite(message.maxActiveFaults, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.common.fault.v3.FaultRateLimit response_rate_limit = 7; */
        if (message.responseRateLimit)
            FaultRateLimit.internalBinaryWrite(message.responseRateLimit, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string delay_percent_runtime = 8; */
        if (message.delayPercentRuntime !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.delayPercentRuntime);
        /* string abort_percent_runtime = 9; */
        if (message.abortPercentRuntime !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.abortPercentRuntime);
        /* string delay_duration_runtime = 10; */
        if (message.delayDurationRuntime !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.delayDurationRuntime);
        /* string abort_http_status_runtime = 11; */
        if (message.abortHttpStatusRuntime !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.abortHttpStatusRuntime);
        /* string max_active_faults_runtime = 12; */
        if (message.maxActiveFaultsRuntime !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.maxActiveFaultsRuntime);
        /* string response_rate_limit_percent_runtime = 13; */
        if (message.responseRateLimitPercentRuntime !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.responseRateLimitPercentRuntime);
        /* string abort_grpc_status_runtime = 14; */
        if (message.abortGrpcStatusRuntime !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.abortGrpcStatusRuntime);
        /* bool disable_downstream_cluster_stats = 15; */
        if (message.disableDownstreamClusterStats !== false)
            writer.tag(15, WireType.Varint).bool(message.disableDownstreamClusterStats);
        /* google.protobuf.Struct filter_metadata = 16; */
        if (message.filterMetadata)
            Struct.internalBinaryWrite(message.filterMetadata, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.fault.v3.HTTPFault
 */
export const HTTPFault = new HTTPFault$Type();
