// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/ratelimit/v3/rate_limit.proto" (package "envoy.extensions.filters.http.ratelimit.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MetadataKey } from "../../../../../type/metadata/v3/metadata";
import { HeaderMatcher } from "../../../../../config/route/v3/route_components";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { RateLimitServiceConfig } from "../../../../../config/ratelimit/v3/rls";
import { Duration } from "../../../../../../google/protobuf/duration";
// [#protodoc-title: Rate limit]
// Rate limit :ref:`configuration overview <config_http_filters_rate_limit>`.
// [#extension: envoy.filters.http.ratelimit]

/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimit
 */
export interface RateLimit {
    /**
     * The rate limit domain to use when calling the rate limit service.
     *
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
    /**
     * Specifies the rate limit configurations to be applied with the same
     * stage number. If not set, the default stage number is 0.
     *
     * .. note::
     *
     *  The filter supports a range of 0 - 10 inclusively for stage numbers.
     *
     * @generated from protobuf field: uint32 stage = 2;
     */
    stage: number;
    /**
     * The type of requests the filter should apply to. The supported
     * types are ``internal``, ``external`` or ``both``. A request is considered internal if
     * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
     * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
     * request is considered external. The filter defaults to ``both``, and it will apply to all request
     * types.
     *
     * @generated from protobuf field: string request_type = 3;
     */
    requestType: string;
    /**
     * The timeout in milliseconds for the rate limit service RPC. If not
     * set, this defaults to 20ms.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 4;
     */
    timeout?: Duration;
    /**
     * The filter's behaviour in case the rate limiting service does
     * not respond back. When it is set to true, Envoy will not allow traffic in case of
     * communication failure between rate limiting service and the proxy.
     *
     * @generated from protobuf field: bool failure_mode_deny = 5;
     */
    failureModeDeny: boolean;
    /**
     * Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
     * of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
     * HTTP code will be 200 for a gRPC response.
     *
     * @generated from protobuf field: bool rate_limited_as_resource_exhausted = 6;
     */
    rateLimitedAsResourceExhausted: boolean;
    /**
     * Configuration for an external rate limit service provider. If not
     * specified, any calls to the rate limit service will immediately return
     * success.
     *
     * @generated from protobuf field: envoy.config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 7;
     */
    rateLimitService?: RateLimitServiceConfig;
    /**
     * Defines the standard version to use for X-RateLimit headers emitted by the filter:
     *
     * * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
     *   client in the current time-window followed by the description of the
     *   quota policy. The values are returned by the rate limiting service in
     *   :ref:`current_limit<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit>`
     *   field. Example: ``10, 10;w=1;name="per-ip", 1000;w=3600``.
     * * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
     *   current time-window. The values are returned by the rate limiting service
     *   in :ref:`limit_remaining<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.limit_remaining>`
     *   field.
     * * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
     *   the current time-window. The values are returned by the rate limiting service
     *   in :ref:`duration_until_reset<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset>`
     *   field.
     *
     * In case rate limiting policy specifies more then one time window, the values
     * above represent the window that is closest to reaching its limit.
     *
     * For more information about the headers specification see selected version of
     * the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
     *
     * Disabled by default.
     *
     * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 8;
     */
    enableXRatelimitHeaders: RateLimit_XRateLimitHeadersRFCVersion;
    /**
     * Disables emitting the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>` header
     * in case of rate limiting (i.e. 429 responses).
     * Having this header not present potentially makes the request retriable.
     *
     * @generated from protobuf field: bool disable_x_envoy_ratelimited_header = 9;
     */
    disableXEnvoyRatelimitedHeader: boolean;
    /**
     * This field allows for a custom HTTP response status code to the downstream client when
     * the request has been rate limited.
     * Defaults to 429 (TooManyRequests).
     *
     * .. note::
     *   If this is set to < 400, 429 will be used instead.
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus rate_limited_status = 10;
     */
    rateLimitedStatus?: HttpStatus;
    /**
     * Specifies a list of HTTP headers that should be added to each response for requests that
     * have been rate limited.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 11;
     */
    responseHeadersToAdd: HeaderValueOption[];
}
/**
 * Defines the version of the standard to use for X-RateLimit headers.
 *
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
 *
 * @generated from protobuf enum envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion
 */
export enum RateLimit_XRateLimitHeadersRFCVersion {
    /**
     * X-RateLimit headers disabled.
     *
     * @generated from protobuf enum value: OFF = 0;
     */
    OFF = 0,
    /**
     * Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
     *
     * @generated from protobuf enum value: DRAFT_VERSION_03 = 1;
     */
    DRAFT_VERSION_03 = 1
}
/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig
 */
export interface RateLimitConfig {
    /**
     * Refers to the stage set in the filter. The rate limit configuration only
     * applies to filters with the same stage number. The default stage number is
     * 0.
     *
     * .. note::
     *
     *   The filter supports a range of 0 - 10 inclusively for stage numbers.
     *
     * @generated from protobuf field: uint32 stage = 1;
     */
    stage: number;
    /**
     * The key to be set in runtime to disable this rate limit configuration.
     *
     * @generated from protobuf field: string disable_key = 2;
     */
    disableKey: string;
    /**
     * A list of actions that are to be applied for this rate limit configuration.
     * Order matters as the actions are processed sequentially and the descriptor
     * is composed by appending descriptor entries in that sequence. If an action
     * cannot append a descriptor entry, no descriptor is generated for the
     * configuration. See :ref:`composing actions
     * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action actions = 3;
     */
    actions: RateLimitConfig_Action[];
    /**
     * An optional limit override to be appended to the descriptor produced by this
     * rate limit configuration. If the override value is invalid or cannot be resolved
     * from metadata, no override is provided. See :ref:`rate limit override
     * <config_http_filters_rate_limit_rate_limit_override>` for more information.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override limit = 4;
     */
    limit?: RateLimitConfig_Override;
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action
 */
export interface RateLimitConfig_Action {
    /**
     * @generated from protobuf oneof: action_specifier
     */
    actionSpecifier: {
        oneofKind: "sourceCluster";
        /**
         * Rate limit on source cluster.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster source_cluster = 1;
         */
        sourceCluster: RateLimitConfig_Action_SourceCluster;
    } | {
        oneofKind: "destinationCluster";
        /**
         * Rate limit on destination cluster.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster destination_cluster = 2;
         */
        destinationCluster: RateLimitConfig_Action_DestinationCluster;
    } | {
        oneofKind: "requestHeaders";
        /**
         * Rate limit on request headers.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders request_headers = 3;
         */
        requestHeaders: RateLimitConfig_Action_RequestHeaders;
    } | {
        oneofKind: "remoteAddress";
        /**
         * Rate limit on remote address.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress remote_address = 4;
         */
        remoteAddress: RateLimitConfig_Action_RemoteAddress;
    } | {
        oneofKind: "genericKey";
        /**
         * Rate limit on a generic key.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey generic_key = 5;
         */
        genericKey: RateLimitConfig_Action_GenericKey;
    } | {
        oneofKind: "headerValueMatch";
        /**
         * Rate limit on the existence of request headers.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch header_value_match = 6;
         */
        headerValueMatch: RateLimitConfig_Action_HeaderValueMatch;
    } | {
        oneofKind: "metadata";
        /**
         * Rate limit on metadata.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData metadata = 8;
         */
        metadata: RateLimitConfig_Action_MetaData;
    } | {
        oneofKind: "extension";
        /**
         * Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
         * [#extension-category: envoy.rate_limit_descriptors]
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig extension = 9;
         */
        extension: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster
 */
export interface RateLimitConfig_Action_SourceCluster {
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster
 */
export interface RateLimitConfig_Action_DestinationCluster {
}
/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders
 */
export interface RateLimitConfig_Action_RequestHeaders {
    /**
     * The header name to be queried from the request headers. The header’s
     * value is used to populate the value of the descriptor entry for the
     * descriptor_key.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 2;
     */
    descriptorKey: string;
    /**
     * If set to true, Envoy skips the descriptor while calling rate limiting service
     * when header is not present in the request. By default it skips calling the
     * rate limiting service if this header is not present in the request.
     *
     * @generated from protobuf field: bool skip_if_absent = 3;
     */
    skipIfAbsent: boolean;
}
/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress
 */
export interface RateLimitConfig_Action_RemoteAddress {
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey
 */
export interface RateLimitConfig_Action_GenericKey {
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * An optional key to use in the descriptor entry. If not set it defaults
     * to 'generic_key' as the descriptor key.
     *
     * @generated from protobuf field: string descriptor_key = 2;
     */
    descriptorKey: string;
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch
 */
export interface RateLimitConfig_Action_HeaderValueMatch {
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * If set to true, the action will append a descriptor entry when the
     * request matches the headers. If set to false, the action will append a
     * descriptor entry when the request does not match the headers. The
     * default value is true.
     *
     * @generated from protobuf field: bool expect_match = 2;
     */
    expectMatch: boolean;
    /**
     * Specifies a set of headers that the rate limit action should match
     * on. The action will check the request’s headers against all the
     * specified headers in the config. A match will happen if all the
     * headers in the config are present in the request with the same values
     * (or based on presence if the value field is not in the config).
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 3;
     */
    headers: HeaderMatcher[];
}
/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData
 */
export interface RateLimitConfig_Action_MetaData {
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 1;
     */
    descriptorKey: string;
    /**
     * Metadata struct that defines the key and path to retrieve the string value. A match will
     * only happen if the value in the metadata is of type string.
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 2;
     */
    metadataKey?: MetadataKey;
    /**
     * An optional value to use if ``metadata_key`` is empty. If not set and
     * no value is present under the metadata_key then ``skip_if_absent`` is followed to
     * skip calling the rate limiting service or skip the descriptor.
     *
     * @generated from protobuf field: string default_value = 3;
     */
    defaultValue: string;
    /**
     * Source of metadata
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source source = 4;
     */
    source: RateLimitConfig_Action_MetaData_Source;
    /**
     * If set to true, Envoy skips the descriptor while calling rate limiting service
     * when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
     * rate limiting service in that case.
     *
     * @generated from protobuf field: bool skip_if_absent = 5;
     */
    skipIfAbsent: boolean;
}
/**
 * @generated from protobuf enum envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source
 */
export enum RateLimitConfig_Action_MetaData_Source {
    /**
     * Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
     *
     * @generated from protobuf enum value: DYNAMIC = 0;
     */
    DYNAMIC = 0,
    /**
     * Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
     *
     * @generated from protobuf enum value: ROUTE_ENTRY = 1;
     */
    ROUTE_ENTRY = 1
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override
 */
export interface RateLimitConfig_Override {
    /**
     * @generated from protobuf oneof: override_specifier
     */
    overrideSpecifier: {
        oneofKind: "dynamicMetadata";
        /**
         * Limit override from dynamic metadata.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata dynamic_metadata = 1;
         */
        dynamicMetadata: RateLimitConfig_Override_DynamicMetadata;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Fetches the override from the dynamic metadata.
 *
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata
 */
export interface RateLimitConfig_Override_DynamicMetadata {
    /**
     * Metadata struct that defines the key and path to retrieve the struct value.
     * The value must be a struct containing an integer "requests_per_unit" property
     * and a "unit" property with a value parseable to :ref:`RateLimitUnit
     * enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 1;
     */
    metadataKey?: MetadataKey;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute
 */
export interface RateLimitPerRoute {
    /**
     * Specifies if the rate limit filter should include the virtual host rate limits.
     * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions vh_rate_limits = 1;
     */
    vhRateLimits: RateLimitPerRoute_VhRateLimitsOptions;
    /**
     * Specifies if the rate limit filter should include the lower levels (route level, virtual host level or cluster weight level) rate limits override options.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions override_option = 2;
     */
    overrideOption: RateLimitPerRoute_OverrideOptions;
    /**
     * Rate limit configuration. If not set, uses the
     * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
     * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields instead.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig rate_limits = 3;
     */
    rateLimits: RateLimitConfig[];
    /**
     * Overrides the domain. If not set, uses the filter-level domain instead.
     *
     * @generated from protobuf field: string domain = 4;
     */
    domain: string;
}
/**
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
 *
 * @generated from protobuf enum envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions
 */
export enum RateLimitPerRoute_VhRateLimitsOptions {
    /**
     * Use the virtual host rate limits unless the route has a rate limit policy.
     *
     * @generated from protobuf enum value: OVERRIDE = 0;
     */
    OVERRIDE = 0,
    /**
     * Use the virtual host rate limits even if the route has a rate limit policy.
     *
     * @generated from protobuf enum value: INCLUDE = 1;
     */
    INCLUDE = 1,
    /**
     * Ignore the virtual host rate limits even if the route does not have a rate limit policy.
     *
     * @generated from protobuf enum value: IGNORE = 2;
     */
    IGNORE = 2
}
/**
 * The override option determines how the filter handles the cases where there is an override config at a more specific level than this one (from least to most specific: virtual host, route, cluster weight).
 * [#not-implemented-hide:]
 *
 * @generated from protobuf enum envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions
 */
export enum RateLimitPerRoute_OverrideOptions {
    /**
     * Client-defined default, typically OVERRIDE_POLICY. If VhRateLimitsOptions is set, that will be used instead.
     *
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * If there is an override config at a more specific level, use that instead of this one.
     *
     * @generated from protobuf enum value: OVERRIDE_POLICY = 1;
     */
    OVERRIDE_POLICY = 1,
    /**
     * If there is an override config at a more specific level, use data from both.
     *
     * @generated from protobuf enum value: INCLUDE_POLICY = 2;
     */
    INCLUDE_POLICY = 2,
    /**
     * If there is an override config at a more specific level, ignore it and use only this one.
     *
     * @generated from protobuf enum value: IGNORE_POLICY = 3;
     */
    IGNORE_POLICY = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit$Type extends MessageType<RateLimit> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimit", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "stage", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 10 } } } },
            { no: 3, name: "request_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { in: ["internal", "external", "both", ""] } } } },
            { no: 4, name: "timeout", kind: "message", T: () => Duration },
            { no: 5, name: "failure_mode_deny", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "rate_limited_as_resource_exhausted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "rate_limit_service", kind: "message", T: () => RateLimitServiceConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 8, name: "enable_x_ratelimit_headers", kind: "enum", T: () => ["envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion", RateLimit_XRateLimitHeadersRFCVersion], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 9, name: "disable_x_envoy_ratelimited_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "rate_limited_status", kind: "message", T: () => HttpStatus },
            { no: 11, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "10" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.rate_limit.v2.RateLimit" } });
    }
    create(value?: PartialMessage<RateLimit>): RateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.stage = 0;
        message.requestType = "";
        message.failureModeDeny = false;
        message.rateLimitedAsResourceExhausted = false;
        message.enableXRatelimitHeaders = 0;
        message.disableXEnvoyRatelimitedHeader = false;
        message.responseHeadersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit): RateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* uint32 stage */ 2:
                    message.stage = reader.uint32();
                    break;
                case /* string request_type */ 3:
                    message.requestType = reader.string();
                    break;
                case /* google.protobuf.Duration timeout */ 4:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* bool failure_mode_deny */ 5:
                    message.failureModeDeny = reader.bool();
                    break;
                case /* bool rate_limited_as_resource_exhausted */ 6:
                    message.rateLimitedAsResourceExhausted = reader.bool();
                    break;
                case /* envoy.config.ratelimit.v3.RateLimitServiceConfig rate_limit_service */ 7:
                    message.rateLimitService = RateLimitServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.rateLimitService);
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers */ 8:
                    message.enableXRatelimitHeaders = reader.int32();
                    break;
                case /* bool disable_x_envoy_ratelimited_header */ 9:
                    message.disableXEnvoyRatelimitedHeader = reader.bool();
                    break;
                case /* envoy.type.v3.HttpStatus rate_limited_status */ 10:
                    message.rateLimitedStatus = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.rateLimitedStatus);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 11:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* uint32 stage = 2; */
        if (message.stage !== 0)
            writer.tag(2, WireType.Varint).uint32(message.stage);
        /* string request_type = 3; */
        if (message.requestType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.requestType);
        /* google.protobuf.Duration timeout = 4; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool failure_mode_deny = 5; */
        if (message.failureModeDeny !== false)
            writer.tag(5, WireType.Varint).bool(message.failureModeDeny);
        /* bool rate_limited_as_resource_exhausted = 6; */
        if (message.rateLimitedAsResourceExhausted !== false)
            writer.tag(6, WireType.Varint).bool(message.rateLimitedAsResourceExhausted);
        /* envoy.config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 7; */
        if (message.rateLimitService)
            RateLimitServiceConfig.internalBinaryWrite(message.rateLimitService, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 8; */
        if (message.enableXRatelimitHeaders !== 0)
            writer.tag(8, WireType.Varint).int32(message.enableXRatelimitHeaders);
        /* bool disable_x_envoy_ratelimited_header = 9; */
        if (message.disableXEnvoyRatelimitedHeader !== false)
            writer.tag(9, WireType.Varint).bool(message.disableXEnvoyRatelimitedHeader);
        /* envoy.type.v3.HttpStatus rate_limited_status = 10; */
        if (message.rateLimitedStatus)
            HttpStatus.internalBinaryWrite(message.rateLimitedStatus, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 11; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimit
 */
export const RateLimit = new RateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig$Type extends MessageType<RateLimitConfig> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig", [
            { no: 1, name: "stage", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 10 } } } },
            { no: 2, name: "disable_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimitConfig_Action, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 4, name: "limit", kind: "message", T: () => RateLimitConfig_Override }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig>): RateLimitConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stage = 0;
        message.disableKey = "";
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig): RateLimitConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 stage */ 1:
                    message.stage = reader.uint32();
                    break;
                case /* string disable_key */ 2:
                    message.disableKey = reader.string();
                    break;
                case /* repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action actions */ 3:
                    message.actions.push(RateLimitConfig_Action.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override limit */ 4:
                    message.limit = RateLimitConfig_Override.internalBinaryRead(reader, reader.uint32(), options, message.limit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).uint32(message.stage);
        /* string disable_key = 2; */
        if (message.disableKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.disableKey);
        /* repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action actions = 3; */
        for (let i = 0; i < message.actions.length; i++)
            RateLimitConfig_Action.internalBinaryWrite(message.actions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override limit = 4; */
        if (message.limit)
            RateLimitConfig_Override.internalBinaryWrite(message.limit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig
 */
export const RateLimitConfig = new RateLimitConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action$Type extends MessageType<RateLimitConfig_Action> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action", [
            { no: 1, name: "source_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_SourceCluster },
            { no: 2, name: "destination_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_DestinationCluster },
            { no: 3, name: "request_headers", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_RequestHeaders },
            { no: 4, name: "remote_address", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_RemoteAddress },
            { no: 5, name: "generic_key", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_GenericKey },
            { no: 6, name: "header_value_match", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_HeaderValueMatch },
            { no: 8, name: "metadata", kind: "message", oneof: "actionSpecifier", T: () => RateLimitConfig_Action_MetaData },
            { no: 9, name: "extension", kind: "message", oneof: "actionSpecifier", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Action>): RateLimitConfig_Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action): RateLimitConfig_Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster source_cluster */ 1:
                    message.actionSpecifier = {
                        oneofKind: "sourceCluster",
                        sourceCluster: RateLimitConfig_Action_SourceCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).sourceCluster)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster destination_cluster */ 2:
                    message.actionSpecifier = {
                        oneofKind: "destinationCluster",
                        destinationCluster: RateLimitConfig_Action_DestinationCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).destinationCluster)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders request_headers */ 3:
                    message.actionSpecifier = {
                        oneofKind: "requestHeaders",
                        requestHeaders: RateLimitConfig_Action_RequestHeaders.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).requestHeaders)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress remote_address */ 4:
                    message.actionSpecifier = {
                        oneofKind: "remoteAddress",
                        remoteAddress: RateLimitConfig_Action_RemoteAddress.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).remoteAddress)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey generic_key */ 5:
                    message.actionSpecifier = {
                        oneofKind: "genericKey",
                        genericKey: RateLimitConfig_Action_GenericKey.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).genericKey)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch header_value_match */ 6:
                    message.actionSpecifier = {
                        oneofKind: "headerValueMatch",
                        headerValueMatch: RateLimitConfig_Action_HeaderValueMatch.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).headerValueMatch)
                    };
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData metadata */ 8:
                    message.actionSpecifier = {
                        oneofKind: "metadata",
                        metadata: RateLimitConfig_Action_MetaData.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).metadata)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig extension */ 9:
                    message.actionSpecifier = {
                        oneofKind: "extension",
                        extension: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).extension)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster source_cluster = 1; */
        if (message.actionSpecifier.oneofKind === "sourceCluster")
            RateLimitConfig_Action_SourceCluster.internalBinaryWrite(message.actionSpecifier.sourceCluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster destination_cluster = 2; */
        if (message.actionSpecifier.oneofKind === "destinationCluster")
            RateLimitConfig_Action_DestinationCluster.internalBinaryWrite(message.actionSpecifier.destinationCluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders request_headers = 3; */
        if (message.actionSpecifier.oneofKind === "requestHeaders")
            RateLimitConfig_Action_RequestHeaders.internalBinaryWrite(message.actionSpecifier.requestHeaders, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress remote_address = 4; */
        if (message.actionSpecifier.oneofKind === "remoteAddress")
            RateLimitConfig_Action_RemoteAddress.internalBinaryWrite(message.actionSpecifier.remoteAddress, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey generic_key = 5; */
        if (message.actionSpecifier.oneofKind === "genericKey")
            RateLimitConfig_Action_GenericKey.internalBinaryWrite(message.actionSpecifier.genericKey, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch header_value_match = 6; */
        if (message.actionSpecifier.oneofKind === "headerValueMatch")
            RateLimitConfig_Action_HeaderValueMatch.internalBinaryWrite(message.actionSpecifier.headerValueMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData metadata = 8; */
        if (message.actionSpecifier.oneofKind === "metadata")
            RateLimitConfig_Action_MetaData.internalBinaryWrite(message.actionSpecifier.metadata, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig extension = 9; */
        if (message.actionSpecifier.oneofKind === "extension")
            TypedExtensionConfig.internalBinaryWrite(message.actionSpecifier.extension, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action
 */
export const RateLimitConfig_Action = new RateLimitConfig_Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_SourceCluster$Type extends MessageType<RateLimitConfig_Action_SourceCluster> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster", []);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_SourceCluster>): RateLimitConfig_Action_SourceCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_SourceCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_SourceCluster): RateLimitConfig_Action_SourceCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimitConfig_Action_SourceCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster
 */
export const RateLimitConfig_Action_SourceCluster = new RateLimitConfig_Action_SourceCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_DestinationCluster$Type extends MessageType<RateLimitConfig_Action_DestinationCluster> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster", []);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_DestinationCluster>): RateLimitConfig_Action_DestinationCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_DestinationCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_DestinationCluster): RateLimitConfig_Action_DestinationCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimitConfig_Action_DestinationCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster
 */
export const RateLimitConfig_Action_DestinationCluster = new RateLimitConfig_Action_DestinationCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_RequestHeaders$Type extends MessageType<RateLimitConfig_Action_RequestHeaders> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "skip_if_absent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_RequestHeaders>): RateLimitConfig_Action_RequestHeaders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        message.descriptorKey = "";
        message.skipIfAbsent = false;
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_RequestHeaders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_RequestHeaders): RateLimitConfig_Action_RequestHeaders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                case /* string descriptor_key */ 2:
                    message.descriptorKey = reader.string();
                    break;
                case /* bool skip_if_absent */ 3:
                    message.skipIfAbsent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Action_RequestHeaders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        /* string descriptor_key = 2; */
        if (message.descriptorKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.descriptorKey);
        /* bool skip_if_absent = 3; */
        if (message.skipIfAbsent !== false)
            writer.tag(3, WireType.Varint).bool(message.skipIfAbsent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders
 */
export const RateLimitConfig_Action_RequestHeaders = new RateLimitConfig_Action_RequestHeaders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_RemoteAddress$Type extends MessageType<RateLimitConfig_Action_RemoteAddress> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress", []);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_RemoteAddress>): RateLimitConfig_Action_RemoteAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_RemoteAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_RemoteAddress): RateLimitConfig_Action_RemoteAddress {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimitConfig_Action_RemoteAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress
 */
export const RateLimitConfig_Action_RemoteAddress = new RateLimitConfig_Action_RemoteAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_GenericKey$Type extends MessageType<RateLimitConfig_Action_GenericKey> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey", [
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_GenericKey>): RateLimitConfig_Action_GenericKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorValue = "";
        message.descriptorKey = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_GenericKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_GenericKey): RateLimitConfig_Action_GenericKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* string descriptor_key */ 2:
                    message.descriptorKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Action_GenericKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* string descriptor_key = 2; */
        if (message.descriptorKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.descriptorKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey
 */
export const RateLimitConfig_Action_GenericKey = new RateLimitConfig_Action_GenericKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_HeaderValueMatch$Type extends MessageType<RateLimitConfig_Action_HeaderValueMatch> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch", [
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "expect_match", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_HeaderValueMatch>): RateLimitConfig_Action_HeaderValueMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorValue = "";
        message.expectMatch = false;
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_HeaderValueMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_HeaderValueMatch): RateLimitConfig_Action_HeaderValueMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* bool expect_match */ 2:
                    message.expectMatch = reader.bool();
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 3:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Action_HeaderValueMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* bool expect_match = 2; */
        if (message.expectMatch !== false)
            writer.tag(2, WireType.Varint).bool(message.expectMatch);
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 3; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch
 */
export const RateLimitConfig_Action_HeaderValueMatch = new RateLimitConfig_Action_HeaderValueMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Action_MetaData$Type extends MessageType<RateLimitConfig_Action_MetaData> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData", [
            { no: 1, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "metadata_key", kind: "message", T: () => MetadataKey, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "source", kind: "enum", T: () => ["envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source", RateLimitConfig_Action_MetaData_Source], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 5, name: "skip_if_absent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Action_MetaData>): RateLimitConfig_Action_MetaData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorKey = "";
        message.defaultValue = "";
        message.source = 0;
        message.skipIfAbsent = false;
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Action_MetaData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Action_MetaData): RateLimitConfig_Action_MetaData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_key */ 1:
                    message.descriptorKey = reader.string();
                    break;
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 2:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                case /* string default_value */ 3:
                    message.defaultValue = reader.string();
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source source */ 4:
                    message.source = reader.int32();
                    break;
                case /* bool skip_if_absent */ 5:
                    message.skipIfAbsent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Action_MetaData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_key = 1; */
        if (message.descriptorKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorKey);
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 2; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string default_value = 3; */
        if (message.defaultValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultValue);
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source source = 4; */
        if (message.source !== 0)
            writer.tag(4, WireType.Varint).int32(message.source);
        /* bool skip_if_absent = 5; */
        if (message.skipIfAbsent !== false)
            writer.tag(5, WireType.Varint).bool(message.skipIfAbsent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData
 */
export const RateLimitConfig_Action_MetaData = new RateLimitConfig_Action_MetaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Override$Type extends MessageType<RateLimitConfig_Override> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override", [
            { no: 1, name: "dynamic_metadata", kind: "message", oneof: "overrideSpecifier", T: () => RateLimitConfig_Override_DynamicMetadata }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Override>): RateLimitConfig_Override {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.overrideSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Override>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Override): RateLimitConfig_Override {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata dynamic_metadata */ 1:
                    message.overrideSpecifier = {
                        oneofKind: "dynamicMetadata",
                        dynamicMetadata: RateLimitConfig_Override_DynamicMetadata.internalBinaryRead(reader, reader.uint32(), options, (message.overrideSpecifier as any).dynamicMetadata)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Override, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata dynamic_metadata = 1; */
        if (message.overrideSpecifier.oneofKind === "dynamicMetadata")
            RateLimitConfig_Override_DynamicMetadata.internalBinaryWrite(message.overrideSpecifier.dynamicMetadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override
 */
export const RateLimitConfig_Override = new RateLimitConfig_Override$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitConfig_Override_DynamicMetadata$Type extends MessageType<RateLimitConfig_Override_DynamicMetadata> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata", [
            { no: 1, name: "metadata_key", kind: "message", T: () => MetadataKey, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitConfig_Override_DynamicMetadata>): RateLimitConfig_Override_DynamicMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitConfig_Override_DynamicMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitConfig_Override_DynamicMetadata): RateLimitConfig_Override_DynamicMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 1:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitConfig_Override_DynamicMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 1; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata
 */
export const RateLimitConfig_Override_DynamicMetadata = new RateLimitConfig_Override_DynamicMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitPerRoute$Type extends MessageType<RateLimitPerRoute> {
    constructor() {
        super("envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute", [
            { no: 1, name: "vh_rate_limits", kind: "enum", T: () => ["envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions", RateLimitPerRoute_VhRateLimitsOptions], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "override_option", kind: "enum", T: () => ["envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions", RateLimitPerRoute_OverrideOptions], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "rate_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimitConfig },
            { no: 4, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitPerRoute>): RateLimitPerRoute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vhRateLimits = 0;
        message.overrideOption = 0;
        message.rateLimits = [];
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimitPerRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitPerRoute): RateLimitPerRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions vh_rate_limits */ 1:
                    message.vhRateLimits = reader.int32();
                    break;
                case /* envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions override_option */ 2:
                    message.overrideOption = reader.int32();
                    break;
                case /* repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig rate_limits */ 3:
                    message.rateLimits.push(RateLimitConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string domain */ 4:
                    message.domain = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitPerRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions vh_rate_limits = 1; */
        if (message.vhRateLimits !== 0)
            writer.tag(1, WireType.Varint).int32(message.vhRateLimits);
        /* envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions override_option = 2; */
        if (message.overrideOption !== 0)
            writer.tag(2, WireType.Varint).int32(message.overrideOption);
        /* repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig rate_limits = 3; */
        for (let i = 0; i < message.rateLimits.length; i++)
            RateLimitConfig.internalBinaryWrite(message.rateLimits[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string domain = 4; */
        if (message.domain !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.domain);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute
 */
export const RateLimitPerRoute = new RateLimitPerRoute$Type();
