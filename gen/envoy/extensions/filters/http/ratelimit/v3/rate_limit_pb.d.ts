// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/filters/http/ratelimit/v3/rate_limit.proto (package envoy.extensions.filters.http.ratelimit.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { RateLimitServiceConfig } from "../../../../../config/ratelimit/v3/rls_pb.js";
import type { HttpStatus } from "../../../../../type/v3/http_status_pb.js";
import type { HeaderValueOption } from "../../../../../config/core/v3/base_pb.js";
import type { TypedExtensionConfig } from "../../../../../config/core/v3/extension_pb.js";
import type { HeaderMatcher } from "../../../../../config/route/v3/route_components_pb.js";
import type { MetadataKey } from "../../../../../type/metadata/v3/metadata_pb.js";

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimit
 */
export declare class RateLimit extends Message<RateLimit> {
  /**
   * The rate limit domain to use when calling the rate limit service.
   *
   * @generated from field: string domain = 1;
   */
  domain: string;

  /**
   * Specifies the rate limit configurations to be applied with the same
   * stage number. If not set, the default stage number is 0.
   *
   * .. note::
   *
   *  The filter supports a range of 0 - 10 inclusively for stage numbers.
   *
   * @generated from field: uint32 stage = 2;
   */
  stage: number;

  /**
   * The type of requests the filter should apply to. The supported
   * types are ``internal``, ``external`` or ``both``. A request is considered internal if
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is set to true. If
   * :ref:`x-envoy-internal<config_http_conn_man_headers_x-envoy-internal>` is not set or false, a
   * request is considered external. The filter defaults to ``both``, and it will apply to all request
   * types.
   *
   * @generated from field: string request_type = 3;
   */
  requestType: string;

  /**
   * The timeout in milliseconds for the rate limit service RPC. If not
   * set, this defaults to 20ms.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: Duration;

  /**
   * The filter's behaviour in case the rate limiting service does
   * not respond back. When it is set to true, Envoy will not allow traffic in case of
   * communication failure between rate limiting service and the proxy.
   *
   * @generated from field: bool failure_mode_deny = 5;
   */
  failureModeDeny: boolean;

  /**
   * Specifies whether a ``RESOURCE_EXHAUSTED`` gRPC code must be returned instead
   * of the default ``UNAVAILABLE`` gRPC code for a rate limited gRPC call. The
   * HTTP code will be 200 for a gRPC response.
   *
   * @generated from field: bool rate_limited_as_resource_exhausted = 6;
   */
  rateLimitedAsResourceExhausted: boolean;

  /**
   * Configuration for an external rate limit service provider. If not
   * specified, any calls to the rate limit service will immediately return
   * success.
   *
   * @generated from field: envoy.config.ratelimit.v3.RateLimitServiceConfig rate_limit_service = 7;
   */
  rateLimitService?: RateLimitServiceConfig;

  /**
   * Defines the standard version to use for X-RateLimit headers emitted by the filter:
   *
   * * ``X-RateLimit-Limit`` - indicates the request-quota associated to the
   *   client in the current time-window followed by the description of the
   *   quota policy. The values are returned by the rate limiting service in
   *   :ref:`current_limit<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.current_limit>`
   *   field. Example: ``10, 10;w=1;name="per-ip", 1000;w=3600``.
   * * ``X-RateLimit-Remaining`` - indicates the remaining requests in the
   *   current time-window. The values are returned by the rate limiting service
   *   in :ref:`limit_remaining<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.limit_remaining>`
   *   field.
   * * ``X-RateLimit-Reset`` - indicates the number of seconds until reset of
   *   the current time-window. The values are returned by the rate limiting service
   *   in :ref:`duration_until_reset<envoy_v3_api_field_service.ratelimit.v3.RateLimitResponse.DescriptorStatus.duration_until_reset>`
   *   field.
   *
   * In case rate limiting policy specifies more then one time window, the values
   * above represent the window that is closest to reaching its limit.
   *
   * For more information about the headers specification see selected version of
   * the `draft RFC <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
   *
   * Disabled by default.
   *
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
   *
   * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion enable_x_ratelimit_headers = 8;
   */
  enableXRatelimitHeaders: RateLimit_XRateLimitHeadersRFCVersion;

  /**
   * Disables emitting the :ref:`x-envoy-ratelimited<config_http_filters_router_x-envoy-ratelimited>` header
   * in case of rate limiting (i.e. 429 responses).
   * Having this header not present potentially makes the request retriable.
   *
   * @generated from field: bool disable_x_envoy_ratelimited_header = 9;
   */
  disableXEnvoyRatelimitedHeader: boolean;

  /**
   * This field allows for a custom HTTP response status code to the downstream client when
   * the request has been rate limited.
   * Defaults to 429 (TooManyRequests).
   *
   * .. note::
   *   If this is set to < 400, 429 will be used instead.
   *
   * @generated from field: envoy.type.v3.HttpStatus rate_limited_status = 10;
   */
  rateLimitedStatus?: HttpStatus;

  /**
   * Specifies a list of HTTP headers that should be added to each response for requests that
   * have been rate limited.
   *
   * @generated from field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 11;
   */
  responseHeadersToAdd: HeaderValueOption[];

  constructor(data?: PartialMessage<RateLimit>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimit";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit;

  static equals(a: RateLimit | PlainMessage<RateLimit> | undefined, b: RateLimit | PlainMessage<RateLimit> | undefined): boolean;
}

/**
 * Defines the version of the standard to use for X-RateLimit headers.
 *
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.XRateLimitHeadersRFCVersion instead.]
 *
 * @generated from enum envoy.extensions.filters.http.ratelimit.v3.RateLimit.XRateLimitHeadersRFCVersion
 */
export declare enum RateLimit_XRateLimitHeadersRFCVersion {
  /**
   * X-RateLimit headers disabled.
   *
   * @generated from enum value: OFF = 0;
   */
  OFF = 0,

  /**
   * Use `draft RFC Version 03 <https://tools.ietf.org/id/draft-polli-ratelimit-headers-03.html>`_.
   *
   * @generated from enum value: DRAFT_VERSION_03 = 1;
   */
  DRAFT_VERSION_03 = 1,
}

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig
 */
export declare class RateLimitConfig extends Message<RateLimitConfig> {
  /**
   * Refers to the stage set in the filter. The rate limit configuration only
   * applies to filters with the same stage number. The default stage number is
   * 0.
   *
   * .. note::
   *
   *   The filter supports a range of 0 - 10 inclusively for stage numbers.
   *
   * @generated from field: uint32 stage = 1;
   */
  stage: number;

  /**
   * The key to be set in runtime to disable this rate limit configuration.
   *
   * @generated from field: string disable_key = 2;
   */
  disableKey: string;

  /**
   * A list of actions that are to be applied for this rate limit configuration.
   * Order matters as the actions are processed sequentially and the descriptor
   * is composed by appending descriptor entries in that sequence. If an action
   * cannot append a descriptor entry, no descriptor is generated for the
   * configuration. See :ref:`composing actions
   * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
   *
   * @generated from field: repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action actions = 3;
   */
  actions: RateLimitConfig_Action[];

  /**
   * An optional limit override to be appended to the descriptor produced by this
   * rate limit configuration. If the override value is invalid or cannot be resolved
   * from metadata, no override is provided. See :ref:`rate limit override
   * <config_http_filters_rate_limit_rate_limit_override>` for more information.
   *
   * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override limit = 4;
   */
  limit?: RateLimitConfig_Override;

  constructor(data?: PartialMessage<RateLimitConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig;

  static equals(a: RateLimitConfig | PlainMessage<RateLimitConfig> | undefined, b: RateLimitConfig | PlainMessage<RateLimitConfig> | undefined): boolean;
}

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action
 */
export declare class RateLimitConfig_Action extends Message<RateLimitConfig_Action> {
  /**
   * @generated from oneof envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.action_specifier
   */
  actionSpecifier: {
    /**
     * Rate limit on source cluster.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster source_cluster = 1;
     */
    value: RateLimitConfig_Action_SourceCluster;
    case: "sourceCluster";
  } | {
    /**
     * Rate limit on destination cluster.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster destination_cluster = 2;
     */
    value: RateLimitConfig_Action_DestinationCluster;
    case: "destinationCluster";
  } | {
    /**
     * Rate limit on request headers.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders request_headers = 3;
     */
    value: RateLimitConfig_Action_RequestHeaders;
    case: "requestHeaders";
  } | {
    /**
     * Rate limit on remote address.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress remote_address = 4;
     */
    value: RateLimitConfig_Action_RemoteAddress;
    case: "remoteAddress";
  } | {
    /**
     * Rate limit on a generic key.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey generic_key = 5;
     */
    value: RateLimitConfig_Action_GenericKey;
    case: "genericKey";
  } | {
    /**
     * Rate limit on the existence of request headers.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch header_value_match = 6;
     */
    value: RateLimitConfig_Action_HeaderValueMatch;
    case: "headerValueMatch";
  } | {
    /**
     * Rate limit on metadata.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData metadata = 8;
     */
    value: RateLimitConfig_Action_MetaData;
    case: "metadata";
  } | {
    /**
     * Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
     * [#extension-category: envoy.rate_limit_descriptors]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig extension = 9;
     */
    value: TypedExtensionConfig;
    case: "extension";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RateLimitConfig_Action>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action;

  static equals(a: RateLimitConfig_Action | PlainMessage<RateLimitConfig_Action> | undefined, b: RateLimitConfig_Action | PlainMessage<RateLimitConfig_Action> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster
 */
export declare class RateLimitConfig_Action_SourceCluster extends Message<RateLimitConfig_Action_SourceCluster> {
  constructor(data?: PartialMessage<RateLimitConfig_Action_SourceCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.SourceCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_SourceCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_SourceCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_SourceCluster;

  static equals(a: RateLimitConfig_Action_SourceCluster | PlainMessage<RateLimitConfig_Action_SourceCluster> | undefined, b: RateLimitConfig_Action_SourceCluster | PlainMessage<RateLimitConfig_Action_SourceCluster> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster
 */
export declare class RateLimitConfig_Action_DestinationCluster extends Message<RateLimitConfig_Action_DestinationCluster> {
  constructor(data?: PartialMessage<RateLimitConfig_Action_DestinationCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.DestinationCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_DestinationCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_DestinationCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_DestinationCluster;

  static equals(a: RateLimitConfig_Action_DestinationCluster | PlainMessage<RateLimitConfig_Action_DestinationCluster> | undefined, b: RateLimitConfig_Action_DestinationCluster | PlainMessage<RateLimitConfig_Action_DestinationCluster> | undefined): boolean;
}

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders
 */
export declare class RateLimitConfig_Action_RequestHeaders extends Message<RateLimitConfig_Action_RequestHeaders> {
  /**
   * The header name to be queried from the request headers. The header’s
   * value is used to populate the value of the descriptor entry for the
   * descriptor_key.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  /**
   * The key to use in the descriptor entry.
   *
   * @generated from field: string descriptor_key = 2;
   */
  descriptorKey: string;

  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when header is not present in the request. By default it skips calling the
   * rate limiting service if this header is not present in the request.
   *
   * @generated from field: bool skip_if_absent = 3;
   */
  skipIfAbsent: boolean;

  constructor(data?: PartialMessage<RateLimitConfig_Action_RequestHeaders>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RequestHeaders";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_RequestHeaders;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_RequestHeaders;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_RequestHeaders;

  static equals(a: RateLimitConfig_Action_RequestHeaders | PlainMessage<RateLimitConfig_Action_RequestHeaders> | undefined, b: RateLimitConfig_Action_RequestHeaders | PlainMessage<RateLimitConfig_Action_RequestHeaders> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress
 */
export declare class RateLimitConfig_Action_RemoteAddress extends Message<RateLimitConfig_Action_RemoteAddress> {
  constructor(data?: PartialMessage<RateLimitConfig_Action_RemoteAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.RemoteAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_RemoteAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_RemoteAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_RemoteAddress;

  static equals(a: RateLimitConfig_Action_RemoteAddress | PlainMessage<RateLimitConfig_Action_RemoteAddress> | undefined, b: RateLimitConfig_Action_RemoteAddress | PlainMessage<RateLimitConfig_Action_RemoteAddress> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey
 */
export declare class RateLimitConfig_Action_GenericKey extends Message<RateLimitConfig_Action_GenericKey> {
  /**
   * The value to use in the descriptor entry.
   *
   * @generated from field: string descriptor_value = 1;
   */
  descriptorValue: string;

  /**
   * An optional key to use in the descriptor entry. If not set it defaults
   * to 'generic_key' as the descriptor key.
   *
   * @generated from field: string descriptor_key = 2;
   */
  descriptorKey: string;

  constructor(data?: PartialMessage<RateLimitConfig_Action_GenericKey>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.GenericKey";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_GenericKey;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_GenericKey;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_GenericKey;

  static equals(a: RateLimitConfig_Action_GenericKey | PlainMessage<RateLimitConfig_Action_GenericKey> | undefined, b: RateLimitConfig_Action_GenericKey | PlainMessage<RateLimitConfig_Action_GenericKey> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch
 */
export declare class RateLimitConfig_Action_HeaderValueMatch extends Message<RateLimitConfig_Action_HeaderValueMatch> {
  /**
   * The value to use in the descriptor entry.
   *
   * @generated from field: string descriptor_value = 1;
   */
  descriptorValue: string;

  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   *
   * @generated from field: bool expect_match = 2;
   */
  expectMatch: boolean;

  /**
   * Specifies a set of headers that the rate limit action should match
   * on. The action will check the request’s headers against all the
   * specified headers in the config. A match will happen if all the
   * headers in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 3;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<RateLimitConfig_Action_HeaderValueMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.HeaderValueMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_HeaderValueMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_HeaderValueMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_HeaderValueMatch;

  static equals(a: RateLimitConfig_Action_HeaderValueMatch | PlainMessage<RateLimitConfig_Action_HeaderValueMatch> | undefined, b: RateLimitConfig_Action_HeaderValueMatch | PlainMessage<RateLimitConfig_Action_HeaderValueMatch> | undefined): boolean;
}

/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData
 */
export declare class RateLimitConfig_Action_MetaData extends Message<RateLimitConfig_Action_MetaData> {
  /**
   * The key to use in the descriptor entry.
   *
   * @generated from field: string descriptor_key = 1;
   */
  descriptorKey: string;

  /**
   * Metadata struct that defines the key and path to retrieve the string value. A match will
   * only happen if the value in the metadata is of type string.
   *
   * @generated from field: envoy.type.metadata.v3.MetadataKey metadata_key = 2;
   */
  metadataKey?: MetadataKey;

  /**
   * An optional value to use if ``metadata_key`` is empty. If not set and
   * no value is present under the metadata_key then ``skip_if_absent`` is followed to
   * skip calling the rate limiting service or skip the descriptor.
   *
   * @generated from field: string default_value = 3;
   */
  defaultValue: string;

  /**
   * Source of metadata
   *
   * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source source = 4;
   */
  source: RateLimitConfig_Action_MetaData_Source;

  /**
   * If set to true, Envoy skips the descriptor while calling rate limiting service
   * when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
   * rate limiting service in that case.
   *
   * @generated from field: bool skip_if_absent = 5;
   */
  skipIfAbsent: boolean;

  constructor(data?: PartialMessage<RateLimitConfig_Action_MetaData>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Action_MetaData;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_MetaData;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Action_MetaData;

  static equals(a: RateLimitConfig_Action_MetaData | PlainMessage<RateLimitConfig_Action_MetaData> | undefined, b: RateLimitConfig_Action_MetaData | PlainMessage<RateLimitConfig_Action_MetaData> | undefined): boolean;
}

/**
 * @generated from enum envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Action.MetaData.Source
 */
export declare enum RateLimitConfig_Action_MetaData_Source {
  /**
   * Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
   *
   * @generated from enum value: DYNAMIC = 0;
   */
  DYNAMIC = 0,

  /**
   * Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
   *
   * @generated from enum value: ROUTE_ENTRY = 1;
   */
  ROUTE_ENTRY = 1,
}

/**
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override
 */
export declare class RateLimitConfig_Override extends Message<RateLimitConfig_Override> {
  /**
   * @generated from oneof envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.override_specifier
   */
  overrideSpecifier: {
    /**
     * Limit override from dynamic metadata.
     *
     * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata dynamic_metadata = 1;
     */
    value: RateLimitConfig_Override_DynamicMetadata;
    case: "dynamicMetadata";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RateLimitConfig_Override>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Override;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Override;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Override;

  static equals(a: RateLimitConfig_Override | PlainMessage<RateLimitConfig_Override> | undefined, b: RateLimitConfig_Override | PlainMessage<RateLimitConfig_Override> | undefined): boolean;
}

/**
 * Fetches the override from the dynamic metadata.
 *
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata
 */
export declare class RateLimitConfig_Override_DynamicMetadata extends Message<RateLimitConfig_Override_DynamicMetadata> {
  /**
   * Metadata struct that defines the key and path to retrieve the struct value.
   * The value must be a struct containing an integer "requests_per_unit" property
   * and a "unit" property with a value parseable to :ref:`RateLimitUnit
   * enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
   *
   * @generated from field: envoy.type.metadata.v3.MetadataKey metadata_key = 1;
   */
  metadataKey?: MetadataKey;

  constructor(data?: PartialMessage<RateLimitConfig_Override_DynamicMetadata>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig.Override.DynamicMetadata";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitConfig_Override_DynamicMetadata;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitConfig_Override_DynamicMetadata;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitConfig_Override_DynamicMetadata;

  static equals(a: RateLimitConfig_Override_DynamicMetadata | PlainMessage<RateLimitConfig_Override_DynamicMetadata> | undefined, b: RateLimitConfig_Override_DynamicMetadata | PlainMessage<RateLimitConfig_Override_DynamicMetadata> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute
 */
export declare class RateLimitPerRoute extends Message<RateLimitPerRoute> {
  /**
   * Specifies if the rate limit filter should include the virtual host rate limits.
   * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
   *
   * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions vh_rate_limits = 1;
   */
  vhRateLimits: RateLimitPerRoute_VhRateLimitsOptions;

  /**
   * Specifies if the rate limit filter should include the lower levels (route level, virtual host level or cluster weight level) rate limits override options.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions override_option = 2;
   */
  overrideOption: RateLimitPerRoute_OverrideOptions;

  /**
   * Rate limit configuration. If not set, uses the
   * :ref:`VirtualHost.rate_limits<envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` or
   * :ref:`RouteAction.rate_limits<envoy_v3_api_field_config.route.v3.RouteAction.rate_limits>` fields instead.
   * [#not-implemented-hide:]
   *
   * @generated from field: repeated envoy.extensions.filters.http.ratelimit.v3.RateLimitConfig rate_limits = 3;
   */
  rateLimits: RateLimitConfig[];

  /**
   * Overrides the domain. If not set, uses the filter-level domain instead.
   *
   * @generated from field: string domain = 4;
   */
  domain: string;

  constructor(data?: PartialMessage<RateLimitPerRoute>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitPerRoute;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitPerRoute;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitPerRoute;

  static equals(a: RateLimitPerRoute | PlainMessage<RateLimitPerRoute> | undefined, b: RateLimitPerRoute | PlainMessage<RateLimitPerRoute> | undefined): boolean;
}

/**
 * [#next-major-version: unify with local ratelimit, should use common.ratelimit.v3.VhRateLimitsOptions instead.]
 *
 * @generated from enum envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.VhRateLimitsOptions
 */
export declare enum RateLimitPerRoute_VhRateLimitsOptions {
  /**
   * Use the virtual host rate limits unless the route has a rate limit policy.
   *
   * @generated from enum value: OVERRIDE = 0;
   */
  OVERRIDE = 0,

  /**
   * Use the virtual host rate limits even if the route has a rate limit policy.
   *
   * @generated from enum value: INCLUDE = 1;
   */
  INCLUDE = 1,

  /**
   * Ignore the virtual host rate limits even if the route does not have a rate limit policy.
   *
   * @generated from enum value: IGNORE = 2;
   */
  IGNORE = 2,
}

/**
 * The override option determines how the filter handles the cases where there is an override config at a more specific level than this one (from least to most specific: virtual host, route, cluster weight).
 * [#not-implemented-hide:]
 *
 * @generated from enum envoy.extensions.filters.http.ratelimit.v3.RateLimitPerRoute.OverrideOptions
 */
export declare enum RateLimitPerRoute_OverrideOptions {
  /**
   * Client-defined default, typically OVERRIDE_POLICY. If VhRateLimitsOptions is set, that will be used instead.
   *
   * @generated from enum value: DEFAULT = 0;
   */
  DEFAULT = 0,

  /**
   * If there is an override config at a more specific level, use that instead of this one.
   *
   * @generated from enum value: OVERRIDE_POLICY = 1;
   */
  OVERRIDE_POLICY = 1,

  /**
   * If there is an override config at a more specific level, use data from both.
   *
   * @generated from enum value: INCLUDE_POLICY = 2;
   */
  INCLUDE_POLICY = 2,

  /**
   * If there is an override config at a more specific level, ignore it and use only this one.
   *
   * @generated from enum value: IGNORE_POLICY = 3;
   */
  IGNORE_POLICY = 3,
}

