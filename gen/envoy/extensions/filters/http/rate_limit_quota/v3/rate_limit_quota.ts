// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/rate_limit_quota/v3/rate_limit_quota.proto" (package "envoy.extensions.filters.http.rate_limit_quota.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { Status } from "../../../../../../google/rpc/status";
import { BytesValue } from "../../../../../../google/protobuf/wrappers";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { RateLimitStrategy } from "../../../../../type/v3/ratelimit_strategy";
import { Duration } from "../../../../../../google/protobuf/duration";
import { HeaderValueOption } from "../../../../../config/core/v3/base";
import { RuntimeFractionalPercent } from "../../../../../config/core/v3/base";
import { Matcher } from "../../../../../../xds/type/matcher/v3/matcher";
import { GrpcService } from "../../../../../config/core/v3/grpc_service";
// [#protodoc-title: Rate Limit Quota]
// Rate Limit Quota :ref:`configuration overview <config_http_filters_rate_limit_quota>`.
// [#extension: envoy.filters.http.rate_limit_quota]

/**
 * Configures the Rate Limit Quota filter.
 *
 * Can be overridden in the per-route and per-host configurations.
 * The more specific definition completely overrides the less specific definition.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig
 */
export interface RateLimitQuotaFilterConfig {
    /**
     * Configures the gRPC Rate Limit Quota Service (RLQS) RateLimitQuotaService.
     *
     * @generated from protobuf field: envoy.config.core.v3.GrpcService rlqs_server = 1;
     */
    rlqsServer?: GrpcService;
    /**
     * The application domain to use when calling the service. This enables sharing the quota
     * server between different applications without fear of overlap.
     * E.g., "envoy".
     *
     * @generated from protobuf field: string domain = 2;
     */
    domain: string;
    /**
     * The match tree to use for grouping incoming requests into buckets.
     *
     * Example:
     *
     * .. validated-code-block:: yaml
     *   :type-name: xds.type.matcher.v3.Matcher
     *
     *   matcher_list:
     *     matchers:
     *     # Assign requests with header['env'] set to 'staging' to the bucket { name: 'staging' }
     *     - predicate:
     *         single_predicate:
     *           input:
     *             typed_config:
     *               '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
     *               header_name: env
     *           value_match:
     *             exact: staging
     *       on_match:
     *         action:
     *           typed_config:
     *             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
     *             bucket_id_builder:
     *               bucket_id_builder:
     *                 name:
     *                   string_value: staging
     *
     *     # Assign requests with header['user_group'] set to 'admin' to the bucket { acl: 'admin_users' }
     *     - predicate:
     *         single_predicate:
     *           input:
     *             typed_config:
     *               '@type': type.googleapis.com/xds.type.matcher.v3.HttpAttributesCelMatchInput
     *           custom_match:
     *             typed_config:
     *               '@type': type.googleapis.com/xds.type.matcher.v3.CelMatcher
     *               expr_match:
     *                 # Shortened for illustration purposes. Here should be parsed CEL expression:
     *                 # request.headers['user_group'] == 'admin'
     *                 parsed_expr: {}
     *       on_match:
     *         action:
     *           typed_config:
     *             '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
     *             bucket_id_builder:
     *               bucket_id_builder:
     *                 acl:
     *                   string_value: admin_users
     *
     *   # Catch-all clause for the requests not matched by any of the matchers.
     *   # In this example, deny all requests.
     *   on_no_match:
     *     action:
     *       typed_config:
     *         '@type': type.googleapis.com/envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
     *         no_assignment_behavior:
     *           fallback_rate_limit:
     *             blanket_rule: DENY_ALL
     *
     * .. attention::
     *  The first matched group wins. Once the request is matched into a bucket, matcher
     *  evaluation ends.
     *
     * Use ``on_no_match`` field to assign the catch-all bucket. If a request is not matched
     * into any bucket, and there's no  ``on_no_match`` field configured, the request will be
     * ALLOWED by default. It will NOT be reported to the RLQS server.
     *
     * Refer to :ref:`Unified Matcher API <envoy_v3_api_msg_.xds.type.matcher.v3.Matcher>`
     * documentation for more information on the matcher trees.
     *
     * @generated from protobuf field: xds.type.matcher.v3.Matcher bucket_matchers = 3;
     */
    bucketMatchers?: Matcher;
    /**
     * If set, this will enable -- but not necessarily enforce -- the rate limit for the given
     * fraction of requests.
     *
     * Defaults to 100% of requests.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4;
     */
    filterEnabled?: RuntimeFractionalPercent;
    /**
     * If set, this will enforce the rate limit decisions for the given fraction of requests.
     * For requests that are not enforced the filter will still obtain the quota and include it
     * in the load computation, however the request will always be allowed regardless of the outcome
     * of quota application. This allows validation or testing of the rate limiting service
     * infrastructure without disrupting existing traffic.
     *
     * Note: this only applies to the fraction of enabled requests.
     *
     * Defaults to 100% of requests.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5;
     */
    filterEnforced?: RuntimeFractionalPercent;
    /**
     * Specifies a list of HTTP headers that should be added to each request that
     * has been rate limited and is also forwarded upstream. This can only occur when the
     * filter is enabled but not enforced.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 6;
     */
    requestHeadersToAddWhenNotEnforced: HeaderValueOption[];
}
/**
 * Per-route and per-host configuration overrides. The more specific definition completely
 * overrides the less specific definition.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride
 */
export interface RateLimitQuotaOverride {
    /**
     * The application domain to use when calling the service. This enables sharing the quota
     * server between different applications without fear of overlap.
     * E.g., "envoy".
     *
     * If empty, inherits the value from the less specific definition.
     *
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
    /**
     * The match tree to use for grouping incoming requests into buckets.
     *
     * If set, fully overrides the bucket matchers provided on the less specific definition.
     * If not set, inherits the value from the less specific definition.
     *
     * See usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
     * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
     *
     * @generated from protobuf field: xds.type.matcher.v3.Matcher bucket_matchers = 2;
     */
    bucketMatchers?: Matcher;
}
/**
 * Rate Limit Quota Bucket Settings to apply on the successful ``bucket_matchers`` match.
 *
 * Specify this message in the :ref:`Matcher.OnMatch.action
 * <envoy_v3_api_field_.xds.type.matcher.v3.Matcher.OnMatch.action>` field of the
 * ``bucket_matchers`` matcher tree to assign the matched requests to the Quota Bucket.
 * Usage example: :ref:`RateLimitQuotaFilterConfig.bucket_matchers
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig.bucket_matchers>`.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
 */
export interface RateLimitQuotaBucketSettings {
    /**
     * ``BucketId`` builder.
     *
     * :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` is a map from
     * the string key to the string value which serves as bucket identifier common for on
     * the control plane and the data plane.
     *
     * While ``BucketId`` is always static, ``BucketIdBuilder`` allows to populate map values
     * with the dynamic properties associated with the each individual request.
     *
     * Example 1: static fields only
     *
     * ``BucketIdBuilder``:
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
     *
     *   bucket_id_builder:
     *     name:
     *       string_value: my_bucket
     *     hello:
     *       string_value: world
     *
     * Produces the following ``BucketId`` for all requests:
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
     *
     *   bucket:
     *     name: my_bucket
     *     hello: world
     *
     * Example 2: static and dynamic fields
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
     *
     *   bucket_id_builder:
     *     name:
     *       string_value: my_bucket
     *     env:
     *       custom_value:
     *         typed_config:
     *           '@type': type.googleapis.com/envoy.type.matcher.v3.HttpRequestHeaderMatchInput
     *           header_name: environment
     *
     * In this example, the value of ``BucketId`` key ``env`` is substituted from the ``environment``
     * request header.
     *
     * This is equivalent to the following ``pseudo-code``:
     *
     * .. code-block:: yaml
     *
     *    name: 'my_bucket'
     *    env: $header['environment']
     *
     * For example, the request with the HTTP header ``env`` set to ``staging`` will produce
     * the following ``BucketId``:
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
     *
     *   bucket:
     *     name: my_bucket
     *     env: staging
     *
     * For the request with the HTTP header ``environment`` set to ``prod``, will produce:
     *
     * .. validated-code-block:: yaml
     *   :type-name: envoy.service.rate_limit_quota.v3.BucketId
     *
     *   bucket:
     *     name: my_bucket
     *     env: prod
     *
     * .. note::
     *   The order of ``BucketId`` keys do not matter. Buckets ``{ a: 'A', b: 'B' }`` and
     *   ``{ b: 'B', a: 'A' }`` are identical.
     *
     * If not set, requests will NOT be reported to the server, and will always limited
     * according to :ref:`no_assignment_behavior
     * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.no_assignment_behavior>`
     * configuration.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder bucket_id_builder = 1;
     */
    bucketIdBuilder?: RateLimitQuotaBucketSettings_BucketIdBuilder;
    /**
     * The interval at which the data plane (RLQS client) is to report quota usage for this bucket.
     *
     * When the first request is matched to a bucket with no assignment, the data plane is to report
     * the request immediately in the :ref:`RateLimitQuotaUsageReports
     * <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaUsageReports>` message.
     * For the RLQS server, this signals that the data plane is now subscribed to
     * the quota assignments in this bucket, and will start sending the assignment as described in
     * the :ref:`RLQS documentation <envoy_v3_api_file_envoy/service/rate_limit_quota/v3/rlqs.proto>`.
     *
     * After sending the initial report, the data plane is to continue reporting the bucket usage with
     * the internal specified in this field.
     * [#comment: 100000000 nanoseconds = 0.1 seconds]
     *
     * @generated from protobuf field: google.protobuf.Duration reporting_interval = 2;
     */
    reportingInterval?: Duration;
    /**
     * Customize the deny response to the requests over the rate limit.
     * If not set, the filter will be configured as if an empty message is set,
     * and will behave according to the defaults specified in :ref:`DenyResponseSettings
     * <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings>`.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings deny_response_settings = 3;
     */
    denyResponseSettings?: RateLimitQuotaBucketSettings_DenyResponseSettings;
    /**
     * Configures the behavior in the "no assignment" state: after the first request has been
     * matched to the bucket, and before the the RLQS server returns the first quota assignment.
     *
     * If not set, the default behavior is to allow all requests.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior no_assignment_behavior = 4;
     */
    noAssignmentBehavior?: RateLimitQuotaBucketSettings_NoAssignmentBehavior;
    /**
     * Configures the behavior in the "expired assignment" state: the bucket's assignment has expired,
     * and cannot be refreshed.
     *
     * If not set, the bucket is abandoned when its ``active`` assignment expires.
     * The process of abandoning the bucket, and restarting the subscription is described in the
     * :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
     * message.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior expired_assignment_behavior = 5;
     */
    expiredAssignmentBehavior?: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior;
}
/**
 * Configures the behavior after the first request has been matched to the bucket, and before the
 * the RLQS server returns the first quota assignment.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior
 */
export interface RateLimitQuotaBucketSettings_NoAssignmentBehavior {
    /**
     * @generated from protobuf oneof: no_assignment_behavior
     */
    noAssignmentBehavior: {
        oneofKind: "fallbackRateLimit";
        /**
         * Apply pre-configured rate limiting strategy until the server sends the first assignment.
         *
         * @generated from protobuf field: envoy.type.v3.RateLimitStrategy fallback_rate_limit = 1;
         */
        fallbackRateLimit: RateLimitStrategy;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies the behavior when the bucket's assignment has expired, and cannot be refreshed for
 * any reason.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior
 */
export interface RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
    /**
     * Limit the time :ref:`ExpiredAssignmentBehavior
     * <envoy_v3_api_msg_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior>`
     * is applied. If the server doesn't respond within this duration:
     *
     * 1. Selected ``ExpiredAssignmentBehavior`` is no longer applied.
     * 2. The bucket is abandoned. The process of abandoning the bucket is described in the
     *    :ref:`AbandonAction <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
     *    message.
     * 3. If a new request is matched into the bucket that has become abandoned,
     *    the data plane restarts the subscription to the bucket. The process of restarting the
     *    subscription is described in the :ref:`AbandonAction
     *    <envoy_v3_api_msg_service.rate_limit_quota.v3.RateLimitQuotaResponse.BucketAction.AbandonAction>`
     *    message.
     *
     * If the field is not set, the ``ExpiredAssignmentBehavior`` time is **not limited**:
     * it applies to the bucket until replaced by an ``active`` assignment.
     *
     * @generated from protobuf field: google.protobuf.Duration expired_assignment_behavior_timeout = 1;
     */
    expiredAssignmentBehaviorTimeout?: Duration;
    /**
     * @generated from protobuf oneof: expired_assignment_behavior
     */
    expiredAssignmentBehavior: {
        oneofKind: "fallbackRateLimit";
        /**
         * Apply the rate limiting strategy to all requests matched into the bucket until the RLQS
         * server sends a new assignment, or the :ref:`expired_assignment_behavior_timeout
         * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
         * runs out.
         *
         * @generated from protobuf field: envoy.type.v3.RateLimitStrategy fallback_rate_limit = 2;
         */
        fallbackRateLimit: RateLimitStrategy;
    } | {
        oneofKind: "reuseLastAssignment";
        /**
         * Reuse the last ``active`` assignment until the RLQS server sends a new assignment, or the
         * :ref:`expired_assignment_behavior_timeout
         * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
         * runs out.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment reuse_last_assignment = 3;
         */
        reuseLastAssignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Reuse the last known quota assignment, effectively extending it for the duration
 * specified in the :ref:`expired_assignment_behavior_timeout
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.expired_assignment_behavior_timeout>`
 * field.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment
 */
export interface RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
}
/**
 * Customize the deny response to the requests over the rate limit.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings
 */
export interface RateLimitQuotaBucketSettings_DenyResponseSettings {
    /**
     * HTTP response code to deny for HTTP requests (gRPC excluded).
     * Defaults to 429 (:ref:`StatusCode.TooManyRequests<envoy_v3_api_enum_value_type.v3.StatusCode.TooManyRequests>`).
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus http_status = 1;
     */
    httpStatus?: HttpStatus;
    /**
     * HTTP response body used to deny for HTTP requests (gRPC excluded).
     * If not set, an empty body is returned.
     *
     * @generated from protobuf field: google.protobuf.BytesValue http_body = 2;
     */
    httpBody?: BytesValue;
    /**
     * Configure the deny response for gRPC requests over the rate limit.
     * Allows to specify the `RPC status code
     * <https://cloud.google.com/natural-language/docs/reference/rpc/google.rpc#google.rpc.Code>`_,
     * and the error message.
     * Defaults to the Status with the RPC Code ``UNAVAILABLE`` and empty message.
     *
     * To identify gRPC requests, Envoy checks that the ``Content-Type`` header is
     * ``application/grpc``, or one of the various ``application/grpc+`` values.
     *
     * .. note::
     *   The HTTP code for a gRPC response is always 200.
     *
     * @generated from protobuf field: google.rpc.Status grpc_status = 3;
     */
    grpcStatus?: Status;
    /**
     * Specifies a list of HTTP headers that should be added to each response for requests that
     * have been rate limited. Applies both to plain HTTP, and gRPC requests.
     * The headers are added even when the rate limit quota was not enforced.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 4;
     */
    responseHeadersToAdd: HeaderValueOption[];
}
/**
 * ``BucketIdBuilder`` makes it possible to build :ref:`BucketId
 * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` with values substituted
 * from the dynamic properties associated with each individual request. See usage examples in
 * the docs to :ref:`bucket_id_builder
 * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
 * field.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
 */
export interface RateLimitQuotaBucketSettings_BucketIdBuilder {
    /**
     * The map translated into the ``BucketId`` map.
     *
     * The ``string key`` of this map and becomes the key of ``BucketId`` map as is.
     *
     * The ``ValueBuilder value`` for the key can be:
     *
     * * static ``StringValue string_value`` — becomes the value in the ``BucketId`` map as is.
     * * dynamic ``TypedExtensionConfig custom_value`` — evaluated for each request. Must produce
     *   a string output, which becomes the value in the the ``BucketId`` map.
     *
     * See usage examples in the docs to :ref:`bucket_id_builder
     * <envoy_v3_api_field_extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.bucket_id_builder>`
     * field.
     *
     * @generated from protobuf field: map<string, envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder> bucket_id_builder = 1;
     */
    bucketIdBuilder: {
        [key: string]: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder;
    };
}
/**
 * Produces the value of the :ref:`BucketId
 * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map.
 *
 * @generated from protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder
 */
export interface RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
    /**
     * @generated from protobuf oneof: value_specifier
     */
    valueSpecifier: {
        oneofKind: "stringValue";
        /**
         * Static string value — becomes the value in the :ref:`BucketId
         * <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>` map as is.
         *
         * @generated from protobuf field: string string_value = 1;
         */
        stringValue: string;
    } | {
        oneofKind: "customValue";
        /**
         * Dynamic value — evaluated for each request. Must produce a string output, which becomes
         * the value in the :ref:`BucketId <envoy_v3_api_msg_service.rate_limit_quota.v3.BucketId>`
         * map. For example, extensions with the ``envoy.matching.http.input`` category can be used.
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig custom_value = 2;
         */
        customValue: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaFilterConfig$Type extends MessageType<RateLimitQuotaFilterConfig> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig", [
            { no: 1, name: "rlqs_server", kind: "message", T: () => GrpcService, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "bucket_matchers", kind: "message", T: () => Matcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "filter_enabled", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 5, name: "filter_enforced", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 6, name: "request_headers_to_add_when_not_enforced", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "10" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaFilterConfig>): RateLimitQuotaFilterConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.requestHeadersToAddWhenNotEnforced = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaFilterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaFilterConfig): RateLimitQuotaFilterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.GrpcService rlqs_server */ 1:
                    message.rlqsServer = GrpcService.internalBinaryRead(reader, reader.uint32(), options, message.rlqsServer);
                    break;
                case /* string domain */ 2:
                    message.domain = reader.string();
                    break;
                case /* xds.type.matcher.v3.Matcher bucket_matchers */ 3:
                    message.bucketMatchers = Matcher.internalBinaryRead(reader, reader.uint32(), options, message.bucketMatchers);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled */ 4:
                    message.filterEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnabled);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enforced */ 5:
                    message.filterEnforced = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnforced);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced */ 6:
                    message.requestHeadersToAddWhenNotEnforced.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaFilterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.GrpcService rlqs_server = 1; */
        if (message.rlqsServer)
            GrpcService.internalBinaryWrite(message.rlqsServer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string domain = 2; */
        if (message.domain !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.domain);
        /* xds.type.matcher.v3.Matcher bucket_matchers = 3; */
        if (message.bucketMatchers)
            Matcher.internalBinaryWrite(message.bucketMatchers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 4; */
        if (message.filterEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnabled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enforced = 5; */
        if (message.filterEnforced)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnforced, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add_when_not_enforced = 6; */
        for (let i = 0; i < message.requestHeadersToAddWhenNotEnforced.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAddWhenNotEnforced[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaFilterConfig
 */
export const RateLimitQuotaFilterConfig = new RateLimitQuotaFilterConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaOverride$Type extends MessageType<RateLimitQuotaOverride> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bucket_matchers", kind: "message", T: () => Matcher }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaOverride>): RateLimitQuotaOverride {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaOverride>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaOverride): RateLimitQuotaOverride {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* xds.type.matcher.v3.Matcher bucket_matchers */ 2:
                    message.bucketMatchers = Matcher.internalBinaryRead(reader, reader.uint32(), options, message.bucketMatchers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaOverride, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* xds.type.matcher.v3.Matcher bucket_matchers = 2; */
        if (message.bucketMatchers)
            Matcher.internalBinaryWrite(message.bucketMatchers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaOverride
 */
export const RateLimitQuotaOverride = new RateLimitQuotaOverride$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings$Type extends MessageType<RateLimitQuotaBucketSettings> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings", [
            { no: 1, name: "bucket_id_builder", kind: "message", T: () => RateLimitQuotaBucketSettings_BucketIdBuilder },
            { no: 2, name: "reporting_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: { nanos: 100000000 } } } } },
            { no: 3, name: "deny_response_settings", kind: "message", T: () => RateLimitQuotaBucketSettings_DenyResponseSettings },
            { no: 4, name: "no_assignment_behavior", kind: "message", T: () => RateLimitQuotaBucketSettings_NoAssignmentBehavior },
            { no: 5, name: "expired_assignment_behavior", kind: "message", T: () => RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings>): RateLimitQuotaBucketSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings): RateLimitQuotaBucketSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder bucket_id_builder */ 1:
                    message.bucketIdBuilder = RateLimitQuotaBucketSettings_BucketIdBuilder.internalBinaryRead(reader, reader.uint32(), options, message.bucketIdBuilder);
                    break;
                case /* google.protobuf.Duration reporting_interval */ 2:
                    message.reportingInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.reportingInterval);
                    break;
                case /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings deny_response_settings */ 3:
                    message.denyResponseSettings = RateLimitQuotaBucketSettings_DenyResponseSettings.internalBinaryRead(reader, reader.uint32(), options, message.denyResponseSettings);
                    break;
                case /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior no_assignment_behavior */ 4:
                    message.noAssignmentBehavior = RateLimitQuotaBucketSettings_NoAssignmentBehavior.internalBinaryRead(reader, reader.uint32(), options, message.noAssignmentBehavior);
                    break;
                case /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior expired_assignment_behavior */ 5:
                    message.expiredAssignmentBehavior = RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.internalBinaryRead(reader, reader.uint32(), options, message.expiredAssignmentBehavior);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder bucket_id_builder = 1; */
        if (message.bucketIdBuilder)
            RateLimitQuotaBucketSettings_BucketIdBuilder.internalBinaryWrite(message.bucketIdBuilder, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration reporting_interval = 2; */
        if (message.reportingInterval)
            Duration.internalBinaryWrite(message.reportingInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings deny_response_settings = 3; */
        if (message.denyResponseSettings)
            RateLimitQuotaBucketSettings_DenyResponseSettings.internalBinaryWrite(message.denyResponseSettings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior no_assignment_behavior = 4; */
        if (message.noAssignmentBehavior)
            RateLimitQuotaBucketSettings_NoAssignmentBehavior.internalBinaryWrite(message.noAssignmentBehavior, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior expired_assignment_behavior = 5; */
        if (message.expiredAssignmentBehavior)
            RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior.internalBinaryWrite(message.expiredAssignmentBehavior, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings
 */
export const RateLimitQuotaBucketSettings = new RateLimitQuotaBucketSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_NoAssignmentBehavior$Type extends MessageType<RateLimitQuotaBucketSettings_NoAssignmentBehavior> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior", [
            { no: 1, name: "fallback_rate_limit", kind: "message", oneof: "noAssignmentBehavior", T: () => RateLimitStrategy }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_NoAssignmentBehavior>): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.noAssignmentBehavior = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_NoAssignmentBehavior>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_NoAssignmentBehavior): RateLimitQuotaBucketSettings_NoAssignmentBehavior {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.RateLimitStrategy fallback_rate_limit */ 1:
                    message.noAssignmentBehavior = {
                        oneofKind: "fallbackRateLimit",
                        fallbackRateLimit: RateLimitStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.noAssignmentBehavior as any).fallbackRateLimit)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_NoAssignmentBehavior, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.RateLimitStrategy fallback_rate_limit = 1; */
        if (message.noAssignmentBehavior.oneofKind === "fallbackRateLimit")
            RateLimitStrategy.internalBinaryWrite(message.noAssignmentBehavior.fallbackRateLimit, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.NoAssignmentBehavior
 */
export const RateLimitQuotaBucketSettings_NoAssignmentBehavior = new RateLimitQuotaBucketSettings_NoAssignmentBehavior$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior$Type extends MessageType<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior", [
            { no: 1, name: "expired_assignment_behavior_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 2, name: "fallback_rate_limit", kind: "message", oneof: "expiredAssignmentBehavior", T: () => RateLimitStrategy },
            { no: 3, name: "reuse_last_assignment", kind: "message", oneof: "expiredAssignmentBehavior", T: () => RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior>): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.expiredAssignmentBehavior = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration expired_assignment_behavior_timeout */ 1:
                    message.expiredAssignmentBehaviorTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.expiredAssignmentBehaviorTimeout);
                    break;
                case /* envoy.type.v3.RateLimitStrategy fallback_rate_limit */ 2:
                    message.expiredAssignmentBehavior = {
                        oneofKind: "fallbackRateLimit",
                        fallbackRateLimit: RateLimitStrategy.internalBinaryRead(reader, reader.uint32(), options, (message.expiredAssignmentBehavior as any).fallbackRateLimit)
                    };
                    break;
                case /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment reuse_last_assignment */ 3:
                    message.expiredAssignmentBehavior = {
                        oneofKind: "reuseLastAssignment",
                        reuseLastAssignment: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.internalBinaryRead(reader, reader.uint32(), options, (message.expiredAssignmentBehavior as any).reuseLastAssignment)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration expired_assignment_behavior_timeout = 1; */
        if (message.expiredAssignmentBehaviorTimeout)
            Duration.internalBinaryWrite(message.expiredAssignmentBehaviorTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.RateLimitStrategy fallback_rate_limit = 2; */
        if (message.expiredAssignmentBehavior.oneofKind === "fallbackRateLimit")
            RateLimitStrategy.internalBinaryWrite(message.expiredAssignmentBehavior.fallbackRateLimit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment reuse_last_assignment = 3; */
        if (message.expiredAssignmentBehavior.oneofKind === "reuseLastAssignment")
            RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment.internalBinaryWrite(message.expiredAssignmentBehavior.reuseLastAssignment, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior
 */
export const RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior = new RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment$Type extends MessageType<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment", []);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment>): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment): RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.ExpiredAssignmentBehavior.ReuseLastAssignment
 */
export const RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment = new RateLimitQuotaBucketSettings_ExpiredAssignmentBehavior_ReuseLastAssignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_DenyResponseSettings$Type extends MessageType<RateLimitQuotaBucketSettings_DenyResponseSettings> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings", [
            { no: 1, name: "http_status", kind: "message", T: () => HttpStatus },
            { no: 2, name: "http_body", kind: "message", T: () => BytesValue },
            { no: 3, name: "grpc_status", kind: "message", T: () => Status },
            { no: 4, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "10" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_DenyResponseSettings>): RateLimitQuotaBucketSettings_DenyResponseSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responseHeadersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_DenyResponseSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_DenyResponseSettings): RateLimitQuotaBucketSettings_DenyResponseSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.HttpStatus http_status */ 1:
                    message.httpStatus = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.httpStatus);
                    break;
                case /* google.protobuf.BytesValue http_body */ 2:
                    message.httpBody = BytesValue.internalBinaryRead(reader, reader.uint32(), options, message.httpBody);
                    break;
                case /* google.rpc.Status grpc_status */ 3:
                    message.grpcStatus = Status.internalBinaryRead(reader, reader.uint32(), options, message.grpcStatus);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 4:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_DenyResponseSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.HttpStatus http_status = 1; */
        if (message.httpStatus)
            HttpStatus.internalBinaryWrite(message.httpStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BytesValue http_body = 2; */
        if (message.httpBody)
            BytesValue.internalBinaryWrite(message.httpBody, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.rpc.Status grpc_status = 3; */
        if (message.grpcStatus)
            Status.internalBinaryWrite(message.grpcStatus, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 4; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.DenyResponseSettings
 */
export const RateLimitQuotaBucketSettings_DenyResponseSettings = new RateLimitQuotaBucketSettings_DenyResponseSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_BucketIdBuilder$Type extends MessageType<RateLimitQuotaBucketSettings_BucketIdBuilder> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder", [
            { no: 1, name: "bucket_id_builder", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder }, options: { "validate.rules": { map: { minPairs: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_BucketIdBuilder>): RateLimitQuotaBucketSettings_BucketIdBuilder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bucketIdBuilder = {};
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_BucketIdBuilder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_BucketIdBuilder): RateLimitQuotaBucketSettings_BucketIdBuilder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder> bucket_id_builder */ 1:
                    this.binaryReadMap1(message.bucketIdBuilder, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: RateLimitQuotaBucketSettings_BucketIdBuilder["bucketIdBuilder"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RateLimitQuotaBucketSettings_BucketIdBuilder["bucketIdBuilder"] | undefined, val: RateLimitQuotaBucketSettings_BucketIdBuilder["bucketIdBuilder"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.bucket_id_builder");
            }
        }
        map[key ?? ""] = val ?? RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.create();
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_BucketIdBuilder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder> bucket_id_builder = 1; */
        for (let k of globalThis.Object.keys(message.bucketIdBuilder)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder.internalBinaryWrite(message.bucketIdBuilder[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder
 */
export const RateLimitQuotaBucketSettings_BucketIdBuilder = new RateLimitQuotaBucketSettings_BucketIdBuilder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder$Type extends MessageType<RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder> {
    constructor() {
        super("envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder", [
            { no: 1, name: "string_value", kind: "scalar", oneof: "valueSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "custom_value", kind: "message", oneof: "valueSpecifier", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder>): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.valueSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder): RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string string_value */ 1:
                    message.valueSpecifier = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig custom_value */ 2:
                    message.valueSpecifier = {
                        oneofKind: "customValue",
                        customValue: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.valueSpecifier as any).customValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string string_value = 1; */
        if (message.valueSpecifier.oneofKind === "stringValue")
            writer.tag(1, WireType.LengthDelimited).string(message.valueSpecifier.stringValue);
        /* envoy.config.core.v3.TypedExtensionConfig custom_value = 2; */
        if (message.valueSpecifier.oneofKind === "customValue")
            TypedExtensionConfig.internalBinaryWrite(message.valueSpecifier.customValue, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.rate_limit_quota.v3.RateLimitQuotaBucketSettings.BucketIdBuilder.ValueBuilder
 */
export const RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder = new RateLimitQuotaBucketSettings_BucketIdBuilder_ValueBuilder$Type();
