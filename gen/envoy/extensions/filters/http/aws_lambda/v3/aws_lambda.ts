// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/aws_lambda/v3/aws_lambda.proto" (package "envoy.extensions.filters.http.aws_lambda.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// [#protodoc-title: AWS Lambda]
// AWS Lambda :ref:`configuration overview <config_http_filters_aws_lambda>`.
// [#extension: envoy.filters.http.aws_lambda]

/**
 * AWS Lambda filter config
 *
 * @generated from protobuf message envoy.extensions.filters.http.aws_lambda.v3.Config
 */
export interface Config {
    /**
     * The ARN of the AWS Lambda to invoke when the filter is engaged
     * Must be in the following format:
     * arn:<partition>:lambda:<region>:<account-number>:function:<function-name>
     *
     * @generated from protobuf field: string arn = 1;
     */
    arn: string;
    /**
     * Whether to transform the request (headers and body) to a JSON payload or pass it as is.
     *
     * @generated from protobuf field: bool payload_passthrough = 2;
     */
    payloadPassthrough: boolean;
    /**
     * Determines the way to invoke the Lambda function.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.aws_lambda.v3.Config.InvocationMode invocation_mode = 3;
     */
    invocationMode: Config_InvocationMode;
}
/**
 * @generated from protobuf enum envoy.extensions.filters.http.aws_lambda.v3.Config.InvocationMode
 */
export enum Config_InvocationMode {
    /**
     * This is the more common mode of invocation, in which Lambda responds after it has completed the function. In
     * this mode the output of the Lambda function becomes the response of the HTTP request.
     *
     * @generated from protobuf enum value: SYNCHRONOUS = 0;
     */
    SYNCHRONOUS = 0,
    /**
     * In this mode Lambda responds immediately but continues to process the function asynchronously. This mode can be
     * used to signal events for example. In this mode, Lambda responds with an acknowledgment that it received the
     * call which is translated to an HTTP 200 OK by the filter.
     *
     * @generated from protobuf enum value: ASYNCHRONOUS = 1;
     */
    ASYNCHRONOUS = 1
}
/**
 * Per-route configuration for AWS Lambda. This can be useful when invoking a different Lambda function or a different
 * version of the same Lambda depending on the route.
 *
 * @generated from protobuf message envoy.extensions.filters.http.aws_lambda.v3.PerRouteConfig
 */
export interface PerRouteConfig {
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.aws_lambda.v3.Config invoke_config = 1;
     */
    invokeConfig?: Config;
}
// @generated message type with reflection information, may provide speed optimized methods
class Config$Type extends MessageType<Config> {
    constructor() {
        super("envoy.extensions.filters.http.aws_lambda.v3.Config", [
            { no: 1, name: "arn", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "payload_passthrough", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "invocation_mode", kind: "enum", T: () => ["envoy.extensions.filters.http.aws_lambda.v3.Config.InvocationMode", Config_InvocationMode], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.aws_lambda.v2alpha.Config" } });
    }
    create(value?: PartialMessage<Config>): Config {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.arn = "";
        message.payloadPassthrough = false;
        message.invocationMode = 0;
        if (value !== undefined)
            reflectionMergePartial<Config>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Config): Config {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string arn */ 1:
                    message.arn = reader.string();
                    break;
                case /* bool payload_passthrough */ 2:
                    message.payloadPassthrough = reader.bool();
                    break;
                case /* envoy.extensions.filters.http.aws_lambda.v3.Config.InvocationMode invocation_mode */ 3:
                    message.invocationMode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Config, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string arn = 1; */
        if (message.arn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.arn);
        /* bool payload_passthrough = 2; */
        if (message.payloadPassthrough !== false)
            writer.tag(2, WireType.Varint).bool(message.payloadPassthrough);
        /* envoy.extensions.filters.http.aws_lambda.v3.Config.InvocationMode invocation_mode = 3; */
        if (message.invocationMode !== 0)
            writer.tag(3, WireType.Varint).int32(message.invocationMode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.aws_lambda.v3.Config
 */
export const Config = new Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerRouteConfig$Type extends MessageType<PerRouteConfig> {
    constructor() {
        super("envoy.extensions.filters.http.aws_lambda.v3.PerRouteConfig", [
            { no: 1, name: "invoke_config", kind: "message", T: () => Config }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.aws_lambda.v2alpha.PerRouteConfig" } });
    }
    create(value?: PartialMessage<PerRouteConfig>): PerRouteConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PerRouteConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerRouteConfig): PerRouteConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.aws_lambda.v3.Config invoke_config */ 1:
                    message.invokeConfig = Config.internalBinaryRead(reader, reader.uint32(), options, message.invokeConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerRouteConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.aws_lambda.v3.Config invoke_config = 1; */
        if (message.invokeConfig)
            Config.internalBinaryWrite(message.invokeConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.aws_lambda.v3.PerRouteConfig
 */
export const PerRouteConfig = new PerRouteConfig$Type();
