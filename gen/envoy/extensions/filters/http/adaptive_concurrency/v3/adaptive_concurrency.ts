// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/adaptive_concurrency/v3/adaptive_concurrency.proto" (package "envoy.extensions.filters.http.adaptive_concurrency.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HttpStatus } from "../../../../../type/v3/http_status";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
import { Duration } from "../../../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { Percent } from "../../../../../type/v3/percent";
// [#protodoc-title: Adaptive Concurrency]
// Adaptive Concurrency Control :ref:`configuration overview
// <config_http_filters_adaptive_concurrency>`.
// [#extension: envoy.filters.http.adaptive_concurrency]

/**
 * Configuration parameters for the gradient controller.
 *
 * @generated from protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig
 */
export interface GradientControllerConfig {
    /**
     * The percentile to use when summarizing aggregated samples. Defaults to p50.
     *
     * @generated from protobuf field: envoy.type.v3.Percent sample_aggregate_percentile = 1;
     */
    sampleAggregatePercentile?: Percent;
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams concurrency_limit_params = 2;
     */
    concurrencyLimitParams?: GradientControllerConfig_ConcurrencyLimitCalculationParams;
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams min_rtt_calc_params = 3;
     */
    minRttCalcParams?: GradientControllerConfig_MinimumRTTCalculationParams;
}
/**
 * Parameters controlling the periodic recalculation of the concurrency limit from sampled request
 * latencies.
 *
 * @generated from protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams
 */
export interface GradientControllerConfig_ConcurrencyLimitCalculationParams {
    /**
     * The allowed upper-bound on the calculated concurrency limit. Defaults to 1000.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_concurrency_limit = 2;
     */
    maxConcurrencyLimit?: UInt32Value;
    /**
     * The period of time samples are taken to recalculate the concurrency limit.
     *
     * @generated from protobuf field: google.protobuf.Duration concurrency_update_interval = 3;
     */
    concurrencyUpdateInterval?: Duration;
}
/**
 * Parameters controlling the periodic minRTT recalculation.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams
 */
export interface GradientControllerConfig_MinimumRTTCalculationParams {
    /**
     * The time interval between recalculating the minimum request round-trip time. Has to be
     * positive.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 1;
     */
    interval?: Duration;
    /**
     * The number of requests to aggregate/sample during the minRTT recalculation window before
     * updating. Defaults to 50.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value request_count = 2;
     */
    requestCount?: UInt32Value;
    /**
     * Randomized time delta that will be introduced to the start of the minRTT calculation window.
     * This is represented as a percentage of the interval duration. Defaults to 15%.
     *
     * Example: If the interval is 10s and the jitter is 15%, the next window will begin
     * somewhere in the range (10s - 11.5s).
     *
     * @generated from protobuf field: envoy.type.v3.Percent jitter = 3;
     */
    jitter?: Percent;
    /**
     * The concurrency limit set while measuring the minRTT. Defaults to 3.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value min_concurrency = 4;
     */
    minConcurrency?: UInt32Value;
    /**
     * Amount added to the measured minRTT to add stability to the concurrency limit during natural
     * variability in latency. This is expressed as a percentage of the measured value and can be
     * adjusted to allow more or less tolerance to the sampled latency values.
     *
     * Defaults to 25%.
     *
     * @generated from protobuf field: envoy.type.v3.Percent buffer = 5;
     */
    buffer?: Percent;
}
/**
 * @generated from protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.AdaptiveConcurrency
 */
export interface AdaptiveConcurrency {
    /**
     * @generated from protobuf oneof: concurrency_controller_config
     */
    concurrencyControllerConfig: {
        oneofKind: "gradientControllerConfig";
        /**
         * Gradient concurrency control will be used.
         *
         * @generated from protobuf field: envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig gradient_controller_config = 1;
         */
        gradientControllerConfig: GradientControllerConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * If set to false, the adaptive concurrency filter will operate as a pass-through filter. If the
     * message is unspecified, the filter will be enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag enabled = 2;
     */
    enabled?: RuntimeFeatureFlag;
    /**
     * This field allows for a custom HTTP response status code to the downstream client when
     * the concurrency limit has been exceeded.
     * Defaults to 503 (Service Unavailable).
     *
     * .. note::
     *   If this is set to < 400, 503 will be used instead.
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus concurrency_limit_exceeded_status = 3;
     */
    concurrencyLimitExceededStatus?: HttpStatus;
}
// @generated message type with reflection information, may provide speed optimized methods
class GradientControllerConfig$Type extends MessageType<GradientControllerConfig> {
    constructor() {
        super("envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig", [
            { no: 1, name: "sample_aggregate_percentile", kind: "message", T: () => Percent },
            { no: 2, name: "concurrency_limit_params", kind: "message", T: () => GradientControllerConfig_ConcurrencyLimitCalculationParams, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "min_rtt_calc_params", kind: "message", T: () => GradientControllerConfig_MinimumRTTCalculationParams, options: { "validate.rules": { message: { required: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig" } });
    }
    create(value?: PartialMessage<GradientControllerConfig>): GradientControllerConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GradientControllerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GradientControllerConfig): GradientControllerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent sample_aggregate_percentile */ 1:
                    message.sampleAggregatePercentile = Percent.internalBinaryRead(reader, reader.uint32(), options, message.sampleAggregatePercentile);
                    break;
                case /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams concurrency_limit_params */ 2:
                    message.concurrencyLimitParams = GradientControllerConfig_ConcurrencyLimitCalculationParams.internalBinaryRead(reader, reader.uint32(), options, message.concurrencyLimitParams);
                    break;
                case /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams min_rtt_calc_params */ 3:
                    message.minRttCalcParams = GradientControllerConfig_MinimumRTTCalculationParams.internalBinaryRead(reader, reader.uint32(), options, message.minRttCalcParams);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GradientControllerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent sample_aggregate_percentile = 1; */
        if (message.sampleAggregatePercentile)
            Percent.internalBinaryWrite(message.sampleAggregatePercentile, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams concurrency_limit_params = 2; */
        if (message.concurrencyLimitParams)
            GradientControllerConfig_ConcurrencyLimitCalculationParams.internalBinaryWrite(message.concurrencyLimitParams, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams min_rtt_calc_params = 3; */
        if (message.minRttCalcParams)
            GradientControllerConfig_MinimumRTTCalculationParams.internalBinaryWrite(message.minRttCalcParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig
 */
export const GradientControllerConfig = new GradientControllerConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GradientControllerConfig_ConcurrencyLimitCalculationParams$Type extends MessageType<GradientControllerConfig_ConcurrencyLimitCalculationParams> {
    constructor() {
        super("envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams", [
            { no: 2, name: "max_concurrency_limit", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 3, name: "concurrency_update_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig.ConcurrencyLimitCalculationParams" } });
    }
    create(value?: PartialMessage<GradientControllerConfig_ConcurrencyLimitCalculationParams>): GradientControllerConfig_ConcurrencyLimitCalculationParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GradientControllerConfig_ConcurrencyLimitCalculationParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GradientControllerConfig_ConcurrencyLimitCalculationParams): GradientControllerConfig_ConcurrencyLimitCalculationParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value max_concurrency_limit */ 2:
                    message.maxConcurrencyLimit = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxConcurrencyLimit);
                    break;
                case /* google.protobuf.Duration concurrency_update_interval */ 3:
                    message.concurrencyUpdateInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.concurrencyUpdateInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GradientControllerConfig_ConcurrencyLimitCalculationParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value max_concurrency_limit = 2; */
        if (message.maxConcurrencyLimit)
            UInt32Value.internalBinaryWrite(message.maxConcurrencyLimit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration concurrency_update_interval = 3; */
        if (message.concurrencyUpdateInterval)
            Duration.internalBinaryWrite(message.concurrencyUpdateInterval, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.ConcurrencyLimitCalculationParams
 */
export const GradientControllerConfig_ConcurrencyLimitCalculationParams = new GradientControllerConfig_ConcurrencyLimitCalculationParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GradientControllerConfig_MinimumRTTCalculationParams$Type extends MessageType<GradientControllerConfig_MinimumRTTCalculationParams> {
    constructor() {
        super("envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams", [
            { no: 1, name: "interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gte: { nanos: 1000000 } } } } },
            { no: 2, name: "request_count", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 3, name: "jitter", kind: "message", T: () => Percent },
            { no: 4, name: "min_concurrency", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 5, name: "buffer", kind: "message", T: () => Percent }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.adaptive_concurrency.v2alpha.GradientControllerConfig.MinimumRTTCalculationParams" } });
    }
    create(value?: PartialMessage<GradientControllerConfig_MinimumRTTCalculationParams>): GradientControllerConfig_MinimumRTTCalculationParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GradientControllerConfig_MinimumRTTCalculationParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GradientControllerConfig_MinimumRTTCalculationParams): GradientControllerConfig_MinimumRTTCalculationParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration interval */ 1:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                case /* google.protobuf.UInt32Value request_count */ 2:
                    message.requestCount = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.requestCount);
                    break;
                case /* envoy.type.v3.Percent jitter */ 3:
                    message.jitter = Percent.internalBinaryRead(reader, reader.uint32(), options, message.jitter);
                    break;
                case /* google.protobuf.UInt32Value min_concurrency */ 4:
                    message.minConcurrency = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.minConcurrency);
                    break;
                case /* envoy.type.v3.Percent buffer */ 5:
                    message.buffer = Percent.internalBinaryRead(reader, reader.uint32(), options, message.buffer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GradientControllerConfig_MinimumRTTCalculationParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration interval = 1; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value request_count = 2; */
        if (message.requestCount)
            UInt32Value.internalBinaryWrite(message.requestCount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent jitter = 3; */
        if (message.jitter)
            Percent.internalBinaryWrite(message.jitter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value min_concurrency = 4; */
        if (message.minConcurrency)
            UInt32Value.internalBinaryWrite(message.minConcurrency, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent buffer = 5; */
        if (message.buffer)
            Percent.internalBinaryWrite(message.buffer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig.MinimumRTTCalculationParams
 */
export const GradientControllerConfig_MinimumRTTCalculationParams = new GradientControllerConfig_MinimumRTTCalculationParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdaptiveConcurrency$Type extends MessageType<AdaptiveConcurrency> {
    constructor() {
        super("envoy.extensions.filters.http.adaptive_concurrency.v3.AdaptiveConcurrency", [
            { no: 1, name: "gradient_controller_config", kind: "message", oneof: "concurrencyControllerConfig", T: () => GradientControllerConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "enabled", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 3, name: "concurrency_limit_exceeded_status", kind: "message", T: () => HttpStatus }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.filter.http.adaptive_concurrency.v2alpha.AdaptiveConcurrency" } });
    }
    create(value?: PartialMessage<AdaptiveConcurrency>): AdaptiveConcurrency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.concurrencyControllerConfig = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AdaptiveConcurrency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdaptiveConcurrency): AdaptiveConcurrency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig gradient_controller_config */ 1:
                    message.concurrencyControllerConfig = {
                        oneofKind: "gradientControllerConfig",
                        gradientControllerConfig: GradientControllerConfig.internalBinaryRead(reader, reader.uint32(), options, (message.concurrencyControllerConfig as any).gradientControllerConfig)
                    };
                    break;
                case /* envoy.config.core.v3.RuntimeFeatureFlag enabled */ 2:
                    message.enabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* envoy.type.v3.HttpStatus concurrency_limit_exceeded_status */ 3:
                    message.concurrencyLimitExceededStatus = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.concurrencyLimitExceededStatus);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdaptiveConcurrency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.adaptive_concurrency.v3.GradientControllerConfig gradient_controller_config = 1; */
        if (message.concurrencyControllerConfig.oneofKind === "gradientControllerConfig")
            GradientControllerConfig.internalBinaryWrite(message.concurrencyControllerConfig.gradientControllerConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFeatureFlag enabled = 2; */
        if (message.enabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.enabled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.HttpStatus concurrency_limit_exceeded_status = 3; */
        if (message.concurrencyLimitExceededStatus)
            HttpStatus.internalBinaryWrite(message.concurrencyLimitExceededStatus, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.adaptive_concurrency.v3.AdaptiveConcurrency
 */
export const AdaptiveConcurrency = new AdaptiveConcurrency$Type();
