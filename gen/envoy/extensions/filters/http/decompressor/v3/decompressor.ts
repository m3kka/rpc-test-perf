// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/http/decompressor/v3/decompressor.proto" (package "envoy.extensions.filters.http.decompressor.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
import { RuntimeFeatureFlag } from "../../../../../config/core/v3/base";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
// [#protodoc-title: Decompressor]
// [#extension: envoy.filters.http.decompressor]

/**
 * @generated from protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor
 */
export interface Decompressor {
    /**
     * A decompressor library to use for both request and response decompression. Currently only
     * :ref:`envoy.compression.gzip.compressor<envoy_v3_api_msg_extensions.compression.gzip.decompressor.v3.Gzip>`
     * is included in Envoy.
     * [#extension-category: envoy.compression.decompressor]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig decompressor_library = 1;
     */
    decompressorLibrary?: TypedExtensionConfig;
    /**
     * Configuration for request decompression. Decompression is enabled by default if left empty.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig request_direction_config = 2;
     */
    requestDirectionConfig?: Decompressor_RequestDirectionConfig;
    /**
     * Configuration for response decompression. Decompression is enabled by default if left empty.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig response_direction_config = 3;
     */
    responseDirectionConfig?: Decompressor_ResponseDirectionConfig;
}
/**
 * Common configuration for filter behavior on both the request and response direction.
 *
 * @generated from protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig
 */
export interface Decompressor_CommonDirectionConfig {
    /**
     * Runtime flag that controls whether the filter is enabled for decompression or not. If set to false, the
     * filter will operate as a pass-through filter. If the message is unspecified, the filter will be enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag enabled = 1;
     */
    enabled?: RuntimeFeatureFlag;
    /**
     * If set to true, will decompress response even if a ``no-transform`` cache control header is set.
     *
     * @generated from protobuf field: bool ignore_no_transform_header = 2;
     */
    ignoreNoTransformHeader: boolean;
}
/**
 * Configuration for filter behavior on the request direction.
 *
 * @generated from protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig
 */
export interface Decompressor_RequestDirectionConfig {
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config = 1;
     */
    commonConfig?: Decompressor_CommonDirectionConfig;
    /**
     * If set to true, and response decompression is enabled, the filter modifies the Accept-Encoding
     * request header by appending the decompressor_library's encoding. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue advertise_accept_encoding = 2;
     */
    advertiseAcceptEncoding?: BoolValue;
}
/**
 * Configuration for filter behavior on the response direction.
 *
 * @generated from protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig
 */
export interface Decompressor_ResponseDirectionConfig {
    /**
     * @generated from protobuf field: envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config = 1;
     */
    commonConfig?: Decompressor_CommonDirectionConfig;
}
// @generated message type with reflection information, may provide speed optimized methods
class Decompressor$Type extends MessageType<Decompressor> {
    constructor() {
        super("envoy.extensions.filters.http.decompressor.v3.Decompressor", [
            { no: 1, name: "decompressor_library", kind: "message", T: () => TypedExtensionConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "request_direction_config", kind: "message", T: () => Decompressor_RequestDirectionConfig },
            { no: 3, name: "response_direction_config", kind: "message", T: () => Decompressor_ResponseDirectionConfig }
        ]);
    }
    create(value?: PartialMessage<Decompressor>): Decompressor {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Decompressor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decompressor): Decompressor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig decompressor_library */ 1:
                    message.decompressorLibrary = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.decompressorLibrary);
                    break;
                case /* envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig request_direction_config */ 2:
                    message.requestDirectionConfig = Decompressor_RequestDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.requestDirectionConfig);
                    break;
                case /* envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig response_direction_config */ 3:
                    message.responseDirectionConfig = Decompressor_ResponseDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.responseDirectionConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decompressor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig decompressor_library = 1; */
        if (message.decompressorLibrary)
            TypedExtensionConfig.internalBinaryWrite(message.decompressorLibrary, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig request_direction_config = 2; */
        if (message.requestDirectionConfig)
            Decompressor_RequestDirectionConfig.internalBinaryWrite(message.requestDirectionConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig response_direction_config = 3; */
        if (message.responseDirectionConfig)
            Decompressor_ResponseDirectionConfig.internalBinaryWrite(message.responseDirectionConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor
 */
export const Decompressor = new Decompressor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decompressor_CommonDirectionConfig$Type extends MessageType<Decompressor_CommonDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig", [
            { no: 1, name: "enabled", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 2, name: "ignore_no_transform_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Decompressor_CommonDirectionConfig>): Decompressor_CommonDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ignoreNoTransformHeader = false;
        if (value !== undefined)
            reflectionMergePartial<Decompressor_CommonDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decompressor_CommonDirectionConfig): Decompressor_CommonDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.RuntimeFeatureFlag enabled */ 1:
                    message.enabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* bool ignore_no_transform_header */ 2:
                    message.ignoreNoTransformHeader = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decompressor_CommonDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.RuntimeFeatureFlag enabled = 1; */
        if (message.enabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.enabled, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool ignore_no_transform_header = 2; */
        if (message.ignoreNoTransformHeader !== false)
            writer.tag(2, WireType.Varint).bool(message.ignoreNoTransformHeader);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig
 */
export const Decompressor_CommonDirectionConfig = new Decompressor_CommonDirectionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decompressor_RequestDirectionConfig$Type extends MessageType<Decompressor_RequestDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig", [
            { no: 1, name: "common_config", kind: "message", T: () => Decompressor_CommonDirectionConfig },
            { no: 2, name: "advertise_accept_encoding", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<Decompressor_RequestDirectionConfig>): Decompressor_RequestDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Decompressor_RequestDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decompressor_RequestDirectionConfig): Decompressor_RequestDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config */ 1:
                    message.commonConfig = Decompressor_CommonDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.commonConfig);
                    break;
                case /* google.protobuf.BoolValue advertise_accept_encoding */ 2:
                    message.advertiseAcceptEncoding = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.advertiseAcceptEncoding);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decompressor_RequestDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config = 1; */
        if (message.commonConfig)
            Decompressor_CommonDirectionConfig.internalBinaryWrite(message.commonConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue advertise_accept_encoding = 2; */
        if (message.advertiseAcceptEncoding)
            BoolValue.internalBinaryWrite(message.advertiseAcceptEncoding, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.RequestDirectionConfig
 */
export const Decompressor_RequestDirectionConfig = new Decompressor_RequestDirectionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decompressor_ResponseDirectionConfig$Type extends MessageType<Decompressor_ResponseDirectionConfig> {
    constructor() {
        super("envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig", [
            { no: 1, name: "common_config", kind: "message", T: () => Decompressor_CommonDirectionConfig }
        ]);
    }
    create(value?: PartialMessage<Decompressor_ResponseDirectionConfig>): Decompressor_ResponseDirectionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Decompressor_ResponseDirectionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decompressor_ResponseDirectionConfig): Decompressor_ResponseDirectionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config */ 1:
                    message.commonConfig = Decompressor_CommonDirectionConfig.internalBinaryRead(reader, reader.uint32(), options, message.commonConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decompressor_ResponseDirectionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.filters.http.decompressor.v3.Decompressor.CommonDirectionConfig common_config = 1; */
        if (message.commonConfig)
            Decompressor_CommonDirectionConfig.internalBinaryWrite(message.commonConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.http.decompressor.v3.Decompressor.ResponseDirectionConfig
 */
export const Decompressor_ResponseDirectionConfig = new Decompressor_ResponseDirectionConfig$Type();
