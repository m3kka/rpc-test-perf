// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/filters/udp/udp_proxy/v3/udp_proxy.proto (package envoy.extensions.filters.udp.udp_proxy.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Matcher } from "../../../../../../xds/type/matcher/v3/matcher_pb.js";
import type { UdpSocketConfig } from "../../../../../config/core/v3/udp_socket_config_pb.js";
import type { AccessLog } from "../../../../../config/accesslog/v3/accesslog_pb.js";

/**
 * Configuration for the UDP proxy filter.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig
 */
export declare class UdpProxyConfig extends Message<UdpProxyConfig> {
  /**
   * The stat prefix used when emitting UDP proxy filter stats.
   *
   * @generated from field: string stat_prefix = 1;
   */
  statPrefix: string;

  /**
   * @generated from oneof envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.route_specifier
   */
  routeSpecifier: {
    /**
     * The upstream cluster to connect to.
     * This field is deprecated in favor of
     * :ref:`matcher <envoy_v3_api_field_extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.matcher>`.
     *
     * @generated from field: string cluster = 2 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * The match tree to use when resolving route actions for incoming requests.
     * See :ref:`Routing <config_udp_listener_filters_udp_proxy_routing>` for more information.
     *
     * @generated from field: xds.type.matcher.v3.Matcher matcher = 9;
     */
    value: Matcher;
    case: "matcher";
  } | { case: undefined; value?: undefined };

  /**
   * The idle timeout for sessions. Idle is defined as no datagrams between received or sent by
   * the session. The default if not specified is 1 minute.
   *
   * @generated from field: google.protobuf.Duration idle_timeout = 3;
   */
  idleTimeout?: Duration;

  /**
   * Use the remote downstream IP address as the sender IP address when sending packets to upstream hosts.
   * This option requires Envoy to be run with the ``CAP_NET_ADMIN`` capability on Linux.
   * And the IPv6 stack must be enabled on Linux kernel.
   * This option does not preserve the remote downstream port.
   * If this option is enabled, the IP address of sent datagrams will be changed to the remote downstream IP address.
   * This means that Envoy will not receive packets that are sent by upstream hosts because the upstream hosts
   * will send the packets with the remote downstream IP address as the destination. All packets will be routed
   * to the remote downstream directly if there are route rules on the upstream host side.
   * There are two options to return the packets back to the remote downstream.
   * The first one is to use DSR (Direct Server Return).
   * The other one is to configure routing rules on the upstream hosts to forward
   * all packets back to Envoy and configure iptables rules on the host running Envoy to
   * forward all packets from upstream hosts to the Envoy process so that Envoy can forward the packets to the downstream.
   * If the platform does not support this option, Envoy will raise a configuration error.
   *
   * @generated from field: bool use_original_src_ip = 4;
   */
  useOriginalSrcIp: boolean;

  /**
   * Optional configuration for UDP proxy hash policies. If hash_policies is not set, the hash-based
   * load balancing algorithms will select a host randomly. Currently the number of hash policies is
   * limited to 1.
   *
   * @generated from field: repeated envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy hash_policies = 5;
   */
  hashPolicies: UdpProxyConfig_HashPolicy[];

  /**
   * UDP socket configuration for upstream sockets. The default for
   * :ref:`prefer_gro <envoy_v3_api_field_config.core.v3.UdpSocketConfig.prefer_gro>` is true for upstream
   * sockets as the assumption is datagrams will be received from a single source.
   *
   * @generated from field: envoy.config.core.v3.UdpSocketConfig upstream_socket_config = 6;
   */
  upstreamSocketConfig?: UdpSocketConfig;

  /**
   * Perform per packet load balancing (upstream host selection) on each received data chunk.
   * The default if not specified is false, that means each data chunk is forwarded
   * to upstream host selected on first chunk receival for that "session" (identified by source IP/port and local IP/port).
   *
   * @generated from field: bool use_per_packet_load_balancing = 7;
   */
  usePerPacketLoadBalancing: boolean;

  /**
   * Configuration for session access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLog access_log = 8;
   */
  accessLog: AccessLog[];

  /**
   * Configuration for proxy access logs emitted by the UDP proxy. Note that certain UDP specific data is emitted as :ref:`Dynamic Metadata <config_access_log_format_dynamic_metadata>`.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLog proxy_access_log = 10;
   */
  proxyAccessLog: AccessLog[];

  constructor(data?: PartialMessage<UdpProxyConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UdpProxyConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UdpProxyConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UdpProxyConfig;

  static equals(a: UdpProxyConfig | PlainMessage<UdpProxyConfig> | undefined, b: UdpProxyConfig | PlainMessage<UdpProxyConfig> | undefined): boolean;
}

/**
 * Specifies the UDP hash policy.
 * The packets can be routed by hash policy.
 *
 * @generated from message envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy
 */
export declare class UdpProxyConfig_HashPolicy extends Message<UdpProxyConfig_HashPolicy> {
  /**
   * @generated from oneof envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy.policy_specifier
   */
  policySpecifier: {
    /**
     * The source IP will be used to compute the hash used by hash-based load balancing algorithms.
     *
     * @generated from field: bool source_ip = 1;
     */
    value: boolean;
    case: "sourceIp";
  } | {
    /**
     * A given key will be used to compute the hash used by hash-based load balancing algorithms.
     * In certain cases there is a need to direct different UDP streams jointly towards the selected set of endpoints.
     * A possible use-case is VoIP telephony, where media (RTP) and its corresponding control (RTCP) belong to the same logical session,
     * although they travel in separate streams. To ensure that these pair of streams are load-balanced on session level
     * (instead of individual stream level), dynamically created listeners can use the same hash key for each stream in the session.
     *
     * @generated from field: string key = 2;
     */
    value: string;
    case: "key";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<UdpProxyConfig_HashPolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.udp.udp_proxy.v3.UdpProxyConfig.HashPolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UdpProxyConfig_HashPolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UdpProxyConfig_HashPolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UdpProxyConfig_HashPolicy;

  static equals(a: UdpProxyConfig_HashPolicy | PlainMessage<UdpProxyConfig_HashPolicy> | undefined, b: UdpProxyConfig_HashPolicy | PlainMessage<UdpProxyConfig_HashPolicy> | undefined): boolean;
}

