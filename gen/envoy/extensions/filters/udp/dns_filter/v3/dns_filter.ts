// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/filters/udp/dns_filter/v3/dns_filter.proto" (package "envoy.extensions.filters.udp.dns_filter.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedExtensionConfig } from "../../../../../config/core/v3/extension";
import { DnsResolutionConfig } from "../../../../../config/core/v3/resolver";
import { Address } from "../../../../../config/core/v3/address";
import { Duration } from "../../../../../../google/protobuf/duration";
import { DataSource } from "../../../../../config/core/v3/base";
import { DnsTable } from "../../../../../data/dns/v3/dns_table";
// [#protodoc-title: DNS Filter]
// DNS Filter :ref:`configuration overview <config_udp_listener_filters_dns_filter>`.
// [#extension: envoy.filters.udp.dns_filter]

/**
 * Configuration for the DNS filter.
 *
 * @generated from protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig
 */
export interface DnsFilterConfig {
    /**
     * The stat prefix used when emitting DNS filter statistics
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * Server context configuration contains the data that the filter uses to respond
     * to DNS requests.
     *
     * @generated from protobuf field: envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig server_config = 2;
     */
    serverConfig?: DnsFilterConfig_ServerContextConfig;
    /**
     * Client context configuration controls Envoy's behavior when it must use external
     * resolvers to answer a query. This object is optional and if omitted instructs
     * the filter to resolve queries from the data in the server_config
     *
     * @generated from protobuf field: envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig client_config = 3;
     */
    clientConfig?: DnsFilterConfig_ClientContextConfig;
}
/**
 * This message contains the configuration for the DNS Filter operating
 * in a server context. This message will contain the virtual hosts and
 * associated addresses with which Envoy will respond to queries
 *
 * @generated from protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig
 */
export interface DnsFilterConfig_ServerContextConfig {
    /**
     * @generated from protobuf oneof: config_source
     */
    configSource: {
        oneofKind: "inlineDnsTable";
        /**
         * Load the configuration specified from the control plane
         *
         * @generated from protobuf field: envoy.data.dns.v3.DnsTable inline_dns_table = 1;
         */
        inlineDnsTable: DnsTable;
    } | {
        oneofKind: "externalDnsTable";
        /**
         * Seed the filter configuration from an external path. This source
         * is a yaml formatted file that contains the DnsTable driving Envoy's
         * responses to DNS queries
         *
         * @generated from protobuf field: envoy.config.core.v3.DataSource external_dns_table = 2;
         */
        externalDnsTable: DataSource;
    } | {
        oneofKind: undefined;
    };
}
/**
 * This message contains the configuration for the DNS Filter operating
 * in a client context. This message will contain the timeouts, retry,
 * and forwarding configuration for Envoy to make DNS requests to other
 * resolvers
 *
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig
 */
export interface DnsFilterConfig_ClientContextConfig {
    /**
     * Sets the maximum time we will wait for the upstream query to complete
     * We allow 5s for the upstream resolution to complete, so the minimum
     * value here is 1. Note that the total latency for a failed query is the
     * number of retries multiplied by the resolver_timeout.
     *
     * @generated from protobuf field: google.protobuf.Duration resolver_timeout = 1;
     */
    resolverTimeout?: Duration;
    /**
     * This field was used for `dns_resolution_config` in Envoy 1.19.0 and
     * 1.19.1.
     * Control planes that need to set this field for Envoy 1.19.0 and
     * 1.19.1 clients should fork the protobufs and change the field type
     * to `DnsResolutionConfig`.
     * Control planes that need to simultaneously support Envoy 1.18.x and
     * Envoy 1.19.x should avoid Envoy 1.19.0 and 1.19.1.
     *
     * [#not-implemented-hide:]
     *
     * @deprecated
     * @generated from protobuf field: repeated envoy.config.core.v3.Address upstream_resolvers = 2 [deprecated = true];
     */
    upstreamResolvers: Address[];
    /**
     * DNS resolution configuration which includes the underlying dns resolver addresses and options.
     * This field is deprecated in favor of
     * :ref:`typed_dns_resolver_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.typed_dns_resolver_config>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 5 [deprecated = true];
     */
    dnsResolutionConfig?: DnsResolutionConfig;
    /**
     * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
     * or any other DNS resolver types and the related parameters.
     * For example, an object of
     * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
     * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
     * :ref:`dns_resolution_config <envoy_v3_api_field_extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig.dns_resolution_config>`
     * configuration.
     * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
     * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
     * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
     * [#extension-category: envoy.network.dns_resolver]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 4;
     */
    typedDnsResolverConfig?: TypedExtensionConfig;
    /**
     * Controls how many outstanding external lookup contexts the filter tracks.
     * The context structure allows the filter to respond to every query even if the external
     * resolution times out or is otherwise unsuccessful
     *
     * @generated from protobuf field: uint64 max_pending_lookups = 3;
     */
    maxPendingLookups: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class DnsFilterConfig$Type extends MessageType<DnsFilterConfig> {
    constructor() {
        super("envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "server_config", kind: "message", T: () => DnsFilterConfig_ServerContextConfig },
            { no: 3, name: "client_config", kind: "message", T: () => DnsFilterConfig_ClientContextConfig }
        ]);
    }
    create(value?: PartialMessage<DnsFilterConfig>): DnsFilterConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<DnsFilterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DnsFilterConfig): DnsFilterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig server_config */ 2:
                    message.serverConfig = DnsFilterConfig_ServerContextConfig.internalBinaryRead(reader, reader.uint32(), options, message.serverConfig);
                    break;
                case /* envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig client_config */ 3:
                    message.clientConfig = DnsFilterConfig_ClientContextConfig.internalBinaryRead(reader, reader.uint32(), options, message.clientConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DnsFilterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig server_config = 2; */
        if (message.serverConfig)
            DnsFilterConfig_ServerContextConfig.internalBinaryWrite(message.serverConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig client_config = 3; */
        if (message.clientConfig)
            DnsFilterConfig_ClientContextConfig.internalBinaryWrite(message.clientConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig
 */
export const DnsFilterConfig = new DnsFilterConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DnsFilterConfig_ServerContextConfig$Type extends MessageType<DnsFilterConfig_ServerContextConfig> {
    constructor() {
        super("envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig", [
            { no: 1, name: "inline_dns_table", kind: "message", oneof: "configSource", T: () => DnsTable },
            { no: 2, name: "external_dns_table", kind: "message", oneof: "configSource", T: () => DataSource }
        ]);
    }
    create(value?: PartialMessage<DnsFilterConfig_ServerContextConfig>): DnsFilterConfig_ServerContextConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configSource = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DnsFilterConfig_ServerContextConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DnsFilterConfig_ServerContextConfig): DnsFilterConfig_ServerContextConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.data.dns.v3.DnsTable inline_dns_table */ 1:
                    message.configSource = {
                        oneofKind: "inlineDnsTable",
                        inlineDnsTable: DnsTable.internalBinaryRead(reader, reader.uint32(), options, (message.configSource as any).inlineDnsTable)
                    };
                    break;
                case /* envoy.config.core.v3.DataSource external_dns_table */ 2:
                    message.configSource = {
                        oneofKind: "externalDnsTable",
                        externalDnsTable: DataSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSource as any).externalDnsTable)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DnsFilterConfig_ServerContextConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.data.dns.v3.DnsTable inline_dns_table = 1; */
        if (message.configSource.oneofKind === "inlineDnsTable")
            DnsTable.internalBinaryWrite(message.configSource.inlineDnsTable, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DataSource external_dns_table = 2; */
        if (message.configSource.oneofKind === "externalDnsTable")
            DataSource.internalBinaryWrite(message.configSource.externalDnsTable, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ServerContextConfig
 */
export const DnsFilterConfig_ServerContextConfig = new DnsFilterConfig_ServerContextConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DnsFilterConfig_ClientContextConfig$Type extends MessageType<DnsFilterConfig_ClientContextConfig> {
    constructor() {
        super("envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig", [
            { no: 1, name: "resolver_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: { seconds: "1" } } } } },
            { no: 2, name: "upstream_resolvers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Address, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 5, name: "dns_resolution_config", kind: "message", T: () => DnsResolutionConfig, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "typed_dns_resolver_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 3, name: "max_pending_lookups", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "validate.rules": { uint64: { gte: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DnsFilterConfig_ClientContextConfig>): DnsFilterConfig_ClientContextConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upstreamResolvers = [];
        message.maxPendingLookups = 0n;
        if (value !== undefined)
            reflectionMergePartial<DnsFilterConfig_ClientContextConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DnsFilterConfig_ClientContextConfig): DnsFilterConfig_ClientContextConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration resolver_timeout */ 1:
                    message.resolverTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.resolverTimeout);
                    break;
                case /* repeated envoy.config.core.v3.Address upstream_resolvers = 2 [deprecated = true];*/ 2:
                    message.upstreamResolvers.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 5 [deprecated = true];*/ 5:
                    message.dnsResolutionConfig = DnsResolutionConfig.internalBinaryRead(reader, reader.uint32(), options, message.dnsResolutionConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config */ 4:
                    message.typedDnsResolverConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.typedDnsResolverConfig);
                    break;
                case /* uint64 max_pending_lookups */ 3:
                    message.maxPendingLookups = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DnsFilterConfig_ClientContextConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration resolver_timeout = 1; */
        if (message.resolverTimeout)
            Duration.internalBinaryWrite(message.resolverTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.Address upstream_resolvers = 2 [deprecated = true]; */
        for (let i = 0; i < message.upstreamResolvers.length; i++)
            Address.internalBinaryWrite(message.upstreamResolvers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 5 [deprecated = true]; */
        if (message.dnsResolutionConfig)
            DnsResolutionConfig.internalBinaryWrite(message.dnsResolutionConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 4; */
        if (message.typedDnsResolverConfig)
            TypedExtensionConfig.internalBinaryWrite(message.typedDnsResolverConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint64 max_pending_lookups = 3; */
        if (message.maxPendingLookups !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.maxPendingLookups);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.udp.dns_filter.v3.DnsFilterConfig.ClientContextConfig
 */
export const DnsFilterConfig_ClientContextConfig = new DnsFilterConfig_ClientContextConfig$Type();
