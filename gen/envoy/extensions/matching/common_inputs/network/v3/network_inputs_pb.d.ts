// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto (package envoy.extensions.matching.common_inputs.network.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Specifies that matching should be performed by the destination IP address.
 * [#extension: envoy.matching.inputs.destination_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput
 */
export declare class DestinationIPInput extends Message<DestinationIPInput> {
  constructor(data?: PartialMessage<DestinationIPInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.DestinationIPInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestinationIPInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestinationIPInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestinationIPInput;

  static equals(a: DestinationIPInput | PlainMessage<DestinationIPInput> | undefined, b: DestinationIPInput | PlainMessage<DestinationIPInput> | undefined): boolean;
}

/**
 * Specifies that matching should be performed by the destination port.
 * [#extension: envoy.matching.inputs.destination_port]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput
 */
export declare class DestinationPortInput extends Message<DestinationPortInput> {
  constructor(data?: PartialMessage<DestinationPortInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.DestinationPortInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DestinationPortInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DestinationPortInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DestinationPortInput;

  static equals(a: DestinationPortInput | PlainMessage<DestinationPortInput> | undefined, b: DestinationPortInput | PlainMessage<DestinationPortInput> | undefined): boolean;
}

/**
 * Specifies that matching should be performed by the source IP address.
 * [#extension: envoy.matching.inputs.source_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourceIPInput
 */
export declare class SourceIPInput extends Message<SourceIPInput> {
  constructor(data?: PartialMessage<SourceIPInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.SourceIPInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceIPInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceIPInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceIPInput;

  static equals(a: SourceIPInput | PlainMessage<SourceIPInput> | undefined, b: SourceIPInput | PlainMessage<SourceIPInput> | undefined): boolean;
}

/**
 * Specifies that matching should be performed by the source port.
 * [#extension: envoy.matching.inputs.source_port]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourcePortInput
 */
export declare class SourcePortInput extends Message<SourcePortInput> {
  constructor(data?: PartialMessage<SourcePortInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.SourcePortInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourcePortInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourcePortInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourcePortInput;

  static equals(a: SourcePortInput | PlainMessage<SourcePortInput> | undefined, b: SourcePortInput | PlainMessage<SourcePortInput> | undefined): boolean;
}

/**
 * Input that matches by the directly connected source IP address (this
 * will only be different from the source IP address when using a listener
 * filter that overrides the source address, such as the :ref:`Proxy Protocol
 * listener filter <config_listener_filters_proxy_protocol>`).
 * [#extension: envoy.matching.inputs.direct_source_ip]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput
 */
export declare class DirectSourceIPInput extends Message<DirectSourceIPInput> {
  constructor(data?: PartialMessage<DirectSourceIPInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.DirectSourceIPInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectSourceIPInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectSourceIPInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectSourceIPInput;

  static equals(a: DirectSourceIPInput | PlainMessage<DirectSourceIPInput> | undefined, b: DirectSourceIPInput | PlainMessage<DirectSourceIPInput> | undefined): boolean;
}

/**
 * Input that matches by the source IP type.
 * Specifies the source IP match type. The values include:
 *
 * * ``local`` - matches a connection originating from the same host,
 * [#extension: envoy.matching.inputs.source_type]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput
 */
export declare class SourceTypeInput extends Message<SourceTypeInput> {
  constructor(data?: PartialMessage<SourceTypeInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.SourceTypeInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceTypeInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceTypeInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceTypeInput;

  static equals(a: SourceTypeInput | PlainMessage<SourceTypeInput> | undefined, b: SourceTypeInput | PlainMessage<SourceTypeInput> | undefined): boolean;
}

/**
 * Input that matches by the requested server name (e.g. SNI in TLS).
 *
 * :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides the requested server name based on SNI,
 * when TLS protocol is detected.
 * [#extension: envoy.matching.inputs.server_name]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.ServerNameInput
 */
export declare class ServerNameInput extends Message<ServerNameInput> {
  constructor(data?: PartialMessage<ServerNameInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.ServerNameInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerNameInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerNameInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerNameInput;

  static equals(a: ServerNameInput | PlainMessage<ServerNameInput> | undefined, b: ServerNameInput | PlainMessage<ServerNameInput> | undefined): boolean;
}

/**
 * Input that matches by the transport protocol.
 *
 * Suggested values include:
 *
 * * ``raw_buffer`` - default, used when no transport protocol is detected,
 * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
 *   when TLS protocol is detected.
 * [#extension: envoy.matching.inputs.transport_protocol]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput
 */
export declare class TransportProtocolInput extends Message<TransportProtocolInput> {
  constructor(data?: PartialMessage<TransportProtocolInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.TransportProtocolInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransportProtocolInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransportProtocolInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransportProtocolInput;

  static equals(a: TransportProtocolInput | PlainMessage<TransportProtocolInput> | undefined, b: TransportProtocolInput | PlainMessage<TransportProtocolInput> | undefined): boolean;
}

/**
 * List of quoted and comma-separated requested application protocols. The list consists of a
 * single negotiated application protocol once the network stream is established.
 *
 * Examples:
 *
 * * ``'h2','http/1.1'``
 * * ``'h2c'``
 *
 * Suggested values in the list include:
 *
 * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
 *   <config_listener_filters_tls_inspector>` and :ref:`envoy.filters.listener.http_inspector
 *   <config_listener_filters_http_inspector>`,
 * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
 * * ``h2c`` - set by :ref:`envoy.filters.listener.http_inspector <config_listener_filters_http_inspector>`
 *
 * .. attention::
 *
 *   Currently, :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
 *   application protocol detection based on the requested
 *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
 *
 *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
 *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
 *   unless all connecting clients are known to use ALPN.
 * [#extension: envoy.matching.inputs.application_protocol]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput
 */
export declare class ApplicationProtocolInput extends Message<ApplicationProtocolInput> {
  constructor(data?: PartialMessage<ApplicationProtocolInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationProtocolInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationProtocolInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationProtocolInput;

  static equals(a: ApplicationProtocolInput | PlainMessage<ApplicationProtocolInput> | undefined, b: ApplicationProtocolInput | PlainMessage<ApplicationProtocolInput> | undefined): boolean;
}

/**
 * Input that matches by a specific filter state key.
 * The value of the provided filter state key will be the raw string representation of the filter state object
 * [#extension: envoy.matching.inputs.filter_state]
 *
 * @generated from message envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
 */
export declare class FilterStateInput extends Message<FilterStateInput> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  constructor(data?: PartialMessage<FilterStateInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.common_inputs.network.v3.FilterStateInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterStateInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterStateInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterStateInput;

  static equals(a: FilterStateInput | PlainMessage<FilterStateInput> | undefined, b: FilterStateInput | PlainMessage<FilterStateInput> | undefined): boolean;
}

