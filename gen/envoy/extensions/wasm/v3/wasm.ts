// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/extensions/wasm/v3/wasm.proto" (package "envoy.extensions.wasm.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../../google/protobuf/any";
import { AsyncDataSource } from "../../../config/core/v3/base";
// [#protodoc-title: Wasm]
// [#extension: envoy.bootstrap.wasm]

/**
 * Configuration for restricting Proxy-Wasm capabilities available to modules.
 *
 * @generated from protobuf message envoy.extensions.wasm.v3.CapabilityRestrictionConfig
 */
export interface CapabilityRestrictionConfig {
    /**
     * The Proxy-Wasm capabilities which will be allowed. Capabilities are mapped by
     * name. The ``SanitizationConfig`` which each capability maps to is currently unimplemented and ignored,
     * and so should be left empty.
     *
     * The capability names are given in the
     * `Proxy-Wasm ABI <https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT>`_.
     * Additionally, the following WASI capabilities from
     * `this list <https://github.com/WebAssembly/WASI/blob/master/phases/snapshot/docs.md#modules>`_
     * are implemented and can be allowed:
     * ``fd_write``, ``fd_read``, ``fd_seek``, ``fd_close``, ``fd_fdstat_get``, ``environ_get``, ``environ_sizes_get``,
     * ``args_get``, ``args_sizes_get``, ``proc_exit``, ``clock_time_get``, ``random_get``.
     *
     * @generated from protobuf field: map<string, envoy.extensions.wasm.v3.SanitizationConfig> allowed_capabilities = 1;
     */
    allowedCapabilities: {
        [key: string]: SanitizationConfig;
    };
}
/**
 * Configuration for sanitization of inputs to an allowed capability.
 *
 * NOTE: This is currently unimplemented.
 *
 * @generated from protobuf message envoy.extensions.wasm.v3.SanitizationConfig
 */
export interface SanitizationConfig {
}
/**
 * Configuration for a Wasm VM.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.extensions.wasm.v3.VmConfig
 */
export interface VmConfig {
    /**
     * An ID which will be used along with a hash of the wasm code (or the name of the registered Null
     * VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
     * ``vm_id`` and code will use the same VM. May be left blank. Sharing a VM between plugins can
     * reduce memory utilization and make sharing of data easier which may have security implications.
     * [#comment: TODO: add ref for details.]
     *
     * @generated from protobuf field: string vm_id = 1;
     */
    vmId: string;
    /**
     * The Wasm runtime type, defaults to the first available Wasm engine used at Envoy build-time.
     * The priority to search for the available engine is: v8 -> wasmtime -> wamr -> wavm.
     * Available Wasm runtime types are registered as extensions. The following runtimes are included
     * in Envoy code base:
     *
     * .. _extension_envoy.wasm.runtime.null:
     *
     * **envoy.wasm.runtime.null**: Null sandbox, the Wasm module must be compiled and linked into the
     * Envoy binary. The registered name is given in the ``code`` field as ``inline_string``.
     *
     * .. _extension_envoy.wasm.runtime.v8:
     *
     * **envoy.wasm.runtime.v8**: `V8 <https://v8.dev/>`_-based WebAssembly runtime.
     *
     * .. _extension_envoy.wasm.runtime.wamr:
     *
     * **envoy.wasm.runtime.wamr**: `WAMR <https://github.com/bytecodealliance/wasm-micro-runtime/>`_-based WebAssembly runtime.
     * This runtime is not enabled in the official build.
     *
     * .. _extension_envoy.wasm.runtime.wavm:
     *
     * **envoy.wasm.runtime.wavm**: `WAVM <https://wavm.github.io/>`_-based WebAssembly runtime.
     * This runtime is not enabled in the official build.
     *
     * .. _extension_envoy.wasm.runtime.wasmtime:
     *
     * **envoy.wasm.runtime.wasmtime**: `Wasmtime <https://wasmtime.dev/>`_-based WebAssembly runtime.
     * This runtime is not enabled in the official build.
     *
     * [#extension-category: envoy.wasm.runtime]
     *
     * @generated from protobuf field: string runtime = 2;
     */
    runtime: string;
    /**
     * The Wasm code that Envoy will execute.
     *
     * @generated from protobuf field: envoy.config.core.v3.AsyncDataSource code = 3;
     */
    code?: AsyncDataSource;
    /**
     * The Wasm configuration used in initialization of a new VM
     * (proxy_on_start). ``google.protobuf.Struct`` is serialized as JSON before
     * passing it to the plugin. ``google.protobuf.BytesValue`` and
     * ``google.protobuf.StringValue`` are passed directly without the wrapper.
     *
     * @generated from protobuf field: google.protobuf.Any configuration = 4;
     */
    configuration?: Any;
    /**
     * Allow the wasm file to include pre-compiled code on VMs which support it.
     * Warning: this should only be enable for trusted sources as the precompiled code is not
     * verified.
     *
     * @generated from protobuf field: bool allow_precompiled = 5;
     */
    allowPrecompiled: boolean;
    /**
     * If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
     * update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
     * warming state.
     *
     * @generated from protobuf field: bool nack_on_code_cache_miss = 6;
     */
    nackOnCodeCacheMiss: boolean;
    /**
     * Specifies environment variables to be injected to this VM which will be available through
     * WASI's ``environ_get`` and ``environ_get_sizes`` system calls. Note that these functions are mostly implicitly
     * called in your language's standard library, so you do not need to call them directly and you can access to env
     * vars just like when you do on native platforms.
     * Warning: Envoy rejects the configuration if there's conflict of key space.
     *
     * @generated from protobuf field: envoy.extensions.wasm.v3.EnvironmentVariables environment_variables = 7;
     */
    environmentVariables?: EnvironmentVariables;
}
/**
 * @generated from protobuf message envoy.extensions.wasm.v3.EnvironmentVariables
 */
export interface EnvironmentVariables {
    /**
     * The keys of *Envoy's* environment variables exposed to this VM. In other words, if a key exists in Envoy's environment
     * variables, then that key-value pair will be injected. Note that if a key does not exist, it will be ignored.
     *
     * @generated from protobuf field: repeated string host_env_keys = 1;
     */
    hostEnvKeys: string[];
    /**
     * Explicitly given key-value pairs to be injected to this VM in the form of "KEY=VALUE".
     *
     * @generated from protobuf field: map<string, string> key_values = 2;
     */
    keyValues: {
        [key: string]: string;
    };
}
/**
 * Base Configuration for Wasm Plugins e.g. filters and services.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.extensions.wasm.v3.PluginConfig
 */
export interface PluginConfig {
    /**
     * A unique name for a filters/services in a VM for use in identifying the filter/service if
     * multiple filters/services are handled by the same ``vm_id`` and ``root_id`` and for
     * logging/debugging.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
     * if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
     * filters/services with a blank root_id with the same ``vm_id`` will share Context(s).
     *
     * @generated from protobuf field: string root_id = 2;
     */
    rootId: string;
    /**
     * @generated from protobuf oneof: vm
     */
    vm: {
        oneofKind: "vmConfig";
        /**
         * @generated from protobuf field: envoy.extensions.wasm.v3.VmConfig vm_config = 3;
         */
        vmConfig: VmConfig; // TODO: add referential VM configurations.
    } | {
        oneofKind: undefined;
    };
    /**
     * Filter/service configuration used to configure or reconfigure a plugin
     * (``proxy_on_configure``).
     * ``google.protobuf.Struct`` is serialized as JSON before
     * passing it to the plugin. ``google.protobuf.BytesValue`` and
     * ``google.protobuf.StringValue`` are passed directly without the wrapper.
     *
     * @generated from protobuf field: google.protobuf.Any configuration = 4;
     */
    configuration?: Any;
    /**
     * If there is a fatal error on the VM (e.g. exception, abort(), on_start or on_configure return false),
     * then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
     * or fail open (if 'fail_open' is set to true) by bypassing the filter. Note: when on_start or on_configure return false
     * during xDS updates the xDS configuration will be rejected and when on_start or on_configuration return false on initial
     * startup the proxy will not start.
     *
     * @generated from protobuf field: bool fail_open = 5;
     */
    failOpen: boolean;
    /**
     * Configuration for restricting Proxy-Wasm capabilities available to modules.
     *
     * @generated from protobuf field: envoy.extensions.wasm.v3.CapabilityRestrictionConfig capability_restriction_config = 6;
     */
    capabilityRestrictionConfig?: CapabilityRestrictionConfig;
}
/**
 * WasmService is configured as a built-in ``envoy.wasm_service`` :ref:`WasmService
 * <config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
 *
 * @generated from protobuf message envoy.extensions.wasm.v3.WasmService
 */
export interface WasmService {
    /**
     * General plugin configuration.
     *
     * @generated from protobuf field: envoy.extensions.wasm.v3.PluginConfig config = 1;
     */
    config?: PluginConfig;
    /**
     * If true, create a single VM rather than creating one VM per worker. Such a singleton can
     * not be used with filters.
     *
     * @generated from protobuf field: bool singleton = 2;
     */
    singleton: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class CapabilityRestrictionConfig$Type extends MessageType<CapabilityRestrictionConfig> {
    constructor() {
        super("envoy.extensions.wasm.v3.CapabilityRestrictionConfig", [
            { no: 1, name: "allowed_capabilities", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SanitizationConfig } }
        ]);
    }
    create(value?: PartialMessage<CapabilityRestrictionConfig>): CapabilityRestrictionConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedCapabilities = {};
        if (value !== undefined)
            reflectionMergePartial<CapabilityRestrictionConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CapabilityRestrictionConfig): CapabilityRestrictionConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, envoy.extensions.wasm.v3.SanitizationConfig> allowed_capabilities */ 1:
                    this.binaryReadMap1(message.allowedCapabilities, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CapabilityRestrictionConfig["allowedCapabilities"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CapabilityRestrictionConfig["allowedCapabilities"] | undefined, val: CapabilityRestrictionConfig["allowedCapabilities"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SanitizationConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.wasm.v3.CapabilityRestrictionConfig.allowed_capabilities");
            }
        }
        map[key ?? ""] = val ?? SanitizationConfig.create();
    }
    internalBinaryWrite(message: CapabilityRestrictionConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, envoy.extensions.wasm.v3.SanitizationConfig> allowed_capabilities = 1; */
        for (let k of globalThis.Object.keys(message.allowedCapabilities)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SanitizationConfig.internalBinaryWrite(message.allowedCapabilities[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.CapabilityRestrictionConfig
 */
export const CapabilityRestrictionConfig = new CapabilityRestrictionConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SanitizationConfig$Type extends MessageType<SanitizationConfig> {
    constructor() {
        super("envoy.extensions.wasm.v3.SanitizationConfig", []);
    }
    create(value?: PartialMessage<SanitizationConfig>): SanitizationConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SanitizationConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SanitizationConfig): SanitizationConfig {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SanitizationConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.SanitizationConfig
 */
export const SanitizationConfig = new SanitizationConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VmConfig$Type extends MessageType<VmConfig> {
    constructor() {
        super("envoy.extensions.wasm.v3.VmConfig", [
            { no: 1, name: "vm_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "message", T: () => AsyncDataSource },
            { no: 4, name: "configuration", kind: "message", T: () => Any },
            { no: 5, name: "allow_precompiled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "nack_on_code_cache_miss", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "environment_variables", kind: "message", T: () => EnvironmentVariables }
        ]);
    }
    create(value?: PartialMessage<VmConfig>): VmConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vmId = "";
        message.runtime = "";
        message.allowPrecompiled = false;
        message.nackOnCodeCacheMiss = false;
        if (value !== undefined)
            reflectionMergePartial<VmConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VmConfig): VmConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string vm_id */ 1:
                    message.vmId = reader.string();
                    break;
                case /* string runtime */ 2:
                    message.runtime = reader.string();
                    break;
                case /* envoy.config.core.v3.AsyncDataSource code */ 3:
                    message.code = AsyncDataSource.internalBinaryRead(reader, reader.uint32(), options, message.code);
                    break;
                case /* google.protobuf.Any configuration */ 4:
                    message.configuration = Any.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* bool allow_precompiled */ 5:
                    message.allowPrecompiled = reader.bool();
                    break;
                case /* bool nack_on_code_cache_miss */ 6:
                    message.nackOnCodeCacheMiss = reader.bool();
                    break;
                case /* envoy.extensions.wasm.v3.EnvironmentVariables environment_variables */ 7:
                    message.environmentVariables = EnvironmentVariables.internalBinaryRead(reader, reader.uint32(), options, message.environmentVariables);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VmConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string vm_id = 1; */
        if (message.vmId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.vmId);
        /* string runtime = 2; */
        if (message.runtime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtime);
        /* envoy.config.core.v3.AsyncDataSource code = 3; */
        if (message.code)
            AsyncDataSource.internalBinaryWrite(message.code, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any configuration = 4; */
        if (message.configuration)
            Any.internalBinaryWrite(message.configuration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_precompiled = 5; */
        if (message.allowPrecompiled !== false)
            writer.tag(5, WireType.Varint).bool(message.allowPrecompiled);
        /* bool nack_on_code_cache_miss = 6; */
        if (message.nackOnCodeCacheMiss !== false)
            writer.tag(6, WireType.Varint).bool(message.nackOnCodeCacheMiss);
        /* envoy.extensions.wasm.v3.EnvironmentVariables environment_variables = 7; */
        if (message.environmentVariables)
            EnvironmentVariables.internalBinaryWrite(message.environmentVariables, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.VmConfig
 */
export const VmConfig = new VmConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnvironmentVariables$Type extends MessageType<EnvironmentVariables> {
    constructor() {
        super("envoy.extensions.wasm.v3.EnvironmentVariables", [
            { no: 1, name: "host_env_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<EnvironmentVariables>): EnvironmentVariables {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostEnvKeys = [];
        message.keyValues = {};
        if (value !== undefined)
            reflectionMergePartial<EnvironmentVariables>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnvironmentVariables): EnvironmentVariables {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string host_env_keys */ 1:
                    message.hostEnvKeys.push(reader.string());
                    break;
                case /* map<string, string> key_values */ 2:
                    this.binaryReadMap2(message.keyValues, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: EnvironmentVariables["keyValues"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EnvironmentVariables["keyValues"] | undefined, val: EnvironmentVariables["keyValues"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.extensions.wasm.v3.EnvironmentVariables.key_values");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: EnvironmentVariables, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string host_env_keys = 1; */
        for (let i = 0; i < message.hostEnvKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.hostEnvKeys[i]);
        /* map<string, string> key_values = 2; */
        for (let k of globalThis.Object.keys(message.keyValues))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.keyValues[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.EnvironmentVariables
 */
export const EnvironmentVariables = new EnvironmentVariables$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginConfig$Type extends MessageType<PluginConfig> {
    constructor() {
        super("envoy.extensions.wasm.v3.PluginConfig", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "root_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "vm_config", kind: "message", oneof: "vm", T: () => VmConfig },
            { no: 4, name: "configuration", kind: "message", T: () => Any },
            { no: 5, name: "fail_open", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "capability_restriction_config", kind: "message", T: () => CapabilityRestrictionConfig }
        ]);
    }
    create(value?: PartialMessage<PluginConfig>): PluginConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.rootId = "";
        message.vm = { oneofKind: undefined };
        message.failOpen = false;
        if (value !== undefined)
            reflectionMergePartial<PluginConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginConfig): PluginConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string root_id */ 2:
                    message.rootId = reader.string();
                    break;
                case /* envoy.extensions.wasm.v3.VmConfig vm_config */ 3:
                    message.vm = {
                        oneofKind: "vmConfig",
                        vmConfig: VmConfig.internalBinaryRead(reader, reader.uint32(), options, (message.vm as any).vmConfig)
                    };
                    break;
                case /* google.protobuf.Any configuration */ 4:
                    message.configuration = Any.internalBinaryRead(reader, reader.uint32(), options, message.configuration);
                    break;
                case /* bool fail_open */ 5:
                    message.failOpen = reader.bool();
                    break;
                case /* envoy.extensions.wasm.v3.CapabilityRestrictionConfig capability_restriction_config */ 6:
                    message.capabilityRestrictionConfig = CapabilityRestrictionConfig.internalBinaryRead(reader, reader.uint32(), options, message.capabilityRestrictionConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string root_id = 2; */
        if (message.rootId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.rootId);
        /* envoy.extensions.wasm.v3.VmConfig vm_config = 3; */
        if (message.vm.oneofKind === "vmConfig")
            VmConfig.internalBinaryWrite(message.vm.vmConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any configuration = 4; */
        if (message.configuration)
            Any.internalBinaryWrite(message.configuration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool fail_open = 5; */
        if (message.failOpen !== false)
            writer.tag(5, WireType.Varint).bool(message.failOpen);
        /* envoy.extensions.wasm.v3.CapabilityRestrictionConfig capability_restriction_config = 6; */
        if (message.capabilityRestrictionConfig)
            CapabilityRestrictionConfig.internalBinaryWrite(message.capabilityRestrictionConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.PluginConfig
 */
export const PluginConfig = new PluginConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WasmService$Type extends MessageType<WasmService> {
    constructor() {
        super("envoy.extensions.wasm.v3.WasmService", [
            { no: 1, name: "config", kind: "message", T: () => PluginConfig },
            { no: 2, name: "singleton", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<WasmService>): WasmService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.singleton = false;
        if (value !== undefined)
            reflectionMergePartial<WasmService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WasmService): WasmService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.extensions.wasm.v3.PluginConfig config */ 1:
                    message.config = PluginConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* bool singleton */ 2:
                    message.singleton = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WasmService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.extensions.wasm.v3.PluginConfig config = 1; */
        if (message.config)
            PluginConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool singleton = 2; */
        if (message.singleton !== false)
            writer.tag(2, WireType.Varint).bool(message.singleton);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.wasm.v3.WasmService
 */
export const WasmService = new WasmService$Type();
