// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/status/v2/csds.proto" (package "envoy.service.status.v2", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Node } from "../../../api/v2/core/base";
import { ScopedRoutesConfigDump } from "../../../admin/v2alpha/config_dump";
import { RoutesConfigDump } from "../../../admin/v2alpha/config_dump";
import { ClustersConfigDump } from "../../../admin/v2alpha/config_dump";
import { ListenersConfigDump } from "../../../admin/v2alpha/config_dump";
import { NodeMatcher } from "../../../type/matcher/node";
/**
 * Request for client status of clients identified by a list of NodeMatchers.
 *
 * @generated from protobuf message envoy.service.status.v2.ClientStatusRequest
 */
export interface ClientStatusRequest {
    /**
     * Management server can use these match criteria to identify clients.
     * The match follows OR semantics.
     *
     * @generated from protobuf field: repeated envoy.type.matcher.NodeMatcher node_matchers = 1;
     */
    nodeMatchers: NodeMatcher[];
}
/**
 * Detailed config (per xDS) with status.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.service.status.v2.PerXdsConfig
 */
export interface PerXdsConfig {
    /**
     * @generated from protobuf field: envoy.service.status.v2.ConfigStatus status = 1;
     */
    status: ConfigStatus;
    /**
     * @generated from protobuf oneof: per_xds_config
     */
    perXdsConfig: {
        oneofKind: "listenerConfig";
        /**
         * @generated from protobuf field: envoy.admin.v2alpha.ListenersConfigDump listener_config = 2;
         */
        listenerConfig: ListenersConfigDump;
    } | {
        oneofKind: "clusterConfig";
        /**
         * @generated from protobuf field: envoy.admin.v2alpha.ClustersConfigDump cluster_config = 3;
         */
        clusterConfig: ClustersConfigDump;
    } | {
        oneofKind: "routeConfig";
        /**
         * @generated from protobuf field: envoy.admin.v2alpha.RoutesConfigDump route_config = 4;
         */
        routeConfig: RoutesConfigDump;
    } | {
        oneofKind: "scopedRouteConfig";
        /**
         * @generated from protobuf field: envoy.admin.v2alpha.ScopedRoutesConfigDump scoped_route_config = 5;
         */
        scopedRouteConfig: ScopedRoutesConfigDump;
    } | {
        oneofKind: undefined;
    };
}
/**
 * All xds configs for a particular client.
 *
 * @generated from protobuf message envoy.service.status.v2.ClientConfig
 */
export interface ClientConfig {
    /**
     * Node for a particular client.
     *
     * @generated from protobuf field: envoy.api.v2.core.Node node = 1;
     */
    node?: Node;
    /**
     * @generated from protobuf field: repeated envoy.service.status.v2.PerXdsConfig xds_config = 2;
     */
    xdsConfig: PerXdsConfig[];
}
/**
 * @generated from protobuf message envoy.service.status.v2.ClientStatusResponse
 */
export interface ClientStatusResponse {
    /**
     * Client configs for the clients specified in the ClientStatusRequest.
     *
     * @generated from protobuf field: repeated envoy.service.status.v2.ClientConfig config = 1;
     */
    config: ClientConfig[];
}
/**
 * Status of a config.
 *
 * @generated from protobuf enum envoy.service.status.v2.ConfigStatus
 */
export enum ConfigStatus {
    /**
     * Status info is not available/unknown.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Management server has sent the config to client and received ACK.
     *
     * @generated from protobuf enum value: SYNCED = 1;
     */
    SYNCED = 1,
    /**
     * Config is not sent.
     *
     * @generated from protobuf enum value: NOT_SENT = 2;
     */
    NOT_SENT = 2,
    /**
     * Management server has sent the config to client but hasnâ€™t received
     * ACK/NACK.
     *
     * @generated from protobuf enum value: STALE = 3;
     */
    STALE = 3,
    /**
     * Management server has sent the config to client but received NACK.
     *
     * @generated from protobuf enum value: ERROR = 4;
     */
    ERROR = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class ClientStatusRequest$Type extends MessageType<ClientStatusRequest> {
    constructor() {
        super("envoy.service.status.v2.ClientStatusRequest", [
            { no: 1, name: "node_matchers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NodeMatcher }
        ]);
    }
    create(value?: PartialMessage<ClientStatusRequest>): ClientStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeMatchers = [];
        if (value !== undefined)
            reflectionMergePartial<ClientStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientStatusRequest): ClientStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.type.matcher.NodeMatcher node_matchers */ 1:
                    message.nodeMatchers.push(NodeMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.type.matcher.NodeMatcher node_matchers = 1; */
        for (let i = 0; i < message.nodeMatchers.length; i++)
            NodeMatcher.internalBinaryWrite(message.nodeMatchers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.status.v2.ClientStatusRequest
 */
export const ClientStatusRequest = new ClientStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PerXdsConfig$Type extends MessageType<PerXdsConfig> {
    constructor() {
        super("envoy.service.status.v2.PerXdsConfig", [
            { no: 1, name: "status", kind: "enum", T: () => ["envoy.service.status.v2.ConfigStatus", ConfigStatus] },
            { no: 2, name: "listener_config", kind: "message", oneof: "perXdsConfig", T: () => ListenersConfigDump },
            { no: 3, name: "cluster_config", kind: "message", oneof: "perXdsConfig", T: () => ClustersConfigDump },
            { no: 4, name: "route_config", kind: "message", oneof: "perXdsConfig", T: () => RoutesConfigDump },
            { no: 5, name: "scoped_route_config", kind: "message", oneof: "perXdsConfig", T: () => ScopedRoutesConfigDump }
        ]);
    }
    create(value?: PartialMessage<PerXdsConfig>): PerXdsConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.perXdsConfig = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PerXdsConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PerXdsConfig): PerXdsConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.status.v2.ConfigStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* envoy.admin.v2alpha.ListenersConfigDump listener_config */ 2:
                    message.perXdsConfig = {
                        oneofKind: "listenerConfig",
                        listenerConfig: ListenersConfigDump.internalBinaryRead(reader, reader.uint32(), options, (message.perXdsConfig as any).listenerConfig)
                    };
                    break;
                case /* envoy.admin.v2alpha.ClustersConfigDump cluster_config */ 3:
                    message.perXdsConfig = {
                        oneofKind: "clusterConfig",
                        clusterConfig: ClustersConfigDump.internalBinaryRead(reader, reader.uint32(), options, (message.perXdsConfig as any).clusterConfig)
                    };
                    break;
                case /* envoy.admin.v2alpha.RoutesConfigDump route_config */ 4:
                    message.perXdsConfig = {
                        oneofKind: "routeConfig",
                        routeConfig: RoutesConfigDump.internalBinaryRead(reader, reader.uint32(), options, (message.perXdsConfig as any).routeConfig)
                    };
                    break;
                case /* envoy.admin.v2alpha.ScopedRoutesConfigDump scoped_route_config */ 5:
                    message.perXdsConfig = {
                        oneofKind: "scopedRouteConfig",
                        scopedRouteConfig: ScopedRoutesConfigDump.internalBinaryRead(reader, reader.uint32(), options, (message.perXdsConfig as any).scopedRouteConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PerXdsConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.status.v2.ConfigStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* envoy.admin.v2alpha.ListenersConfigDump listener_config = 2; */
        if (message.perXdsConfig.oneofKind === "listenerConfig")
            ListenersConfigDump.internalBinaryWrite(message.perXdsConfig.listenerConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.ClustersConfigDump cluster_config = 3; */
        if (message.perXdsConfig.oneofKind === "clusterConfig")
            ClustersConfigDump.internalBinaryWrite(message.perXdsConfig.clusterConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.RoutesConfigDump route_config = 4; */
        if (message.perXdsConfig.oneofKind === "routeConfig")
            RoutesConfigDump.internalBinaryWrite(message.perXdsConfig.routeConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.ScopedRoutesConfigDump scoped_route_config = 5; */
        if (message.perXdsConfig.oneofKind === "scopedRouteConfig")
            ScopedRoutesConfigDump.internalBinaryWrite(message.perXdsConfig.scopedRouteConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.status.v2.PerXdsConfig
 */
export const PerXdsConfig = new PerXdsConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientConfig$Type extends MessageType<ClientConfig> {
    constructor() {
        super("envoy.service.status.v2.ClientConfig", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "xds_config", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PerXdsConfig }
        ]);
    }
    create(value?: PartialMessage<ClientConfig>): ClientConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.xdsConfig = [];
        if (value !== undefined)
            reflectionMergePartial<ClientConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientConfig): ClientConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* repeated envoy.service.status.v2.PerXdsConfig xds_config */ 2:
                    message.xdsConfig.push(PerXdsConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.status.v2.PerXdsConfig xds_config = 2; */
        for (let i = 0; i < message.xdsConfig.length; i++)
            PerXdsConfig.internalBinaryWrite(message.xdsConfig[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.status.v2.ClientConfig
 */
export const ClientConfig = new ClientConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientStatusResponse$Type extends MessageType<ClientStatusResponse> {
    constructor() {
        super("envoy.service.status.v2.ClientStatusResponse", [
            { no: 1, name: "config", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClientConfig }
        ]);
    }
    create(value?: PartialMessage<ClientStatusResponse>): ClientStatusResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.config = [];
        if (value !== undefined)
            reflectionMergePartial<ClientStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientStatusResponse): ClientStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.status.v2.ClientConfig config */ 1:
                    message.config.push(ClientConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.status.v2.ClientConfig config = 1; */
        for (let i = 0; i < message.config.length; i++)
            ClientConfig.internalBinaryWrite(message.config[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.status.v2.ClientStatusResponse
 */
export const ClientStatusResponse = new ClientStatusResponse$Type();
/**
 * @generated ServiceType for protobuf service envoy.service.status.v2.ClientStatusDiscoveryService
 */
export const ClientStatusDiscoveryService = new ServiceType("envoy.service.status.v2.ClientStatusDiscoveryService", [
    { name: "StreamClientStatus", serverStreaming: true, clientStreaming: true, options: {}, I: ClientStatusRequest, O: ClientStatusResponse },
    { name: "FetchClientStatus", options: { "google.api.http": { post: "/v2/discovery:client_status", body: "*" } }, I: ClientStatusRequest, O: ClientStatusResponse }
]);
