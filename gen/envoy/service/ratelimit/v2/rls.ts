// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/ratelimit/v2/rls.proto" (package "envoy.service.ratelimit.v2", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderValue } from "../../../api/v2/core/base";
import { RateLimitDescriptor } from "../../../api/v2/ratelimit/ratelimit";
/**
 * Main message for a rate limit request. The rate limit service is designed to be fully generic
 * in the sense that it can operate on arbitrary hierarchical key/value pairs. The loaded
 * configuration will parse the request and find the most specific limit to apply. In addition,
 * a RateLimitRequest can contain multiple "descriptors" to limit on. When multiple descriptors
 * are provided, the server will limit on *ALL* of them and return an OVER_LIMIT response if any
 * of them are over limit. This enables more complex application level rate limiting scenarios
 * if desired.
 *
 * @generated from protobuf message envoy.service.ratelimit.v2.RateLimitRequest
 */
export interface RateLimitRequest {
    /**
     * All rate limit requests must specify a domain. This enables the configuration to be per
     * application without fear of overlap. E.g., "envoy".
     *
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
    /**
     * All rate limit requests must specify at least one RateLimitDescriptor. Each descriptor is
     * processed by the service (see below). If any of the descriptors are over limit, the entire
     * request is considered to be over limit.
     *
     * @generated from protobuf field: repeated envoy.api.v2.ratelimit.RateLimitDescriptor descriptors = 2;
     */
    descriptors: RateLimitDescriptor[];
    /**
     * Rate limit requests can optionally specify the number of hits a request adds to the matched
     * limit. If the value is not set in the message, a request increases the matched limit by 1.
     *
     * @generated from protobuf field: uint32 hits_addend = 3;
     */
    hitsAddend: number;
}
/**
 * A response from a ShouldRateLimit call.
 *
 * @generated from protobuf message envoy.service.ratelimit.v2.RateLimitResponse
 */
export interface RateLimitResponse {
    /**
     * The overall response code which takes into account all of the descriptors that were passed
     * in the RateLimitRequest message.
     *
     * @generated from protobuf field: envoy.service.ratelimit.v2.RateLimitResponse.Code overall_code = 1;
     */
    overallCode: RateLimitResponse_Code;
    /**
     * A list of DescriptorStatus messages which matches the length of the descriptor list passed
     * in the RateLimitRequest. This can be used by the caller to determine which individual
     * descriptors failed and/or what the currently configured limits are for all of them.
     *
     * @generated from protobuf field: repeated envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus statuses = 2;
     */
    statuses: RateLimitResponse_DescriptorStatus[];
    /**
     * A list of headers to add to the response
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValue headers = 3;
     */
    headers: HeaderValue[];
    /**
     * A list of headers to add to the request when forwarded
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValue request_headers_to_add = 4;
     */
    requestHeadersToAdd: HeaderValue[];
}
/**
 * Defines an actual rate limit in terms of requests per unit of time and the unit itself.
 *
 * @generated from protobuf message envoy.service.ratelimit.v2.RateLimitResponse.RateLimit
 */
export interface RateLimitResponse_RateLimit {
    /**
     * A name or description of this limit.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * The number of requests per unit of time.
     *
     * @generated from protobuf field: uint32 requests_per_unit = 1;
     */
    requestsPerUnit: number;
    /**
     * The unit of time.
     *
     * @generated from protobuf field: envoy.service.ratelimit.v2.RateLimitResponse.RateLimit.Unit unit = 2;
     */
    unit: RateLimitResponse_RateLimit_Unit;
}
/**
 * @generated from protobuf enum envoy.service.ratelimit.v2.RateLimitResponse.RateLimit.Unit
 */
export enum RateLimitResponse_RateLimit_Unit {
    /**
     * The time unit is not known.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * The time unit representing a second.
     *
     * @generated from protobuf enum value: SECOND = 1;
     */
    SECOND = 1,
    /**
     * The time unit representing a minute.
     *
     * @generated from protobuf enum value: MINUTE = 2;
     */
    MINUTE = 2,
    /**
     * The time unit representing an hour.
     *
     * @generated from protobuf enum value: HOUR = 3;
     */
    HOUR = 3,
    /**
     * The time unit representing a day.
     *
     * @generated from protobuf enum value: DAY = 4;
     */
    DAY = 4
}
/**
 * @generated from protobuf message envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus
 */
export interface RateLimitResponse_DescriptorStatus {
    /**
     * The response code for an individual descriptor.
     *
     * @generated from protobuf field: envoy.service.ratelimit.v2.RateLimitResponse.Code code = 1;
     */
    code: RateLimitResponse_Code;
    /**
     * The current limit as configured by the server. Useful for debugging, etc.
     *
     * @generated from protobuf field: envoy.service.ratelimit.v2.RateLimitResponse.RateLimit current_limit = 2;
     */
    currentLimit?: RateLimitResponse_RateLimit;
    /**
     * The limit remaining in the current time unit.
     *
     * @generated from protobuf field: uint32 limit_remaining = 3;
     */
    limitRemaining: number;
}
/**
 * @generated from protobuf enum envoy.service.ratelimit.v2.RateLimitResponse.Code
 */
export enum RateLimitResponse_Code {
    /**
     * The response code is not known.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * The response code to notify that the number of requests are under limit.
     *
     * @generated from protobuf enum value: OK = 1;
     */
    OK = 1,
    /**
     * The response code to notify that the number of requests are over limit.
     *
     * @generated from protobuf enum value: OVER_LIMIT = 2;
     */
    OVER_LIMIT = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitRequest$Type extends MessageType<RateLimitRequest> {
    constructor() {
        super("envoy.service.ratelimit.v2.RateLimitRequest", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "descriptors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimitDescriptor },
            { no: 3, name: "hits_addend", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitRequest>): RateLimitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.descriptors = [];
        message.hitsAddend = 0;
        if (value !== undefined)
            reflectionMergePartial<RateLimitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitRequest): RateLimitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* repeated envoy.api.v2.ratelimit.RateLimitDescriptor descriptors */ 2:
                    message.descriptors.push(RateLimitDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 hits_addend */ 3:
                    message.hitsAddend = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* repeated envoy.api.v2.ratelimit.RateLimitDescriptor descriptors = 2; */
        for (let i = 0; i < message.descriptors.length; i++)
            RateLimitDescriptor.internalBinaryWrite(message.descriptors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 hits_addend = 3; */
        if (message.hitsAddend !== 0)
            writer.tag(3, WireType.Varint).uint32(message.hitsAddend);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ratelimit.v2.RateLimitRequest
 */
export const RateLimitRequest = new RateLimitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitResponse$Type extends MessageType<RateLimitResponse> {
    constructor() {
        super("envoy.service.ratelimit.v2.RateLimitResponse", [
            { no: 1, name: "overall_code", kind: "enum", T: () => ["envoy.service.ratelimit.v2.RateLimitResponse.Code", RateLimitResponse_Code] },
            { no: 2, name: "statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimitResponse_DescriptorStatus },
            { no: 3, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue, options: { "udpa.annotations.field_migrate": { rename: "response_headers_to_add" } } },
            { no: 4, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue }
        ]);
    }
    create(value?: PartialMessage<RateLimitResponse>): RateLimitResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.overallCode = 0;
        message.statuses = [];
        message.headers = [];
        message.requestHeadersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimitResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitResponse): RateLimitResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ratelimit.v2.RateLimitResponse.Code overall_code */ 1:
                    message.overallCode = reader.int32();
                    break;
                case /* repeated envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus statuses */ 2:
                    message.statuses.push(RateLimitResponse_DescriptorStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.core.HeaderValue headers */ 3:
                    message.headers.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.core.HeaderValue request_headers_to_add */ 4:
                    message.requestHeadersToAdd.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ratelimit.v2.RateLimitResponse.Code overall_code = 1; */
        if (message.overallCode !== 0)
            writer.tag(1, WireType.Varint).int32(message.overallCode);
        /* repeated envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus statuses = 2; */
        for (let i = 0; i < message.statuses.length; i++)
            RateLimitResponse_DescriptorStatus.internalBinaryWrite(message.statuses[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HeaderValue headers = 3; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderValue.internalBinaryWrite(message.headers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HeaderValue request_headers_to_add = 4; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValue.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ratelimit.v2.RateLimitResponse
 */
export const RateLimitResponse = new RateLimitResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitResponse_RateLimit$Type extends MessageType<RateLimitResponse_RateLimit> {
    constructor() {
        super("envoy.service.ratelimit.v2.RateLimitResponse.RateLimit", [
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "requests_per_unit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "unit", kind: "enum", T: () => ["envoy.service.ratelimit.v2.RateLimitResponse.RateLimit.Unit", RateLimitResponse_RateLimit_Unit] }
        ]);
    }
    create(value?: PartialMessage<RateLimitResponse_RateLimit>): RateLimitResponse_RateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.requestsPerUnit = 0;
        message.unit = 0;
        if (value !== undefined)
            reflectionMergePartial<RateLimitResponse_RateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitResponse_RateLimit): RateLimitResponse_RateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* uint32 requests_per_unit */ 1:
                    message.requestsPerUnit = reader.uint32();
                    break;
                case /* envoy.service.ratelimit.v2.RateLimitResponse.RateLimit.Unit unit */ 2:
                    message.unit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitResponse_RateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* uint32 requests_per_unit = 1; */
        if (message.requestsPerUnit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.requestsPerUnit);
        /* envoy.service.ratelimit.v2.RateLimitResponse.RateLimit.Unit unit = 2; */
        if (message.unit !== 0)
            writer.tag(2, WireType.Varint).int32(message.unit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ratelimit.v2.RateLimitResponse.RateLimit
 */
export const RateLimitResponse_RateLimit = new RateLimitResponse_RateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitResponse_DescriptorStatus$Type extends MessageType<RateLimitResponse_DescriptorStatus> {
    constructor() {
        super("envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus", [
            { no: 1, name: "code", kind: "enum", T: () => ["envoy.service.ratelimit.v2.RateLimitResponse.Code", RateLimitResponse_Code] },
            { no: 2, name: "current_limit", kind: "message", T: () => RateLimitResponse_RateLimit },
            { no: 3, name: "limit_remaining", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimitResponse_DescriptorStatus>): RateLimitResponse_DescriptorStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.limitRemaining = 0;
        if (value !== undefined)
            reflectionMergePartial<RateLimitResponse_DescriptorStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitResponse_DescriptorStatus): RateLimitResponse_DescriptorStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ratelimit.v2.RateLimitResponse.Code code */ 1:
                    message.code = reader.int32();
                    break;
                case /* envoy.service.ratelimit.v2.RateLimitResponse.RateLimit current_limit */ 2:
                    message.currentLimit = RateLimitResponse_RateLimit.internalBinaryRead(reader, reader.uint32(), options, message.currentLimit);
                    break;
                case /* uint32 limit_remaining */ 3:
                    message.limitRemaining = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitResponse_DescriptorStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ratelimit.v2.RateLimitResponse.Code code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* envoy.service.ratelimit.v2.RateLimitResponse.RateLimit current_limit = 2; */
        if (message.currentLimit)
            RateLimitResponse_RateLimit.internalBinaryWrite(message.currentLimit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 limit_remaining = 3; */
        if (message.limitRemaining !== 0)
            writer.tag(3, WireType.Varint).uint32(message.limitRemaining);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ratelimit.v2.RateLimitResponse.DescriptorStatus
 */
export const RateLimitResponse_DescriptorStatus = new RateLimitResponse_DescriptorStatus$Type();
/**
 * @generated ServiceType for protobuf service envoy.service.ratelimit.v2.RateLimitService
 */
export const RateLimitService = new ServiceType("envoy.service.ratelimit.v2.RateLimitService", [
    { name: "ShouldRateLimit", options: {}, I: RateLimitRequest, O: RateLimitResponse }
]);
