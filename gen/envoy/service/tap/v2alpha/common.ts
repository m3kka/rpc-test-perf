// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/tap/v2alpha/common.proto" (package "envoy.service.tap.v2alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GrpcService } from "../../../api/v2/core/grpc_service";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { HeaderMatcher } from "../../../api/v2/route/route_components";
import { RuntimeFractionalPercent } from "../../../api/v2/core/base";
// [#protodoc-title: Common tap configuration]

/**
 * Tap configuration.
 *
 * [#comment:TODO(mattklein123): Rate limiting]
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.TapConfig
 */
export interface TapConfig {
    /**
     * The match configuration. If the configuration matches the data source being tapped, a tap will
     * occur, with the result written to the configured output.
     *
     * @generated from protobuf field: envoy.service.tap.v2alpha.MatchPredicate match_config = 1;
     */
    matchConfig?: MatchPredicate;
    /**
     * The tap output configuration. If a match configuration matches a data source being tapped,
     * a tap will occur and the data will be written to the configured output.
     *
     * @generated from protobuf field: envoy.service.tap.v2alpha.OutputConfig output_config = 2;
     */
    outputConfig?: OutputConfig;
    /**
     * [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
     * which the tap matching is enabled. When not enabled, the request\connection will not be
     * recorded.
     *
     * .. note::
     *
     *   This field defaults to 100/:ref:`HUNDRED
     *   <envoy_api_enum_type.FractionalPercent.DenominatorType>`.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent tap_enabled = 3;
     */
    tapEnabled?: RuntimeFractionalPercent;
}
/**
 * Tap match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.MatchPredicate
 */
export interface MatchPredicate {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "orMatch";
        /**
         * A set that describes a logical OR. If any member of the set matches, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.MatchPredicate.MatchSet or_match = 1;
         */
        orMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "andMatch";
        /**
         * A set that describes a logical AND. If all members of the set match, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.MatchPredicate.MatchSet and_match = 2;
         */
        andMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "notMatch";
        /**
         * A negation match. The match configuration will match if the negated match condition matches.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.MatchPredicate not_match = 3;
         */
        notMatch: MatchPredicate;
    } | {
        oneofKind: "anyMatch";
        /**
         * The match configuration will always match.
         *
         * @generated from protobuf field: bool any_match = 4;
         */
        anyMatch: boolean;
    } | {
        oneofKind: "httpRequestHeadersMatch";
        /**
         * HTTP request headers match configuration.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.HttpHeadersMatch http_request_headers_match = 5;
         */
        httpRequestHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpRequestTrailersMatch";
        /**
         * HTTP request trailers match configuration.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.HttpHeadersMatch http_request_trailers_match = 6;
         */
        httpRequestTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseHeadersMatch";
        /**
         * HTTP response headers match configuration.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.HttpHeadersMatch http_response_headers_match = 7;
         */
        httpResponseHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseTrailersMatch";
        /**
         * HTTP response trailers match configuration.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.HttpHeadersMatch http_response_trailers_match = 8;
         */
        httpResponseTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of match configurations used for logical operations.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.MatchPredicate.MatchSet
 */
export interface MatchPredicate_MatchSet {
    /**
     * The list of rules that make up the set.
     *
     * @generated from protobuf field: repeated envoy.service.tap.v2alpha.MatchPredicate rules = 1;
     */
    rules: MatchPredicate[];
}
/**
 * HTTP headers match configuration.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.HttpHeadersMatch
 */
export interface HttpHeadersMatch {
    /**
     * HTTP headers to match.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher headers = 1;
     */
    headers: HeaderMatcher[];
}
/**
 * Tap output configuration.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.OutputConfig
 */
export interface OutputConfig {
    /**
     * Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
     * sink types are supported this constraint will be relaxed.
     *
     * @generated from protobuf field: repeated envoy.service.tap.v2alpha.OutputSink sinks = 1;
     */
    sinks: OutputSink[];
    /**
     * For buffered tapping, the maximum amount of received body that will be buffered prior to
     * truncation. If truncation occurs, the :ref:`truncated
     * <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
     * default is 1KiB.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_buffered_rx_bytes = 2;
     */
    maxBufferedRxBytes?: UInt32Value;
    /**
     * For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
     * truncation. If truncation occurs, the :ref:`truncated
     * <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
     * default is 1KiB.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_buffered_tx_bytes = 3;
     */
    maxBufferedTxBytes?: UInt32Value;
    /**
     * Indicates whether taps produce a single buffered message per tap, or multiple streamed
     * messages per tap in the emitted :ref:`TraceWrapper
     * <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. Note that streamed tapping does not
     * mean that no buffering takes place. Buffering may be required if data is processed before a
     * match can be determined. See the HTTP tap filter :ref:`streaming
     * <config_http_filters_tap_streaming>` documentation for more information.
     *
     * @generated from protobuf field: bool streaming = 4;
     */
    streaming: boolean;
}
/**
 * Tap output sink configuration.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.OutputSink
 */
export interface OutputSink {
    /**
     * Sink output format.
     *
     * @generated from protobuf field: envoy.service.tap.v2alpha.OutputSink.Format format = 1;
     */
    format: OutputSink_Format;
    /**
     * @generated from protobuf oneof: output_sink_type
     */
    outputSinkType: {
        oneofKind: "streamingAdmin";
        /**
         * Tap output will be streamed out the :http:post:`/tap` admin endpoint.
         *
         * .. attention::
         *
         *   It is only allowed to specify the streaming admin output sink if the tap is being
         *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
         *   been configured to receive tap configuration from some other source (e.g., static
         *   file, XDS, etc.) configuring the streaming admin output type will fail.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.StreamingAdminSink streaming_admin = 2;
         */
        streamingAdmin: StreamingAdminSink;
    } | {
        oneofKind: "filePerTap";
        /**
         * Tap output will be written to a file per tap sink.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.FilePerTapSink file_per_tap = 3;
         */
        filePerTap: FilePerTapSink;
    } | {
        oneofKind: "streamingGrpc";
        /**
         * [#not-implemented-hide:]
         * GrpcService to stream data to. The format argument must be PROTO_BINARY.
         *
         * @generated from protobuf field: envoy.service.tap.v2alpha.StreamingGrpcSink streaming_grpc = 4;
         */
        streamingGrpc: StreamingGrpcSink;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Output format. All output is in the form of one or more :ref:`TraceWrapper
 * <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. This enumeration indicates
 * how those messages are written. Note that not all sinks support all output formats. See
 * individual sink documentation for more information.
 *
 * @generated from protobuf enum envoy.service.tap.v2alpha.OutputSink.Format
 */
export enum OutputSink_Format {
    /**
     * Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
     * data will be present in the :ref:`as_bytes
     * <envoy_api_field_data.tap.v2alpha.Body.as_bytes>` field. This means that body data will be
     * base64 encoded as per the `proto3 JSON mappings
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
     *
     * @generated from protobuf enum value: JSON_BODY_AS_BYTES = 0;
     */
    JSON_BODY_AS_BYTES = 0,
    /**
     * Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
     * data will be present in the :ref:`as_string
     * <envoy_api_field_data.tap.v2alpha.Body.as_string>` field. This means that body data will be
     * string encoded as per the `proto3 JSON mappings
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
     * useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
     * user wishes to view it directly without being forced to base64 decode the body.
     *
     * @generated from protobuf enum value: JSON_BODY_AS_STRING = 1;
     */
    JSON_BODY_AS_STRING = 1,
    /**
     * Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
     * multiple binary messages without any length information the data stream will not be
     * useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
     * this output format makes consumption simpler.
     *
     * @generated from protobuf enum value: PROTO_BINARY = 2;
     */
    PROTO_BINARY = 2,
    /**
     * Messages are written as a sequence tuples, where each tuple is the message length encoded
     * as a `protobuf 32-bit varint
     * <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
     * followed by the binary message. The messages can be read back using the language specific
     * protobuf coded stream implementation to obtain the message length and the message.
     *
     * @generated from protobuf enum value: PROTO_BINARY_LENGTH_DELIMITED = 3;
     */
    PROTO_BINARY_LENGTH_DELIMITED = 3,
    /**
     * Text proto format.
     *
     * @generated from protobuf enum value: PROTO_TEXT = 4;
     */
    PROTO_TEXT = 4
}
/**
 * Streaming admin sink configuration.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.StreamingAdminSink
 */
export interface StreamingAdminSink {
}
/**
 * The file per tap sink outputs a discrete file for every tapped stream.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.FilePerTapSink
 */
export interface FilePerTapSink {
    /**
     * Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
     * identifier distinguishing the recorded trace for stream instances (the Envoy
     * connection ID, HTTP stream ID, etc.).
     *
     * @generated from protobuf field: string path_prefix = 1;
     */
    pathPrefix: string;
}
/**
 * [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
 * server.
 *
 * @generated from protobuf message envoy.service.tap.v2alpha.StreamingGrpcSink
 */
export interface StreamingGrpcSink {
    /**
     * Opaque identifier, that will be sent back to the streaming grpc server.
     *
     * @generated from protobuf field: string tap_id = 1;
     */
    tapId: string;
    /**
     * The gRPC server that hosts the Tap Sink Service.
     *
     * @generated from protobuf field: envoy.api.v2.core.GrpcService grpc_service = 2;
     */
    grpcService?: GrpcService;
}
// @generated message type with reflection information, may provide speed optimized methods
class TapConfig$Type extends MessageType<TapConfig> {
    constructor() {
        super("envoy.service.tap.v2alpha.TapConfig", [
            { no: 1, name: "match_config", kind: "message", T: () => MatchPredicate, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "output_config", kind: "message", T: () => OutputConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "tap_enabled", kind: "message", T: () => RuntimeFractionalPercent }
        ]);
    }
    create(value?: PartialMessage<TapConfig>): TapConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TapConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapConfig): TapConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.tap.v2alpha.MatchPredicate match_config */ 1:
                    message.matchConfig = MatchPredicate.internalBinaryRead(reader, reader.uint32(), options, message.matchConfig);
                    break;
                case /* envoy.service.tap.v2alpha.OutputConfig output_config */ 2:
                    message.outputConfig = OutputConfig.internalBinaryRead(reader, reader.uint32(), options, message.outputConfig);
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent tap_enabled */ 3:
                    message.tapEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.tapEnabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.tap.v2alpha.MatchPredicate match_config = 1; */
        if (message.matchConfig)
            MatchPredicate.internalBinaryWrite(message.matchConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.OutputConfig output_config = 2; */
        if (message.outputConfig)
            OutputConfig.internalBinaryWrite(message.outputConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RuntimeFractionalPercent tap_enabled = 3; */
        if (message.tapEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.tapEnabled, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.TapConfig
 */
export const TapConfig = new TapConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate$Type extends MessageType<MatchPredicate> {
    constructor() {
        super("envoy.service.tap.v2alpha.MatchPredicate", [
            { no: 1, name: "or_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 2, name: "and_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 3, name: "not_match", kind: "message", oneof: "rule", T: () => MatchPredicate },
            { no: 4, name: "any_match", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 5, name: "http_request_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 6, name: "http_request_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 7, name: "http_response_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 8, name: "http_response_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch }
        ]);
    }
    create(value?: PartialMessage<MatchPredicate>): MatchPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate): MatchPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.tap.v2alpha.MatchPredicate.MatchSet or_match */ 1:
                    message.rule = {
                        oneofKind: "orMatch",
                        orMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orMatch)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.MatchPredicate.MatchSet and_match */ 2:
                    message.rule = {
                        oneofKind: "andMatch",
                        andMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andMatch)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.MatchPredicate not_match */ 3:
                    message.rule = {
                        oneofKind: "notMatch",
                        notMatch: MatchPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notMatch)
                    };
                    break;
                case /* bool any_match */ 4:
                    message.rule = {
                        oneofKind: "anyMatch",
                        anyMatch: reader.bool()
                    };
                    break;
                case /* envoy.service.tap.v2alpha.HttpHeadersMatch http_request_headers_match */ 5:
                    message.rule = {
                        oneofKind: "httpRequestHeadersMatch",
                        httpRequestHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestHeadersMatch)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.HttpHeadersMatch http_request_trailers_match */ 6:
                    message.rule = {
                        oneofKind: "httpRequestTrailersMatch",
                        httpRequestTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestTrailersMatch)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.HttpHeadersMatch http_response_headers_match */ 7:
                    message.rule = {
                        oneofKind: "httpResponseHeadersMatch",
                        httpResponseHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseHeadersMatch)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.HttpHeadersMatch http_response_trailers_match */ 8:
                    message.rule = {
                        oneofKind: "httpResponseTrailersMatch",
                        httpResponseTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseTrailersMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.tap.v2alpha.MatchPredicate.MatchSet or_match = 1; */
        if (message.rule.oneofKind === "orMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.orMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.MatchPredicate.MatchSet and_match = 2; */
        if (message.rule.oneofKind === "andMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.andMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.MatchPredicate not_match = 3; */
        if (message.rule.oneofKind === "notMatch")
            MatchPredicate.internalBinaryWrite(message.rule.notMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool any_match = 4; */
        if (message.rule.oneofKind === "anyMatch")
            writer.tag(4, WireType.Varint).bool(message.rule.anyMatch);
        /* envoy.service.tap.v2alpha.HttpHeadersMatch http_request_headers_match = 5; */
        if (message.rule.oneofKind === "httpRequestHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestHeadersMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.HttpHeadersMatch http_request_trailers_match = 6; */
        if (message.rule.oneofKind === "httpRequestTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestTrailersMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.HttpHeadersMatch http_response_headers_match = 7; */
        if (message.rule.oneofKind === "httpResponseHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseHeadersMatch, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.HttpHeadersMatch http_response_trailers_match = 8; */
        if (message.rule.oneofKind === "httpResponseTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseTrailersMatch, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.MatchPredicate
 */
export const MatchPredicate = new MatchPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate_MatchSet$Type extends MessageType<MatchPredicate_MatchSet> {
    constructor() {
        super("envoy.service.tap.v2alpha.MatchPredicate.MatchSet", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MatchPredicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<MatchPredicate_MatchSet>): MatchPredicate_MatchSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate_MatchSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate_MatchSet): MatchPredicate_MatchSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.tap.v2alpha.MatchPredicate rules */ 1:
                    message.rules.push(MatchPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate_MatchSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.tap.v2alpha.MatchPredicate rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            MatchPredicate.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.MatchPredicate.MatchSet
 */
export const MatchPredicate_MatchSet = new MatchPredicate_MatchSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpHeadersMatch$Type extends MessageType<HttpHeadersMatch> {
    constructor() {
        super("envoy.service.tap.v2alpha.HttpHeadersMatch", [
            { no: 1, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher }
        ]);
    }
    create(value?: PartialMessage<HttpHeadersMatch>): HttpHeadersMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<HttpHeadersMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpHeadersMatch): HttpHeadersMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.route.HeaderMatcher headers */ 1:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpHeadersMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.route.HeaderMatcher headers = 1; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.HttpHeadersMatch
 */
export const HttpHeadersMatch = new HttpHeadersMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutputConfig$Type extends MessageType<OutputConfig> {
    constructor() {
        super("envoy.service.tap.v2alpha.OutputConfig", [
            { no: 1, name: "sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OutputSink, options: { "validate.rules": { repeated: { minItems: "1", maxItems: "1" } } } },
            { no: 2, name: "max_buffered_rx_bytes", kind: "message", T: () => UInt32Value },
            { no: 3, name: "max_buffered_tx_bytes", kind: "message", T: () => UInt32Value },
            { no: 4, name: "streaming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<OutputConfig>): OutputConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sinks = [];
        message.streaming = false;
        if (value !== undefined)
            reflectionMergePartial<OutputConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputConfig): OutputConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.tap.v2alpha.OutputSink sinks */ 1:
                    message.sinks.push(OutputSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value max_buffered_rx_bytes */ 2:
                    message.maxBufferedRxBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxBufferedRxBytes);
                    break;
                case /* google.protobuf.UInt32Value max_buffered_tx_bytes */ 3:
                    message.maxBufferedTxBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxBufferedTxBytes);
                    break;
                case /* bool streaming */ 4:
                    message.streaming = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutputConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.tap.v2alpha.OutputSink sinks = 1; */
        for (let i = 0; i < message.sinks.length; i++)
            OutputSink.internalBinaryWrite(message.sinks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_buffered_rx_bytes = 2; */
        if (message.maxBufferedRxBytes)
            UInt32Value.internalBinaryWrite(message.maxBufferedRxBytes, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_buffered_tx_bytes = 3; */
        if (message.maxBufferedTxBytes)
            UInt32Value.internalBinaryWrite(message.maxBufferedTxBytes, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool streaming = 4; */
        if (message.streaming !== false)
            writer.tag(4, WireType.Varint).bool(message.streaming);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.OutputConfig
 */
export const OutputConfig = new OutputConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutputSink$Type extends MessageType<OutputSink> {
    constructor() {
        super("envoy.service.tap.v2alpha.OutputSink", [
            { no: 1, name: "format", kind: "enum", T: () => ["envoy.service.tap.v2alpha.OutputSink.Format", OutputSink_Format], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "streaming_admin", kind: "message", oneof: "outputSinkType", T: () => StreamingAdminSink },
            { no: 3, name: "file_per_tap", kind: "message", oneof: "outputSinkType", T: () => FilePerTapSink },
            { no: 4, name: "streaming_grpc", kind: "message", oneof: "outputSinkType", T: () => StreamingGrpcSink }
        ]);
    }
    create(value?: PartialMessage<OutputSink>): OutputSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.format = 0;
        message.outputSinkType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OutputSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputSink): OutputSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.tap.v2alpha.OutputSink.Format format */ 1:
                    message.format = reader.int32();
                    break;
                case /* envoy.service.tap.v2alpha.StreamingAdminSink streaming_admin */ 2:
                    message.outputSinkType = {
                        oneofKind: "streamingAdmin",
                        streamingAdmin: StreamingAdminSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).streamingAdmin)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.FilePerTapSink file_per_tap */ 3:
                    message.outputSinkType = {
                        oneofKind: "filePerTap",
                        filePerTap: FilePerTapSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).filePerTap)
                    };
                    break;
                case /* envoy.service.tap.v2alpha.StreamingGrpcSink streaming_grpc */ 4:
                    message.outputSinkType = {
                        oneofKind: "streamingGrpc",
                        streamingGrpc: StreamingGrpcSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).streamingGrpc)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutputSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.tap.v2alpha.OutputSink.Format format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format);
        /* envoy.service.tap.v2alpha.StreamingAdminSink streaming_admin = 2; */
        if (message.outputSinkType.oneofKind === "streamingAdmin")
            StreamingAdminSink.internalBinaryWrite(message.outputSinkType.streamingAdmin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.FilePerTapSink file_per_tap = 3; */
        if (message.outputSinkType.oneofKind === "filePerTap")
            FilePerTapSink.internalBinaryWrite(message.outputSinkType.filePerTap, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.tap.v2alpha.StreamingGrpcSink streaming_grpc = 4; */
        if (message.outputSinkType.oneofKind === "streamingGrpc")
            StreamingGrpcSink.internalBinaryWrite(message.outputSinkType.streamingGrpc, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.OutputSink
 */
export const OutputSink = new OutputSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamingAdminSink$Type extends MessageType<StreamingAdminSink> {
    constructor() {
        super("envoy.service.tap.v2alpha.StreamingAdminSink", []);
    }
    create(value?: PartialMessage<StreamingAdminSink>): StreamingAdminSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamingAdminSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamingAdminSink): StreamingAdminSink {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StreamingAdminSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.StreamingAdminSink
 */
export const StreamingAdminSink = new StreamingAdminSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilePerTapSink$Type extends MessageType<FilePerTapSink> {
    constructor() {
        super("envoy.service.tap.v2alpha.FilePerTapSink", [
            { no: 1, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<FilePerTapSink>): FilePerTapSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<FilePerTapSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilePerTapSink): FilePerTapSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path_prefix */ 1:
                    message.pathPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilePerTapSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path_prefix = 1; */
        if (message.pathPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pathPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.FilePerTapSink
 */
export const FilePerTapSink = new FilePerTapSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamingGrpcSink$Type extends MessageType<StreamingGrpcSink> {
    constructor() {
        super("envoy.service.tap.v2alpha.StreamingGrpcSink", [
            { no: 1, name: "tap_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grpc_service", kind: "message", T: () => GrpcService, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<StreamingGrpcSink>): StreamingGrpcSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tapId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamingGrpcSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamingGrpcSink): StreamingGrpcSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tap_id */ 1:
                    message.tapId = reader.string();
                    break;
                case /* envoy.api.v2.core.GrpcService grpc_service */ 2:
                    message.grpcService = GrpcService.internalBinaryRead(reader, reader.uint32(), options, message.grpcService);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamingGrpcSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tap_id = 1; */
        if (message.tapId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tapId);
        /* envoy.api.v2.core.GrpcService grpc_service = 2; */
        if (message.grpcService)
            GrpcService.internalBinaryWrite(message.grpcService, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.tap.v2alpha.StreamingGrpcSink
 */
export const StreamingGrpcSink = new StreamingGrpcSink$Type();
