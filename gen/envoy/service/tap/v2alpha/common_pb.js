// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/service/tap/v2alpha/common.proto (package envoy.service.tap.v2alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3, UInt32Value } from "@bufbuild/protobuf";
import { RuntimeFractionalPercent } from "../../../api/v2/core/base_pb.js";
import { HeaderMatcher } from "../../../api/v2/route/route_components_pb.js";
import { GrpcService } from "../../../api/v2/core/grpc_service_pb.js";

/**
 * Tap configuration.
 *
 * [#comment:TODO(mattklein123): Rate limiting]
 *
 * @generated from message envoy.service.tap.v2alpha.TapConfig
 */
export const TapConfig = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.TapConfig",
  () => [
    { no: 1, name: "match_config", kind: "message", T: MatchPredicate },
    { no: 2, name: "output_config", kind: "message", T: OutputConfig },
    { no: 3, name: "tap_enabled", kind: "message", T: RuntimeFractionalPercent },
  ],
);

/**
 * Tap match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.service.tap.v2alpha.MatchPredicate
 */
export const MatchPredicate = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.MatchPredicate",
  () => [
    { no: 1, name: "or_match", kind: "message", T: MatchPredicate_MatchSet, oneof: "rule" },
    { no: 2, name: "and_match", kind: "message", T: MatchPredicate_MatchSet, oneof: "rule" },
    { no: 3, name: "not_match", kind: "message", T: MatchPredicate, oneof: "rule" },
    { no: 4, name: "any_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 5, name: "http_request_headers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 6, name: "http_request_trailers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 7, name: "http_response_headers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 8, name: "http_response_trailers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
  ],
);

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.service.tap.v2alpha.MatchPredicate.MatchSet
 */
export const MatchPredicate_MatchSet = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.MatchPredicate.MatchSet",
  () => [
    { no: 1, name: "rules", kind: "message", T: MatchPredicate, repeated: true },
  ],
  {localName: "MatchPredicate_MatchSet"},
);

/**
 * HTTP headers match configuration.
 *
 * @generated from message envoy.service.tap.v2alpha.HttpHeadersMatch
 */
export const HttpHeadersMatch = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.HttpHeadersMatch",
  () => [
    { no: 1, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
);

/**
 * Tap output configuration.
 *
 * @generated from message envoy.service.tap.v2alpha.OutputConfig
 */
export const OutputConfig = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.OutputConfig",
  () => [
    { no: 1, name: "sinks", kind: "message", T: OutputSink, repeated: true },
    { no: 2, name: "max_buffered_rx_bytes", kind: "message", T: UInt32Value },
    { no: 3, name: "max_buffered_tx_bytes", kind: "message", T: UInt32Value },
    { no: 4, name: "streaming", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Tap output sink configuration.
 *
 * @generated from message envoy.service.tap.v2alpha.OutputSink
 */
export const OutputSink = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.OutputSink",
  () => [
    { no: 1, name: "format", kind: "enum", T: proto3.getEnumType(OutputSink_Format) },
    { no: 2, name: "streaming_admin", kind: "message", T: StreamingAdminSink, oneof: "output_sink_type" },
    { no: 3, name: "file_per_tap", kind: "message", T: FilePerTapSink, oneof: "output_sink_type" },
    { no: 4, name: "streaming_grpc", kind: "message", T: StreamingGrpcSink, oneof: "output_sink_type" },
  ],
);

/**
 * Output format. All output is in the form of one or more :ref:`TraceWrapper
 * <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. This enumeration indicates
 * how those messages are written. Note that not all sinks support all output formats. See
 * individual sink documentation for more information.
 *
 * @generated from enum envoy.service.tap.v2alpha.OutputSink.Format
 */
export const OutputSink_Format = proto3.makeEnum(
  "envoy.service.tap.v2alpha.OutputSink.Format",
  [
    {no: 0, name: "JSON_BODY_AS_BYTES"},
    {no: 1, name: "JSON_BODY_AS_STRING"},
    {no: 2, name: "PROTO_BINARY"},
    {no: 3, name: "PROTO_BINARY_LENGTH_DELIMITED"},
    {no: 4, name: "PROTO_TEXT"},
  ],
);

/**
 * Streaming admin sink configuration.
 *
 * @generated from message envoy.service.tap.v2alpha.StreamingAdminSink
 */
export const StreamingAdminSink = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.StreamingAdminSink",
  [],
);

/**
 * The file per tap sink outputs a discrete file for every tapped stream.
 *
 * @generated from message envoy.service.tap.v2alpha.FilePerTapSink
 */
export const FilePerTapSink = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.FilePerTapSink",
  () => [
    { no: 1, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
 * server.
 *
 * @generated from message envoy.service.tap.v2alpha.StreamingGrpcSink
 */
export const StreamingGrpcSink = proto3.makeMessageType(
  "envoy.service.tap.v2alpha.StreamingGrpcSink",
  () => [
    { no: 1, name: "tap_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grpc_service", kind: "message", T: GrpcService },
  ],
);

