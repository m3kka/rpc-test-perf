// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/discovery/v2/hds.proto" (package "envoy.service.discovery.v2", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../../google/protobuf/duration";
import { HealthCheck } from "../../../api/v2/core/health_check";
import { Locality } from "../../../api/v2/core/base";
import { HealthStatus } from "../../../api/v2/core/health_check";
import { Endpoint } from "../../../api/v2/endpoint/endpoint_components";
import { Node } from "../../../api/v2/core/base";
/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 *
 * @generated from protobuf message envoy.service.discovery.v2.Capability
 */
export interface Capability {
    /**
     * @generated from protobuf field: repeated envoy.service.discovery.v2.Capability.Protocol health_check_protocols = 1;
     */
    healthCheckProtocols: Capability_Protocol[];
}
/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 *
 * @generated from protobuf enum envoy.service.discovery.v2.Capability.Protocol
 */
export enum Capability_Protocol {
    /**
     * @generated from protobuf enum value: HTTP = 0;
     */
    HTTP = 0,
    /**
     * @generated from protobuf enum value: TCP = 1;
     */
    TCP = 1,
    /**
     * @generated from protobuf enum value: REDIS = 2;
     */
    REDIS = 2
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.HealthCheckRequest
 */
export interface HealthCheckRequest {
    /**
     * @generated from protobuf field: envoy.api.v2.core.Node node = 1;
     */
    node?: Node;
    /**
     * @generated from protobuf field: envoy.service.discovery.v2.Capability capability = 2;
     */
    capability?: Capability;
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.EndpointHealth
 */
export interface EndpointHealth {
    /**
     * @generated from protobuf field: envoy.api.v2.endpoint.Endpoint endpoint = 1;
     */
    endpoint?: Endpoint;
    /**
     * @generated from protobuf field: envoy.api.v2.core.HealthStatus health_status = 2;
     */
    healthStatus: HealthStatus;
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.EndpointHealthResponse
 */
export interface EndpointHealthResponse {
    /**
     * @generated from protobuf field: repeated envoy.service.discovery.v2.EndpointHealth endpoints_health = 1;
     */
    endpointsHealth: EndpointHealth[];
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse
 */
export interface HealthCheckRequestOrEndpointHealthResponse {
    /**
     * @generated from protobuf oneof: request_type
     */
    requestType: {
        oneofKind: "healthCheckRequest";
        /**
         * @generated from protobuf field: envoy.service.discovery.v2.HealthCheckRequest health_check_request = 1;
         */
        healthCheckRequest: HealthCheckRequest;
    } | {
        oneofKind: "endpointHealthResponse";
        /**
         * @generated from protobuf field: envoy.service.discovery.v2.EndpointHealthResponse endpoint_health_response = 2;
         */
        endpointHealthResponse: EndpointHealthResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.LocalityEndpoints
 */
export interface LocalityEndpoints {
    /**
     * @generated from protobuf field: envoy.api.v2.core.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * @generated from protobuf field: repeated envoy.api.v2.endpoint.Endpoint endpoints = 2;
     */
    endpoints: Endpoint[];
}
/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 *
 * @generated from protobuf message envoy.service.discovery.v2.ClusterHealthCheck
 */
export interface ClusterHealthCheck {
    /**
     * @generated from protobuf field: string cluster_name = 1;
     */
    clusterName: string;
    /**
     * @generated from protobuf field: repeated envoy.api.v2.core.HealthCheck health_checks = 2;
     */
    healthChecks: HealthCheck[];
    /**
     * @generated from protobuf field: repeated envoy.service.discovery.v2.LocalityEndpoints locality_endpoints = 3;
     */
    localityEndpoints: LocalityEndpoints[];
}
/**
 * @generated from protobuf message envoy.service.discovery.v2.HealthCheckSpecifier
 */
export interface HealthCheckSpecifier {
    /**
     * @generated from protobuf field: repeated envoy.service.discovery.v2.ClusterHealthCheck cluster_health_checks = 1;
     */
    clusterHealthChecks: ClusterHealthCheck[];
    /**
     * The default is 1 second.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 2;
     */
    interval?: Duration;
}
// @generated message type with reflection information, may provide speed optimized methods
class Capability$Type extends MessageType<Capability> {
    constructor() {
        super("envoy.service.discovery.v2.Capability", [
            { no: 1, name: "health_check_protocols", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["envoy.service.discovery.v2.Capability.Protocol", Capability_Protocol] }
        ]);
    }
    create(value?: PartialMessage<Capability>): Capability {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthCheckProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<Capability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Capability): Capability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.discovery.v2.Capability.Protocol health_check_protocols */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.healthCheckProtocols.push(reader.int32());
                    else
                        message.healthCheckProtocols.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Capability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.discovery.v2.Capability.Protocol health_check_protocols = 1; */
        if (message.healthCheckProtocols.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.healthCheckProtocols.length; i++)
                writer.int32(message.healthCheckProtocols[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.Capability
 */
export const Capability = new Capability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckRequest$Type extends MessageType<HealthCheckRequest> {
    constructor() {
        super("envoy.service.discovery.v2.HealthCheckRequest", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "capability", kind: "message", T: () => Capability }
        ]);
    }
    create(value?: PartialMessage<HealthCheckRequest>): HealthCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckRequest): HealthCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* envoy.service.discovery.v2.Capability capability */ 2:
                    message.capability = Capability.internalBinaryRead(reader, reader.uint32(), options, message.capability);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v2.Capability capability = 2; */
        if (message.capability)
            Capability.internalBinaryWrite(message.capability, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.HealthCheckRequest
 */
export const HealthCheckRequest = new HealthCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointHealth$Type extends MessageType<EndpointHealth> {
    constructor() {
        super("envoy.service.discovery.v2.EndpointHealth", [
            { no: 1, name: "endpoint", kind: "message", T: () => Endpoint },
            { no: 2, name: "health_status", kind: "enum", T: () => ["envoy.api.v2.core.HealthStatus", HealthStatus] }
        ]);
    }
    create(value?: PartialMessage<EndpointHealth>): EndpointHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<EndpointHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointHealth): EndpointHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.endpoint.Endpoint endpoint */ 1:
                    message.endpoint = Endpoint.internalBinaryRead(reader, reader.uint32(), options, message.endpoint);
                    break;
                case /* envoy.api.v2.core.HealthStatus health_status */ 2:
                    message.healthStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.endpoint.Endpoint endpoint = 1; */
        if (message.endpoint)
            Endpoint.internalBinaryWrite(message.endpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthStatus health_status = 2; */
        if (message.healthStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.healthStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.EndpointHealth
 */
export const EndpointHealth = new EndpointHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointHealthResponse$Type extends MessageType<EndpointHealthResponse> {
    constructor() {
        super("envoy.service.discovery.v2.EndpointHealthResponse", [
            { no: 1, name: "endpoints_health", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointHealth }
        ]);
    }
    create(value?: PartialMessage<EndpointHealthResponse>): EndpointHealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpointsHealth = [];
        if (value !== undefined)
            reflectionMergePartial<EndpointHealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointHealthResponse): EndpointHealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.discovery.v2.EndpointHealth endpoints_health */ 1:
                    message.endpointsHealth.push(EndpointHealth.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointHealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.discovery.v2.EndpointHealth endpoints_health = 1; */
        for (let i = 0; i < message.endpointsHealth.length; i++)
            EndpointHealth.internalBinaryWrite(message.endpointsHealth[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.EndpointHealthResponse
 */
export const EndpointHealthResponse = new EndpointHealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckRequestOrEndpointHealthResponse$Type extends MessageType<HealthCheckRequestOrEndpointHealthResponse> {
    constructor() {
        super("envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse", [
            { no: 1, name: "health_check_request", kind: "message", oneof: "requestType", T: () => HealthCheckRequest },
            { no: 2, name: "endpoint_health_response", kind: "message", oneof: "requestType", T: () => EndpointHealthResponse }
        ]);
    }
    create(value?: PartialMessage<HealthCheckRequestOrEndpointHealthResponse>): HealthCheckRequestOrEndpointHealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheckRequestOrEndpointHealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckRequestOrEndpointHealthResponse): HealthCheckRequestOrEndpointHealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.discovery.v2.HealthCheckRequest health_check_request */ 1:
                    message.requestType = {
                        oneofKind: "healthCheckRequest",
                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, (message.requestType as any).healthCheckRequest)
                    };
                    break;
                case /* envoy.service.discovery.v2.EndpointHealthResponse endpoint_health_response */ 2:
                    message.requestType = {
                        oneofKind: "endpointHealthResponse",
                        endpointHealthResponse: EndpointHealthResponse.internalBinaryRead(reader, reader.uint32(), options, (message.requestType as any).endpointHealthResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckRequestOrEndpointHealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.discovery.v2.HealthCheckRequest health_check_request = 1; */
        if (message.requestType.oneofKind === "healthCheckRequest")
            HealthCheckRequest.internalBinaryWrite(message.requestType.healthCheckRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v2.EndpointHealthResponse endpoint_health_response = 2; */
        if (message.requestType.oneofKind === "endpointHealthResponse")
            EndpointHealthResponse.internalBinaryWrite(message.requestType.endpointHealthResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse
 */
export const HealthCheckRequestOrEndpointHealthResponse = new HealthCheckRequestOrEndpointHealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityEndpoints$Type extends MessageType<LocalityEndpoints> {
    constructor() {
        super("envoy.service.discovery.v2.LocalityEndpoints", [
            { no: 1, name: "locality", kind: "message", T: () => Locality },
            { no: 2, name: "endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint }
        ]);
    }
    create(value?: PartialMessage<LocalityEndpoints>): LocalityEndpoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpoints = [];
        if (value !== undefined)
            reflectionMergePartial<LocalityEndpoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityEndpoints): LocalityEndpoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Locality locality */ 1:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* repeated envoy.api.v2.endpoint.Endpoint endpoints */ 2:
                    message.endpoints.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityEndpoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Locality locality = 1; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.endpoint.Endpoint endpoints = 2; */
        for (let i = 0; i < message.endpoints.length; i++)
            Endpoint.internalBinaryWrite(message.endpoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.LocalityEndpoints
 */
export const LocalityEndpoints = new LocalityEndpoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterHealthCheck$Type extends MessageType<ClusterHealthCheck> {
    constructor() {
        super("envoy.service.discovery.v2.ClusterHealthCheck", [
            { no: 1, name: "cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "health_checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck },
            { no: 3, name: "locality_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocalityEndpoints }
        ]);
    }
    create(value?: PartialMessage<ClusterHealthCheck>): ClusterHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.healthChecks = [];
        message.localityEndpoints = [];
        if (value !== undefined)
            reflectionMergePartial<ClusterHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterHealthCheck): ClusterHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_name */ 1:
                    message.clusterName = reader.string();
                    break;
                case /* repeated envoy.api.v2.core.HealthCheck health_checks */ 2:
                    message.healthChecks.push(HealthCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.service.discovery.v2.LocalityEndpoints locality_endpoints */ 3:
                    message.localityEndpoints.push(LocalityEndpoints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_name = 1; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* repeated envoy.api.v2.core.HealthCheck health_checks = 2; */
        for (let i = 0; i < message.healthChecks.length; i++)
            HealthCheck.internalBinaryWrite(message.healthChecks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.discovery.v2.LocalityEndpoints locality_endpoints = 3; */
        for (let i = 0; i < message.localityEndpoints.length; i++)
            LocalityEndpoints.internalBinaryWrite(message.localityEndpoints[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.ClusterHealthCheck
 */
export const ClusterHealthCheck = new ClusterHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckSpecifier$Type extends MessageType<HealthCheckSpecifier> {
    constructor() {
        super("envoy.service.discovery.v2.HealthCheckSpecifier", [
            { no: 1, name: "cluster_health_checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterHealthCheck },
            { no: 2, name: "interval", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<HealthCheckSpecifier>): HealthCheckSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterHealthChecks = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheckSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckSpecifier): HealthCheckSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.discovery.v2.ClusterHealthCheck cluster_health_checks */ 1:
                    message.clusterHealthChecks.push(ClusterHealthCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration interval */ 2:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.discovery.v2.ClusterHealthCheck cluster_health_checks = 1; */
        for (let i = 0; i < message.clusterHealthChecks.length; i++)
            ClusterHealthCheck.internalBinaryWrite(message.clusterHealthChecks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval = 2; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v2.HealthCheckSpecifier
 */
export const HealthCheckSpecifier = new HealthCheckSpecifier$Type();
/**
 * @generated ServiceType for protobuf service envoy.service.discovery.v2.HealthDiscoveryService
 */
export const HealthDiscoveryService = new ServiceType("envoy.service.discovery.v2.HealthDiscoveryService", [
    { name: "StreamHealthCheck", serverStreaming: true, clientStreaming: true, options: {}, I: HealthCheckRequestOrEndpointHealthResponse, O: HealthCheckSpecifier },
    { name: "FetchHealthCheck", options: { "google.api.http": { post: "/v2/discovery:health_check", body: "*" } }, I: HealthCheckRequestOrEndpointHealthResponse, O: HealthCheckSpecifier }
]);
