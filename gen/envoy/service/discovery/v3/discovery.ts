// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/discovery/v3/discovery.proto" (package "envoy.service.discovery.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Metadata } from "../../../config/core/v3/base";
import { Duration } from "../../../../google/protobuf/duration";
import { ControlPlane } from "../../../config/core/v3/base";
import { Any } from "../../../../google/protobuf/any";
import { Status } from "../../../../google/rpc/status";
import { Node } from "../../../config/core/v3/base";
// [#protodoc-title: Common discovery API components]

/**
 * Specifies a resource to be subscribed to.
 *
 * @generated from protobuf message envoy.service.discovery.v3.ResourceLocator
 */
export interface ResourceLocator {
    /**
     * The resource name to subscribe to.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A set of dynamic parameters used to match against the dynamic parameter
     * constraints on the resource. This allows clients to select between
     * multiple variants of the same resource.
     *
     * @generated from protobuf field: map<string, string> dynamic_parameters = 2;
     */
    dynamicParameters: {
        [key: string]: string;
    };
}
/**
 * Specifies a concrete resource name.
 *
 * @generated from protobuf message envoy.service.discovery.v3.ResourceName
 */
export interface ResourceName {
    /**
     * The name of the resource.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Dynamic parameter constraints associated with this resource. To be used by client-side caches
     * (including xDS proxies) when matching subscribed resource locators.
     *
     * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints dynamic_parameter_constraints = 2;
     */
    dynamicParameterConstraints?: DynamicParameterConstraints;
}
/**
 * A DiscoveryRequest requests a set of versioned resources of the same type for
 * a given Envoy node on some API.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.service.discovery.v3.DiscoveryRequest
 */
export interface DiscoveryRequest {
    /**
     * The version_info provided in the request messages will be the version_info
     * received with the most recent successfully processed response or empty on
     * the first request. It is expected that no new request is sent after a
     * response is received until the Envoy instance is ready to ACK/NACK the new
     * configuration. ACK/NACK takes place by returning the new API config version
     * as applied or the previous API config version respectively. Each type_url
     * (see below) has an independent version associated with it.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The node making the request.
     *
     * @generated from protobuf field: envoy.config.core.v3.Node node = 2;
     */
    node?: Node;
    /**
     * List of resources to subscribe to, e.g. list of cluster names or a route
     * configuration name. If this is empty, all resources for the API are
     * returned. LDS/CDS may have empty resource_names, which will cause all
     * resources for the Envoy instance to be returned. The LDS and CDS responses
     * will then imply a number of resources that need to be fetched via EDS/RDS,
     * which will be explicitly enumerated in resource_names.
     *
     * @generated from protobuf field: repeated string resource_names = 3;
     */
    resourceNames: string[];
    /**
     * [#not-implemented-hide:]
     * Alternative to ``resource_names`` field that allows specifying dynamic
     * parameters along with each resource name. Clients that populate this
     * field must be able to handle responses from the server where resources
     * are wrapped in a Resource message.
     * Note that it is legal for a request to have some resources listed
     * in ``resource_names`` and others in ``resource_locators``.
     *
     * @generated from protobuf field: repeated envoy.service.discovery.v3.ResourceLocator resource_locators = 7;
     */
    resourceLocators: ResourceLocator[];
    /**
     * Type of the resource that is being requested, e.g.
     * "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
     * in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
     * required for ADS.
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
     * discussion on version_info and the DiscoveryResponse nonce comment. This
     * may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
     * or 2) the client has not yet accepted an update in this xDS stream (unlike
     * delta, where it is populated only for new explicit ACKs).
     *
     * @generated from protobuf field: string response_nonce = 5;
     */
    responseNonce: string;
    /**
     * This is populated when the previous :ref:`DiscoveryResponse <envoy_v3_api_msg_service.discovery.v3.DiscoveryResponse>`
     * failed to update configuration. The ``message`` field in ``error_details`` provides the Envoy
     * internal exception related to the failure. It is only intended for consumption during manual
     * debugging, the string provided is not guaranteed to be stable across Envoy versions.
     *
     * @generated from protobuf field: google.rpc.Status error_detail = 6;
     */
    errorDetail?: Status;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.service.discovery.v3.DiscoveryResponse
 */
export interface DiscoveryResponse {
    /**
     * The version of the response data.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The response resources. These resources are typed and depend on the API being called.
     *
     * @generated from protobuf field: repeated google.protobuf.Any resources = 2;
     */
    resources: Any[];
    /**
     * [#not-implemented-hide:]
     * Canary is used to support two Envoy command line flags:
     *
     * * --terminate-on-canary-transition-failure. When set, Envoy is able to
     *   terminate if it detects that configuration is stuck at canary. Consider
     *   this example sequence of updates:
     *   - Management server applies a canary config successfully.
     *   - Management server rolls back to a production config.
     *   - Envoy rejects the new production config.
     *   Since there is no sensible way to continue receiving configuration
     *   updates, Envoy will then terminate and apply production config from a
     *   clean slate.
     * * --dry-run-canary. When set, a canary response will never be applied, only
     *   validated via a dry run.
     *
     * @generated from protobuf field: bool canary = 3;
     */
    canary: boolean;
    /**
     * Type URL for resources. Identifies the xDS API when muxing over ADS.
     * Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * For gRPC based subscriptions, the nonce provides a way to explicitly ack a
     * specific DiscoveryResponse in a following DiscoveryRequest. Additional
     * messages may have been sent by Envoy to the management server for the
     * previous version on the stream prior to this DiscoveryResponse, that were
     * unprocessed at response send time. The nonce allows the management server
     * to ignore any further DiscoveryRequests for the previous version until a
     * DiscoveryRequest bearing the nonce. The nonce is optional and is not
     * required for non-stream based xDS implementations.
     *
     * @generated from protobuf field: string nonce = 5;
     */
    nonce: string;
    /**
     * The control plane instance that sent the response.
     *
     * @generated from protobuf field: envoy.config.core.v3.ControlPlane control_plane = 6;
     */
    controlPlane?: ControlPlane;
}
/**
 * DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
 * endpoint for Delta xDS.
 *
 * With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
 * snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
 * diff to the state of a xDS client.
 * In Delta XDS there are per-resource versions, which allow tracking state at
 * the resource granularity.
 * An xDS Delta session is always in the context of a gRPC bidirectional
 * stream. This allows the xDS server to keep track of the state of xDS clients
 * connected to it.
 *
 * In Delta xDS the nonce field is required and used to pair
 * DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
 * Optionally, a response message level system_version_info is present for
 * debugging purposes only.
 *
 * DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
 * can be either or both of: [1] informing the server of what resources the
 * client has gained/lost interest in (using resource_names_subscribe and
 * resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
 * the server (using response_nonce, with presence of error_detail making it a NACK).
 * Additionally, the first message (for a given type_url) of a reconnected gRPC stream
 * has a third role: informing the server of the resources (and their versions)
 * that the client already possesses, using the initial_resource_versions field.
 *
 * As with state-of-the-world, when multiple resource types are multiplexed (ADS),
 * all requests/acknowledgments/updates are logically walled off by type_url:
 * a Cluster ACK exists in a completely separate world from a prior Route NACK.
 * In particular, initial_resource_versions being sent at the "start" of every
 * gRPC stream actually entails a message for each type_url, each with its own
 * initial_resource_versions.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.service.discovery.v3.DeltaDiscoveryRequest
 */
export interface DeltaDiscoveryRequest {
    /**
     * The node making the request.
     *
     * @generated from protobuf field: envoy.config.core.v3.Node node = 1;
     */
    node?: Node;
    /**
     * Type of the resource that is being requested, e.g.
     * ``type.googleapis.com/envoy.api.v2.ClusterLoadAssignment``. This does not need to be set if
     * resources are only referenced via ``xds_resource_subscribe`` and
     * ``xds_resources_unsubscribe``.
     *
     * @generated from protobuf field: string type_url = 2;
     */
    typeUrl: string;
    /**
     * DeltaDiscoveryRequests allow the client to add or remove individual
     * resources to the set of tracked resources in the context of a stream.
     * All resource names in the resource_names_subscribe list are added to the
     * set of tracked resources and all resource names in the resource_names_unsubscribe
     * list are removed from the set of tracked resources.
     *
     * *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
     * resource_names_unsubscribe list simply means that no resources are to be
     * added or removed to the resource list.
     * *Like* state-of-the-world xDS, the server must send updates for all tracked
     * resources, but can also send updates for resources the client has not subscribed to.
     *
     * NOTE: the server must respond with all resources listed in resource_names_subscribe,
     * even if it believes the client has the most recent version of them. The reason:
     * the client may have dropped them, but then regained interest before it had a chance
     * to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
     *
     * These two fields can be set in any DeltaDiscoveryRequest, including ACKs
     * and initial_resource_versions.
     *
     * A list of Resource names to add to the list of tracked resources.
     *
     * @generated from protobuf field: repeated string resource_names_subscribe = 3;
     */
    resourceNamesSubscribe: string[];
    /**
     * A list of Resource names to remove from the list of tracked resources.
     *
     * @generated from protobuf field: repeated string resource_names_unsubscribe = 4;
     */
    resourceNamesUnsubscribe: string[];
    /**
     * [#not-implemented-hide:]
     * Alternative to ``resource_names_subscribe`` field that allows specifying dynamic parameters
     * along with each resource name.
     * Note that it is legal for a request to have some resources listed
     * in ``resource_names_subscribe`` and others in ``resource_locators_subscribe``.
     *
     * @generated from protobuf field: repeated envoy.service.discovery.v3.ResourceLocator resource_locators_subscribe = 8;
     */
    resourceLocatorsSubscribe: ResourceLocator[];
    /**
     * [#not-implemented-hide:]
     * Alternative to ``resource_names_unsubscribe`` field that allows specifying dynamic parameters
     * along with each resource name.
     * Note that it is legal for a request to have some resources listed
     * in ``resource_names_unsubscribe`` and others in ``resource_locators_unsubscribe``.
     *
     * @generated from protobuf field: repeated envoy.service.discovery.v3.ResourceLocator resource_locators_unsubscribe = 9;
     */
    resourceLocatorsUnsubscribe: ResourceLocator[];
    /**
     * Informs the server of the versions of the resources the xDS client knows of, to enable the
     * client to continue the same logical xDS session even in the face of gRPC stream reconnection.
     * It will not be populated: [1] in the very first stream of a session, since the client will
     * not yet have any resources,  [2] in any message after the first in a stream (for a given
     * type_url), since the server will already be correctly tracking the client's state.
     * (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
     * The map's keys are names of xDS resources known to the xDS client.
     * The map's values are opaque resource versions.
     *
     * @generated from protobuf field: map<string, string> initial_resource_versions = 5;
     */
    initialResourceVersions: {
        [key: string]: string;
    };
    /**
     * When the DeltaDiscoveryRequest is a ACK or NACK message in response
     * to a previous DeltaDiscoveryResponse, the response_nonce must be the
     * nonce in the DeltaDiscoveryResponse.
     * Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
     *
     * @generated from protobuf field: string response_nonce = 6;
     */
    responseNonce: string;
    /**
     * This is populated when the previous :ref:`DiscoveryResponse <envoy_v3_api_msg_service.discovery.v3.DiscoveryResponse>`
     * failed to update configuration. The ``message`` field in ``error_details``
     * provides the Envoy internal exception related to the failure.
     *
     * @generated from protobuf field: google.rpc.Status error_detail = 7;
     */
    errorDetail?: Status;
}
/**
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.service.discovery.v3.DeltaDiscoveryResponse
 */
export interface DeltaDiscoveryResponse {
    /**
     * The version of the response data (used for debugging).
     *
     * @generated from protobuf field: string system_version_info = 1;
     */
    systemVersionInfo: string;
    /**
     * The response resources. These are typed resources, whose types must match
     * the type_url field.
     *
     * @generated from protobuf field: repeated envoy.service.discovery.v3.Resource resources = 2;
     */
    resources: Resource[];
    // field id 3 IS available!

    /**
     * Type URL for resources. Identifies the xDS API when muxing over ADS.
     * Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * Resources names of resources that have be deleted and to be removed from the xDS Client.
     * Removed resources for missing resources can be ignored.
     *
     * @generated from protobuf field: repeated string removed_resources = 6;
     */
    removedResources: string[];
    /**
     * Alternative to removed_resources that allows specifying which variant of
     * a resource is being removed. This variant must be used for any resource
     * for which dynamic parameter constraints were sent to the client.
     *
     * @generated from protobuf field: repeated envoy.service.discovery.v3.ResourceName removed_resource_names = 8;
     */
    removedResourceNames: ResourceName[];
    /**
     * The nonce provides a way for DeltaDiscoveryRequests to uniquely
     * reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
     *
     * @generated from protobuf field: string nonce = 5;
     */
    nonce: string;
    /**
     * [#not-implemented-hide:]
     * The control plane instance that sent the response.
     *
     * @generated from protobuf field: envoy.config.core.v3.ControlPlane control_plane = 7;
     */
    controlPlane?: ControlPlane;
}
/**
 * A set of dynamic parameter constraints associated with a variant of an individual xDS resource.
 * These constraints determine whether the resource matches a subscription based on the set of
 * dynamic parameters in the subscription, as specified in the
 * :ref:`ResourceLocator.dynamic_parameters<envoy_v3_api_field_service.discovery.v3.ResourceLocator.dynamic_parameters>`
 * field. This allows xDS implementations (clients, servers, and caching proxies) to determine
 * which variant of a resource is appropriate for a given client.
 *
 * @generated from protobuf message envoy.service.discovery.v3.DynamicParameterConstraints
 */
export interface DynamicParameterConstraints {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "constraint";
        /**
         * A single constraint to evaluate.
         *
         * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint constraint = 1;
         */
        constraint: DynamicParameterConstraints_SingleConstraint;
    } | {
        oneofKind: "orConstraints";
        /**
         * A list of constraints that match if any one constraint in the list
         * matches.
         *
         * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList or_constraints = 2;
         */
        orConstraints: DynamicParameterConstraints_ConstraintList;
    } | {
        oneofKind: "andConstraints";
        /**
         * A list of constraints that must all match.
         *
         * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList and_constraints = 3;
         */
        andConstraints: DynamicParameterConstraints_ConstraintList;
    } | {
        oneofKind: "notConstraints";
        /**
         * The inverse (NOT) of a set of constraints.
         *
         * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints not_constraints = 4;
         */
        notConstraints: DynamicParameterConstraints;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A single constraint for a given key.
 *
 * @generated from protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint
 */
export interface DynamicParameterConstraints_SingleConstraint {
    /**
     * The key to match against.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf oneof: constraint_type
     */
    constraintType: {
        oneofKind: "value";
        /**
         * Matches this exact value.
         *
         * @generated from protobuf field: string value = 2;
         */
        value: string;
    } | {
        oneofKind: "exists";
        /**
         * Key is present (matches any value except for the key being absent).
         * This allows setting a default constraint for clients that do
         * not send a key at all, while there may be other clients that need
         * special configuration based on that key.
         *
         * @generated from protobuf field: envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists exists = 3;
         */
        exists: DynamicParameterConstraints_SingleConstraint_Exists;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists
 */
export interface DynamicParameterConstraints_SingleConstraint_Exists {
}
/**
 * @generated from protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList
 */
export interface DynamicParameterConstraints_ConstraintList {
    /**
     * @generated from protobuf field: repeated envoy.service.discovery.v3.DynamicParameterConstraints constraints = 1;
     */
    constraints: DynamicParameterConstraints[];
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.service.discovery.v3.Resource
 */
export interface Resource {
    /**
     * The resource's name, to distinguish it from others of the same type of resource.
     * Only one of ``name`` or ``resource_name`` may be set.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * Alternative to the ``name`` field, to be used when the server supports
     * multiple variants of the named resource that are differentiated by
     * dynamic parameter constraints.
     * Only one of ``name`` or ``resource_name`` may be set.
     *
     * @generated from protobuf field: envoy.service.discovery.v3.ResourceName resource_name = 8;
     */
    resourceName?: ResourceName;
    /**
     * The aliases are a list of other names that this resource can go by.
     *
     * @generated from protobuf field: repeated string aliases = 4;
     */
    aliases: string[];
    /**
     * The resource level version. It allows xDS to track the state of individual
     * resources.
     *
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * The resource being tracked.
     *
     * @generated from protobuf field: google.protobuf.Any resource = 2;
     */
    resource?: Any;
    /**
     * Time-to-live value for the resource. For each resource, a timer is started. The timer is
     * reset each time the resource is received with a new TTL. If the resource is received with
     * no TTL set, the timer is removed for the resource. Upon expiration of the timer, the
     * configuration for the resource will be removed.
     *
     * The TTL can be refreshed or changed by sending a response that doesn't change the resource
     * version. In this case the resource field does not need to be populated, which allows for
     * light-weight "heartbeat" updates to keep a resource with a TTL alive.
     *
     * The TTL feature is meant to support configurations that should be removed in the event of
     * a management server failure. For example, the feature may be used for fault injection
     * testing where the fault injection should be terminated in the event that Envoy loses contact
     * with the management server.
     *
     * @generated from protobuf field: google.protobuf.Duration ttl = 6;
     */
    ttl?: Duration;
    /**
     * Cache control properties for the resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.service.discovery.v3.Resource.CacheControl cache_control = 7;
     */
    cacheControl?: Resource_CacheControl;
    /**
     * The Metadata field can be used to provide additional information for the resource.
     * E.g. the trace data for debugging.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 9;
     */
    metadata?: Metadata;
}
/**
 * Cache control properties for the resource.
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.service.discovery.v3.Resource.CacheControl
 */
export interface Resource_CacheControl {
    /**
     * If true, xDS proxies may not cache this resource.
     * Note that this does not apply to clients other than xDS proxies, which must cache resources
     * for their own use, regardless of the value of this field.
     *
     * @generated from protobuf field: bool do_not_cache = 1;
     */
    doNotCache: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class ResourceLocator$Type extends MessageType<ResourceLocator> {
    constructor() {
        super("envoy.service.discovery.v3.ResourceLocator", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dynamic_parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<ResourceLocator>): ResourceLocator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.dynamicParameters = {};
        if (value !== undefined)
            reflectionMergePartial<ResourceLocator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceLocator): ResourceLocator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, string> dynamic_parameters */ 2:
                    this.binaryReadMap2(message.dynamicParameters, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: ResourceLocator["dynamicParameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ResourceLocator["dynamicParameters"] | undefined, val: ResourceLocator["dynamicParameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.discovery.v3.ResourceLocator.dynamic_parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: ResourceLocator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, string> dynamic_parameters = 2; */
        for (let k of globalThis.Object.keys(message.dynamicParameters))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.dynamicParameters[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.ResourceLocator
 */
export const ResourceLocator = new ResourceLocator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceName$Type extends MessageType<ResourceName> {
    constructor() {
        super("envoy.service.discovery.v3.ResourceName", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dynamic_parameter_constraints", kind: "message", T: () => DynamicParameterConstraints }
        ]);
    }
    create(value?: PartialMessage<ResourceName>): ResourceName {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ResourceName>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceName): ResourceName {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.service.discovery.v3.DynamicParameterConstraints dynamic_parameter_constraints */ 2:
                    message.dynamicParameterConstraints = DynamicParameterConstraints.internalBinaryRead(reader, reader.uint32(), options, message.dynamicParameterConstraints);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceName, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.service.discovery.v3.DynamicParameterConstraints dynamic_parameter_constraints = 2; */
        if (message.dynamicParameterConstraints)
            DynamicParameterConstraints.internalBinaryWrite(message.dynamicParameterConstraints, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.ResourceName
 */
export const ResourceName = new ResourceName$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryRequest$Type extends MessageType<DiscoveryRequest> {
    constructor() {
        super("envoy.service.discovery.v3.DiscoveryRequest", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "node", kind: "message", T: () => Node },
            { no: 3, name: "resource_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "resource_locators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceLocator },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "response_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "error_detail", kind: "message", T: () => Status }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.DiscoveryRequest" } });
    }
    create(value?: PartialMessage<DiscoveryRequest>): DiscoveryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.resourceNames = [];
        message.resourceLocators = [];
        message.typeUrl = "";
        message.responseNonce = "";
        if (value !== undefined)
            reflectionMergePartial<DiscoveryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryRequest): DiscoveryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* envoy.config.core.v3.Node node */ 2:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* repeated string resource_names */ 3:
                    message.resourceNames.push(reader.string());
                    break;
                case /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators */ 7:
                    message.resourceLocators.push(ResourceLocator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* string response_nonce */ 5:
                    message.responseNonce = reader.string();
                    break;
                case /* google.rpc.Status error_detail */ 6:
                    message.errorDetail = Status.internalBinaryRead(reader, reader.uint32(), options, message.errorDetail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* envoy.config.core.v3.Node node = 2; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string resource_names = 3; */
        for (let i = 0; i < message.resourceNames.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.resourceNames[i]);
        /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators = 7; */
        for (let i = 0; i < message.resourceLocators.length; i++)
            ResourceLocator.internalBinaryWrite(message.resourceLocators[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* string response_nonce = 5; */
        if (message.responseNonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.responseNonce);
        /* google.rpc.Status error_detail = 6; */
        if (message.errorDetail)
            Status.internalBinaryWrite(message.errorDetail, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DiscoveryRequest
 */
export const DiscoveryRequest = new DiscoveryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryResponse$Type extends MessageType<DiscoveryResponse> {
    constructor() {
        super("envoy.service.discovery.v3.DiscoveryResponse", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 3, name: "canary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "control_plane", kind: "message", T: () => ControlPlane }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.DiscoveryResponse" } });
    }
    create(value?: PartialMessage<DiscoveryResponse>): DiscoveryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.resources = [];
        message.canary = false;
        message.typeUrl = "";
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<DiscoveryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryResponse): DiscoveryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated google.protobuf.Any resources */ 2:
                    message.resources.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool canary */ 3:
                    message.canary = reader.bool();
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* string nonce */ 5:
                    message.nonce = reader.string();
                    break;
                case /* envoy.config.core.v3.ControlPlane control_plane */ 6:
                    message.controlPlane = ControlPlane.internalBinaryRead(reader, reader.uint32(), options, message.controlPlane);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated google.protobuf.Any resources = 2; */
        for (let i = 0; i < message.resources.length; i++)
            Any.internalBinaryWrite(message.resources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool canary = 3; */
        if (message.canary !== false)
            writer.tag(3, WireType.Varint).bool(message.canary);
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* string nonce = 5; */
        if (message.nonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nonce);
        /* envoy.config.core.v3.ControlPlane control_plane = 6; */
        if (message.controlPlane)
            ControlPlane.internalBinaryWrite(message.controlPlane, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DiscoveryResponse
 */
export const DiscoveryResponse = new DiscoveryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeltaDiscoveryRequest$Type extends MessageType<DeltaDiscoveryRequest> {
    constructor() {
        super("envoy.service.discovery.v3.DeltaDiscoveryRequest", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resource_names_subscribe", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "resource_names_unsubscribe", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "resource_locators_subscribe", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceLocator },
            { no: 9, name: "resource_locators_unsubscribe", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceLocator },
            { no: 5, name: "initial_resource_versions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "response_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "error_detail", kind: "message", T: () => Status }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.DeltaDiscoveryRequest" } });
    }
    create(value?: PartialMessage<DeltaDiscoveryRequest>): DeltaDiscoveryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeUrl = "";
        message.resourceNamesSubscribe = [];
        message.resourceNamesUnsubscribe = [];
        message.resourceLocatorsSubscribe = [];
        message.resourceLocatorsUnsubscribe = [];
        message.initialResourceVersions = {};
        message.responseNonce = "";
        if (value !== undefined)
            reflectionMergePartial<DeltaDiscoveryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeltaDiscoveryRequest): DeltaDiscoveryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* string type_url */ 2:
                    message.typeUrl = reader.string();
                    break;
                case /* repeated string resource_names_subscribe */ 3:
                    message.resourceNamesSubscribe.push(reader.string());
                    break;
                case /* repeated string resource_names_unsubscribe */ 4:
                    message.resourceNamesUnsubscribe.push(reader.string());
                    break;
                case /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators_subscribe */ 8:
                    message.resourceLocatorsSubscribe.push(ResourceLocator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators_unsubscribe */ 9:
                    message.resourceLocatorsUnsubscribe.push(ResourceLocator.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, string> initial_resource_versions */ 5:
                    this.binaryReadMap5(message.initialResourceVersions, reader, options);
                    break;
                case /* string response_nonce */ 6:
                    message.responseNonce = reader.string();
                    break;
                case /* google.rpc.Status error_detail */ 7:
                    message.errorDetail = Status.internalBinaryRead(reader, reader.uint32(), options, message.errorDetail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: DeltaDiscoveryRequest["initialResourceVersions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeltaDiscoveryRequest["initialResourceVersions"] | undefined, val: DeltaDiscoveryRequest["initialResourceVersions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.discovery.v3.DeltaDiscoveryRequest.initial_resource_versions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeltaDiscoveryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string type_url = 2; */
        if (message.typeUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.typeUrl);
        /* repeated string resource_names_subscribe = 3; */
        for (let i = 0; i < message.resourceNamesSubscribe.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.resourceNamesSubscribe[i]);
        /* repeated string resource_names_unsubscribe = 4; */
        for (let i = 0; i < message.resourceNamesUnsubscribe.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.resourceNamesUnsubscribe[i]);
        /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators_subscribe = 8; */
        for (let i = 0; i < message.resourceLocatorsSubscribe.length; i++)
            ResourceLocator.internalBinaryWrite(message.resourceLocatorsSubscribe[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.discovery.v3.ResourceLocator resource_locators_unsubscribe = 9; */
        for (let i = 0; i < message.resourceLocatorsUnsubscribe.length; i++)
            ResourceLocator.internalBinaryWrite(message.resourceLocatorsUnsubscribe[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> initial_resource_versions = 5; */
        for (let k of globalThis.Object.keys(message.initialResourceVersions))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.initialResourceVersions[k]).join();
        /* string response_nonce = 6; */
        if (message.responseNonce !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.responseNonce);
        /* google.rpc.Status error_detail = 7; */
        if (message.errorDetail)
            Status.internalBinaryWrite(message.errorDetail, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DeltaDiscoveryRequest
 */
export const DeltaDiscoveryRequest = new DeltaDiscoveryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeltaDiscoveryResponse$Type extends MessageType<DeltaDiscoveryResponse> {
    constructor() {
        super("envoy.service.discovery.v3.DeltaDiscoveryResponse", [
            { no: 1, name: "system_version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Resource },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "removed_resources", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "removed_resource_names", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceName },
            { no: 5, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "control_plane", kind: "message", T: () => ControlPlane }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.DeltaDiscoveryResponse" } });
    }
    create(value?: PartialMessage<DeltaDiscoveryResponse>): DeltaDiscoveryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.systemVersionInfo = "";
        message.resources = [];
        message.typeUrl = "";
        message.removedResources = [];
        message.removedResourceNames = [];
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<DeltaDiscoveryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeltaDiscoveryResponse): DeltaDiscoveryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string system_version_info */ 1:
                    message.systemVersionInfo = reader.string();
                    break;
                case /* repeated envoy.service.discovery.v3.Resource resources */ 2:
                    message.resources.push(Resource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* repeated string removed_resources */ 6:
                    message.removedResources.push(reader.string());
                    break;
                case /* repeated envoy.service.discovery.v3.ResourceName removed_resource_names */ 8:
                    message.removedResourceNames.push(ResourceName.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string nonce */ 5:
                    message.nonce = reader.string();
                    break;
                case /* envoy.config.core.v3.ControlPlane control_plane */ 7:
                    message.controlPlane = ControlPlane.internalBinaryRead(reader, reader.uint32(), options, message.controlPlane);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeltaDiscoveryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string system_version_info = 1; */
        if (message.systemVersionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.systemVersionInfo);
        /* repeated envoy.service.discovery.v3.Resource resources = 2; */
        for (let i = 0; i < message.resources.length; i++)
            Resource.internalBinaryWrite(message.resources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* repeated string removed_resources = 6; */
        for (let i = 0; i < message.removedResources.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.removedResources[i]);
        /* repeated envoy.service.discovery.v3.ResourceName removed_resource_names = 8; */
        for (let i = 0; i < message.removedResourceNames.length; i++)
            ResourceName.internalBinaryWrite(message.removedResourceNames[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string nonce = 5; */
        if (message.nonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nonce);
        /* envoy.config.core.v3.ControlPlane control_plane = 7; */
        if (message.controlPlane)
            ControlPlane.internalBinaryWrite(message.controlPlane, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DeltaDiscoveryResponse
 */
export const DeltaDiscoveryResponse = new DeltaDiscoveryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicParameterConstraints$Type extends MessageType<DynamicParameterConstraints> {
    constructor() {
        super("envoy.service.discovery.v3.DynamicParameterConstraints", [
            { no: 1, name: "constraint", kind: "message", oneof: "type", T: () => DynamicParameterConstraints_SingleConstraint },
            { no: 2, name: "or_constraints", kind: "message", oneof: "type", T: () => DynamicParameterConstraints_ConstraintList },
            { no: 3, name: "and_constraints", kind: "message", oneof: "type", T: () => DynamicParameterConstraints_ConstraintList },
            { no: 4, name: "not_constraints", kind: "message", oneof: "type", T: () => DynamicParameterConstraints }
        ]);
    }
    create(value?: PartialMessage<DynamicParameterConstraints>): DynamicParameterConstraints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DynamicParameterConstraints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicParameterConstraints): DynamicParameterConstraints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint constraint */ 1:
                    message.type = {
                        oneofKind: "constraint",
                        constraint: DynamicParameterConstraints_SingleConstraint.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).constraint)
                    };
                    break;
                case /* envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList or_constraints */ 2:
                    message.type = {
                        oneofKind: "orConstraints",
                        orConstraints: DynamicParameterConstraints_ConstraintList.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).orConstraints)
                    };
                    break;
                case /* envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList and_constraints */ 3:
                    message.type = {
                        oneofKind: "andConstraints",
                        andConstraints: DynamicParameterConstraints_ConstraintList.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).andConstraints)
                    };
                    break;
                case /* envoy.service.discovery.v3.DynamicParameterConstraints not_constraints */ 4:
                    message.type = {
                        oneofKind: "notConstraints",
                        notConstraints: DynamicParameterConstraints.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).notConstraints)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicParameterConstraints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint constraint = 1; */
        if (message.type.oneofKind === "constraint")
            DynamicParameterConstraints_SingleConstraint.internalBinaryWrite(message.type.constraint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList or_constraints = 2; */
        if (message.type.oneofKind === "orConstraints")
            DynamicParameterConstraints_ConstraintList.internalBinaryWrite(message.type.orConstraints, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList and_constraints = 3; */
        if (message.type.oneofKind === "andConstraints")
            DynamicParameterConstraints_ConstraintList.internalBinaryWrite(message.type.andConstraints, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v3.DynamicParameterConstraints not_constraints = 4; */
        if (message.type.oneofKind === "notConstraints")
            DynamicParameterConstraints.internalBinaryWrite(message.type.notConstraints, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DynamicParameterConstraints
 */
export const DynamicParameterConstraints = new DynamicParameterConstraints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicParameterConstraints_SingleConstraint$Type extends MessageType<DynamicParameterConstraints_SingleConstraint> {
    constructor() {
        super("envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", oneof: "constraintType", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "exists", kind: "message", oneof: "constraintType", T: () => DynamicParameterConstraints_SingleConstraint_Exists }
        ]);
    }
    create(value?: PartialMessage<DynamicParameterConstraints_SingleConstraint>): DynamicParameterConstraints_SingleConstraint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.constraintType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DynamicParameterConstraints_SingleConstraint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicParameterConstraints_SingleConstraint): DynamicParameterConstraints_SingleConstraint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.constraintType = {
                        oneofKind: "value",
                        value: reader.string()
                    };
                    break;
                case /* envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists exists */ 3:
                    message.constraintType = {
                        oneofKind: "exists",
                        exists: DynamicParameterConstraints_SingleConstraint_Exists.internalBinaryRead(reader, reader.uint32(), options, (message.constraintType as any).exists)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicParameterConstraints_SingleConstraint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.constraintType.oneofKind === "value")
            writer.tag(2, WireType.LengthDelimited).string(message.constraintType.value);
        /* envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists exists = 3; */
        if (message.constraintType.oneofKind === "exists")
            DynamicParameterConstraints_SingleConstraint_Exists.internalBinaryWrite(message.constraintType.exists, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint
 */
export const DynamicParameterConstraints_SingleConstraint = new DynamicParameterConstraints_SingleConstraint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicParameterConstraints_SingleConstraint_Exists$Type extends MessageType<DynamicParameterConstraints_SingleConstraint_Exists> {
    constructor() {
        super("envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists", []);
    }
    create(value?: PartialMessage<DynamicParameterConstraints_SingleConstraint_Exists>): DynamicParameterConstraints_SingleConstraint_Exists {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DynamicParameterConstraints_SingleConstraint_Exists>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicParameterConstraints_SingleConstraint_Exists): DynamicParameterConstraints_SingleConstraint_Exists {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DynamicParameterConstraints_SingleConstraint_Exists, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.SingleConstraint.Exists
 */
export const DynamicParameterConstraints_SingleConstraint_Exists = new DynamicParameterConstraints_SingleConstraint_Exists$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DynamicParameterConstraints_ConstraintList$Type extends MessageType<DynamicParameterConstraints_ConstraintList> {
    constructor() {
        super("envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList", [
            { no: 1, name: "constraints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DynamicParameterConstraints }
        ]);
    }
    create(value?: PartialMessage<DynamicParameterConstraints_ConstraintList>): DynamicParameterConstraints_ConstraintList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.constraints = [];
        if (value !== undefined)
            reflectionMergePartial<DynamicParameterConstraints_ConstraintList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DynamicParameterConstraints_ConstraintList): DynamicParameterConstraints_ConstraintList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.discovery.v3.DynamicParameterConstraints constraints */ 1:
                    message.constraints.push(DynamicParameterConstraints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DynamicParameterConstraints_ConstraintList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.discovery.v3.DynamicParameterConstraints constraints = 1; */
        for (let i = 0; i < message.constraints.length; i++)
            DynamicParameterConstraints.internalBinaryWrite(message.constraints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.DynamicParameterConstraints.ConstraintList
 */
export const DynamicParameterConstraints_ConstraintList = new DynamicParameterConstraints_ConstraintList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resource$Type extends MessageType<Resource> {
    constructor() {
        super("envoy.service.discovery.v3.Resource", [
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "resource_name", kind: "message", T: () => ResourceName },
            { no: 4, name: "aliases", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource", kind: "message", T: () => Any },
            { no: 6, name: "ttl", kind: "message", T: () => Duration },
            { no: 7, name: "cache_control", kind: "message", T: () => Resource_CacheControl },
            { no: 9, name: "metadata", kind: "message", T: () => Metadata }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.Resource" } });
    }
    create(value?: PartialMessage<Resource>): Resource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aliases = [];
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<Resource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resource): Resource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* envoy.service.discovery.v3.ResourceName resource_name */ 8:
                    message.resourceName = ResourceName.internalBinaryRead(reader, reader.uint32(), options, message.resourceName);
                    break;
                case /* repeated string aliases */ 4:
                    message.aliases.push(reader.string());
                    break;
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* google.protobuf.Any resource */ 2:
                    message.resource = Any.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* google.protobuf.Duration ttl */ 6:
                    message.ttl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.ttl);
                    break;
                case /* envoy.service.discovery.v3.Resource.CacheControl cache_control */ 7:
                    message.cacheControl = Resource_CacheControl.internalBinaryRead(reader, reader.uint32(), options, message.cacheControl);
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 9:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* envoy.service.discovery.v3.ResourceName resource_name = 8; */
        if (message.resourceName)
            ResourceName.internalBinaryWrite(message.resourceName, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string aliases = 4; */
        for (let i = 0; i < message.aliases.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.aliases[i]);
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* google.protobuf.Any resource = 2; */
        if (message.resource)
            Any.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration ttl = 6; */
        if (message.ttl)
            Duration.internalBinaryWrite(message.ttl, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.discovery.v3.Resource.CacheControl cache_control = 7; */
        if (message.cacheControl)
            Resource_CacheControl.internalBinaryWrite(message.cacheControl, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata = 9; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.Resource
 */
export const Resource = new Resource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resource_CacheControl$Type extends MessageType<Resource_CacheControl> {
    constructor() {
        super("envoy.service.discovery.v3.Resource.CacheControl", [
            { no: 1, name: "do_not_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Resource_CacheControl>): Resource_CacheControl {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.doNotCache = false;
        if (value !== undefined)
            reflectionMergePartial<Resource_CacheControl>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resource_CacheControl): Resource_CacheControl {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool do_not_cache */ 1:
                    message.doNotCache = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resource_CacheControl, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool do_not_cache = 1; */
        if (message.doNotCache !== false)
            writer.tag(1, WireType.Varint).bool(message.doNotCache);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.discovery.v3.Resource.CacheControl
 */
export const Resource_CacheControl = new Resource_CacheControl$Type();
