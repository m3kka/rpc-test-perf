// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/service/accesslog/v3/als.proto (package envoy.service.accesslog.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Node } from "../../../config/core/v3/base_pb.js";
import type { HTTPAccessLogEntry, TCPAccessLogEntry } from "../../../data/accesslog/v3/accesslog_pb.js";

/**
 * Empty response for the StreamAccessLogs API. Will never be sent. See below.
 *
 * @generated from message envoy.service.accesslog.v3.StreamAccessLogsResponse
 */
export declare class StreamAccessLogsResponse extends Message<StreamAccessLogsResponse> {
  constructor(data?: PartialMessage<StreamAccessLogsResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.accesslog.v3.StreamAccessLogsResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccessLogsResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccessLogsResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccessLogsResponse;

  static equals(a: StreamAccessLogsResponse | PlainMessage<StreamAccessLogsResponse> | undefined, b: StreamAccessLogsResponse | PlainMessage<StreamAccessLogsResponse> | undefined): boolean;
}

/**
 * Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
 * access logs without ever expecting a response.
 *
 * @generated from message envoy.service.accesslog.v3.StreamAccessLogsMessage
 */
export declare class StreamAccessLogsMessage extends Message<StreamAccessLogsMessage> {
  /**
   * Identifier data that will only be sent in the first message on the stream. This is effectively
   * structured metadata and is a performance optimization.
   *
   * @generated from field: envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier identifier = 1;
   */
  identifier?: StreamAccessLogsMessage_Identifier;

  /**
   * Batches of log entries of a single type. Generally speaking, a given stream should only
   * ever include one type of log entry.
   *
   * @generated from oneof envoy.service.accesslog.v3.StreamAccessLogsMessage.log_entries
   */
  logEntries: {
    /**
     * @generated from field: envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries http_logs = 2;
     */
    value: StreamAccessLogsMessage_HTTPAccessLogEntries;
    case: "httpLogs";
  } | {
    /**
     * @generated from field: envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries tcp_logs = 3;
     */
    value: StreamAccessLogsMessage_TCPAccessLogEntries;
    case: "tcpLogs";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<StreamAccessLogsMessage>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.accesslog.v3.StreamAccessLogsMessage";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccessLogsMessage;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage;

  static equals(a: StreamAccessLogsMessage | PlainMessage<StreamAccessLogsMessage> | undefined, b: StreamAccessLogsMessage | PlainMessage<StreamAccessLogsMessage> | undefined): boolean;
}

/**
 * @generated from message envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier
 */
export declare class StreamAccessLogsMessage_Identifier extends Message<StreamAccessLogsMessage_Identifier> {
  /**
   * The node sending the access log messages over the stream.
   *
   * @generated from field: envoy.config.core.v3.Node node = 1;
   */
  node?: Node;

  /**
   * The friendly name of the log configured in :ref:`CommonGrpcAccessLogConfig
   * <envoy_v3_api_msg_extensions.access_loggers.grpc.v3.CommonGrpcAccessLogConfig>`.
   *
   * @generated from field: string log_name = 2;
   */
  logName: string;

  constructor(data?: PartialMessage<StreamAccessLogsMessage_Identifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.accesslog.v3.StreamAccessLogsMessage.Identifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccessLogsMessage_Identifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_Identifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_Identifier;

  static equals(a: StreamAccessLogsMessage_Identifier | PlainMessage<StreamAccessLogsMessage_Identifier> | undefined, b: StreamAccessLogsMessage_Identifier | PlainMessage<StreamAccessLogsMessage_Identifier> | undefined): boolean;
}

/**
 * Wrapper for batches of HTTP access log entries.
 *
 * @generated from message envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries
 */
export declare class StreamAccessLogsMessage_HTTPAccessLogEntries extends Message<StreamAccessLogsMessage_HTTPAccessLogEntries> {
  /**
   * @generated from field: repeated envoy.data.accesslog.v3.HTTPAccessLogEntry log_entry = 1;
   */
  logEntry: HTTPAccessLogEntry[];

  constructor(data?: PartialMessage<StreamAccessLogsMessage_HTTPAccessLogEntries>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.accesslog.v3.StreamAccessLogsMessage.HTTPAccessLogEntries";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccessLogsMessage_HTTPAccessLogEntries;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_HTTPAccessLogEntries;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_HTTPAccessLogEntries;

  static equals(a: StreamAccessLogsMessage_HTTPAccessLogEntries | PlainMessage<StreamAccessLogsMessage_HTTPAccessLogEntries> | undefined, b: StreamAccessLogsMessage_HTTPAccessLogEntries | PlainMessage<StreamAccessLogsMessage_HTTPAccessLogEntries> | undefined): boolean;
}

/**
 * Wrapper for batches of TCP access log entries.
 *
 * @generated from message envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries
 */
export declare class StreamAccessLogsMessage_TCPAccessLogEntries extends Message<StreamAccessLogsMessage_TCPAccessLogEntries> {
  /**
   * @generated from field: repeated envoy.data.accesslog.v3.TCPAccessLogEntry log_entry = 1;
   */
  logEntry: TCPAccessLogEntry[];

  constructor(data?: PartialMessage<StreamAccessLogsMessage_TCPAccessLogEntries>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.accesslog.v3.StreamAccessLogsMessage.TCPAccessLogEntries";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamAccessLogsMessage_TCPAccessLogEntries;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_TCPAccessLogEntries;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamAccessLogsMessage_TCPAccessLogEntries;

  static equals(a: StreamAccessLogsMessage_TCPAccessLogEntries | PlainMessage<StreamAccessLogsMessage_TCPAccessLogEntries> | undefined, b: StreamAccessLogsMessage_TCPAccessLogEntries | PlainMessage<StreamAccessLogsMessage_TCPAccessLogEntries> | undefined): boolean;
}

