// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/service/health/v3/hds.proto (package envoy.service.health.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Locality, Node } from "../../../config/core/v3/base_pb.js";
import type { Endpoint } from "../../../config/endpoint/v3/endpoint_components_pb.js";
import type { HealthCheck, HealthStatus } from "../../../config/core/v3/health_check_pb.js";
import type { Cluster_TransportSocketMatch } from "../../../config/cluster/v3/cluster_pb.js";
import type { BindConfig } from "../../../config/core/v3/address_pb.js";

/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 *
 * @generated from message envoy.service.health.v3.Capability
 */
export declare class Capability extends Message<Capability> {
  /**
   * @generated from field: repeated envoy.service.health.v3.Capability.Protocol health_check_protocols = 1;
   */
  healthCheckProtocols: Capability_Protocol[];

  constructor(data?: PartialMessage<Capability>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.Capability";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Capability;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Capability;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Capability;

  static equals(a: Capability | PlainMessage<Capability> | undefined, b: Capability | PlainMessage<Capability> | undefined): boolean;
}

/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 *
 * @generated from enum envoy.service.health.v3.Capability.Protocol
 */
export declare enum Capability_Protocol {
  /**
   * @generated from enum value: HTTP = 0;
   */
  HTTP = 0,

  /**
   * @generated from enum value: TCP = 1;
   */
  TCP = 1,

  /**
   * @generated from enum value: REDIS = 2;
   */
  REDIS = 2,
}

/**
 * @generated from message envoy.service.health.v3.HealthCheckRequest
 */
export declare class HealthCheckRequest extends Message<HealthCheckRequest> {
  /**
   * @generated from field: envoy.config.core.v3.Node node = 1;
   */
  node?: Node;

  /**
   * @generated from field: envoy.service.health.v3.Capability capability = 2;
   */
  capability?: Capability;

  constructor(data?: PartialMessage<HealthCheckRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.HealthCheckRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckRequest;

  static equals(a: HealthCheckRequest | PlainMessage<HealthCheckRequest> | undefined, b: HealthCheckRequest | PlainMessage<HealthCheckRequest> | undefined): boolean;
}

/**
 * @generated from message envoy.service.health.v3.EndpointHealth
 */
export declare class EndpointHealth extends Message<EndpointHealth> {
  /**
   * @generated from field: envoy.config.endpoint.v3.Endpoint endpoint = 1;
   */
  endpoint?: Endpoint;

  /**
   * @generated from field: envoy.config.core.v3.HealthStatus health_status = 2;
   */
  healthStatus: HealthStatus;

  constructor(data?: PartialMessage<EndpointHealth>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.EndpointHealth";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndpointHealth;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndpointHealth;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndpointHealth;

  static equals(a: EndpointHealth | PlainMessage<EndpointHealth> | undefined, b: EndpointHealth | PlainMessage<EndpointHealth> | undefined): boolean;
}

/**
 * Group endpoint health by locality under each cluster.
 *
 * @generated from message envoy.service.health.v3.LocalityEndpointsHealth
 */
export declare class LocalityEndpointsHealth extends Message<LocalityEndpointsHealth> {
  /**
   * @generated from field: envoy.config.core.v3.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * @generated from field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 2;
   */
  endpointsHealth: EndpointHealth[];

  constructor(data?: PartialMessage<LocalityEndpointsHealth>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.LocalityEndpointsHealth";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityEndpointsHealth;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityEndpointsHealth;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityEndpointsHealth;

  static equals(a: LocalityEndpointsHealth | PlainMessage<LocalityEndpointsHealth> | undefined, b: LocalityEndpointsHealth | PlainMessage<LocalityEndpointsHealth> | undefined): boolean;
}

/**
 * The health status of endpoints in a cluster. The cluster name and locality
 * should match the corresponding fields in ClusterHealthCheck message.
 *
 * @generated from message envoy.service.health.v3.ClusterEndpointsHealth
 */
export declare class ClusterEndpointsHealth extends Message<ClusterEndpointsHealth> {
  /**
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * @generated from field: repeated envoy.service.health.v3.LocalityEndpointsHealth locality_endpoints_health = 2;
   */
  localityEndpointsHealth: LocalityEndpointsHealth[];

  constructor(data?: PartialMessage<ClusterEndpointsHealth>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.ClusterEndpointsHealth";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterEndpointsHealth;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterEndpointsHealth;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterEndpointsHealth;

  static equals(a: ClusterEndpointsHealth | PlainMessage<ClusterEndpointsHealth> | undefined, b: ClusterEndpointsHealth | PlainMessage<ClusterEndpointsHealth> | undefined): boolean;
}

/**
 * @generated from message envoy.service.health.v3.EndpointHealthResponse
 */
export declare class EndpointHealthResponse extends Message<EndpointHealthResponse> {
  /**
   * Deprecated - Flat list of endpoint health information.
   *
   * @generated from field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 1 [deprecated = true];
   * @deprecated
   */
  endpointsHealth: EndpointHealth[];

  /**
   * Organize Endpoint health information by cluster.
   *
   * @generated from field: repeated envoy.service.health.v3.ClusterEndpointsHealth cluster_endpoints_health = 2;
   */
  clusterEndpointsHealth: ClusterEndpointsHealth[];

  constructor(data?: PartialMessage<EndpointHealthResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.EndpointHealthResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndpointHealthResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndpointHealthResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndpointHealthResponse;

  static equals(a: EndpointHealthResponse | PlainMessage<EndpointHealthResponse> | undefined, b: EndpointHealthResponse | PlainMessage<EndpointHealthResponse> | undefined): boolean;
}

/**
 * @generated from message envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse
 */
export declare class HealthCheckRequestOrEndpointHealthResponse extends Message<HealthCheckRequestOrEndpointHealthResponse> {
  /**
   * @generated from oneof envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse.request_type
   */
  requestType: {
    /**
     * @generated from field: envoy.service.health.v3.HealthCheckRequest health_check_request = 1;
     */
    value: HealthCheckRequest;
    case: "healthCheckRequest";
  } | {
    /**
     * @generated from field: envoy.service.health.v3.EndpointHealthResponse endpoint_health_response = 2;
     */
    value: EndpointHealthResponse;
    case: "endpointHealthResponse";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<HealthCheckRequestOrEndpointHealthResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckRequestOrEndpointHealthResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckRequestOrEndpointHealthResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckRequestOrEndpointHealthResponse;

  static equals(a: HealthCheckRequestOrEndpointHealthResponse | PlainMessage<HealthCheckRequestOrEndpointHealthResponse> | undefined, b: HealthCheckRequestOrEndpointHealthResponse | PlainMessage<HealthCheckRequestOrEndpointHealthResponse> | undefined): boolean;
}

/**
 * @generated from message envoy.service.health.v3.LocalityEndpoints
 */
export declare class LocalityEndpoints extends Message<LocalityEndpoints> {
  /**
   * @generated from field: envoy.config.core.v3.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * @generated from field: repeated envoy.config.endpoint.v3.Endpoint endpoints = 2;
   */
  endpoints: Endpoint[];

  constructor(data?: PartialMessage<LocalityEndpoints>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.LocalityEndpoints";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityEndpoints;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityEndpoints;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityEndpoints;

  static equals(a: LocalityEndpoints | PlainMessage<LocalityEndpoints> | undefined, b: LocalityEndpoints | PlainMessage<LocalityEndpoints> | undefined): boolean;
}

/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.service.health.v3.ClusterHealthCheck
 */
export declare class ClusterHealthCheck extends Message<ClusterHealthCheck> {
  /**
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * @generated from field: repeated envoy.config.core.v3.HealthCheck health_checks = 2;
   */
  healthChecks: HealthCheck[];

  /**
   * @generated from field: repeated envoy.service.health.v3.LocalityEndpoints locality_endpoints = 3;
   */
  localityEndpoints: LocalityEndpoints[];

  /**
   * Optional map that gets filtered by :ref:`health_checks.transport_socket_match_criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>`
   * on connection when health checking. For more details, see
   * :ref:`config.cluster.v3.Cluster.transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
   *
   * @generated from field: repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 4;
   */
  transportSocketMatches: Cluster_TransportSocketMatch[];

  /**
   * Optional configuration used to bind newly established upstream connections.
   * If the address and port are empty, no bind will be performed.
   *
   * @generated from field: envoy.config.core.v3.BindConfig upstream_bind_config = 5;
   */
  upstreamBindConfig?: BindConfig;

  constructor(data?: PartialMessage<ClusterHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.ClusterHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterHealthCheck;

  static equals(a: ClusterHealthCheck | PlainMessage<ClusterHealthCheck> | undefined, b: ClusterHealthCheck | PlainMessage<ClusterHealthCheck> | undefined): boolean;
}

/**
 * @generated from message envoy.service.health.v3.HealthCheckSpecifier
 */
export declare class HealthCheckSpecifier extends Message<HealthCheckSpecifier> {
  /**
   * @generated from field: repeated envoy.service.health.v3.ClusterHealthCheck cluster_health_checks = 1;
   */
  clusterHealthChecks: ClusterHealthCheck[];

  /**
   * The default is 1 second.
   *
   * @generated from field: google.protobuf.Duration interval = 2;
   */
  interval?: Duration;

  constructor(data?: PartialMessage<HealthCheckSpecifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.HealthCheckSpecifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheckSpecifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheckSpecifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheckSpecifier;

  static equals(a: HealthCheckSpecifier | PlainMessage<HealthCheckSpecifier> | undefined, b: HealthCheckSpecifier | PlainMessage<HealthCheckSpecifier> | undefined): boolean;
}

/**
 * [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
 * services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
 *
 * @generated from message envoy.service.health.v3.HdsDummy
 */
export declare class HdsDummy extends Message<HdsDummy> {
  constructor(data?: PartialMessage<HdsDummy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.service.health.v3.HdsDummy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HdsDummy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HdsDummy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HdsDummy;

  static equals(a: HdsDummy | PlainMessage<HdsDummy> | undefined, b: HdsDummy | PlainMessage<HdsDummy> | undefined): boolean;
}

