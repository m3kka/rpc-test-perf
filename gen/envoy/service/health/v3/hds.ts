// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/health/v3/hds.proto" (package "envoy.service.health.v3", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../../google/protobuf/duration";
import { BindConfig } from "../../../config/core/v3/address";
import { Cluster_TransportSocketMatch } from "../../../config/cluster/v3/cluster";
import { HealthCheck } from "../../../config/core/v3/health_check";
import { Locality } from "../../../config/core/v3/base";
import { HealthStatus } from "../../../config/core/v3/health_check";
import { Endpoint } from "../../../config/endpoint/v3/endpoint_components";
import { Node } from "../../../config/core/v3/base";
/**
 * Defines supported protocols etc, so the management server can assign proper
 * endpoints to healthcheck.
 *
 * @generated from protobuf message envoy.service.health.v3.Capability
 */
export interface Capability {
    /**
     * @generated from protobuf field: repeated envoy.service.health.v3.Capability.Protocol health_check_protocols = 1;
     */
    healthCheckProtocols: Capability_Protocol[];
}
/**
 * Different Envoy instances may have different capabilities (e.g. Redis)
 * and/or have ports enabled for different protocols.
 *
 * @generated from protobuf enum envoy.service.health.v3.Capability.Protocol
 */
export enum Capability_Protocol {
    /**
     * @generated from protobuf enum value: HTTP = 0;
     */
    HTTP = 0,
    /**
     * @generated from protobuf enum value: TCP = 1;
     */
    TCP = 1,
    /**
     * @generated from protobuf enum value: REDIS = 2;
     */
    REDIS = 2
}
/**
 * @generated from protobuf message envoy.service.health.v3.HealthCheckRequest
 */
export interface HealthCheckRequest {
    /**
     * @generated from protobuf field: envoy.config.core.v3.Node node = 1;
     */
    node?: Node;
    /**
     * @generated from protobuf field: envoy.service.health.v3.Capability capability = 2;
     */
    capability?: Capability;
}
/**
 * @generated from protobuf message envoy.service.health.v3.EndpointHealth
 */
export interface EndpointHealth {
    /**
     * @generated from protobuf field: envoy.config.endpoint.v3.Endpoint endpoint = 1;
     */
    endpoint?: Endpoint;
    /**
     * @generated from protobuf field: envoy.config.core.v3.HealthStatus health_status = 2;
     */
    healthStatus: HealthStatus;
}
/**
 * Group endpoint health by locality under each cluster.
 *
 * @generated from protobuf message envoy.service.health.v3.LocalityEndpointsHealth
 */
export interface LocalityEndpointsHealth {
    /**
     * @generated from protobuf field: envoy.config.core.v3.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * @generated from protobuf field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 2;
     */
    endpointsHealth: EndpointHealth[];
}
/**
 * The health status of endpoints in a cluster. The cluster name and locality
 * should match the corresponding fields in ClusterHealthCheck message.
 *
 * @generated from protobuf message envoy.service.health.v3.ClusterEndpointsHealth
 */
export interface ClusterEndpointsHealth {
    /**
     * @generated from protobuf field: string cluster_name = 1;
     */
    clusterName: string;
    /**
     * @generated from protobuf field: repeated envoy.service.health.v3.LocalityEndpointsHealth locality_endpoints_health = 2;
     */
    localityEndpointsHealth: LocalityEndpointsHealth[];
}
/**
 * @generated from protobuf message envoy.service.health.v3.EndpointHealthResponse
 */
export interface EndpointHealthResponse {
    /**
     * Deprecated - Flat list of endpoint health information.
     *
     * @deprecated
     * @generated from protobuf field: repeated envoy.service.health.v3.EndpointHealth endpoints_health = 1 [deprecated = true];
     */
    endpointsHealth: EndpointHealth[];
    /**
     * Organize Endpoint health information by cluster.
     *
     * @generated from protobuf field: repeated envoy.service.health.v3.ClusterEndpointsHealth cluster_endpoints_health = 2;
     */
    clusterEndpointsHealth: ClusterEndpointsHealth[];
}
/**
 * @generated from protobuf message envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse
 */
export interface HealthCheckRequestOrEndpointHealthResponse {
    /**
     * @generated from protobuf oneof: request_type
     */
    requestType: {
        oneofKind: "healthCheckRequest";
        /**
         * @generated from protobuf field: envoy.service.health.v3.HealthCheckRequest health_check_request = 1;
         */
        healthCheckRequest: HealthCheckRequest;
    } | {
        oneofKind: "endpointHealthResponse";
        /**
         * @generated from protobuf field: envoy.service.health.v3.EndpointHealthResponse endpoint_health_response = 2;
         */
        endpointHealthResponse: EndpointHealthResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.service.health.v3.LocalityEndpoints
 */
export interface LocalityEndpoints {
    /**
     * @generated from protobuf field: envoy.config.core.v3.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * @generated from protobuf field: repeated envoy.config.endpoint.v3.Endpoint endpoints = 2;
     */
    endpoints: Endpoint[];
}
/**
 * The cluster name and locality is provided to Envoy for the endpoints that it
 * health checks to support statistics reporting, logging and debugging by the
 * Envoy instance (outside of HDS). For maximum usefulness, it should match the
 * same cluster structure as that provided by EDS.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.service.health.v3.ClusterHealthCheck
 */
export interface ClusterHealthCheck {
    /**
     * @generated from protobuf field: string cluster_name = 1;
     */
    clusterName: string;
    /**
     * @generated from protobuf field: repeated envoy.config.core.v3.HealthCheck health_checks = 2;
     */
    healthChecks: HealthCheck[];
    /**
     * @generated from protobuf field: repeated envoy.service.health.v3.LocalityEndpoints locality_endpoints = 3;
     */
    localityEndpoints: LocalityEndpoints[];
    /**
     * Optional map that gets filtered by :ref:`health_checks.transport_socket_match_criteria <envoy_v3_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>`
     * on connection when health checking. For more details, see
     * :ref:`config.cluster.v3.Cluster.transport_socket_matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 4;
     */
    transportSocketMatches: Cluster_TransportSocketMatch[];
    /**
     * Optional configuration used to bind newly established upstream connections.
     * If the address and port are empty, no bind will be performed.
     *
     * @generated from protobuf field: envoy.config.core.v3.BindConfig upstream_bind_config = 5;
     */
    upstreamBindConfig?: BindConfig;
}
/**
 * @generated from protobuf message envoy.service.health.v3.HealthCheckSpecifier
 */
export interface HealthCheckSpecifier {
    /**
     * @generated from protobuf field: repeated envoy.service.health.v3.ClusterHealthCheck cluster_health_checks = 1;
     */
    clusterHealthChecks: ClusterHealthCheck[];
    /**
     * The default is 1 second.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 2;
     */
    interval?: Duration;
}
/**
 * [#not-implemented-hide:] Not configuration. Workaround c++ protobuf issue with importing
 * services: https://github.com/google/protobuf/issues/4221 and protoxform to upgrade the file.
 *
 * @generated from protobuf message envoy.service.health.v3.HdsDummy
 */
export interface HdsDummy {
}
// @generated message type with reflection information, may provide speed optimized methods
class Capability$Type extends MessageType<Capability> {
    constructor() {
        super("envoy.service.health.v3.Capability", [
            { no: 1, name: "health_check_protocols", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["envoy.service.health.v3.Capability.Protocol", Capability_Protocol] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.Capability" } });
    }
    create(value?: PartialMessage<Capability>): Capability {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthCheckProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<Capability>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Capability): Capability {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.health.v3.Capability.Protocol health_check_protocols */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.healthCheckProtocols.push(reader.int32());
                    else
                        message.healthCheckProtocols.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Capability, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.health.v3.Capability.Protocol health_check_protocols = 1; */
        if (message.healthCheckProtocols.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.healthCheckProtocols.length; i++)
                writer.int32(message.healthCheckProtocols[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.Capability
 */
export const Capability = new Capability$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckRequest$Type extends MessageType<HealthCheckRequest> {
    constructor() {
        super("envoy.service.health.v3.HealthCheckRequest", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "capability", kind: "message", T: () => Capability }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.HealthCheckRequest" } });
    }
    create(value?: PartialMessage<HealthCheckRequest>): HealthCheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HealthCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckRequest): HealthCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* envoy.service.health.v3.Capability capability */ 2:
                    message.capability = Capability.internalBinaryRead(reader, reader.uint32(), options, message.capability);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.health.v3.Capability capability = 2; */
        if (message.capability)
            Capability.internalBinaryWrite(message.capability, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.HealthCheckRequest
 */
export const HealthCheckRequest = new HealthCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointHealth$Type extends MessageType<EndpointHealth> {
    constructor() {
        super("envoy.service.health.v3.EndpointHealth", [
            { no: 1, name: "endpoint", kind: "message", T: () => Endpoint },
            { no: 2, name: "health_status", kind: "enum", T: () => ["envoy.config.core.v3.HealthStatus", HealthStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.EndpointHealth" } });
    }
    create(value?: PartialMessage<EndpointHealth>): EndpointHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.healthStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<EndpointHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointHealth): EndpointHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.endpoint.v3.Endpoint endpoint */ 1:
                    message.endpoint = Endpoint.internalBinaryRead(reader, reader.uint32(), options, message.endpoint);
                    break;
                case /* envoy.config.core.v3.HealthStatus health_status */ 2:
                    message.healthStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.endpoint.v3.Endpoint endpoint = 1; */
        if (message.endpoint)
            Endpoint.internalBinaryWrite(message.endpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthStatus health_status = 2; */
        if (message.healthStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.healthStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.EndpointHealth
 */
export const EndpointHealth = new EndpointHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityEndpointsHealth$Type extends MessageType<LocalityEndpointsHealth> {
    constructor() {
        super("envoy.service.health.v3.LocalityEndpointsHealth", [
            { no: 1, name: "locality", kind: "message", T: () => Locality },
            { no: 2, name: "endpoints_health", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointHealth }
        ]);
    }
    create(value?: PartialMessage<LocalityEndpointsHealth>): LocalityEndpointsHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpointsHealth = [];
        if (value !== undefined)
            reflectionMergePartial<LocalityEndpointsHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityEndpointsHealth): LocalityEndpointsHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Locality locality */ 1:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* repeated envoy.service.health.v3.EndpointHealth endpoints_health */ 2:
                    message.endpointsHealth.push(EndpointHealth.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityEndpointsHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Locality locality = 1; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.health.v3.EndpointHealth endpoints_health = 2; */
        for (let i = 0; i < message.endpointsHealth.length; i++)
            EndpointHealth.internalBinaryWrite(message.endpointsHealth[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.LocalityEndpointsHealth
 */
export const LocalityEndpointsHealth = new LocalityEndpointsHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterEndpointsHealth$Type extends MessageType<ClusterEndpointsHealth> {
    constructor() {
        super("envoy.service.health.v3.ClusterEndpointsHealth", [
            { no: 1, name: "cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "locality_endpoints_health", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocalityEndpointsHealth }
        ]);
    }
    create(value?: PartialMessage<ClusterEndpointsHealth>): ClusterEndpointsHealth {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.localityEndpointsHealth = [];
        if (value !== undefined)
            reflectionMergePartial<ClusterEndpointsHealth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterEndpointsHealth): ClusterEndpointsHealth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_name */ 1:
                    message.clusterName = reader.string();
                    break;
                case /* repeated envoy.service.health.v3.LocalityEndpointsHealth locality_endpoints_health */ 2:
                    message.localityEndpointsHealth.push(LocalityEndpointsHealth.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterEndpointsHealth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_name = 1; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* repeated envoy.service.health.v3.LocalityEndpointsHealth locality_endpoints_health = 2; */
        for (let i = 0; i < message.localityEndpointsHealth.length; i++)
            LocalityEndpointsHealth.internalBinaryWrite(message.localityEndpointsHealth[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.ClusterEndpointsHealth
 */
export const ClusterEndpointsHealth = new ClusterEndpointsHealth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointHealthResponse$Type extends MessageType<EndpointHealthResponse> {
    constructor() {
        super("envoy.service.health.v3.EndpointHealthResponse", [
            { no: 1, name: "endpoints_health", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointHealth, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 2, name: "cluster_endpoints_health", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterEndpointsHealth }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.EndpointHealthResponse" } });
    }
    create(value?: PartialMessage<EndpointHealthResponse>): EndpointHealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpointsHealth = [];
        message.clusterEndpointsHealth = [];
        if (value !== undefined)
            reflectionMergePartial<EndpointHealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointHealthResponse): EndpointHealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.health.v3.EndpointHealth endpoints_health = 1 [deprecated = true];*/ 1:
                    message.endpointsHealth.push(EndpointHealth.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.service.health.v3.ClusterEndpointsHealth cluster_endpoints_health */ 2:
                    message.clusterEndpointsHealth.push(ClusterEndpointsHealth.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointHealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.health.v3.EndpointHealth endpoints_health = 1 [deprecated = true]; */
        for (let i = 0; i < message.endpointsHealth.length; i++)
            EndpointHealth.internalBinaryWrite(message.endpointsHealth[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.health.v3.ClusterEndpointsHealth cluster_endpoints_health = 2; */
        for (let i = 0; i < message.clusterEndpointsHealth.length; i++)
            ClusterEndpointsHealth.internalBinaryWrite(message.clusterEndpointsHealth[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.EndpointHealthResponse
 */
export const EndpointHealthResponse = new EndpointHealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckRequestOrEndpointHealthResponse$Type extends MessageType<HealthCheckRequestOrEndpointHealthResponse> {
    constructor() {
        super("envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse", [
            { no: 1, name: "health_check_request", kind: "message", oneof: "requestType", T: () => HealthCheckRequest },
            { no: 2, name: "endpoint_health_response", kind: "message", oneof: "requestType", T: () => EndpointHealthResponse }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.HealthCheckRequestOrEndpointHealthResponse" } });
    }
    create(value?: PartialMessage<HealthCheckRequestOrEndpointHealthResponse>): HealthCheckRequestOrEndpointHealthResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheckRequestOrEndpointHealthResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckRequestOrEndpointHealthResponse): HealthCheckRequestOrEndpointHealthResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.health.v3.HealthCheckRequest health_check_request */ 1:
                    message.requestType = {
                        oneofKind: "healthCheckRequest",
                        healthCheckRequest: HealthCheckRequest.internalBinaryRead(reader, reader.uint32(), options, (message.requestType as any).healthCheckRequest)
                    };
                    break;
                case /* envoy.service.health.v3.EndpointHealthResponse endpoint_health_response */ 2:
                    message.requestType = {
                        oneofKind: "endpointHealthResponse",
                        endpointHealthResponse: EndpointHealthResponse.internalBinaryRead(reader, reader.uint32(), options, (message.requestType as any).endpointHealthResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckRequestOrEndpointHealthResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.health.v3.HealthCheckRequest health_check_request = 1; */
        if (message.requestType.oneofKind === "healthCheckRequest")
            HealthCheckRequest.internalBinaryWrite(message.requestType.healthCheckRequest, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.health.v3.EndpointHealthResponse endpoint_health_response = 2; */
        if (message.requestType.oneofKind === "endpointHealthResponse")
            EndpointHealthResponse.internalBinaryWrite(message.requestType.endpointHealthResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.HealthCheckRequestOrEndpointHealthResponse
 */
export const HealthCheckRequestOrEndpointHealthResponse = new HealthCheckRequestOrEndpointHealthResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityEndpoints$Type extends MessageType<LocalityEndpoints> {
    constructor() {
        super("envoy.service.health.v3.LocalityEndpoints", [
            { no: 1, name: "locality", kind: "message", T: () => Locality },
            { no: 2, name: "endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Endpoint }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.LocalityEndpoints" } });
    }
    create(value?: PartialMessage<LocalityEndpoints>): LocalityEndpoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endpoints = [];
        if (value !== undefined)
            reflectionMergePartial<LocalityEndpoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityEndpoints): LocalityEndpoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Locality locality */ 1:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* repeated envoy.config.endpoint.v3.Endpoint endpoints */ 2:
                    message.endpoints.push(Endpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityEndpoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Locality locality = 1; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.endpoint.v3.Endpoint endpoints = 2; */
        for (let i = 0; i < message.endpoints.length; i++)
            Endpoint.internalBinaryWrite(message.endpoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.LocalityEndpoints
 */
export const LocalityEndpoints = new LocalityEndpoints$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterHealthCheck$Type extends MessageType<ClusterHealthCheck> {
    constructor() {
        super("envoy.service.health.v3.ClusterHealthCheck", [
            { no: 1, name: "cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "health_checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck },
            { no: 3, name: "locality_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocalityEndpoints },
            { no: 4, name: "transport_socket_matches", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster_TransportSocketMatch },
            { no: 5, name: "upstream_bind_config", kind: "message", T: () => BindConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.ClusterHealthCheck" } });
    }
    create(value?: PartialMessage<ClusterHealthCheck>): ClusterHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterName = "";
        message.healthChecks = [];
        message.localityEndpoints = [];
        message.transportSocketMatches = [];
        if (value !== undefined)
            reflectionMergePartial<ClusterHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterHealthCheck): ClusterHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster_name */ 1:
                    message.clusterName = reader.string();
                    break;
                case /* repeated envoy.config.core.v3.HealthCheck health_checks */ 2:
                    message.healthChecks.push(HealthCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.service.health.v3.LocalityEndpoints locality_endpoints */ 3:
                    message.localityEndpoints.push(LocalityEndpoints.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches */ 4:
                    message.transportSocketMatches.push(Cluster_TransportSocketMatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.BindConfig upstream_bind_config */ 5:
                    message.upstreamBindConfig = BindConfig.internalBinaryRead(reader, reader.uint32(), options, message.upstreamBindConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster_name = 1; */
        if (message.clusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterName);
        /* repeated envoy.config.core.v3.HealthCheck health_checks = 2; */
        for (let i = 0; i < message.healthChecks.length; i++)
            HealthCheck.internalBinaryWrite(message.healthChecks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.service.health.v3.LocalityEndpoints locality_endpoints = 3; */
        for (let i = 0; i < message.localityEndpoints.length; i++)
            LocalityEndpoints.internalBinaryWrite(message.localityEndpoints[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.cluster.v3.Cluster.TransportSocketMatch transport_socket_matches = 4; */
        for (let i = 0; i < message.transportSocketMatches.length; i++)
            Cluster_TransportSocketMatch.internalBinaryWrite(message.transportSocketMatches[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.BindConfig upstream_bind_config = 5; */
        if (message.upstreamBindConfig)
            BindConfig.internalBinaryWrite(message.upstreamBindConfig, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.ClusterHealthCheck
 */
export const ClusterHealthCheck = new ClusterHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckSpecifier$Type extends MessageType<HealthCheckSpecifier> {
    constructor() {
        super("envoy.service.health.v3.HealthCheckSpecifier", [
            { no: 1, name: "cluster_health_checks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterHealthCheck },
            { no: 2, name: "interval", kind: "message", T: () => Duration }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.discovery.v2.HealthCheckSpecifier" } });
    }
    create(value?: PartialMessage<HealthCheckSpecifier>): HealthCheckSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterHealthChecks = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheckSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckSpecifier): HealthCheckSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.service.health.v3.ClusterHealthCheck cluster_health_checks */ 1:
                    message.clusterHealthChecks.push(ClusterHealthCheck.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration interval */ 2:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.service.health.v3.ClusterHealthCheck cluster_health_checks = 1; */
        for (let i = 0; i < message.clusterHealthChecks.length; i++)
            ClusterHealthCheck.internalBinaryWrite(message.clusterHealthChecks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval = 2; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.HealthCheckSpecifier
 */
export const HealthCheckSpecifier = new HealthCheckSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HdsDummy$Type extends MessageType<HdsDummy> {
    constructor() {
        super("envoy.service.health.v3.HdsDummy", []);
    }
    create(value?: PartialMessage<HdsDummy>): HdsDummy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HdsDummy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HdsDummy): HdsDummy {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HdsDummy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.health.v3.HdsDummy
 */
export const HdsDummy = new HdsDummy$Type();
/**
 * @generated ServiceType for protobuf service envoy.service.health.v3.HealthDiscoveryService
 */
export const HealthDiscoveryService = new ServiceType("envoy.service.health.v3.HealthDiscoveryService", [
    { name: "StreamHealthCheck", serverStreaming: true, clientStreaming: true, options: {}, I: HealthCheckRequestOrEndpointHealthResponse, O: HealthCheckSpecifier },
    { name: "FetchHealthCheck", options: { "google.api.http": { post: "/v3/discovery:health_check", body: "*" } }, I: HealthCheckRequestOrEndpointHealthResponse, O: HealthCheckSpecifier }
]);
