// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/ext_proc/v3/external_processor.proto" (package "envoy.service.ext_proc.v3", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderValueOption } from "../../../config/core/v3/base";
import { HttpStatus } from "../../../type/v3/http_status";
import { HeaderMap } from "../../../config/core/v3/base";
import { Duration } from "../../../../google/protobuf/duration";
import { ProcessingMode } from "../../../extensions/filters/http/ext_proc/v3/processing_mode";
import { Struct } from "../../../../google/protobuf/struct";
/**
 * This represents the different types of messages that Envoy can send
 * to an external processing server.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.ProcessingRequest
 */
export interface ProcessingRequest {
    /**
     * Specify whether the filter that sent this request is running in synchronous
     * or asynchronous mode. The choice of synchronous or asynchronous mode
     * can be set in the filter configuration, and defaults to false.
     *
     * * A value of ``false`` indicates that the server must respond
     *   to this message by either sending back a matching ProcessingResponse message,
     *   or by closing the stream.
     * * A value of ``true`` indicates that the server must not respond to this
     *   message, although it may still close the stream to indicate that no more messages
     *   are needed.
     *
     *
     * @generated from protobuf field: bool async_mode = 1;
     */
    asyncMode: boolean;
    /**
     * @generated from protobuf oneof: request
     */
    request: {
        oneofKind: "requestHeaders";
        /**
         * Information about the HTTP request headers, as well as peer info and additional
         * properties. Unless ``async_mode`` is ``true``, the server must send back a
         * HeaderResponse message, an ImmediateResponse message, or close the stream.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpHeaders request_headers = 2;
         */
        requestHeaders: HttpHeaders;
    } | {
        oneofKind: "responseHeaders";
        /**
         * Information about the HTTP response headers, as well as peer info and additional
         * properties. Unless ``async_mode`` is ``true``, the server must send back a
         * HeaderResponse message or close the stream.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpHeaders response_headers = 3;
         */
        responseHeaders: HttpHeaders;
    } | {
        oneofKind: "requestBody";
        /**
         * A chunk of the HTTP request body. Unless ``async_mode`` is true, the server must send back
         * a BodyResponse message, an ImmediateResponse message, or close the stream.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpBody request_body = 4;
         */
        requestBody: HttpBody;
    } | {
        oneofKind: "responseBody";
        /**
         * A chunk of the HTTP request body. Unless ``async_mode`` is ``true``, the server must send back
         * a BodyResponse message or close the stream.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpBody response_body = 5;
         */
        responseBody: HttpBody;
    } | {
        oneofKind: "requestTrailers";
        /**
         * The HTTP trailers for the request path. Unless ``async_mode`` is ``true``, the server
         * must send back a TrailerResponse message or close the stream.
         *
         * This message is only sent if the trailers processing mode is set to ``SEND``.
         * If there are no trailers on the original downstream request, then this message
         * will only be sent (with empty trailers waiting to be populated) if the
         * processing mode is set before the request headers are sent, such as
         * in the filter configuration.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpTrailers request_trailers = 6;
         */
        requestTrailers: HttpTrailers;
    } | {
        oneofKind: "responseTrailers";
        /**
         * The HTTP trailers for the response path. Unless ``async_mode`` is ``true``, the server
         * must send back a TrailerResponse message or close the stream.
         *
         * This message is only sent if the trailers processing mode is set to ``SEND``.
         * If there are no trailers on the original downstream request, then this message
         * will only be sent (with empty trailers waiting to be populated) if the
         * processing mode is set before the request headers are sent, such as
         * in the filter configuration.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HttpTrailers response_trailers = 7;
         */
        responseTrailers: HttpTrailers;
    } | {
        oneofKind: undefined;
    };
}
/**
 * For every ProcessingRequest received by the server with the ``async_mode`` field
 * set to false, the server must send back exactly one ProcessingResponse message.
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.ProcessingResponse
 */
export interface ProcessingResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "requestHeaders";
        /**
         * The server must send back this message in response to a message with the
         * ``request_headers`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HeadersResponse request_headers = 1;
         */
        requestHeaders: HeadersResponse;
    } | {
        oneofKind: "responseHeaders";
        /**
         * The server must send back this message in response to a message with the
         * ``response_headers`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.HeadersResponse response_headers = 2;
         */
        responseHeaders: HeadersResponse;
    } | {
        oneofKind: "requestBody";
        /**
         * The server must send back this message in response to a message with
         * the ``request_body`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.BodyResponse request_body = 3;
         */
        requestBody: BodyResponse;
    } | {
        oneofKind: "responseBody";
        /**
         * The server must send back this message in response to a message with
         * the ``response_body`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.BodyResponse response_body = 4;
         */
        responseBody: BodyResponse;
    } | {
        oneofKind: "requestTrailers";
        /**
         * The server must send back this message in response to a message with
         * the ``request_trailers`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.TrailersResponse request_trailers = 5;
         */
        requestTrailers: TrailersResponse;
    } | {
        oneofKind: "responseTrailers";
        /**
         * The server must send back this message in response to a message with
         * the ``response_trailers`` field set.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.TrailersResponse response_trailers = 6;
         */
        responseTrailers: TrailersResponse;
    } | {
        oneofKind: "immediateResponse";
        /**
         * If specified, attempt to create a locally generated response, send it
         * downstream, and stop processing additional filters and ignore any
         * additional messages received from the remote server for this request or
         * response. If a response has already started -- for example, if this
         * message is sent response to a ``response_body`` message -- then
         * this will either ship the reply directly to the downstream codec,
         * or reset the stream.
         *
         * @generated from protobuf field: envoy.service.ext_proc.v3.ImmediateResponse immediate_response = 7;
         */
        immediateResponse: ImmediateResponse;
    } | {
        oneofKind: undefined;
    };
    /**
     * [#not-implemented-hide:]
     * Optional metadata that will be emitted as dynamic metadata to be consumed by the next
     * filter. This metadata will be placed in the namespace ``envoy.filters.http.ext_proc``.
     *
     * @generated from protobuf field: google.protobuf.Struct dynamic_metadata = 8;
     */
    dynamicMetadata?: Struct;
    /**
     * Override how parts of the HTTP request and response are processed
     * for the duration of this particular request/response only. Servers
     * may use this to intelligently control how requests are processed
     * based on the headers and other metadata that they see.
     * This field is ignored by Envoy when the ext_proc filter config
     * :ref:`allow_mode_override
     * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.allow_mode_override>`
     * is set to false.
     *
     * @generated from protobuf field: envoy.extensions.filters.http.ext_proc.v3.ProcessingMode mode_override = 9;
     */
    modeOverride?: ProcessingMode;
    /**
     * When ext_proc server receives a request message, in case it needs more
     * time to process the message, it sends back a ProcessingResponse message
     * with a new timeout value. When Envoy receives this response message,
     * it ignores other fields in the response, just stop the original timer,
     * which has the timeout value specified in
     * :ref:`message_timeout
     * <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.message_timeout>`
     * and start a new timer with this ``override_message_timeout`` value and keep the
     * Envoy ext_proc filter state machine intact.
     * Has to be >= 1ms and <=
     * :ref:`max_message_timeout <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.max_message_timeout>`
     * Such message can be sent at most once in a particular Envoy ext_proc filter processing state.
     * To enable this API, one has to set ``max_message_timeout`` to a number >= 1ms.
     *
     * @generated from protobuf field: google.protobuf.Duration override_message_timeout = 10;
     */
    overrideMessageTimeout?: Duration;
}
// The following are messages that are sent to the server.

/**
 * This message is sent to the external server when the HTTP request and responses
 * are first received.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.HttpHeaders
 */
export interface HttpHeaders {
    /**
     * The HTTP request headers. All header keys will be
     * lower-cased, because HTTP header keys are case-insensitive.
     * The ``headers`` encoding is based on the runtime guard
     * envoy_reloadable_features_send_header_raw_value setting.
     * When it is true, the header value is encoded in the
     * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
     * When it is false, the header value is encoded in the
     * :ref:`value <envoy_v3_api_field_config.core.v3.HeaderValue.value>` field.
     *
     * @generated from protobuf field: envoy.config.core.v3.HeaderMap headers = 1;
     */
    headers?: HeaderMap;
    /**
     * [#not-implemented-hide:]
     * The values of properties selected by the ``request_attributes``
     * or ``response_attributes`` list in the configuration. Each entry
     * in the list is populated
     * from the standard :ref:`attributes <arch_overview_attributes>`
     * supported across Envoy.
     *
     * @generated from protobuf field: map<string, google.protobuf.Struct> attributes = 2;
     */
    attributes: {
        [key: string]: Struct;
    };
    /**
     * If true, then there is no message body associated with this
     * request or response.
     *
     * @generated from protobuf field: bool end_of_stream = 3;
     */
    endOfStream: boolean;
}
/**
 * This message contains the message body that Envoy sends to the external server.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.HttpBody
 */
export interface HttpBody {
    /**
     * @generated from protobuf field: bytes body = 1;
     */
    body: Uint8Array;
    /**
     * @generated from protobuf field: bool end_of_stream = 2;
     */
    endOfStream: boolean;
}
/**
 * This message contains the trailers.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.HttpTrailers
 */
export interface HttpTrailers {
    /**
     * The ``trailers`` encoding is based on the runtime guard
     * envoy_reloadable_features_send_header_raw_value setting.
     * When it is true, the header value is encoded in the
     * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
     * When it is false, the header value is encoded in the
     * :ref:`value <envoy_v3_api_field_config.core.v3.HeaderValue.value>` field.
     *
     * @generated from protobuf field: envoy.config.core.v3.HeaderMap trailers = 1;
     */
    trailers?: HeaderMap;
}
// The following are messages that may be sent back by the server.

/**
 * This message must be sent in response to an HttpHeaders message.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.HeadersResponse
 */
export interface HeadersResponse {
    /**
     * @generated from protobuf field: envoy.service.ext_proc.v3.CommonResponse response = 1;
     */
    response?: CommonResponse;
}
/**
 * This message must be sent in response to an HttpTrailers message.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.TrailersResponse
 */
export interface TrailersResponse {
    /**
     * Instructions on how to manipulate the trailers
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.HeaderMutation header_mutation = 1;
     */
    headerMutation?: HeaderMutation;
}
/**
 * This message must be sent in response to an HttpBody message.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.BodyResponse
 */
export interface BodyResponse {
    /**
     * @generated from protobuf field: envoy.service.ext_proc.v3.CommonResponse response = 1;
     */
    response?: CommonResponse;
}
/**
 * This message contains common fields between header and body responses.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.CommonResponse
 */
export interface CommonResponse {
    /**
     * If set, provide additional direction on how the Envoy proxy should
     * handle the rest of the HTTP filter chain.
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.CommonResponse.ResponseStatus status = 1;
     */
    status: CommonResponse_ResponseStatus;
    /**
     * Instructions on how to manipulate the headers. When responding to an
     * HttpBody request, header mutations will only take effect if
     * the current processing mode for the body is BUFFERED.
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.HeaderMutation header_mutation = 2;
     */
    headerMutation?: HeaderMutation;
    /**
     * Replace the body of the last message sent to the remote server on this
     * stream. If responding to an HttpBody request, simply replace or clear
     * the body chunk that was sent with that request. Body mutations may take
     * effect in response either to ``header`` or ``body`` messages. When it is
     * in response to ``header`` messages, it only take effect if the
     * :ref:`status <envoy_v3_api_field_service.ext_proc.v3.CommonResponse.status>`
     * is set to CONTINUE_AND_REPLACE.
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.BodyMutation body_mutation = 3;
     */
    bodyMutation?: BodyMutation;
    /**
     * [#not-implemented-hide:]
     * Add new trailers to the message. This may be used when responding to either a
     * HttpHeaders or HttpBody message, but only if this message is returned
     * along with the CONTINUE_AND_REPLACE status.
     * The ``trailers`` encoding is based on the runtime guard
     * envoy_reloadable_features_send_header_raw_value setting.
     * When it is true, the header value is encoded in the
     * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
     * When it is false, the header value is encoded in the
     * :ref:`value <envoy_v3_api_field_config.core.v3.HeaderValue.value>` field.
     *
     * @generated from protobuf field: envoy.config.core.v3.HeaderMap trailers = 4;
     */
    trailers?: HeaderMap;
    /**
     * Clear the route cache for the current client request. This is necessary
     * if the remote server modified headers that are used to calculate the route.
     * This field is ignored in the response direction.
     *
     * @generated from protobuf field: bool clear_route_cache = 5;
     */
    clearRouteCache: boolean;
}
/**
 * @generated from protobuf enum envoy.service.ext_proc.v3.CommonResponse.ResponseStatus
 */
export enum CommonResponse_ResponseStatus {
    /**
     * Apply the mutation instructions in this message to the
     * request or response, and then continue processing the filter
     * stream as normal. This is the default.
     *
     * @generated from protobuf enum value: CONTINUE = 0;
     */
    CONTINUE = 0,
    /**
     * Apply the specified header mutation, replace the body with the body
     * specified in the body mutation (if present), and do not send any
     * further messages for this request or response even if the processing
     * mode is configured to do so.
     *
     * When used in response to a request_headers or response_headers message,
     * this status makes it possible to either completely replace the body
     * while discarding the original body, or to add a body to a message that
     * formerly did not have one.
     *
     * In other words, this response makes it possible to turn an HTTP GET
     * into a POST, PUT, or PATCH.
     *
     * @generated from protobuf enum value: CONTINUE_AND_REPLACE = 1;
     */
    CONTINUE_AND_REPLACE = 1
}
/**
 * This message causes the filter to attempt to create a locally
 * generated response, send it  downstream, stop processing
 * additional filters, and ignore any additional messages received
 * from the remote server for this request or response. If a response
 * has already started, then  this will either ship the reply directly
 * to the downstream codec, or reset the stream.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.ImmediateResponse
 */
export interface ImmediateResponse {
    /**
     * The response code to return
     *
     * @generated from protobuf field: envoy.type.v3.HttpStatus status = 1;
     */
    status?: HttpStatus;
    /**
     * Apply changes to the default headers, which will include content-type.
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.HeaderMutation headers = 2;
     */
    headers?: HeaderMutation;
    /**
     * The message body to return with the response which is sent using the
     * text/plain content type, or encoded in the grpc-message header.
     *
     * @generated from protobuf field: string body = 3;
     */
    body: string;
    /**
     * If set, then include a gRPC status trailer.
     *
     * @generated from protobuf field: envoy.service.ext_proc.v3.GrpcStatus grpc_status = 4;
     */
    grpcStatus?: GrpcStatus;
    /**
     * A string detailing why this local reply was sent, which may be included
     * in log and debug output (e.g. this populates the %RESPONSE_CODE_DETAILS%
     * command operator field for use in access logging).
     *
     * @generated from protobuf field: string details = 5;
     */
    details: string;
}
/**
 * This message specifies a gRPC status for an ImmediateResponse message.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.GrpcStatus
 */
export interface GrpcStatus {
    /**
     * The actual gRPC status
     *
     * @generated from protobuf field: uint32 status = 1;
     */
    status: number;
}
/**
 * Change HTTP headers or trailers by appending, replacing, or removing
 * headers.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.HeaderMutation
 */
export interface HeaderMutation {
    /**
     * Add or replace HTTP headers. Attempts to set the value of
     * any ``x-envoy`` header, and attempts to set the ``:method``,
     * ``:authority``, ``:scheme``, or ``host`` headers will be ignored.
     * The ``set_headers`` encoding is based on the runtime guard
     * envoy_reloadable_features_send_header_raw_value setting.
     * When it is true, the header value is encoded in the
     * :ref:`raw_value <envoy_v3_api_field_config.core.v3.HeaderValue.raw_value>` field.
     * When it is false, the header value is encoded in the
     * :ref:`value <envoy_v3_api_field_config.core.v3.HeaderValue.value>` field.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption set_headers = 1;
     */
    setHeaders: HeaderValueOption[];
    /**
     * Remove these HTTP headers. Attempts to remove system headers --
     * any header starting with ``:``, plus ``host`` -- will be ignored.
     *
     * @generated from protobuf field: repeated string remove_headers = 2;
     */
    removeHeaders: string[];
}
/**
 * Replace the entire message body chunk received in the corresponding
 * HttpBody message with this new body, or clear the body.
 *
 * @generated from protobuf message envoy.service.ext_proc.v3.BodyMutation
 */
export interface BodyMutation {
    /**
     * @generated from protobuf oneof: mutation
     */
    mutation: {
        oneofKind: "body";
        /**
         * The entire body to replace
         *
         * @generated from protobuf field: bytes body = 1;
         */
        body: Uint8Array;
    } | {
        oneofKind: "clearBody";
        /**
         * Clear the corresponding body chunk
         *
         * @generated from protobuf field: bool clear_body = 2;
         */
        clearBody: boolean;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingRequest$Type extends MessageType<ProcessingRequest> {
    constructor() {
        super("envoy.service.ext_proc.v3.ProcessingRequest", [
            { no: 1, name: "async_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "request_headers", kind: "message", oneof: "request", T: () => HttpHeaders },
            { no: 3, name: "response_headers", kind: "message", oneof: "request", T: () => HttpHeaders },
            { no: 4, name: "request_body", kind: "message", oneof: "request", T: () => HttpBody },
            { no: 5, name: "response_body", kind: "message", oneof: "request", T: () => HttpBody },
            { no: 6, name: "request_trailers", kind: "message", oneof: "request", T: () => HttpTrailers },
            { no: 7, name: "response_trailers", kind: "message", oneof: "request", T: () => HttpTrailers }
        ]);
    }
    create(value?: PartialMessage<ProcessingRequest>): ProcessingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.asyncMode = false;
        message.request = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProcessingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingRequest): ProcessingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool async_mode */ 1:
                    message.asyncMode = reader.bool();
                    break;
                case /* envoy.service.ext_proc.v3.HttpHeaders request_headers */ 2:
                    message.request = {
                        oneofKind: "requestHeaders",
                        requestHeaders: HttpHeaders.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).requestHeaders)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HttpHeaders response_headers */ 3:
                    message.request = {
                        oneofKind: "responseHeaders",
                        responseHeaders: HttpHeaders.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).responseHeaders)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HttpBody request_body */ 4:
                    message.request = {
                        oneofKind: "requestBody",
                        requestBody: HttpBody.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).requestBody)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HttpBody response_body */ 5:
                    message.request = {
                        oneofKind: "responseBody",
                        responseBody: HttpBody.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).responseBody)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HttpTrailers request_trailers */ 6:
                    message.request = {
                        oneofKind: "requestTrailers",
                        requestTrailers: HttpTrailers.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).requestTrailers)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HttpTrailers response_trailers */ 7:
                    message.request = {
                        oneofKind: "responseTrailers",
                        responseTrailers: HttpTrailers.internalBinaryRead(reader, reader.uint32(), options, (message.request as any).responseTrailers)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool async_mode = 1; */
        if (message.asyncMode !== false)
            writer.tag(1, WireType.Varint).bool(message.asyncMode);
        /* envoy.service.ext_proc.v3.HttpHeaders request_headers = 2; */
        if (message.request.oneofKind === "requestHeaders")
            HttpHeaders.internalBinaryWrite(message.request.requestHeaders, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HttpHeaders response_headers = 3; */
        if (message.request.oneofKind === "responseHeaders")
            HttpHeaders.internalBinaryWrite(message.request.responseHeaders, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HttpBody request_body = 4; */
        if (message.request.oneofKind === "requestBody")
            HttpBody.internalBinaryWrite(message.request.requestBody, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HttpBody response_body = 5; */
        if (message.request.oneofKind === "responseBody")
            HttpBody.internalBinaryWrite(message.request.responseBody, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HttpTrailers request_trailers = 6; */
        if (message.request.oneofKind === "requestTrailers")
            HttpTrailers.internalBinaryWrite(message.request.requestTrailers, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HttpTrailers response_trailers = 7; */
        if (message.request.oneofKind === "responseTrailers")
            HttpTrailers.internalBinaryWrite(message.request.responseTrailers, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.ProcessingRequest
 */
export const ProcessingRequest = new ProcessingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProcessingResponse$Type extends MessageType<ProcessingResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.ProcessingResponse", [
            { no: 1, name: "request_headers", kind: "message", oneof: "response", T: () => HeadersResponse },
            { no: 2, name: "response_headers", kind: "message", oneof: "response", T: () => HeadersResponse },
            { no: 3, name: "request_body", kind: "message", oneof: "response", T: () => BodyResponse },
            { no: 4, name: "response_body", kind: "message", oneof: "response", T: () => BodyResponse },
            { no: 5, name: "request_trailers", kind: "message", oneof: "response", T: () => TrailersResponse },
            { no: 6, name: "response_trailers", kind: "message", oneof: "response", T: () => TrailersResponse },
            { no: 7, name: "immediate_response", kind: "message", oneof: "response", T: () => ImmediateResponse },
            { no: 8, name: "dynamic_metadata", kind: "message", T: () => Struct },
            { no: 9, name: "mode_override", kind: "message", T: () => ProcessingMode },
            { no: 10, name: "override_message_timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<ProcessingResponse>): ProcessingResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProcessingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProcessingResponse): ProcessingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ext_proc.v3.HeadersResponse request_headers */ 1:
                    message.response = {
                        oneofKind: "requestHeaders",
                        requestHeaders: HeadersResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).requestHeaders)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.HeadersResponse response_headers */ 2:
                    message.response = {
                        oneofKind: "responseHeaders",
                        responseHeaders: HeadersResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).responseHeaders)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.BodyResponse request_body */ 3:
                    message.response = {
                        oneofKind: "requestBody",
                        requestBody: BodyResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).requestBody)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.BodyResponse response_body */ 4:
                    message.response = {
                        oneofKind: "responseBody",
                        responseBody: BodyResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).responseBody)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.TrailersResponse request_trailers */ 5:
                    message.response = {
                        oneofKind: "requestTrailers",
                        requestTrailers: TrailersResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).requestTrailers)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.TrailersResponse response_trailers */ 6:
                    message.response = {
                        oneofKind: "responseTrailers",
                        responseTrailers: TrailersResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).responseTrailers)
                    };
                    break;
                case /* envoy.service.ext_proc.v3.ImmediateResponse immediate_response */ 7:
                    message.response = {
                        oneofKind: "immediateResponse",
                        immediateResponse: ImmediateResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).immediateResponse)
                    };
                    break;
                case /* google.protobuf.Struct dynamic_metadata */ 8:
                    message.dynamicMetadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.dynamicMetadata);
                    break;
                case /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode mode_override */ 9:
                    message.modeOverride = ProcessingMode.internalBinaryRead(reader, reader.uint32(), options, message.modeOverride);
                    break;
                case /* google.protobuf.Duration override_message_timeout */ 10:
                    message.overrideMessageTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.overrideMessageTimeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProcessingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ext_proc.v3.HeadersResponse request_headers = 1; */
        if (message.response.oneofKind === "requestHeaders")
            HeadersResponse.internalBinaryWrite(message.response.requestHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HeadersResponse response_headers = 2; */
        if (message.response.oneofKind === "responseHeaders")
            HeadersResponse.internalBinaryWrite(message.response.responseHeaders, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.BodyResponse request_body = 3; */
        if (message.response.oneofKind === "requestBody")
            BodyResponse.internalBinaryWrite(message.response.requestBody, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.BodyResponse response_body = 4; */
        if (message.response.oneofKind === "responseBody")
            BodyResponse.internalBinaryWrite(message.response.responseBody, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.TrailersResponse request_trailers = 5; */
        if (message.response.oneofKind === "requestTrailers")
            TrailersResponse.internalBinaryWrite(message.response.requestTrailers, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.TrailersResponse response_trailers = 6; */
        if (message.response.oneofKind === "responseTrailers")
            TrailersResponse.internalBinaryWrite(message.response.responseTrailers, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.ImmediateResponse immediate_response = 7; */
        if (message.response.oneofKind === "immediateResponse")
            ImmediateResponse.internalBinaryWrite(message.response.immediateResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct dynamic_metadata = 8; */
        if (message.dynamicMetadata)
            Struct.internalBinaryWrite(message.dynamicMetadata, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.http.ext_proc.v3.ProcessingMode mode_override = 9; */
        if (message.modeOverride)
            ProcessingMode.internalBinaryWrite(message.modeOverride, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration override_message_timeout = 10; */
        if (message.overrideMessageTimeout)
            Duration.internalBinaryWrite(message.overrideMessageTimeout, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.ProcessingResponse
 */
export const ProcessingResponse = new ProcessingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpHeaders$Type extends MessageType<HttpHeaders> {
    constructor() {
        super("envoy.service.ext_proc.v3.HttpHeaders", [
            { no: 1, name: "headers", kind: "message", T: () => HeaderMap },
            { no: 2, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 3, name: "end_of_stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HttpHeaders>): HttpHeaders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attributes = {};
        message.endOfStream = false;
        if (value !== undefined)
            reflectionMergePartial<HttpHeaders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpHeaders): HttpHeaders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HeaderMap headers */ 1:
                    message.headers = HeaderMap.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* map<string, google.protobuf.Struct> attributes */ 2:
                    this.binaryReadMap2(message.attributes, reader, options);
                    break;
                case /* bool end_of_stream */ 3:
                    message.endOfStream = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: HttpHeaders["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HttpHeaders["attributes"] | undefined, val: HttpHeaders["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.service.ext_proc.v3.HttpHeaders.attributes");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    internalBinaryWrite(message: HttpHeaders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HeaderMap headers = 1; */
        if (message.headers)
            HeaderMap.internalBinaryWrite(message.headers, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Struct> attributes = 2; */
        for (let k of globalThis.Object.keys(message.attributes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.attributes[k], writer, options);
            writer.join().join();
        }
        /* bool end_of_stream = 3; */
        if (message.endOfStream !== false)
            writer.tag(3, WireType.Varint).bool(message.endOfStream);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.HttpHeaders
 */
export const HttpHeaders = new HttpHeaders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpBody$Type extends MessageType<HttpBody> {
    constructor() {
        super("envoy.service.ext_proc.v3.HttpBody", [
            { no: 1, name: "body", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "end_of_stream", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HttpBody>): HttpBody {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.body = new Uint8Array(0);
        message.endOfStream = false;
        if (value !== undefined)
            reflectionMergePartial<HttpBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpBody): HttpBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body */ 1:
                    message.body = reader.bytes();
                    break;
                case /* bool end_of_stream */ 2:
                    message.endOfStream = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body = 1; */
        if (message.body.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.body);
        /* bool end_of_stream = 2; */
        if (message.endOfStream !== false)
            writer.tag(2, WireType.Varint).bool(message.endOfStream);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.HttpBody
 */
export const HttpBody = new HttpBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpTrailers$Type extends MessageType<HttpTrailers> {
    constructor() {
        super("envoy.service.ext_proc.v3.HttpTrailers", [
            { no: 1, name: "trailers", kind: "message", T: () => HeaderMap }
        ]);
    }
    create(value?: PartialMessage<HttpTrailers>): HttpTrailers {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HttpTrailers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpTrailers): HttpTrailers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HeaderMap trailers */ 1:
                    message.trailers = HeaderMap.internalBinaryRead(reader, reader.uint32(), options, message.trailers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpTrailers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HeaderMap trailers = 1; */
        if (message.trailers)
            HeaderMap.internalBinaryWrite(message.trailers, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.HttpTrailers
 */
export const HttpTrailers = new HttpTrailers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeadersResponse$Type extends MessageType<HeadersResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.HeadersResponse", [
            { no: 1, name: "response", kind: "message", T: () => CommonResponse }
        ]);
    }
    create(value?: PartialMessage<HeadersResponse>): HeadersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeadersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeadersResponse): HeadersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ext_proc.v3.CommonResponse response */ 1:
                    message.response = CommonResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeadersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ext_proc.v3.CommonResponse response = 1; */
        if (message.response)
            CommonResponse.internalBinaryWrite(message.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.HeadersResponse
 */
export const HeadersResponse = new HeadersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrailersResponse$Type extends MessageType<TrailersResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.TrailersResponse", [
            { no: 1, name: "header_mutation", kind: "message", T: () => HeaderMutation }
        ]);
    }
    create(value?: PartialMessage<TrailersResponse>): TrailersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TrailersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrailersResponse): TrailersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ext_proc.v3.HeaderMutation header_mutation */ 1:
                    message.headerMutation = HeaderMutation.internalBinaryRead(reader, reader.uint32(), options, message.headerMutation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrailersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ext_proc.v3.HeaderMutation header_mutation = 1; */
        if (message.headerMutation)
            HeaderMutation.internalBinaryWrite(message.headerMutation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.TrailersResponse
 */
export const TrailersResponse = new TrailersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BodyResponse$Type extends MessageType<BodyResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.BodyResponse", [
            { no: 1, name: "response", kind: "message", T: () => CommonResponse }
        ]);
    }
    create(value?: PartialMessage<BodyResponse>): BodyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BodyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BodyResponse): BodyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ext_proc.v3.CommonResponse response */ 1:
                    message.response = CommonResponse.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BodyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ext_proc.v3.CommonResponse response = 1; */
        if (message.response)
            CommonResponse.internalBinaryWrite(message.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.BodyResponse
 */
export const BodyResponse = new BodyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonResponse$Type extends MessageType<CommonResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.CommonResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["envoy.service.ext_proc.v3.CommonResponse.ResponseStatus", CommonResponse_ResponseStatus], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "header_mutation", kind: "message", T: () => HeaderMutation },
            { no: 3, name: "body_mutation", kind: "message", T: () => BodyMutation },
            { no: 4, name: "trailers", kind: "message", T: () => HeaderMap },
            { no: 5, name: "clear_route_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CommonResponse>): CommonResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.clearRouteCache = false;
        if (value !== undefined)
            reflectionMergePartial<CommonResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommonResponse): CommonResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.service.ext_proc.v3.CommonResponse.ResponseStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* envoy.service.ext_proc.v3.HeaderMutation header_mutation */ 2:
                    message.headerMutation = HeaderMutation.internalBinaryRead(reader, reader.uint32(), options, message.headerMutation);
                    break;
                case /* envoy.service.ext_proc.v3.BodyMutation body_mutation */ 3:
                    message.bodyMutation = BodyMutation.internalBinaryRead(reader, reader.uint32(), options, message.bodyMutation);
                    break;
                case /* envoy.config.core.v3.HeaderMap trailers */ 4:
                    message.trailers = HeaderMap.internalBinaryRead(reader, reader.uint32(), options, message.trailers);
                    break;
                case /* bool clear_route_cache */ 5:
                    message.clearRouteCache = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CommonResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.service.ext_proc.v3.CommonResponse.ResponseStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* envoy.service.ext_proc.v3.HeaderMutation header_mutation = 2; */
        if (message.headerMutation)
            HeaderMutation.internalBinaryWrite(message.headerMutation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.BodyMutation body_mutation = 3; */
        if (message.bodyMutation)
            BodyMutation.internalBinaryWrite(message.bodyMutation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HeaderMap trailers = 4; */
        if (message.trailers)
            HeaderMap.internalBinaryWrite(message.trailers, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool clear_route_cache = 5; */
        if (message.clearRouteCache !== false)
            writer.tag(5, WireType.Varint).bool(message.clearRouteCache);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.CommonResponse
 */
export const CommonResponse = new CommonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImmediateResponse$Type extends MessageType<ImmediateResponse> {
    constructor() {
        super("envoy.service.ext_proc.v3.ImmediateResponse", [
            { no: 1, name: "status", kind: "message", T: () => HttpStatus, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "headers", kind: "message", T: () => HeaderMutation },
            { no: 3, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "grpc_status", kind: "message", T: () => GrpcStatus },
            { no: 5, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ImmediateResponse>): ImmediateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.body = "";
        message.details = "";
        if (value !== undefined)
            reflectionMergePartial<ImmediateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImmediateResponse): ImmediateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.HttpStatus status */ 1:
                    message.status = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* envoy.service.ext_proc.v3.HeaderMutation headers */ 2:
                    message.headers = HeaderMutation.internalBinaryRead(reader, reader.uint32(), options, message.headers);
                    break;
                case /* string body */ 3:
                    message.body = reader.string();
                    break;
                case /* envoy.service.ext_proc.v3.GrpcStatus grpc_status */ 4:
                    message.grpcStatus = GrpcStatus.internalBinaryRead(reader, reader.uint32(), options, message.grpcStatus);
                    break;
                case /* string details */ 5:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImmediateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.HttpStatus status = 1; */
        if (message.status)
            HttpStatus.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.service.ext_proc.v3.HeaderMutation headers = 2; */
        if (message.headers)
            HeaderMutation.internalBinaryWrite(message.headers, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string body = 3; */
        if (message.body !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.body);
        /* envoy.service.ext_proc.v3.GrpcStatus grpc_status = 4; */
        if (message.grpcStatus)
            GrpcStatus.internalBinaryWrite(message.grpcStatus, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string details = 5; */
        if (message.details !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.ImmediateResponse
 */
export const ImmediateResponse = new ImmediateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrpcStatus$Type extends MessageType<GrpcStatus> {
    constructor() {
        super("envoy.service.ext_proc.v3.GrpcStatus", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GrpcStatus>): GrpcStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<GrpcStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcStatus): GrpcStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrpcStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.GrpcStatus
 */
export const GrpcStatus = new GrpcStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMutation$Type extends MessageType<HeaderMutation> {
    constructor() {
        super("envoy.service.ext_proc.v3.HeaderMutation", [
            { no: 1, name: "set_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption },
            { no: 2, name: "remove_headers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HeaderMutation>): HeaderMutation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.setHeaders = [];
        message.removeHeaders = [];
        if (value !== undefined)
            reflectionMergePartial<HeaderMutation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMutation): HeaderMutation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.core.v3.HeaderValueOption set_headers */ 1:
                    message.setHeaders.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string remove_headers */ 2:
                    message.removeHeaders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMutation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.core.v3.HeaderValueOption set_headers = 1; */
        for (let i = 0; i < message.setHeaders.length; i++)
            HeaderValueOption.internalBinaryWrite(message.setHeaders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string remove_headers = 2; */
        for (let i = 0; i < message.removeHeaders.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.removeHeaders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.HeaderMutation
 */
export const HeaderMutation = new HeaderMutation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BodyMutation$Type extends MessageType<BodyMutation> {
    constructor() {
        super("envoy.service.ext_proc.v3.BodyMutation", [
            { no: 1, name: "body", kind: "scalar", oneof: "mutation", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "clear_body", kind: "scalar", oneof: "mutation", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BodyMutation>): BodyMutation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mutation = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<BodyMutation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BodyMutation): BodyMutation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes body */ 1:
                    message.mutation = {
                        oneofKind: "body",
                        body: reader.bytes()
                    };
                    break;
                case /* bool clear_body */ 2:
                    message.mutation = {
                        oneofKind: "clearBody",
                        clearBody: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BodyMutation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes body = 1; */
        if (message.mutation.oneofKind === "body")
            writer.tag(1, WireType.LengthDelimited).bytes(message.mutation.body);
        /* bool clear_body = 2; */
        if (message.mutation.oneofKind === "clearBody")
            writer.tag(2, WireType.Varint).bool(message.mutation.clearBody);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.service.ext_proc.v3.BodyMutation
 */
export const BodyMutation = new BodyMutation$Type();
/**
 * @generated ServiceType for protobuf service envoy.service.ext_proc.v3.ExternalProcessor
 */
export const ExternalProcessor = new ServiceType("envoy.service.ext_proc.v3.ExternalProcessor", [
    { name: "Process", serverStreaming: true, clientStreaming: true, options: {}, I: ProcessingRequest, O: ProcessingResponse }
]);
