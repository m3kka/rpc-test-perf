// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/service/ext_proc/v3/external_processor.proto" (package "envoy.service.ext_proc.v3", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ExternalProcessor } from "./external_processor";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ProcessingResponse } from "./external_processor";
import type { ProcessingRequest } from "./external_processor";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
// [#protodoc-title: External processing service]

// A service that can access and modify HTTP requests and responses
// as part of a filter chain.
// The overall external processing protocol works like this:
// 
// 1. Envoy sends to the service information about the HTTP request.
// 2. The service sends back a ProcessingResponse message that directs Envoy
//    to either stop processing, continue without it, or send it the
//    next chunk of the message body.
// 3. If so requested, Envoy sends the server chunks of the message body,
//    or the entire body at once. In either case, the server sends back
//    a ProcessingResponse after each message it receives.
// 4. If so requested, Envoy sends the server the HTTP trailers,
//    and the server sends back a ProcessingResponse.
// 5. At this point, request processing is done, and we pick up again
//    at step 1 when Envoy receives a response from the upstream server.
// 6. At any point above, if the server closes the gRPC stream cleanly,
//    then Envoy proceeds without consulting the server.
// 7. At any point above, if the server closes the gRPC stream with an error,
//    then Envoy returns a 500 error to the client, unless the filter
//    was configured to ignore errors.
// 
// In other words, the process is a request/response conversation, but
// using a gRPC stream to make it easier for the server to
// maintain state.

/**
 * @generated from protobuf service envoy.service.ext_proc.v3.ExternalProcessor
 */
export interface IExternalProcessorClient {
    /**
     * This begins the bidirectional stream that Envoy will use to
     * give the server control over what the filter does. The actual
     * protocol is described by the ProcessingRequest and ProcessingResponse
     * messages below.
     *
     * @generated from protobuf rpc: Process(stream envoy.service.ext_proc.v3.ProcessingRequest) returns (stream envoy.service.ext_proc.v3.ProcessingResponse);
     */
    process(options?: RpcOptions): DuplexStreamingCall<ProcessingRequest, ProcessingResponse>;
}
// [#protodoc-title: External processing service]

// A service that can access and modify HTTP requests and responses
// as part of a filter chain.
// The overall external processing protocol works like this:
// 
// 1. Envoy sends to the service information about the HTTP request.
// 2. The service sends back a ProcessingResponse message that directs Envoy
//    to either stop processing, continue without it, or send it the
//    next chunk of the message body.
// 3. If so requested, Envoy sends the server chunks of the message body,
//    or the entire body at once. In either case, the server sends back
//    a ProcessingResponse after each message it receives.
// 4. If so requested, Envoy sends the server the HTTP trailers,
//    and the server sends back a ProcessingResponse.
// 5. At this point, request processing is done, and we pick up again
//    at step 1 when Envoy receives a response from the upstream server.
// 6. At any point above, if the server closes the gRPC stream cleanly,
//    then Envoy proceeds without consulting the server.
// 7. At any point above, if the server closes the gRPC stream with an error,
//    then Envoy returns a 500 error to the client, unless the filter
//    was configured to ignore errors.
// 
// In other words, the process is a request/response conversation, but
// using a gRPC stream to make it easier for the server to
// maintain state.

/**
 * @generated from protobuf service envoy.service.ext_proc.v3.ExternalProcessor
 */
export class ExternalProcessorClient implements IExternalProcessorClient, ServiceInfo {
    typeName = ExternalProcessor.typeName;
    methods = ExternalProcessor.methods;
    options = ExternalProcessor.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * This begins the bidirectional stream that Envoy will use to
     * give the server control over what the filter does. The actual
     * protocol is described by the ProcessingRequest and ProcessingResponse
     * messages below.
     *
     * @generated from protobuf rpc: Process(stream envoy.service.ext_proc.v3.ProcessingRequest) returns (stream envoy.service.ext_proc.v3.ProcessingResponse);
     */
    process(options?: RpcOptions): DuplexStreamingCall<ProcessingRequest, ProcessingResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ProcessingRequest, ProcessingResponse>("duplex", this._transport, method, opt);
    }
}
