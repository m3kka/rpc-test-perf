// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/route/v3/route_components.proto" (package "envoy.config.route.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int64Range } from "../../../type/v3/range";
import { MetadataKey } from "../../../type/metadata/v3/metadata";
import { CustomTag } from "../../../type/tracing/v3/custom_tag";
import { DataSource } from "../../core/v3/base";
import { FractionalPercent } from "../../../type/v3/percent";
import { ProxyProtocolConfig } from "../../core/v3/proxy_protocol";
import { RoutingPriority } from "../../core/v3/base";
import { Duration } from "../../../../google/protobuf/duration";
import { RegexMatchAndSubstitute } from "../../../type/matcher/v3/regex";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata";
import { RuntimeFractionalPercent } from "../../core/v3/base";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { RegexMatcher } from "../../../type/matcher/v3/regex";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { Metadata } from "../../core/v3/base";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
import { HeaderValueOption } from "../../core/v3/base";
import { Matcher } from "../../../../xds/type/matcher/v3/matcher";
// [#protodoc-title: HTTP route components]
// * Routing :ref:`architecture overview <arch_overview_http_routing>`
// * HTTP :ref:`router filter <config_http_filters_router>`

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 24]
 *
 * @generated from protobuf message envoy.config.route.v3.VirtualHost
 */
export interface VirtualHost {
    /**
     * The logical name of the virtual host. This is used when emitting certain
     * statistics but is not relevant for routing.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A list of domains (host/authority header) that will be matched to this
     * virtual host. Wildcard hosts are supported in the suffix or prefix form.
     *
     * Domain search order:
     *  1. Exact domain names: ``www.foo.com``.
     *  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
     *  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
     *  4. Special wildcard ``*`` matching any domain.
     *
     * .. note::
     *
     *   The wildcard will not match the empty string.
     *   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
     *   The longest wildcards match first.
     *   Only a single virtual host in the entire route configuration can match on ``*``. A domain
     *   must be unique across all virtual hosts or the config will fail to load.
     *
     * Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
     *
     * @generated from protobuf field: repeated string domains = 2;
     */
    domains: string[];
    /**
     * The list of routes that will be matched, in order, for incoming requests.
     * The first route that matches will be used.
     * Only one of this and ``matcher`` can be specified.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.Route routes = 3;
     */
    routes: Route[];
    /**
     * [#next-major-version: This should be included in a oneof with routes wrapped in a message.]
     * The match tree to use when resolving route actions for incoming requests. Only one of this and ``routes``
     * can be specified.
     *
     * @generated from protobuf field: xds.type.matcher.v3.Matcher matcher = 21;
     */
    matcher?: Matcher;
    /**
     * Specifies the type of TLS enforcement the virtual host expects. If this option is not
     * specified, there is no TLS requirement for the virtual host.
     *
     * @generated from protobuf field: envoy.config.route.v3.VirtualHost.TlsRequirementType require_tls = 4;
     */
    requireTls: VirtualHost_TlsRequirementType;
    /**
     * A list of virtual clusters defined for this virtual host. Virtual clusters
     * are used for additional statistics gathering.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.VirtualCluster virtual_clusters = 5;
     */
    virtualClusters: VirtualCluster[];
    /**
     * Specifies a set of rate limit configurations that will be applied to the
     * virtual host.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RateLimit rate_limits = 6;
     */
    rateLimits: RateLimit[];
    /**
     * Specifies a list of HTTP headers that should be added to each request
     * handled by this virtual host. Headers specified at this level are applied
     * after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
     * enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 7;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request
     * handled by this virtual host.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 13;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a list of HTTP headers that should be added to each response
     * handled by this virtual host. Headers specified at this level are applied
     * after headers from enclosed :ref:`envoy_v3_api_msg_config.route.v3.Route` and before headers from the
     * enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each response
     * handled by this virtual host.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 11;
     */
    responseHeadersToRemove: string[];
    /**
     * Indicates that the virtual host has a CORS policy. This field is ignored if related cors policy is
     * found in the
     * :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`.
     *
     * .. attention::
     *
     *   This option has been deprecated. Please use
     *   :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`
     *   to configure the CORS HTTP filter.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.route.v3.CorsPolicy cors = 8 [deprecated = true];
     */
    cors?: CorsPolicy;
    /**
     * The per_filter_config field can be used to provide virtual host-specific configurations for filters.
     * The key should match the :ref:`filter config name
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
     * The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
     * be used for the backwards compatibility. If there is no entry referred by the filter config name, the
     * entry referred by the canonical filter name will be provided to the filters as fallback.
     *
     * Use of this field is filter specific;
     * see the :ref:`HTTP filter documentation <config_http_filters>` for if and how it is utilized.
     * [#comment: An entry's value may be wrapped in a
     * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
     * message to specify additional options.]
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 15;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
    /**
     * Decides whether the :ref:`x-envoy-attempt-count
     * <config_http_filters_router_x-envoy-attempt-count>` header should be included
     * in the upstream request. Setting this option will cause it to override any existing header
     * value, so in the case of two Envoys on the request path with this option enabled, the upstream
     * will see the attempt count as perceived by the second Envoy. Defaults to false.
     * This header is unaffected by the
     * :ref:`suppress_envoy_headers
     * <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
     *
     * [#next-major-version: rename to include_attempt_count_in_request.]
     *
     * @generated from protobuf field: bool include_request_attempt_count = 14;
     */
    includeRequestAttemptCount: boolean;
    /**
     * Decides whether the :ref:`x-envoy-attempt-count
     * <config_http_filters_router_x-envoy-attempt-count>` header should be included
     * in the downstream response. Setting this option will cause the router to override any existing header
     * value, so in the case of two Envoys on the request path with this option enabled, the downstream
     * will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
     * This header is unaffected by the
     * :ref:`suppress_envoy_headers
     * <envoy_v3_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
     *
     * @generated from protobuf field: bool include_attempt_count_in_response = 19;
     */
    includeAttemptCountInResponse: boolean;
    /**
     * Indicates the retry policy for all routes in this virtual host. Note that setting a
     * route level entry will take precedence over this config and it'll be treated
     * independently (e.g.: values are not inherited).
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy retry_policy = 16;
     */
    retryPolicy?: RetryPolicy;
    /**
     * [#not-implemented-hide:]
     * Specifies the configuration for retry policy extension. Note that setting a route level entry
     * will take precedence over this config and it'll be treated independently (e.g.: values are not
     * inherited). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
     * set if this field is used.
     *
     * @generated from protobuf field: google.protobuf.Any retry_policy_typed_config = 20;
     */
    retryPolicyTypedConfig?: Any;
    /**
     * Indicates the hedge policy for all routes in this virtual host. Note that setting a
     * route level entry will take precedence over this config and it'll be treated
     * independently (e.g.: values are not inherited).
     *
     * @generated from protobuf field: envoy.config.route.v3.HedgePolicy hedge_policy = 17;
     */
    hedgePolicy?: HedgePolicy;
    /**
     * Decides whether to include the :ref:`x-envoy-is-timeout-retry <config_http_filters_router_x-envoy-is-timeout-retry>`
     * request header in retries initiated by per try timeouts.
     *
     * @generated from protobuf field: bool include_is_timeout_retry_header = 23;
     */
    includeIsTimeoutRetryHeader: boolean;
    /**
     * The maximum bytes which will be buffered for retries and shadowing.
     * If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
     * value of this and the listener per_connection_buffer_limit_bytes.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;
     */
    perRequestBufferLimitBytes?: UInt32Value;
    /**
     * Specify a set of default request mirroring policies for every route under this virtual host.
     * It takes precedence over the route config mirror policy entirely.
     * That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 22;
     */
    requestMirrorPolicies: RouteAction_RequestMirrorPolicy[];
}
/**
 * @generated from protobuf enum envoy.config.route.v3.VirtualHost.TlsRequirementType
 */
export enum VirtualHost_TlsRequirementType {
    /**
     * No TLS requirement for the virtual host.
     *
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * External requests must use TLS. If a request is external and it is not
     * using TLS, a 301 redirect will be sent telling the client to use HTTPS.
     *
     * @generated from protobuf enum value: EXTERNAL_ONLY = 1;
     */
    EXTERNAL_ONLY = 1,
    /**
     * All requests must use TLS. If a request is not using TLS, a 301 redirect
     * will be sent telling the client to use HTTPS.
     *
     * @generated from protobuf enum value: ALL = 2;
     */
    ALL = 2
}
/**
 * A filter-defined action type.
 *
 * @generated from protobuf message envoy.config.route.v3.FilterAction
 */
export interface FilterAction {
    /**
     * @generated from protobuf field: google.protobuf.Any action = 1;
     */
    action?: Any;
}
/**
 * This can be used in route matcher :ref:`VirtualHost.matcher <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
 * When the matcher matches, routes will be matched and run.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteList
 */
export interface RouteList {
    /**
     * The list of routes that will be matched and run, in order. The first route that matches will be used.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.Route routes = 1;
     */
    routes: Route[];
}
/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
 * [#next-free-field: 20]
 *
 * @generated from protobuf message envoy.config.route.v3.Route
 */
export interface Route {
    /**
     * Name for the route.
     *
     * @generated from protobuf field: string name = 14;
     */
    name: string;
    /**
     * Route matching parameters.
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteMatch match = 1;
     */
    match?: RouteMatch;
    /**
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "route";
        /**
         * Route request to some upstream cluster.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction route = 2;
         */
        route: RouteAction;
    } | {
        oneofKind: "redirect";
        /**
         * Return a redirect.
         *
         * @generated from protobuf field: envoy.config.route.v3.RedirectAction redirect = 3;
         */
        redirect: RedirectAction;
    } | {
        oneofKind: "directResponse";
        /**
         * Return an arbitrary HTTP response directly, without proxying.
         *
         * @generated from protobuf field: envoy.config.route.v3.DirectResponseAction direct_response = 7;
         */
        directResponse: DirectResponseAction;
    } | {
        oneofKind: "filterAction";
        /**
         * [#not-implemented-hide:]
         * A filter-defined action (e.g., it could dynamically generate the RouteAction).
         * [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
         * implemented]
         *
         * @generated from protobuf field: envoy.config.route.v3.FilterAction filter_action = 17;
         */
        filterAction: FilterAction;
    } | {
        oneofKind: "nonForwardingAction";
        /**
         * [#not-implemented-hide:]
         * An action used when the route will generate a response directly,
         * without forwarding to an upstream host. This will be used in non-proxy
         * xDS clients like the gRPC server. It could also be used in the future
         * in Envoy for a filter that directly generates responses for requests.
         *
         * @generated from protobuf field: envoy.config.route.v3.NonForwardingAction non_forwarding_action = 18;
         */
        nonForwardingAction: NonForwardingAction;
    } | {
        oneofKind: undefined;
    };
    /**
     * The Metadata field can be used to provide additional information
     * about the route. It can be used for configuration, stats, and logging.
     * The metadata should go under the filter namespace that will need it.
     * For instance, if the metadata is intended for the Router filter,
     * the filter name should be specified as ``envoy.filters.http.router``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 4;
     */
    metadata?: Metadata;
    /**
     * Decorator for the matched route.
     *
     * @generated from protobuf field: envoy.config.route.v3.Decorator decorator = 5;
     */
    decorator?: Decorator;
    /**
     * The per_filter_config field can be used to provide route-specific configurations for filters.
     * The key should match the :ref:`filter config name
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
     * The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
     * be used for the backwards compatibility. If there is no entry referred by the filter config name, the
     * entry referred by the canonical filter name will be provided to the filters as fallback.
     *
     * Use of this field is filter specific;
     * see the :ref:`HTTP filter documentation <config_http_filters>` for if and how it is utilized.
     * [#comment: An entry's value may be wrapped in a
     * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
     * message to specify additional options.]
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 13;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
    /**
     * Specifies a set of headers that will be added to requests matching this
     * route. Headers specified at this level are applied before headers from the
     * enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
     * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 9;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request
     * matching this route.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 12;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a set of headers that will be added to responses to requests
     * matching this route. Headers specified at this level are applied before
     * headers from the enclosing :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost` and
     * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on
     * :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each response
     * to requests matching this route.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 11;
     */
    responseHeadersToRemove: string[];
    /**
     * Presence of the object defines whether the connection manager's tracing configuration
     * is overridden by this route specific instance.
     *
     * @generated from protobuf field: envoy.config.route.v3.Tracing tracing = 15;
     */
    tracing?: Tracing;
    /**
     * The maximum bytes which will be buffered for retries and shadowing.
     * If set, the bytes actually buffered will be the minimum value of this and the
     * listener per_connection_buffer_limit_bytes.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;
     */
    perRequestBufferLimitBytes?: UInt32Value;
    /**
     * The human readable prefix to use when emitting statistics for this endpoint.
     * The statistics are rooted at vhost.<virtual host name>.route.<stat_prefix>.
     * This should be set for highly critical
     * endpoints that one wishes to get “per-route” statistics on.
     * If not set, endpoint statistics are not generated.
     *
     * The emitted statistics are the same as those documented for :ref:`virtual clusters <config_http_filters_router_vcluster_stats>`.
     *
     * .. warning::
     *
     *    We do not recommend setting up a stat prefix for
     *    every application endpoint. This is both not easily maintainable and
     *    statistics use a non-trivial amount of memory(approximately 1KiB per route).
     *
     * @generated from protobuf field: string stat_prefix = 19;
     */
    statPrefix: string;
}
/**
 * Compared to the :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 *
 * @generated from protobuf message envoy.config.route.v3.WeightedCluster
 */
export interface WeightedCluster {
    /**
     * Specifies one or more upstream clusters associated with the route.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.WeightedCluster.ClusterWeight clusters = 1;
     */
    clusters: WeightedCluster_ClusterWeight[];
    /**
     * Specifies the total weight across all clusters. The sum of all cluster weights must equal this
     * value, if this is greater than 0.
     * This field is now deprecated, and the client will use the sum of all
     * cluster weights. It is up to the management server to supply the correct weights.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.UInt32Value total_weight = 3 [deprecated = true];
     */
    totalWeight?: UInt32Value;
    /**
     * Specifies the runtime key prefix that should be used to construct the
     * runtime keys associated with each cluster. When the ``runtime_key_prefix`` is
     * specified, the router will look for weights associated with each upstream
     * cluster under the key ``runtime_key_prefix`` + ``.`` + ``cluster[i].name`` where
     * ``cluster[i]`` denotes an entry in the clusters array field. If the runtime
     * key for the cluster does not exist, the value specified in the
     * configuration file will be used as the default weight. See the :ref:`runtime documentation
     * <operations_runtime>` for how key names map to the underlying implementation.
     *
     * @generated from protobuf field: string runtime_key_prefix = 2;
     */
    runtimeKeyPrefix: string;
    /**
     * @generated from protobuf oneof: random_value_specifier
     */
    randomValueSpecifier: {
        oneofKind: "headerName";
        /**
         * Specifies the header name that is used to look up the random value passed in the request header.
         * This is used to ensure consistent cluster picking across multiple proxy levels for weighted traffic.
         * If header is not present or invalid, Envoy will fall back to use the internally generated random value.
         * This header is expected to be single-valued header as we only want to have one selected value throughout
         * the process for the consistency. And the value is a unsigned number between 0 and UINT64_MAX.
         *
         * @generated from protobuf field: string header_name = 4;
         */
        headerName: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.config.route.v3.WeightedCluster.ClusterWeight
 */
export interface WeightedCluster_ClusterWeight {
    /**
     * Only one of ``name`` and ``cluster_header`` may be specified.
     * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
     * Name of the upstream cluster. The cluster must exist in the
     * :ref:`cluster manager configuration <config_cluster_manager>`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Only one of ``name`` and ``cluster_header`` may be specified.
     * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1 }]
     * Envoy will determine the cluster to route to by reading the value of the
     * HTTP header named by cluster_header from the request headers. If the
     * header is not found or the referenced cluster does not exist, Envoy will
     * return a 404 response.
     *
     * .. attention::
     *
     *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
     *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from protobuf field: string cluster_header = 12;
     */
    clusterHeader: string;
    /**
     * The weight of the cluster. This value is relative to the other clusters'
     * weights. When a request matches the route, the choice of an upstream cluster
     * is determined by its weight. The sum of weights across all
     * entries in the clusters array must be greater than 0, and must not exceed
     * uint32_t maximal value (4294967295).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value weight = 2;
     */
    weight?: UInt32Value;
    /**
     * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
     * the upstream cluster with metadata matching what is set in this field will be considered for
     * load balancing. Note that this will be merged with what's provided in
     * :ref:`RouteAction.metadata_match <envoy_v3_api_field_config.route.v3.RouteAction.metadata_match>`, with
     * values here taking precedence. The filter name should be specified as ``envoy.lb``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata_match = 3;
     */
    metadataMatch?: Metadata;
    /**
     * Specifies a list of headers to be added to requests when this cluster is selected
     * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
     * Headers specified at this level are applied before headers from the enclosing
     * :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
     * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 4;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request when
     * this cluster is selected through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 9;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a list of headers to be added to responses when this cluster is selected
     * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
     * Headers specified at this level are applied before headers from the enclosing
     * :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`, and
     * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 5;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of headers to be removed from responses when this cluster is selected
     * through the enclosing :ref:`envoy_v3_api_msg_config.route.v3.RouteAction`.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 6;
     */
    responseHeadersToRemove: string[];
    /**
     * The per_filter_config field can be used to provide weighted cluster-specific configurations
     * for filters.
     * The key should match the :ref:`filter config name
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpFilter.name>`.
     * The canonical filter name (e.g., ``envoy.filters.http.buffer`` for the HTTP buffer filter) can also
     * be used for the backwards compatibility. If there is no entry referred by the filter config name, the
     * entry referred by the canonical filter name will be provided to the filters as fallback.
     *
     * Use of this field is filter specific;
     * see the :ref:`HTTP filter documentation <config_http_filters>` for if and how it is utilized.
     * [#comment: An entry's value may be wrapped in a
     * :ref:`FilterConfig<envoy_v3_api_msg_config.route.v3.FilterConfig>`
     * message to specify additional options.]
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 10;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
    /**
     * @generated from protobuf oneof: host_rewrite_specifier
     */
    hostRewriteSpecifier: {
        oneofKind: "hostRewriteLiteral";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * this value.
         *
         * @generated from protobuf field: string host_rewrite_literal = 11;
         */
        hostRewriteLiteral: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Configuration for a cluster specifier plugin.
 *
 * @generated from protobuf message envoy.config.route.v3.ClusterSpecifierPlugin
 */
export interface ClusterSpecifierPlugin {
    /**
     * The name of the plugin and its opaque configuration.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig extension = 1;
     */
    extension?: TypedExtensionConfig;
    /**
     * If is_optional is not set or is set to false and the plugin defined by this message is not a
     * supported type, the containing resource is NACKed. If is_optional is set to true, the resource
     * would not be NACKed for this reason. In this case, routes referencing this plugin's name would
     * not be treated as an illegal configuration, but would result in a failure if the route is
     * selected.
     *
     * @generated from protobuf field: bool is_optional = 2;
     */
    isOptional: boolean;
}
/**
 * [#next-free-field: 16]
 *
 * @generated from protobuf message envoy.config.route.v3.RouteMatch
 */
export interface RouteMatch {
    /**
     * @generated from protobuf oneof: path_specifier
     */
    pathSpecifier: {
        oneofKind: "prefix";
        /**
         * If specified, the route is a prefix rule meaning that the prefix must
         * match the beginning of the ``:path`` header.
         *
         * @generated from protobuf field: string prefix = 1;
         */
        prefix: string;
    } | {
        oneofKind: "path";
        /**
         * If specified, the route is an exact path rule meaning that the path must
         * exactly match the ``:path`` header once the query string is removed.
         *
         * @generated from protobuf field: string path = 2;
         */
        path: string;
    } | {
        oneofKind: "safeRegex";
        /**
         * If specified, the route is a regular expression rule meaning that the
         * regex must match the ``:path`` header once the query string is removed. The entire path
         * (without the query string) must match the regex. The rule will not match if only a
         * subsequence of the ``:path`` header matches the regex.
         *
         * [#next-major-version: In the v3 API we should redo how path specification works such
         * that we utilize StringMatcher, and additionally have consistent options around whether we
         * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
         * to deprecate the existing options. We should even consider whether we want to do away with
         * path_specifier entirely and just rely on a set of header matchers which can already match
         * on :path, etc. The issue with that is it is unclear how to generically deal with query string
         * stripping. This needs more thought.]
         *
         * @generated from protobuf field: envoy.type.matcher.v3.RegexMatcher safe_regex = 10;
         */
        safeRegex: RegexMatcher;
    } | {
        oneofKind: "connectMatcher";
        /**
         * If this is used as the matcher, the matcher will only match CONNECT requests.
         * Note that this will not match HTTP/2 upgrade-style CONNECT requests
         * (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
         * upgrades.
         * This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
         * where Extended CONNECT requests may have a path, the path matchers will work if
         * there is a path present.
         * Note that CONNECT support is currently considered alpha in Envoy.
         * [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12;
         */
        connectMatcher: RouteMatch_ConnectMatcher;
    } | {
        oneofKind: "pathSeparatedPrefix";
        /**
         * If specified, the route is a path-separated prefix rule meaning that the
         * ``:path`` header (without the query string) must either exactly match the
         * ``path_separated_prefix`` or have it as a prefix, followed by ``/``
         *
         * For example, ``/api/dev`` would match
         * ``/api/dev``, ``/api/dev/``, ``/api/dev/v1``, and ``/api/dev?param=true``
         * but would not match ``/api/developer``
         *
         * Expect the value to not contain ``?`` or ``#`` and not to end in ``/``
         *
         * @generated from protobuf field: string path_separated_prefix = 14;
         */
        pathSeparatedPrefix: string;
    } | {
        oneofKind: "pathMatchPolicy";
        /**
         * [#extension-category: envoy.path.match]
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig path_match_policy = 15;
         */
        pathMatchPolicy: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
    /**
     * Indicates that prefix/path matching should be case sensitive. The default
     * is true. Ignored for safe_regex matching.
     *
     * @generated from protobuf field: google.protobuf.BoolValue case_sensitive = 4;
     */
    caseSensitive?: BoolValue;
    /**
     * Indicates that the route should additionally match on a runtime key. Every time the route
     * is considered for a match, it must also fall under the percentage of matches indicated by
     * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
     * number is <= the value of the numerator N, or if the key is not present, the default
     * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
     * route configuration can be used to roll out route changes in a gradual manner without full
     * code/config deploys. Refer to the :ref:`traffic shifting
     * <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
     *
     * .. note::
     *
     *    Parsing this field is implemented such that the runtime key's data may be represented
     *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
     *    integer with the assumption that the value is an integral percentage out of 100. For
     *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
     *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Specifies a set of headers that the route should match on. The router will
     * check the request’s headers against all the specified headers in the route
     * config. A match will happen if all the headers in the route are present in
     * the request with the same values (or based on presence if the value field
     * is not in the config).
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 6;
     */
    headers: HeaderMatcher[];
    /**
     * Specifies a set of URL query parameters on which the route should
     * match. The router will check the query string from the ``path`` header
     * against all the specified query parameters. If the number of specified
     * query parameters is nonzero, they all must match the ``path`` header's
     * query string for a match to occur.
     *
     * .. note::
     *
     *    If query parameters are used to pass request message fields when
     *    `grpc_json_transcoder <https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/grpc_json_transcoder_filter>`_
     *    is used, the transcoded message fields maybe different. The query parameters are
     *    url encoded, but the message fields are not. For example, if a query
     *    parameter is "foo%20bar", the message field will be "foo bar".
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.QueryParameterMatcher query_parameters = 7;
     */
    queryParameters: QueryParameterMatcher[];
    /**
     * If specified, only gRPC requests will be matched. The router will check
     * that the content-type header has a application/grpc or one of the various
     * application/grpc+ values.
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8;
     */
    grpc?: RouteMatch_GrpcRouteMatchOptions;
    /**
     * If specified, the client tls context will be matched against the defined
     * match options.
     *
     * [#next-major-version: unify with RBAC]
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11;
     */
    tlsContext?: RouteMatch_TlsContextMatchOptions;
    /**
     * Specifies a set of dynamic metadata matchers on which the route should match.
     * The router will check the dynamic metadata against all the specified dynamic metadata matchers.
     * If the number of specified dynamic metadata matchers is nonzero, they all must match the
     * dynamic metadata for a match to occur.
     *
     * @generated from protobuf field: repeated envoy.type.matcher.v3.MetadataMatcher dynamic_metadata = 13;
     */
    dynamicMetadata: MetadataMatcher[];
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions
 */
export interface RouteMatch_GrpcRouteMatchOptions {
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteMatch.TlsContextMatchOptions
 */
export interface RouteMatch_TlsContextMatchOptions {
    /**
     * If specified, the route will match against whether or not a certificate is presented.
     * If not specified, certificate presentation status (true or false) will not be considered when route matching.
     *
     * @generated from protobuf field: google.protobuf.BoolValue presented = 1;
     */
    presented?: BoolValue;
    /**
     * If specified, the route will match against whether or not a certificate is validated.
     * If not specified, certificate validation status (true or false) will not be considered when route matching.
     *
     * @generated from protobuf field: google.protobuf.BoolValue validated = 2;
     */
    validated?: BoolValue;
}
/**
 * An extensible message for matching CONNECT requests.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteMatch.ConnectMatcher
 */
export interface RouteMatch_ConnectMatcher {
}
/**
 * Cors policy configuration.
 *
 * .. attention::
 *
 *   This message has been deprecated. Please use
 *   :ref:`CorsPolicy in filter extension <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
 *   as as alternative.
 *
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.config.route.v3.CorsPolicy
 */
export interface CorsPolicy {
    /**
     * Specifies string patterns that match allowed origins. An origin is allowed if any of the
     * string matchers match.
     *
     * @generated from protobuf field: repeated envoy.type.matcher.v3.StringMatcher allow_origin_string_match = 11;
     */
    allowOriginStringMatch: StringMatcher[];
    /**
     * Specifies the content for the ``access-control-allow-methods`` header.
     *
     * @generated from protobuf field: string allow_methods = 2;
     */
    allowMethods: string;
    /**
     * Specifies the content for the ``access-control-allow-headers`` header.
     *
     * @generated from protobuf field: string allow_headers = 3;
     */
    allowHeaders: string;
    /**
     * Specifies the content for the ``access-control-expose-headers`` header.
     *
     * @generated from protobuf field: string expose_headers = 4;
     */
    exposeHeaders: string;
    /**
     * Specifies the content for the ``access-control-max-age`` header.
     *
     * @generated from protobuf field: string max_age = 5;
     */
    maxAge: string;
    /**
     * Specifies whether the resource allows credentials.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_credentials = 6;
     */
    allowCredentials?: BoolValue;
    /**
     * @generated from protobuf oneof: enabled_specifier
     */
    enabledSpecifier: {
        oneofKind: "filterEnabled";
        /**
         * Specifies the % of requests for which the CORS filter is enabled.
         *
         * If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
         * filter will be enabled for 100% of the requests.
         *
         * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
         * specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
         *
         * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9;
         */
        filterEnabled: RuntimeFractionalPercent;
    } | {
        oneofKind: undefined;
    };
    /**
     * Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
     * enforced.
     *
     * This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
     * fields have to explicitly disable the filter in order for this setting to take effect.
     *
     * If :ref:`runtime_key <envoy_v3_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
     * Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
     * and track the request's ``Origin`` to determine if it's valid but will not enforce any policies.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent shadow_enabled = 10;
     */
    shadowEnabled?: RuntimeFractionalPercent;
    /**
     * Specify whether allow requests whose target server's IP address is more private than that from
     * which the request initiator was fetched.
     *
     * More details refer to https://developer.chrome.com/blog/private-network-access-preflight.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_private_network_access = 12;
     */
    allowPrivateNetworkAccess?: BoolValue;
}
/**
 * [#next-free-field: 42]
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction
 */
export interface RouteAction {
    /**
     * @generated from protobuf oneof: cluster_specifier
     */
    clusterSpecifier: {
        oneofKind: "cluster";
        /**
         * Indicates the upstream cluster to which the request should be routed
         * to.
         *
         * @generated from protobuf field: string cluster = 1;
         */
        cluster: string;
    } | {
        oneofKind: "clusterHeader";
        /**
         * Envoy will determine the cluster to route to by reading the value of the
         * HTTP header named by cluster_header from the request headers. If the
         * header is not found or the referenced cluster does not exist, Envoy will
         * return a 404 response.
         *
         * .. attention::
         *
         *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
         *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
         *
         * .. note::
         *
         *   If the header appears multiple times only the first value is used.
         *
         * @generated from protobuf field: string cluster_header = 2;
         */
        clusterHeader: string;
    } | {
        oneofKind: "weightedClusters";
        /**
         * Multiple upstream clusters can be specified for a given route. The
         * request is routed to one of the upstream clusters based on weights
         * assigned to each cluster. See
         * :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
         * for additional documentation.
         *
         * @generated from protobuf field: envoy.config.route.v3.WeightedCluster weighted_clusters = 3;
         */
        weightedClusters: WeightedCluster;
    } | {
        oneofKind: "clusterSpecifierPlugin";
        /**
         * Name of the cluster specifier plugin to use to determine the cluster for requests on this route.
         * The cluster specifier plugin name must be defined in the associated
         * :ref:`cluster specifier plugins <envoy_v3_api_field_config.route.v3.RouteConfiguration.cluster_specifier_plugins>`
         * in the :ref:`name <envoy_v3_api_field_config.core.v3.TypedExtensionConfig.name>` field.
         *
         * @generated from protobuf field: string cluster_specifier_plugin = 37;
         */
        clusterSpecifierPlugin: string;
    } | {
        oneofKind: "inlineClusterSpecifierPlugin";
        /**
         * Custom cluster specifier plugin configuration to use to determine the cluster for requests
         * on this route.
         *
         * @generated from protobuf field: envoy.config.route.v3.ClusterSpecifierPlugin inline_cluster_specifier_plugin = 39;
         */
        inlineClusterSpecifierPlugin: ClusterSpecifierPlugin;
    } | {
        oneofKind: undefined;
    };
    /**
     * The HTTP status code to use when configured cluster is not found.
     * The default response code is 503 Service Unavailable.
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20;
     */
    clusterNotFoundResponseCode: RouteAction_ClusterNotFoundResponseCode;
    /**
     * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
     * in the upstream cluster with metadata matching what's set in this field will be considered
     * for load balancing. If using :ref:`weighted_clusters
     * <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
     * provided there taking precedence. The filter name should be specified as ``envoy.lb``.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata_match = 4;
     */
    metadataMatch?: Metadata;
    /**
     * Indicates that during forwarding, the matched prefix (or path) should be
     * swapped with this value. This option allows application URLs to be rooted
     * at a different path from those exposed at the reverse proxy layer. The router filter will
     * place the original path before rewrite into the :ref:`x-envoy-original-path
     * <config_http_filters_router_x-envoy-original-path>` header.
     *
     * Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`
     * :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`,
     * or :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>` may be specified.
     *
     * .. attention::
     *
     *   Pay careful attention to the use of trailing slashes in the
     *   :ref:`route's match <envoy_v3_api_field_config.route.v3.Route.match>` prefix value.
     *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
     *   rewriting ``/prefix`` to ``/`` and ``/prefix/etc`` to ``/etc`` cannot be done in a single
     *   :ref:`Route <envoy_v3_api_msg_config.route.v3.Route>`, as shown by the below config entries:
     *
     *   .. code-block:: yaml
     *
     *     - match:
     *         prefix: "/prefix/"
     *       route:
     *         prefix_rewrite: "/"
     *     - match:
     *         prefix: "/prefix"
     *       route:
     *         prefix_rewrite: "/"
     *
     *   Having above entries in the config, requests to ``/prefix`` will be stripped to ``/``, while
     *   requests to ``/prefix/etc`` will be stripped to ``/etc``.
     *
     * @generated from protobuf field: string prefix_rewrite = 5;
     */
    prefixRewrite: string;
    /**
     * Indicates that during forwarding, portions of the path that match the
     * pattern should be rewritten, even allowing the substitution of capture
     * groups from the pattern into the new path as specified by the rewrite
     * substitution string. This is useful to allow application paths to be
     * rewritten in a way that is aware of segments with variable content like
     * identifiers. The router filter will place the original path as it was
     * before the rewrite into the :ref:`x-envoy-original-path
     * <config_http_filters_router_x-envoy-original-path>` header.
     *
     * Only one of :ref:`regex_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.regex_rewrite>`,
     * :ref:`prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`, or
     * :ref:`path_rewrite_policy <envoy_v3_api_field_config.route.v3.RouteAction.path_rewrite_policy>`]
     * may be specified.
     *
     * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
     *
     * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
     *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
     *   into ``/v1/api/instance/foo``.
     *
     * * The pattern ``one`` paired with a substitution string of ``two`` would
     *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
     *
     * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
     *   ``\1two\2`` would replace only the first occurrence of ``one``,
     *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
     *
     * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
     *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
     *   ``/aaa/yyy/bbb``.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32;
     */
    regexRewrite?: RegexMatchAndSubstitute;
    /**
     * [#extension-category: envoy.path.rewrite]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig path_rewrite_policy = 41;
     */
    pathRewritePolicy?: TypedExtensionConfig;
    /**
     * @generated from protobuf oneof: host_rewrite_specifier
     */
    hostRewriteSpecifier: {
        oneofKind: "hostRewriteLiteral";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * this value. Using this option will append the
         * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
         * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
         * is set.
         *
         * @generated from protobuf field: string host_rewrite_literal = 6;
         */
        hostRewriteLiteral: string;
    } | {
        oneofKind: "autoHostRewrite";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * the hostname of the upstream host chosen by the cluster manager. This
         * option is applicable only when the destination cluster for a route is of
         * type ``strict_dns`` or ``logical_dns``. Setting this to true with other cluster types
         * has no effect. Using this option will append the
         * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
         * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
         * is set.
         *
         * @generated from protobuf field: google.protobuf.BoolValue auto_host_rewrite = 7;
         */
        autoHostRewrite: BoolValue;
    } | {
        oneofKind: "hostRewriteHeader";
        /**
         * Indicates that during forwarding, the host header will be swapped with the content of given
         * downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
         * If header value is empty, host header is left intact. Using this option will append the
         * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
         * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
         * is set.
         *
         * .. attention::
         *
         *   Pay attention to the potential security implications of using this option. Provided header
         *   must come from trusted source.
         *
         * .. note::
         *
         *   If the header appears multiple times only the first value is used.
         *
         * @generated from protobuf field: string host_rewrite_header = 29;
         */
        hostRewriteHeader: string;
    } | {
        oneofKind: "hostRewritePathRegex";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * the result of the regex substitution executed on path value with query and fragment removed.
         * This is useful for transitioning variable content between path segment and subdomain.
         * Using this option will append the
         * :ref:`config_http_conn_man_headers_x-forwarded-host` header if
         * :ref:`append_x_forwarded_host <envoy_v3_api_field_config.route.v3.RouteAction.append_x_forwarded_host>`
         * is set.
         *
         * For example with the following config:
         *
         *   .. code-block:: yaml
         *
         *     host_rewrite_path_regex:
         *       pattern:
         *         google_re2: {}
         *         regex: "^/(.+)/.+$"
         *       substitution: \1
         *
         * Would rewrite the host header to ``envoyproxy.io`` given the path ``/envoyproxy.io/some/path``.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35;
         */
        hostRewritePathRegex: RegexMatchAndSubstitute;
    } | {
        oneofKind: undefined;
    };
    /**
     * If set, then a host rewrite action (one of
     * :ref:`host_rewrite_literal <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_literal>`,
     * :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`,
     * :ref:`host_rewrite_header <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_header>`, or
     * :ref:`host_rewrite_path_regex <envoy_v3_api_field_config.route.v3.RouteAction.host_rewrite_path_regex>`)
     * causes the original value of the host header, if any, to be appended to the
     * :ref:`config_http_conn_man_headers_x-forwarded-host` HTTP header if it is different to the last value appended.
     * This can be disabled by setting the runtime guard `envoy_reloadable_features_append_xfh_idempotent` to false.
     *
     * @generated from protobuf field: bool append_x_forwarded_host = 38;
     */
    appendXForwardedHost: boolean;
    /**
     * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
     * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
     * processed and when the upstream response has been completely processed. A value of 0 will
     * disable the route's timeout.
     *
     * .. note::
     *
     *   This timeout includes all retries. See also
     *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
     *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
     *   :ref:`retry overview <arch_overview_http_routing_retry>`.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 8;
     */
    timeout?: Duration;
    /**
     * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
     * although the connection manager wide :ref:`stream_idle_timeout
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
     * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
     * connection manager stream idle timeout is configured.
     *
     * The idle timeout is distinct to :ref:`timeout
     * <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
     * on the upstream response time; :ref:`idle_timeout
     * <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
     * of time the request's stream may be idle.
     *
     * After header decoding, the idle timeout will apply on downstream and
     * upstream request events. Each time an encode/decode event for headers or
     * data is processed for the stream, the timer will be reset. If the timeout
     * fires, the stream is terminated with a 408 Request Timeout error code if no
     * upstream response header has been received, otherwise a stream reset
     * occurs.
     *
     * If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
     * is configured, this timeout is scaled according to the value for
     * :ref:`HTTP_DOWNSTREAM_STREAM_IDLE <envoy_v3_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE>`.
     *
     * @generated from protobuf field: google.protobuf.Duration idle_timeout = 24;
     */
    idleTimeout?: Duration;
    /**
     * Specifies how to send request over TLS early data.
     * If absent, allows `safe HTTP requests <https://www.rfc-editor.org/rfc/rfc7231#section-4.2.1>`_ to be sent on early data.
     * [#extension-category: envoy.route.early_data_policy]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig early_data_policy = 40;
     */
    earlyDataPolicy?: TypedExtensionConfig;
    /**
     * Indicates that the route has a retry policy. Note that if this is set,
     * it'll take precedence over the virtual host level retry policy entirely
     * (e.g.: policies are not merged, most internal one becomes the enforced policy).
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy retry_policy = 9;
     */
    retryPolicy?: RetryPolicy;
    /**
     * [#not-implemented-hide:]
     * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
     * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
     * most internal one becomes the enforced policy). :ref:`Retry policy <envoy_v3_api_field_config.route.v3.VirtualHost.retry_policy>`
     * should not be set if this field is used.
     *
     * @generated from protobuf field: google.protobuf.Any retry_policy_typed_config = 33;
     */
    retryPolicyTypedConfig?: Any;
    /**
     * Specify a set of route request mirroring policies.
     * It takes precedence over the virtual host and route config mirror policy entirely.
     * That is, policies are not merged, the most specific non-empty one becomes the mirror policies.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;
     */
    requestMirrorPolicies: RouteAction_RequestMirrorPolicy[];
    /**
     * Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
     *
     * @generated from protobuf field: envoy.config.core.v3.RoutingPriority priority = 11;
     */
    priority: RoutingPriority;
    /**
     * Specifies a set of rate limit configurations that could be applied to the
     * route.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RateLimit rate_limits = 13;
     */
    rateLimits: RateLimit[];
    /**
     * Specifies if the rate limit filter should include the virtual host rate
     * limits. By default, if the route configured rate limits, the virtual host
     * :ref:`rate_limits <envoy_v3_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
     * request.
     *
     * This field is deprecated. Please use :ref:`vh_rate_limits <envoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits>`
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true];
     */
    includeVhRateLimits?: BoolValue;
    /**
     * Specifies a list of hash policies to use for ring hash load balancing. Each
     * hash policy is evaluated individually and the combined result is used to
     * route the request. The method of combination is deterministic such that
     * identical lists of hash policies will produce the same hash. Since a hash
     * policy examines specific parts of a request, it can fail to produce a hash
     * (i.e. if the hashed header is not present). If (and only if) all configured
     * hash policies fail to generate a hash, no hash will be produced for
     * the route. In this case, the behavior is the same as if no hash policies
     * were specified (i.e. the ring hash load balancer will choose a random
     * backend). If a hash policy has the "terminal" attribute set to true, and
     * there is already a hash generated, the hash is returned immediately,
     * ignoring the rest of the hash policy list.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15;
     */
    hashPolicy: RouteAction_HashPolicy[];
    /**
     * Indicates that the route has a CORS policy. This field is ignored if related cors policy is
     * found in the :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
     * :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`.
     *
     * .. attention::
     *
     *   This option has been deprecated. Please use
     *   :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>` or
     *   :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
     *   to configure the CORS HTTP filter.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.route.v3.CorsPolicy cors = 17 [deprecated = true];
     */
    cors?: CorsPolicy;
    /**
     * Deprecated by :ref:`grpc_timeout_header_max <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max>`
     * If present, and the request is a gRPC request, use the
     * `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
     * or its default value (infinity) instead of
     * :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
     * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
     * gRPC requests is infinity. If not configured at all, the ``grpc-timeout`` header is not used
     * and gRPC requests time out like any other requests using
     * :ref:`timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` or its default.
     * This can be used to prevent unexpected upstream request timeouts due to potentially long
     * time gaps between gRPC request and response in gRPC streaming mode.
     *
     * .. note::
     *
     *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
     *    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
     *    both are present. See also
     *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
     *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
     *    :ref:`retry overview <arch_overview_http_routing_retry>`.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true];
     */
    maxGrpcTimeout?: Duration;
    /**
     * Deprecated by :ref:`grpc_timeout_header_offset <envoy_v3_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset>`.
     * If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by subtracting
     * the provided duration from the header. This is useful in allowing Envoy to set its global
     * timeout to be less than that of the deadline imposed by the calling client, which makes it more
     * likely that Envoy will handle the timeout instead of having the call canceled by the client.
     * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
     * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
     * infinity).
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true];
     */
    grpcTimeoutOffset?: Duration;
    /**
     * @generated from protobuf field: repeated envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25;
     */
    upgradeConfigs: RouteAction_UpgradeConfig[];
    /**
     * If present, Envoy will try to follow an upstream redirect response instead of proxying the
     * response back to the downstream. An upstream redirect response is defined
     * by :ref:`redirect_response_codes
     * <envoy_v3_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
     *
     * @generated from protobuf field: envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34;
     */
    internalRedirectPolicy?: InternalRedirectPolicy;
    /**
     * @deprecated
     * @generated from protobuf field: envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26 [deprecated = true];
     */
    internalRedirectAction: RouteAction_InternalRedirectAction;
    /**
     * An internal redirect is handled, iff the number of previous internal redirects that a
     * downstream request has encountered is lower than this value, and
     * :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
     * is set to :ref:`HANDLE_INTERNAL_REDIRECT
     * <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
     * In the case where a downstream request is bounced among multiple routes by internal redirect,
     * the first route that hits this threshold, or has
     * :ref:`internal_redirect_action <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_action>`
     * set to
     * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
     * <envoy_v3_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
     * will pass the redirect back to downstream.
     *
     * If not specified, at most one redirect will be followed.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true];
     */
    maxInternalRedirects?: UInt32Value;
    /**
     * Indicates that the route has a hedge policy. Note that if this is set,
     * it'll take precedence over the virtual host level hedge policy entirely
     * (e.g.: policies are not merged, most internal one becomes the enforced policy).
     *
     * @generated from protobuf field: envoy.config.route.v3.HedgePolicy hedge_policy = 27;
     */
    hedgePolicy?: HedgePolicy;
    /**
     * Specifies the maximum stream duration for this route.
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36;
     */
    maxStreamDuration?: RouteAction_MaxStreamDuration;
}
/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is
 * useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * .. note::
 *
 *   Shadowing doesn't support Http CONNECT and upgrades.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.RequestMirrorPolicy
 */
export interface RouteAction_RequestMirrorPolicy {
    /**
     * Only one of ``cluster`` and ``cluster_header`` can be specified.
     * [#next-major-version: Need to add back the validation rule: (validate.rules).string = {min_len: 1}]
     * Specifies the cluster that requests will be mirrored to. The cluster must
     * exist in the cluster manager configuration.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * Only one of ``cluster`` and ``cluster_header`` can be specified.
     * Envoy will determine the cluster to route to by reading the value of the
     * HTTP header named by cluster_header from the request headers. Only the first value in header is used,
     * and no shadow request will happen if the value is not found in headers. Envoy will not wait for
     * the shadow cluster to respond before returning the response from the primary cluster.
     *
     * .. attention::
     *
     *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1
     *   ``Host`` header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from protobuf field: string cluster_header = 5;
     */
    clusterHeader: string;
    /**
     * If not specified, all requests to the target cluster will be mirrored.
     *
     * If specified, this field takes precedence over the ``runtime_key`` field and requests must also
     * fall under the percentage of matches indicated by this field.
     *
     * For some fraction N/D, a random number in the range [0,D) is selected. If the
     * number is <= the value of the numerator N, or if the key is not present, the default
     * value, the request will be mirrored.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 3;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Determines if the trace span should be sampled. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue trace_sampled = 4;
     */
    traceSampled?: BoolValue;
}
/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy
 */
export interface RouteAction_HashPolicy {
    /**
     * @generated from protobuf oneof: policy_specifier
     */
    policySpecifier: {
        oneofKind: "header";
        /**
         * Header hash policy.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction.HashPolicy.Header header = 1;
         */
        header: RouteAction_HashPolicy_Header;
    } | {
        oneofKind: "cookie";
        /**
         * Cookie hash policy.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction.HashPolicy.Cookie cookie = 2;
         */
        cookie: RouteAction_HashPolicy_Cookie;
    } | {
        oneofKind: "connectionProperties";
        /**
         * Connection properties hash policy.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;
         */
        connectionProperties: RouteAction_HashPolicy_ConnectionProperties;
    } | {
        oneofKind: "queryParameter";
        /**
         * Query parameter hash policy.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter query_parameter = 5;
         */
        queryParameter: RouteAction_HashPolicy_QueryParameter;
    } | {
        oneofKind: "filterState";
        /**
         * Filter state hash policy.
         *
         * @generated from protobuf field: envoy.config.route.v3.RouteAction.HashPolicy.FilterState filter_state = 6;
         */
        filterState: RouteAction_HashPolicy_FilterState;
    } | {
        oneofKind: undefined;
    };
    /**
     * The flag that short-circuits the hash computing. This field provides a
     * 'fallback' style of configuration: "if a terminal policy doesn't work,
     * fallback to rest of the policy list", it saves time when the terminal
     * policy works.
     *
     * If true, and there is already a hash computed, ignore rest of the
     * list of hash polices.
     * For example, if the following hash methods are configured:
     *
     *  ========= ========
     *  specifier terminal
     *  ========= ========
     *  Header A  true
     *  Header B  false
     *  Header C  false
     *  ========= ========
     *
     * The generateHash process ends if policy "header A" generates a hash, as
     * it's a terminal policy.
     *
     * @generated from protobuf field: bool terminal = 4;
     */
    terminal: boolean;
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.Header
 */
export interface RouteAction_HashPolicy_Header {
    /**
     * The name of the request header that will be used to obtain the hash
     * key. If the request header is not present, no hash will be produced.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
    /**
     * If specified, the request header value will be rewritten and used
     * to produce the hash key.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 2;
     */
    regexRewrite?: RegexMatchAndSubstitute;
}
/**
 * CookieAttribute defines an API for adding additional attributes for a HTTP cookie.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute
 */
export interface RouteAction_HashPolicy_CookieAttribute {
    /**
     * The name of the cookie attribute.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The optional value of the cookie attribute.
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.Cookie
 */
export interface RouteAction_HashPolicy_Cookie {
    /**
     * The name of the cookie that will be used to obtain the hash key. If the
     * cookie is not present and ttl below is not set, no hash will be
     * produced.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * If specified, a cookie with the TTL will be generated if the cookie is
     * not present. If the TTL is present and zero, the generated cookie will
     * be a session cookie.
     *
     * @generated from protobuf field: google.protobuf.Duration ttl = 2;
     */
    ttl?: Duration;
    /**
     * The name of the path for the cookie. If no path is specified here, no path
     * will be set for the cookie.
     *
     * @generated from protobuf field: string path = 3;
     */
    path: string;
    /**
     * Additional attributes for the cookie. They will be used when generating a new cookie.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute attributes = 4;
     */
    attributes: RouteAction_HashPolicy_CookieAttribute[];
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties
 */
export interface RouteAction_HashPolicy_ConnectionProperties {
    /**
     * Hash on source IP address.
     *
     * @generated from protobuf field: bool source_ip = 1;
     */
    sourceIp: boolean;
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter
 */
export interface RouteAction_HashPolicy_QueryParameter {
    /**
     * The name of the URL query parameter that will be used to obtain the hash
     * key. If the parameter is not present, no hash will be produced. Query
     * parameter names are case-sensitive.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteAction.HashPolicy.FilterState
 */
export interface RouteAction_HashPolicy_FilterState {
    /**
     * The name of the Object in the per-request filterState, which is an
     * Envoy::Hashable object. If there is no data associated with the key,
     * or the stored object is not Envoy::Hashable, no hash will be produced.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.UpgradeConfig
 */
export interface RouteAction_UpgradeConfig {
    /**
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type] will be proxied upstream.
     *
     * @generated from protobuf field: string upgrade_type = 1;
     */
    upgradeType: string;
    /**
     * Determines if upgrades are available on this route. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue enabled = 2;
     */
    enabled?: BoolValue;
    /**
     * Configuration for sending data upstream as a raw data payload. This is used for
     * CONNECT requests, when forwarding CONNECT payload as raw TCP.
     * Note that CONNECT support is currently considered alpha in Envoy.
     * [#comment: TODO(htuch): Replace the above comment with an alpha tag.]
     *
     * @generated from protobuf field: envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig connect_config = 3;
     */
    connectConfig?: RouteAction_UpgradeConfig_ConnectConfig;
}
/**
 * Configuration for sending data upstream as a raw data payload. This is used for
 * CONNECT or POST requests, when forwarding request payload as raw TCP.
 *
 * @generated from protobuf message envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig
 */
export interface RouteAction_UpgradeConfig_ConnectConfig {
    /**
     * If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream.
     *
     * @generated from protobuf field: envoy.config.core.v3.ProxyProtocolConfig proxy_protocol_config = 1;
     */
    proxyProtocolConfig?: ProxyProtocolConfig;
    /**
     * If set, the route will also allow forwarding POST payload as raw TCP.
     *
     * @generated from protobuf field: bool allow_post = 2;
     */
    allowPost: boolean;
}
/**
 * @generated from protobuf message envoy.config.route.v3.RouteAction.MaxStreamDuration
 */
export interface RouteAction_MaxStreamDuration {
    /**
     * Specifies the maximum duration allowed for streams on the route. If not specified, the value
     * from the :ref:`max_stream_duration
     * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration>` field in
     * :ref:`HttpConnectionManager.common_http_protocol_options
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options>`
     * is used. If this field is set explicitly to zero, any
     * HttpConnectionManager max_stream_duration timeout will be disabled for
     * this route.
     *
     * @generated from protobuf field: google.protobuf.Duration max_stream_duration = 1;
     */
    maxStreamDuration?: Duration;
    /**
     * If present, and the request contains a `grpc-timeout header
     * <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
     * ``max_stream_duration``, but limit the applied timeout to the maximum value specified here.
     * If set to 0, the ``grpc-timeout`` header is used without modification.
     *
     * @generated from protobuf field: google.protobuf.Duration grpc_timeout_header_max = 2;
     */
    grpcTimeoutHeaderMax?: Duration;
    /**
     * If present, Envoy will adjust the timeout provided by the ``grpc-timeout`` header by
     * subtracting the provided duration from the header. This is useful for allowing Envoy to set
     * its global timeout to be less than that of the deadline imposed by the calling client, which
     * makes it more likely that Envoy will handle the timeout instead of having the call canceled
     * by the client. If, after applying the offset, the resulting timeout is zero or negative,
     * the stream will timeout immediately.
     *
     * @generated from protobuf field: google.protobuf.Duration grpc_timeout_header_offset = 3;
     */
    grpcTimeoutHeaderOffset?: Duration;
}
/**
 * @generated from protobuf enum envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode
 */
export enum RouteAction_ClusterNotFoundResponseCode {
    /**
     * HTTP status code - 503 Service Unavailable.
     *
     * @generated from protobuf enum value: SERVICE_UNAVAILABLE = 0;
     */
    SERVICE_UNAVAILABLE = 0,
    /**
     * HTTP status code - 404 Not Found.
     *
     * @generated from protobuf enum value: NOT_FOUND = 1;
     */
    NOT_FOUND = 1,
    /**
     * HTTP status code - 500 Internal Server Error.
     *
     * @generated from protobuf enum value: INTERNAL_SERVER_ERROR = 2;
     */
    INTERNAL_SERVER_ERROR = 2
}
/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 * [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
 *
 * @deprecated
 * @generated from protobuf enum envoy.config.route.v3.RouteAction.InternalRedirectAction
 */
export enum RouteAction_InternalRedirectAction {
    /**
     * @generated from protobuf enum value: PASS_THROUGH_INTERNAL_REDIRECT = 0;
     */
    PASS_THROUGH_INTERNAL_REDIRECT = 0,
    /**
     * @generated from protobuf enum value: HANDLE_INTERNAL_REDIRECT = 1;
     */
    HANDLE_INTERNAL_REDIRECT = 1
}
/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 14]
 *
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * Specifies the conditions under which retry takes place. These are the same
     * conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
     * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
     *
     * @generated from protobuf field: string retry_on = 1;
     */
    retryOn: string;
    /**
     * Specifies the allowed number of retries. This parameter is optional and
     * defaults to 1. These are the same conditions documented for
     * :ref:`config_http_filters_router_x-envoy-max-retries`.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value num_retries = 2;
     */
    numRetries?: UInt32Value;
    /**
     * Specifies a non-zero upstream timeout per retry attempt (including the initial attempt). This
     * parameter is optional. The same conditions documented for
     * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
     *
     * .. note::
     *
     *   If left unspecified, Envoy will use the global
     *   :ref:`route timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` for the request.
     *   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
     *   retry policy, a request that times out will not be retried as the total timeout budget
     *   would have been exhausted.
     *
     * @generated from protobuf field: google.protobuf.Duration per_try_timeout = 3;
     */
    perTryTimeout?: Duration;
    /**
     * Specifies an upstream idle timeout per retry attempt (including the initial attempt). This
     * parameter is optional and if absent there is no per try idle timeout. The semantics of the per
     * try idle timeout are similar to the
     * :ref:`route idle timeout <envoy_v3_api_field_config.route.v3.RouteAction.timeout>` and
     * :ref:`stream idle timeout
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
     * both enforced by the HTTP connection manager. The difference is that this idle timeout
     * is enforced by the router for each individual attempt and thus after all previous filters have
     * run, as opposed to *before* all previous filters run for the other idle timeouts. This timeout
     * is useful in cases in which total request timeout is bounded by a number of retries and a
     * :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`, but
     * there is a desire to ensure each try is making incremental progress. Note also that similar
     * to :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
     * this idle timeout does not start until after both the entire request has been received by the
     * router *and* a connection pool connection has been obtained. Unlike
     * :ref:`per_try_timeout <envoy_v3_api_field_config.route.v3.RetryPolicy.per_try_timeout>`,
     * the idle timer continues once the response starts streaming back to the downstream client.
     * This ensures that response data continues to make progress without using one of the HTTP
     * connection manager idle timeouts.
     *
     * @generated from protobuf field: google.protobuf.Duration per_try_idle_timeout = 13;
     */
    perTryIdleTimeout?: Duration;
    /**
     * Specifies an implementation of a RetryPriority which is used to determine the
     * distribution of load across priorities used for retries. Refer to
     * :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy.RetryPriority retry_priority = 4;
     */
    retryPriority?: RetryPolicy_RetryPriority;
    /**
     * Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
     * for retries. If any of the predicates reject the host, host selection will be reattempted.
     * Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
     * details.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RetryPolicy.RetryHostPredicate retry_host_predicate = 5;
     */
    retryHostPredicate: RetryPolicy_RetryHostPredicate[];
    /**
     * Retry options predicates that will be applied prior to retrying a request. These predicates
     * allow customizing request behavior between retries.
     * [#comment: add [#extension-category: envoy.retry_options_predicates] when there are built-in extensions]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig retry_options_predicates = 12;
     */
    retryOptionsPredicates: TypedExtensionConfig[];
    /**
     * The maximum number of times host selection will be reattempted before giving up, at which
     * point the host that was last selected will be routed to. If unspecified, this will default to
     * retrying once.
     *
     * @generated from protobuf field: int64 host_selection_retry_max_attempts = 6;
     */
    hostSelectionRetryMaxAttempts: bigint;
    /**
     * HTTP status codes that should trigger a retry in addition to those specified by retry_on.
     *
     * @generated from protobuf field: repeated uint32 retriable_status_codes = 7;
     */
    retriableStatusCodes: number[];
    /**
     * Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
     * default base interval is 25 milliseconds or, if set, the current value of the
     * ``upstream.base_retry_backoff_ms`` runtime parameter. The default maximum interval is 10 times
     * the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
     * describes Envoy's back-off algorithm.
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy.RetryBackOff retry_back_off = 8;
     */
    retryBackOff?: RetryPolicy_RetryBackOff;
    /**
     * Specifies parameters that control a retry back-off strategy that is used
     * when the request is rate limited by the upstream server. The server may
     * return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
     * provide feedback to the client on how long to wait before retrying. If
     * configured, this back-off strategy will be used instead of the
     * default exponential back off strategy (configured using ``retry_back_off``)
     * whenever a response includes the matching headers.
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff rate_limited_retry_back_off = 11;
     */
    rateLimitedRetryBackOff?: RetryPolicy_RateLimitedRetryBackOff;
    /**
     * HTTP response headers that trigger a retry if present in the response. A retry will be
     * triggered if any of the header matches match the upstream response headers.
     * The field is only consulted if 'retriable-headers' retry policy is active.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher retriable_headers = 9;
     */
    retriableHeaders: HeaderMatcher[];
    /**
     * HTTP headers which must be present in the request for retries to be attempted.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher retriable_request_headers = 10;
     */
    retriableRequestHeaders: HeaderMatcher[];
}
/**
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy.RetryPriority
 */
export interface RetryPolicy_RetryPriority {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy.RetryHostPredicate
 */
export interface RetryPolicy_RetryHostPredicate {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy.RetryBackOff
 */
export interface RetryPolicy_RetryBackOff {
    /**
     * Specifies the base interval between retries. This parameter is required and must be greater
     * than zero. Values less than 1 ms are rounded up to 1 ms.
     * See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
     * back-off algorithm.
     *
     * @generated from protobuf field: google.protobuf.Duration base_interval = 1;
     */
    baseInterval?: Duration;
    /**
     * Specifies the maximum interval between retries. This parameter is optional, but must be
     * greater than or equal to the ``base_interval`` if set. The default is 10 times the
     * ``base_interval``. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
     * of Envoy's back-off algorithm.
     *
     * @generated from protobuf field: google.protobuf.Duration max_interval = 2;
     */
    maxInterval?: Duration;
}
/**
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy.ResetHeader
 */
export interface RetryPolicy_ResetHeader {
    /**
     * The name of the reset header.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The format of the reset header.
     *
     * @generated from protobuf field: envoy.config.route.v3.RetryPolicy.ResetHeaderFormat format = 2;
     */
    format: RetryPolicy_ResetHeaderFormat;
}
/**
 * A retry back-off strategy that applies when the upstream server rate limits
 * the request.
 *
 * Given this configuration:
 *
 * .. code-block:: yaml
 *
 *   rate_limited_retry_back_off:
 *     reset_headers:
 *     - name: Retry-After
 *       format: SECONDS
 *     - name: X-RateLimit-Reset
 *       format: UNIX_TIMESTAMP
 *     max_interval: "300s"
 *
 * The following algorithm will apply:
 *
 *  1. If the response contains the header ``Retry-After`` its value must be on
 *     the form ``120`` (an integer that represents the number of seconds to
 *     wait before retrying). If so, this value is used as the back-off interval.
 *  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
 *     value must be on the form ``1595320702`` (an integer that represents the
 *     point in time at which to retry, as a Unix timestamp in seconds). If so,
 *     the current time is subtracted from this value and the result is used as
 *     the back-off interval.
 *  3. Otherwise, Envoy will use the default
 *     :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
 *     strategy.
 *
 * No matter which format is used, if the resulting back-off interval exceeds
 * ``max_interval`` it is discarded and the next header in ``reset_headers``
 * is tried. If a request timeout is configured for the route it will further
 * limit how long the request will be allowed to run.
 *
 * To prevent many clients retrying at the same point in time jitter is added
 * to the back-off interval, so the resulting interval is decided by taking:
 * ``random(interval, interval * 1.5)``.
 *
 * .. attention::
 *
 *   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
 *   to be retried. You will still need to configure the right retry policy to match
 *   the responses from the upstream server.
 *
 * @generated from protobuf message envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff
 */
export interface RetryPolicy_RateLimitedRetryBackOff {
    /**
     * Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
     * to match against the response. Headers are tried in order, and matched case
     * insensitive. The first header to be parsed successfully is used. If no headers
     * match the default exponential back-off is used instead.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RetryPolicy.ResetHeader reset_headers = 1;
     */
    resetHeaders: RetryPolicy_ResetHeader[];
    /**
     * Specifies the maximum back off interval that Envoy will allow. If a reset
     * header contains an interval longer than this then it will be discarded and
     * the next header will be tried. Defaults to 300 seconds.
     *
     * @generated from protobuf field: google.protobuf.Duration max_interval = 2;
     */
    maxInterval?: Duration;
}
/**
 * @generated from protobuf enum envoy.config.route.v3.RetryPolicy.ResetHeaderFormat
 */
export enum RetryPolicy_ResetHeaderFormat {
    /**
     * @generated from protobuf enum value: SECONDS = 0;
     */
    SECONDS = 0,
    /**
     * @generated from protobuf enum value: UNIX_TIMESTAMP = 1;
     */
    UNIX_TIMESTAMP = 1
}
/**
 * HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
 *
 * @generated from protobuf message envoy.config.route.v3.HedgePolicy
 */
export interface HedgePolicy {
    /**
     * Specifies the number of initial requests that should be sent upstream.
     * Must be at least 1.
     * Defaults to 1.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value initial_requests = 1;
     */
    initialRequests?: UInt32Value;
    /**
     * Specifies a probability that an additional upstream request should be sent
     * on top of what is specified by initial_requests.
     * Defaults to 0.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent additional_request_chance = 2;
     */
    additionalRequestChance?: FractionalPercent;
    /**
     * Indicates that a hedged request should be sent when the per-try timeout is hit.
     * This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
     * The first request to complete successfully will be the one returned to the caller.
     *
     * * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
     * * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
     *   if there are no more retries left.
     * * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
     *
     * Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_v3_api_msg_config.route.v3.RetryPolicy>` that retries at least
     * one error code and specifies a maximum number of retries.
     *
     * Defaults to false.
     *
     * @generated from protobuf field: bool hedge_on_per_try_timeout = 3;
     */
    hedgeOnPerTryTimeout: boolean;
}
/**
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.config.route.v3.RedirectAction
 */
export interface RedirectAction {
    /**
     * @generated from protobuf oneof: scheme_rewrite_specifier
     */
    schemeRewriteSpecifier: {
        oneofKind: "httpsRedirect";
        /**
         * The scheme portion of the URL will be swapped with "https".
         *
         * @generated from protobuf field: bool https_redirect = 4;
         */
        httpsRedirect: boolean;
    } | {
        oneofKind: "schemeRedirect";
        /**
         * The scheme portion of the URL will be swapped with this value.
         *
         * @generated from protobuf field: string scheme_redirect = 7;
         */
        schemeRedirect: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * The host portion of the URL will be swapped with this value.
     *
     * @generated from protobuf field: string host_redirect = 1;
     */
    hostRedirect: string;
    /**
     * The port value of the URL will be swapped with this value.
     *
     * @generated from protobuf field: uint32 port_redirect = 8;
     */
    portRedirect: number;
    /**
     * @generated from protobuf oneof: path_rewrite_specifier
     */
    pathRewriteSpecifier: {
        oneofKind: "pathRedirect";
        /**
         * The path portion of the URL will be swapped with this value.
         * Please note that query string in path_redirect will override the
         * request's query string and will not be stripped.
         *
         * For example, let's say we have the following routes:
         *
         * - match: { path: "/old-path-1" }
         *   redirect: { path_redirect: "/new-path-1" }
         * - match: { path: "/old-path-2" }
         *   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
         * - match: { path: "/old-path-3" }
         *   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
         *
         * 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
         * 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
         * 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
         *
         * @generated from protobuf field: string path_redirect = 2;
         */
        pathRedirect: string;
    } | {
        oneofKind: "prefixRewrite";
        /**
         * Indicates that during redirection, the matched prefix (or path)
         * should be swapped with this value. This option allows redirect URLs be dynamically created
         * based on the request.
         *
         * .. attention::
         *
         *   Pay attention to the use of trailing slashes as mentioned in
         *   :ref:`RouteAction's prefix_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
         *
         * @generated from protobuf field: string prefix_rewrite = 5;
         */
        prefixRewrite: string;
    } | {
        oneofKind: "regexRewrite";
        /**
         * Indicates that during redirect, portions of the path that match the
         * pattern should be rewritten, even allowing the substitution of capture
         * groups from the pattern into the new path as specified by the rewrite
         * substitution string. This is useful to allow application paths to be
         * rewritten in a way that is aware of segments with variable content like
         * identifiers.
         *
         * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
         *
         * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
         *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
         *   into ``/v1/api/instance/foo``.
         *
         * * The pattern ``one`` paired with a substitution string of ``two`` would
         *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
         *
         * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
         *   ``\1two\2`` would replace only the first occurrence of ``one``,
         *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
         *
         * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
         *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
         *   ``/aaa/yyy/bbb``.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 9;
         */
        regexRewrite: RegexMatchAndSubstitute;
    } | {
        oneofKind: undefined;
    };
    /**
     * The HTTP status code to use in the redirect response. The default response
     * code is MOVED_PERMANENTLY (301).
     *
     * @generated from protobuf field: envoy.config.route.v3.RedirectAction.RedirectResponseCode response_code = 3;
     */
    responseCode: RedirectAction_RedirectResponseCode;
    /**
     * Indicates that during redirection, the query portion of the URL will
     * be removed. Default value is false.
     *
     * @generated from protobuf field: bool strip_query = 6;
     */
    stripQuery: boolean;
}
/**
 * @generated from protobuf enum envoy.config.route.v3.RedirectAction.RedirectResponseCode
 */
export enum RedirectAction_RedirectResponseCode {
    /**
     * Moved Permanently HTTP Status Code - 301.
     *
     * @generated from protobuf enum value: MOVED_PERMANENTLY = 0;
     */
    MOVED_PERMANENTLY = 0,
    /**
     * Found HTTP Status Code - 302.
     *
     * @generated from protobuf enum value: FOUND = 1;
     */
    FOUND = 1,
    /**
     * See Other HTTP Status Code - 303.
     *
     * @generated from protobuf enum value: SEE_OTHER = 2;
     */
    SEE_OTHER = 2,
    /**
     * Temporary Redirect HTTP Status Code - 307.
     *
     * @generated from protobuf enum value: TEMPORARY_REDIRECT = 3;
     */
    TEMPORARY_REDIRECT = 3,
    /**
     * Permanent Redirect HTTP Status Code - 308.
     *
     * @generated from protobuf enum value: PERMANENT_REDIRECT = 4;
     */
    PERMANENT_REDIRECT = 4
}
/**
 * @generated from protobuf message envoy.config.route.v3.DirectResponseAction
 */
export interface DirectResponseAction {
    /**
     * Specifies the HTTP response status to be returned.
     *
     * @generated from protobuf field: uint32 status = 1;
     */
    status: number;
    /**
     * Specifies the content of the response body. If this setting is omitted,
     * no body is included in the generated response.
     *
     * .. note::
     *
     *   Headers can be specified using ``response_headers_to_add`` in the enclosing
     *   :ref:`envoy_v3_api_msg_config.route.v3.Route`, :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` or
     *   :ref:`envoy_v3_api_msg_config.route.v3.VirtualHost`.
     *
     * @generated from protobuf field: envoy.config.core.v3.DataSource body = 2;
     */
    body?: DataSource;
}
/**
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.config.route.v3.NonForwardingAction
 */
export interface NonForwardingAction {
}
/**
 * @generated from protobuf message envoy.config.route.v3.Decorator
 */
export interface Decorator {
    /**
     * The operation name associated with the request matched to this route. If tracing is
     * enabled, this information will be used as the span name reported for this request.
     *
     * .. note::
     *
     *   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
     *   by the :ref:`x-envoy-decorator-operation
     *   <config_http_filters_router_x-envoy-decorator-operation>` header.
     *
     * @generated from protobuf field: string operation = 1;
     */
    operation: string;
    /**
     * Whether the decorated details should be propagated to the other party. The default is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue propagate = 2;
     */
    propagate?: BoolValue;
}
/**
 * @generated from protobuf message envoy.config.route.v3.Tracing
 */
export interface Tracing {
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
     * <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent client_sampling = 1;
     */
    clientSampling?: FractionalPercent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent random_sampling = 2;
     */
    randomSampling?: FractionalPercent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent overall_sampling = 3;
     */
    overallSampling?: FractionalPercent;
    /**
     * A list of custom tags with unique tag name to create tags for the active span.
     * It will take effect after merging with the :ref:`corresponding configuration
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
     * configured in the HTTP connection manager. If two tags with the same name are configured
     * each in the HTTP connection manager and the route level, the one configured here takes
     * priority.
     *
     * @generated from protobuf field: repeated envoy.type.tracing.v3.CustomTag custom_tags = 4;
     */
    customTags: CustomTag[];
}
/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, it’s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get “perfect” statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 *
 * @generated from protobuf message envoy.config.route.v3.VirtualCluster
 */
export interface VirtualCluster {
    /**
     * Specifies a list of header matchers to use for matching requests. Each specified header must
     * match. The pseudo-headers ``:path`` and ``:method`` can be used to match the request path and
     * method, respectively.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 4;
     */
    headers: HeaderMatcher[];
    /**
     * Specifies the name of the virtual cluster. The virtual cluster name as well
     * as the virtual host name are used when emitting statistics. The statistics are emitted by the
     * router filter and are documented :ref:`here <config_http_filters_router_stats>`.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit
 */
export interface RateLimit {
    /**
     * Refers to the stage set in the filter. The rate limit configuration only
     * applies to filters with the same stage number. The default stage number is
     * 0.
     *
     * .. note::
     *
     *   The filter supports a range of 0 - 10 inclusively for stage numbers.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value stage = 1;
     */
    stage?: UInt32Value;
    /**
     * The key to be set in runtime to disable this rate limit configuration.
     *
     * @generated from protobuf field: string disable_key = 2;
     */
    disableKey: string;
    /**
     * A list of actions that are to be applied for this rate limit configuration.
     * Order matters as the actions are processed sequentially and the descriptor
     * is composed by appending descriptor entries in that sequence. If an action
     * cannot append a descriptor entry, no descriptor is generated for the
     * configuration. See :ref:`composing actions
     * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.RateLimit.Action actions = 3;
     */
    actions: RateLimit_Action[];
    /**
     * An optional limit override to be appended to the descriptor produced by this
     * rate limit configuration. If the override value is invalid or cannot be resolved
     * from metadata, no override is provided. See :ref:`rate limit override
     * <config_http_filters_rate_limit_rate_limit_override>` for more information.
     *
     * @generated from protobuf field: envoy.config.route.v3.RateLimit.Override limit = 4;
     */
    limit?: RateLimit_Override;
}
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action
 */
export interface RateLimit_Action {
    /**
     * @generated from protobuf oneof: action_specifier
     */
    actionSpecifier: {
        oneofKind: "sourceCluster";
        /**
         * Rate limit on source cluster.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.SourceCluster source_cluster = 1;
         */
        sourceCluster: RateLimit_Action_SourceCluster;
    } | {
        oneofKind: "destinationCluster";
        /**
         * Rate limit on destination cluster.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.DestinationCluster destination_cluster = 2;
         */
        destinationCluster: RateLimit_Action_DestinationCluster;
    } | {
        oneofKind: "requestHeaders";
        /**
         * Rate limit on request headers.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.RequestHeaders request_headers = 3;
         */
        requestHeaders: RateLimit_Action_RequestHeaders;
    } | {
        oneofKind: "remoteAddress";
        /**
         * Rate limit on remote address.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.RemoteAddress remote_address = 4;
         */
        remoteAddress: RateLimit_Action_RemoteAddress;
    } | {
        oneofKind: "genericKey";
        /**
         * Rate limit on a generic key.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.GenericKey generic_key = 5;
         */
        genericKey: RateLimit_Action_GenericKey;
    } | {
        oneofKind: "headerValueMatch";
        /**
         * Rate limit on the existence of request headers.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.HeaderValueMatch header_value_match = 6;
         */
        headerValueMatch: RateLimit_Action_HeaderValueMatch;
    } | {
        oneofKind: "dynamicMetadata";
        /**
         * Rate limit on dynamic metadata.
         *
         * .. attention::
         *   This field has been deprecated in favor of the :ref:`metadata <envoy_v3_api_field_config.route.v3.RateLimit.Action.metadata>` field
         *
         * @deprecated
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.DynamicMetaData dynamic_metadata = 7 [deprecated = true];
         */
        dynamicMetadata: RateLimit_Action_DynamicMetaData;
    } | {
        oneofKind: "metadata";
        /**
         * Rate limit on metadata.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.MetaData metadata = 8;
         */
        metadata: RateLimit_Action_MetaData;
    } | {
        oneofKind: "extension";
        /**
         * Rate limit descriptor extension. See the rate limit descriptor extensions documentation.
         *
         * :ref:`HTTP matching input functions <arch_overview_matching_api>` are
         * permitted as descriptor extensions. The input functions are only
         * looked up if there is no rate limit descriptor extension matching
         * the type URL.
         *
         * [#extension-category: envoy.rate_limit_descriptors]
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig extension = 9;
         */
        extension: TypedExtensionConfig;
    } | {
        oneofKind: "maskedRemoteAddress";
        /**
         * Rate limit on masked remote address.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress masked_remote_address = 10;
         */
        maskedRemoteAddress: RateLimit_Action_MaskedRemoteAddress;
    } | {
        oneofKind: "queryParameterValueMatch";
        /**
         * Rate limit on the existence of query parameters.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch query_parameter_value_match = 11;
         */
        queryParameterValueMatch: RateLimit_Action_QueryParameterValueMatch;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.SourceCluster
 */
export interface RateLimit_Action_SourceCluster {
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.DestinationCluster
 */
export interface RateLimit_Action_DestinationCluster {
}
/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.RequestHeaders
 */
export interface RateLimit_Action_RequestHeaders {
    /**
     * The header name to be queried from the request headers. The header’s
     * value is used to populate the value of the descriptor entry for the
     * descriptor_key.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 2;
     */
    descriptorKey: string;
    /**
     * If set to true, Envoy skips the descriptor while calling rate limiting service
     * when header is not present in the request. By default it skips calling the
     * rate limiting service if this header is not present in the request.
     *
     * @generated from protobuf field: bool skip_if_absent = 3;
     */
    skipIfAbsent: boolean;
}
/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.RemoteAddress
 */
export interface RateLimit_Action_RemoteAddress {
}
/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * masked address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("masked_remote_address", "<masked address from x-forwarded-for>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress
 */
export interface RateLimit_Action_MaskedRemoteAddress {
    /**
     * Length of prefix mask len for IPv4 (e.g. 0, 32).
     * Defaults to 32 when unset.
     * For example, trusted address from x-forwarded-for is ``192.168.1.1``,
     * the descriptor entry is ("masked_remote_address", "192.168.1.1/32");
     * if mask len is 24, the descriptor entry is ("masked_remote_address", "192.168.1.0/24").
     *
     * @generated from protobuf field: google.protobuf.UInt32Value v4_prefix_mask_len = 1;
     */
    v4PrefixMaskLen?: UInt32Value;
    /**
     * Length of prefix mask len for IPv6 (e.g. 0, 128).
     * Defaults to 128 when unset.
     * For example, trusted address from x-forwarded-for is ``2001:abcd:ef01:2345:6789:abcd:ef01:234``,
     * the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345:6789:abcd:ef01:234/128");
     * if mask len is 64, the descriptor entry is ("masked_remote_address", "2001:abcd:ef01:2345::/64").
     *
     * @generated from protobuf field: google.protobuf.UInt32Value v6_prefix_mask_len = 2;
     */
    v6PrefixMaskLen?: UInt32Value;
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.GenericKey
 */
export interface RateLimit_Action_GenericKey {
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * An optional key to use in the descriptor entry. If not set it defaults
     * to 'generic_key' as the descriptor key.
     *
     * @generated from protobuf field: string descriptor_key = 2;
     */
    descriptorKey: string;
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.HeaderValueMatch
 */
export interface RateLimit_Action_HeaderValueMatch {
    /**
     * The key to use in the descriptor entry. Defaults to ``header_match``.
     *
     * @generated from protobuf field: string descriptor_key = 4;
     */
    descriptorKey: string;
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * If set to true, the action will append a descriptor entry when the
     * request matches the headers. If set to false, the action will append a
     * descriptor entry when the request does not match the headers. The
     * default value is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue expect_match = 2;
     */
    expectMatch?: BoolValue;
    /**
     * Specifies a set of headers that the rate limit action should match
     * on. The action will check the request’s headers against all the
     * specified headers in the config. A match will happen if all the
     * headers in the config are present in the request with the same values
     * (or based on presence if the value field is not in the config).
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 3;
     */
    headers: HeaderMatcher[];
}
/**
 * The following descriptor entry is appended when the
 * :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")
 *
 * .. attention::
 *   This action has been deprecated in favor of the :ref:`metadata <envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.DynamicMetaData
 */
export interface RateLimit_Action_DynamicMetaData {
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 1;
     */
    descriptorKey: string;
    /**
     * Metadata struct that defines the key and path to retrieve the string value. A match will
     * only happen if the value in the dynamic metadata is of type string.
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 2;
     */
    metadataKey?: MetadataKey;
    /**
     * An optional value to use if ``metadata_key`` is empty. If not set and
     * no value is present under the metadata_key then no descriptor is generated.
     *
     * @generated from protobuf field: string default_value = 3;
     */
    defaultValue: string;
}
/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.MetaData
 */
export interface RateLimit_Action_MetaData {
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 1;
     */
    descriptorKey: string;
    /**
     * Metadata struct that defines the key and path to retrieve the string value. A match will
     * only happen if the value in the metadata is of type string.
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 2;
     */
    metadataKey?: MetadataKey;
    /**
     * An optional value to use if ``metadata_key`` is empty. If not set and
     * no value is present under the metadata_key then ``skip_if_absent`` is followed to
     * skip calling the rate limiting service or skip the descriptor.
     *
     * @generated from protobuf field: string default_value = 3;
     */
    defaultValue: string;
    /**
     * Source of metadata
     *
     * @generated from protobuf field: envoy.config.route.v3.RateLimit.Action.MetaData.Source source = 4;
     */
    source: RateLimit_Action_MetaData_Source;
    /**
     * If set to true, Envoy skips the descriptor while calling rate limiting service
     * when ``metadata_key`` is empty and ``default_value`` is not set. By default it skips calling the
     * rate limiting service in that case.
     *
     * @generated from protobuf field: bool skip_if_absent = 5;
     */
    skipIfAbsent: boolean;
}
/**
 * @generated from protobuf enum envoy.config.route.v3.RateLimit.Action.MetaData.Source
 */
export enum RateLimit_Action_MetaData_Source {
    /**
     * Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
     *
     * @generated from protobuf enum value: DYNAMIC = 0;
     */
    DYNAMIC = 0,
    /**
     * Query :ref:`route entry metadata <envoy_v3_api_field_config.route.v3.Route.metadata>`
     *
     * @generated from protobuf enum value: ROUTE_ENTRY = 1;
     */
    ROUTE_ENTRY = 1
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("query_match", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch
 */
export interface RateLimit_Action_QueryParameterValueMatch {
    /**
     * The key to use in the descriptor entry. Defaults to ``query_match``.
     *
     * @generated from protobuf field: string descriptor_key = 4;
     */
    descriptorKey: string;
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * If set to true, the action will append a descriptor entry when the
     * request matches the headers. If set to false, the action will append a
     * descriptor entry when the request does not match the headers. The
     * default value is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue expect_match = 2;
     */
    expectMatch?: BoolValue;
    /**
     * Specifies a set of query parameters that the rate limit action should match
     * on. The action will check the request’s query parameters against all the
     * specified query parameters in the config. A match will happen if all the
     * query parameters in the config are present in the request with the same values
     * (or based on presence if the value field is not in the config).
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.QueryParameterMatcher query_parameters = 3;
     */
    queryParameters: QueryParameterMatcher[];
}
/**
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Override
 */
export interface RateLimit_Override {
    /**
     * @generated from protobuf oneof: override_specifier
     */
    overrideSpecifier: {
        oneofKind: "dynamicMetadata";
        /**
         * Limit override from dynamic metadata.
         *
         * @generated from protobuf field: envoy.config.route.v3.RateLimit.Override.DynamicMetadata dynamic_metadata = 1;
         */
        dynamicMetadata: RateLimit_Override_DynamicMetadata;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Fetches the override from the dynamic metadata.
 *
 * @generated from protobuf message envoy.config.route.v3.RateLimit.Override.DynamicMetadata
 */
export interface RateLimit_Override_DynamicMetadata {
    /**
     * Metadata struct that defines the key and path to retrieve the struct value.
     * The value must be a struct containing an integer "requests_per_unit" property
     * and a "unit" property with a value parseable to :ref:`RateLimitUnit
     * enum <envoy_v3_api_enum_type.v3.RateLimitUnit>`
     *
     * @generated from protobuf field: envoy.type.metadata.v3.MetadataKey metadata_key = 1;
     */
    metadataKey?: MetadataKey;
}
/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``
 *   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "string_match": {
 *         "exact": "POST"
 *       }
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 15]
 *
 * @generated from protobuf message envoy.config.route.v3.HeaderMatcher
 */
export interface HeaderMatcher {
    /**
     * Specifies the name of the header in the request.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: header_match_specifier
     */
    headerMatchSpecifier: {
        oneofKind: "exactMatch";
        /**
         * If specified, header match will be performed based on the value of the header.
         * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
         *
         * @deprecated
         * @generated from protobuf field: string exact_match = 4 [deprecated = true];
         */
        exactMatch: string;
    } | {
        oneofKind: "safeRegexMatch";
        /**
         * If specified, this regex string is a regular expression rule which implies the entire request
         * header value must match the regex. The rule will not match if only a subsequence of the
         * request header value matches the regex.
         * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
         *
         * @deprecated
         * @generated from protobuf field: envoy.type.matcher.v3.RegexMatcher safe_regex_match = 11 [deprecated = true];
         */
        safeRegexMatch: RegexMatcher;
    } | {
        oneofKind: "rangeMatch";
        /**
         * If specified, header match will be performed based on range.
         * The rule will match if the request header value is within this range.
         * The entire request header value must represent an integer in base 10 notation: consisting of
         * an optional plus or minus sign followed by a sequence of digits. The rule will not match if
         * the header value does not represent an integer. Match will fail for empty values, floating
         * point numbers or if only a subsequence of the header value is an integer.
         *
         * Examples:
         *
         * * For range [-10,0), route will match for header value -1, but not for 0, ``somestring``, 10.9,
         *   ``-1somestring``
         *
         * @generated from protobuf field: envoy.type.v3.Int64Range range_match = 6;
         */
        rangeMatch: Int64Range;
    } | {
        oneofKind: "presentMatch";
        /**
         * If specified as true, header match will be performed based on whether the header is in the
         * request. If specified as false, header match will be performed based on whether the header is absent.
         *
         * @generated from protobuf field: bool present_match = 7;
         */
        presentMatch: boolean;
    } | {
        oneofKind: "prefixMatch";
        /**
         * If specified, header match will be performed based on the prefix of the header value.
         * Note: empty prefix is not allowed, please use present_match instead.
         * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
         *
         * Examples:
         *
         * * The prefix ``abcd`` matches the value ``abcdxyz``, but not for ``abcxyz``.
         *
         * @deprecated
         * @generated from protobuf field: string prefix_match = 9 [deprecated = true];
         */
        prefixMatch: string;
    } | {
        oneofKind: "suffixMatch";
        /**
         * If specified, header match will be performed based on the suffix of the header value.
         * Note: empty suffix is not allowed, please use present_match instead.
         * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
         *
         * Examples:
         *
         * * The suffix ``abcd`` matches the value ``xyzabcd``, but not for ``xyzbcd``.
         *
         * @deprecated
         * @generated from protobuf field: string suffix_match = 10 [deprecated = true];
         */
        suffixMatch: string;
    } | {
        oneofKind: "containsMatch";
        /**
         * If specified, header match will be performed based on whether the header value contains
         * the given value or not.
         * Note: empty contains match is not allowed, please use present_match instead.
         * This field is deprecated. Please use :ref:`string_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.string_match>`.
         *
         * Examples:
         *
         * * The value ``abcd`` matches the value ``xyzabcdpqr``, but not for ``xyzbcdpqr``.
         *
         * @deprecated
         * @generated from protobuf field: string contains_match = 12 [deprecated = true];
         */
        containsMatch: string;
    } | {
        oneofKind: "stringMatch";
        /**
         * If specified, header match will be performed based on the string match of the header value.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher string_match = 13;
         */
        stringMatch: StringMatcher;
    } | {
        oneofKind: undefined;
    };
    /**
     * If specified, the match result will be inverted before checking. Defaults to false.
     *
     * Examples:
     *
     * * The regex ``\d{3}`` does not match the value ``1234``, so it will match when inverted.
     * * The range [-10,0) will match the value -1, so it will not match when inverted.
     *
     * @generated from protobuf field: bool invert_match = 8;
     */
    invertMatch: boolean;
    /**
     * If specified, for any header match rule, if the header match rule specified header
     * does not exist, this header value will be treated as empty. Defaults to false.
     *
     * Examples:
     *
     * * The header match rule specified header "header1" to range match of [0, 10],
     *   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
     *   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
     *   is set to true; The "header1" header is not present. The match rule will
     *   treat the "header1" as an empty header. The empty header does not match the range,
     *   so it will match when inverted.
     * * The header match rule specified header "header2" to range match of [0, 10],
     *   :ref:`invert_match <envoy_v3_api_field_config.route.v3.HeaderMatcher.invert_match>`
     *   is set to true and :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
     *   is set to false; The "header2" header is not present and the header
     *   matcher rule for "header2" will be ignored so it will not match.
     * * The header match rule specified header "header3" to a string regex match
     *   ``^$`` which means an empty string, and
     *   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
     *   is set to true; The "header3" header is not present.
     *   The match rule will treat the "header3" header as an empty header so it will match.
     * * The header match rule specified header "header4" to a string regex match
     *   ``^$`` which means an empty string, and
     *   :ref:`treat_missing_header_as_empty <envoy_v3_api_field_config.route.v3.HeaderMatcher.treat_missing_header_as_empty>`
     *   is set to false; The "header4" header is not present.
     *   The match rule for "header4" will be ignored so it will not match.
     *
     * @generated from protobuf field: bool treat_missing_header_as_empty = 14;
     */
    treatMissingHeaderAsEmpty: boolean;
}
/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.route.v3.QueryParameterMatcher
 */
export interface QueryParameterMatcher {
    /**
     * Specifies the name of a key that must be present in the requested
     * ``path``'s query string.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: query_parameter_match_specifier
     */
    queryParameterMatchSpecifier: {
        oneofKind: "stringMatch";
        /**
         * Specifies whether a query parameter value should match against a string.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher string_match = 5;
         */
        stringMatch: StringMatcher;
    } | {
        oneofKind: "presentMatch";
        /**
         * Specifies whether a query parameter should be present.
         *
         * @generated from protobuf field: bool present_match = 6;
         */
        presentMatch: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
 *
 * @generated from protobuf message envoy.config.route.v3.InternalRedirectPolicy
 */
export interface InternalRedirectPolicy {
    /**
     * An internal redirect is not handled, unless the number of previous internal redirects that a
     * downstream request has encountered is lower than this value.
     * In the case where a downstream request is bounced among multiple routes by internal redirect,
     * the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
     * <envoy_v3_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
     * will pass the redirect back to downstream.
     *
     * If not specified, at most one redirect will be followed.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_internal_redirects = 1;
     */
    maxInternalRedirects?: UInt32Value;
    /**
     * Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
     * only 302 will be treated as internal redirect.
     * Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
     *
     * @generated from protobuf field: repeated uint32 redirect_response_codes = 2;
     */
    redirectResponseCodes: number[];
    /**
     * Specifies a list of predicates that are queried when an upstream response is deemed
     * to trigger an internal redirect by all other criteria. Any predicate in the list can reject
     * the redirect, causing the response to be proxied to downstream.
     * [#extension-category: envoy.internal_redirect_predicates]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig predicates = 3;
     */
    predicates: TypedExtensionConfig[];
    /**
     * Allow internal redirect to follow a target URI with a different scheme than the value of
     * x-forwarded-proto. The default is false.
     *
     * @generated from protobuf field: bool allow_cross_scheme_redirect = 4;
     */
    allowCrossSchemeRedirect: boolean;
}
/**
 * A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
 * map value in
 * :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
 * :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
 * or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
 * to add additional flags to the filter.
 *
 * @generated from protobuf message envoy.config.route.v3.FilterConfig
 */
export interface FilterConfig {
    /**
     * The filter config.
     *
     * @generated from protobuf field: google.protobuf.Any config = 1;
     */
    config?: Any;
    /**
     * If true, the filter is optional, meaning that if the client does
     * not support the specified filter, it may ignore the map entry rather
     * than rejecting the config.
     *
     * @generated from protobuf field: bool is_optional = 2;
     */
    isOptional: boolean;
    /**
     * If true, the filter is disabled in the route or virtual host and the ``config`` field is ignored.
     *
     * .. note::
     *
     *   This field will take effect when the request arrive and filter chain is created for the request.
     *   If initial route is selected for the request and a filter is disabled in the initial route, then
     *   the filter will not be added to the filter chain.
     *   And if the request is mutated later and re-match to another route, the disabled filter by the
     *   initial route will not be added back to the filter chain because the filter chain is already
     *   created and it is too late to change the chain.
     *
     *   This field only make sense for the downstream HTTP filters for now.
     *
     * @generated from protobuf field: bool disabled = 3;
     */
    disabled: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class VirtualHost$Type extends MessageType<VirtualHost> {
    constructor() {
        super("envoy.config.route.v3.VirtualHost", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1", items: { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } } } },
            { no: 3, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route },
            { no: 21, name: "matcher", kind: "message", T: () => Matcher, options: { "xds.annotations.v3.field_status": { workInProgress: true } } },
            { no: 4, name: "require_tls", kind: "enum", T: () => ["envoy.config.route.v3.VirtualHost.TlsRequirementType", VirtualHost_TlsRequirementType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 5, name: "virtual_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VirtualCluster },
            { no: 6, name: "rate_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit },
            { no: 7, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 13, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 10, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 11, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 8, name: "cors", kind: "message", T: () => CorsPolicy, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 15, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 14, name: "include_request_attempt_count", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "include_attempt_count_in_response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 20, name: "retry_policy_typed_config", kind: "message", T: () => Any },
            { no: 17, name: "hedge_policy", kind: "message", T: () => HedgePolicy },
            { no: 23, name: "include_is_timeout_retry_header", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "per_request_buffer_limit_bytes", kind: "message", T: () => UInt32Value },
            { no: 22, name: "request_mirror_policies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_RequestMirrorPolicy }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.VirtualHost" } });
    }
    create(value?: PartialMessage<VirtualHost>): VirtualHost {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.domains = [];
        message.routes = [];
        message.requireTls = 0;
        message.virtualClusters = [];
        message.rateLimits = [];
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        message.typedPerFilterConfig = {};
        message.includeRequestAttemptCount = false;
        message.includeAttemptCountInResponse = false;
        message.includeIsTimeoutRetryHeader = false;
        message.requestMirrorPolicies = [];
        if (value !== undefined)
            reflectionMergePartial<VirtualHost>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VirtualHost): VirtualHost {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string domains */ 2:
                    message.domains.push(reader.string());
                    break;
                case /* repeated envoy.config.route.v3.Route routes */ 3:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* xds.type.matcher.v3.Matcher matcher */ 21:
                    message.matcher = Matcher.internalBinaryRead(reader, reader.uint32(), options, message.matcher);
                    break;
                case /* envoy.config.route.v3.VirtualHost.TlsRequirementType require_tls */ 4:
                    message.requireTls = reader.int32();
                    break;
                case /* repeated envoy.config.route.v3.VirtualCluster virtual_clusters */ 5:
                    message.virtualClusters.push(VirtualCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.route.v3.RateLimit rate_limits */ 6:
                    message.rateLimits.push(RateLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add */ 7:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 13:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 10:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 11:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* envoy.config.route.v3.CorsPolicy cors = 8 [deprecated = true];*/ 8:
                    message.cors = CorsPolicy.internalBinaryRead(reader, reader.uint32(), options, message.cors);
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 15:
                    this.binaryReadMap15(message.typedPerFilterConfig, reader, options);
                    break;
                case /* bool include_request_attempt_count */ 14:
                    message.includeRequestAttemptCount = reader.bool();
                    break;
                case /* bool include_attempt_count_in_response */ 19:
                    message.includeAttemptCountInResponse = reader.bool();
                    break;
                case /* envoy.config.route.v3.RetryPolicy retry_policy */ 16:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* google.protobuf.Any retry_policy_typed_config */ 20:
                    message.retryPolicyTypedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicyTypedConfig);
                    break;
                case /* envoy.config.route.v3.HedgePolicy hedge_policy */ 17:
                    message.hedgePolicy = HedgePolicy.internalBinaryRead(reader, reader.uint32(), options, message.hedgePolicy);
                    break;
                case /* bool include_is_timeout_retry_header */ 23:
                    message.includeIsTimeoutRetryHeader = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value per_request_buffer_limit_bytes */ 18:
                    message.perRequestBufferLimitBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.perRequestBufferLimitBytes);
                    break;
                case /* repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies */ 22:
                    message.requestMirrorPolicies.push(RouteAction_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap15(map: VirtualHost["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof VirtualHost["typedPerFilterConfig"] | undefined, val: VirtualHost["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.route.v3.VirtualHost.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: VirtualHost, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string domains = 2; */
        for (let i = 0; i < message.domains.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.domains[i]);
        /* repeated envoy.config.route.v3.Route routes = 3; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* xds.type.matcher.v3.Matcher matcher = 21; */
        if (message.matcher)
            Matcher.internalBinaryWrite(message.matcher, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.VirtualHost.TlsRequirementType require_tls = 4; */
        if (message.requireTls !== 0)
            writer.tag(4, WireType.Varint).int32(message.requireTls);
        /* repeated envoy.config.route.v3.VirtualCluster virtual_clusters = 5; */
        for (let i = 0; i < message.virtualClusters.length; i++)
            VirtualCluster.internalBinaryWrite(message.virtualClusters[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RateLimit rate_limits = 6; */
        for (let i = 0; i < message.rateLimits.length; i++)
            RateLimit.internalBinaryWrite(message.rateLimits[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 7; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 13; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 11; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* envoy.config.route.v3.CorsPolicy cors = 8 [deprecated = true]; */
        if (message.cors)
            CorsPolicy.internalBinaryWrite(message.cors, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Any> typed_per_filter_config = 15; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* bool include_request_attempt_count = 14; */
        if (message.includeRequestAttemptCount !== false)
            writer.tag(14, WireType.Varint).bool(message.includeRequestAttemptCount);
        /* bool include_attempt_count_in_response = 19; */
        if (message.includeAttemptCountInResponse !== false)
            writer.tag(19, WireType.Varint).bool(message.includeAttemptCountInResponse);
        /* envoy.config.route.v3.RetryPolicy retry_policy = 16; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any retry_policy_typed_config = 20; */
        if (message.retryPolicyTypedConfig)
            Any.internalBinaryWrite(message.retryPolicyTypedConfig, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.HedgePolicy hedge_policy = 17; */
        if (message.hedgePolicy)
            HedgePolicy.internalBinaryWrite(message.hedgePolicy, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* bool include_is_timeout_retry_header = 23; */
        if (message.includeIsTimeoutRetryHeader !== false)
            writer.tag(23, WireType.Varint).bool(message.includeIsTimeoutRetryHeader);
        /* google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18; */
        if (message.perRequestBufferLimitBytes)
            UInt32Value.internalBinaryWrite(message.perRequestBufferLimitBytes, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 22; */
        for (let i = 0; i < message.requestMirrorPolicies.length; i++)
            RouteAction_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicies[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.VirtualHost
 */
export const VirtualHost = new VirtualHost$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterAction$Type extends MessageType<FilterAction> {
    constructor() {
        super("envoy.config.route.v3.FilterAction", [
            { no: 1, name: "action", kind: "message", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.FilterAction" } });
    }
    create(value?: PartialMessage<FilterAction>): FilterAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FilterAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterAction): FilterAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any action */ 1:
                    message.action = Any.internalBinaryRead(reader, reader.uint32(), options, message.action);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any action = 1; */
        if (message.action)
            Any.internalBinaryWrite(message.action, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.FilterAction
 */
export const FilterAction = new FilterAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteList$Type extends MessageType<RouteList> {
    constructor() {
        super("envoy.config.route.v3.RouteList", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route }
        ]);
    }
    create(value?: PartialMessage<RouteList>): RouteList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routes = [];
        if (value !== undefined)
            reflectionMergePartial<RouteList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteList): RouteList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.Route routes */ 1:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteList
 */
export const RouteList = new RouteList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Route$Type extends MessageType<Route> {
    constructor() {
        super("envoy.config.route.v3.Route", [
            { no: 14, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "match", kind: "message", T: () => RouteMatch, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "route", kind: "message", oneof: "action", T: () => RouteAction },
            { no: 3, name: "redirect", kind: "message", oneof: "action", T: () => RedirectAction },
            { no: 7, name: "direct_response", kind: "message", oneof: "action", T: () => DirectResponseAction },
            { no: 17, name: "filter_action", kind: "message", oneof: "action", T: () => FilterAction },
            { no: 18, name: "non_forwarding_action", kind: "message", oneof: "action", T: () => NonForwardingAction },
            { no: 4, name: "metadata", kind: "message", T: () => Metadata },
            { no: 5, name: "decorator", kind: "message", T: () => Decorator },
            { no: 13, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 9, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 12, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 10, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 11, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 15, name: "tracing", kind: "message", T: () => Tracing },
            { no: 16, name: "per_request_buffer_limit_bytes", kind: "message", T: () => UInt32Value },
            { no: 19, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.Route" } });
    }
    create(value?: PartialMessage<Route>): Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.action = { oneofKind: undefined };
        message.typedPerFilterConfig = {};
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        message.statPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 14:
                    message.name = reader.string();
                    break;
                case /* envoy.config.route.v3.RouteMatch match */ 1:
                    message.match = RouteMatch.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* envoy.config.route.v3.RouteAction route */ 2:
                    message.action = {
                        oneofKind: "route",
                        route: RouteAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).route)
                    };
                    break;
                case /* envoy.config.route.v3.RedirectAction redirect */ 3:
                    message.action = {
                        oneofKind: "redirect",
                        redirect: RedirectAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).redirect)
                    };
                    break;
                case /* envoy.config.route.v3.DirectResponseAction direct_response */ 7:
                    message.action = {
                        oneofKind: "directResponse",
                        directResponse: DirectResponseAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).directResponse)
                    };
                    break;
                case /* envoy.config.route.v3.FilterAction filter_action */ 17:
                    message.action = {
                        oneofKind: "filterAction",
                        filterAction: FilterAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).filterAction)
                    };
                    break;
                case /* envoy.config.route.v3.NonForwardingAction non_forwarding_action */ 18:
                    message.action = {
                        oneofKind: "nonForwardingAction",
                        nonForwardingAction: NonForwardingAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).nonForwardingAction)
                    };
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.config.route.v3.Decorator decorator */ 5:
                    message.decorator = Decorator.internalBinaryRead(reader, reader.uint32(), options, message.decorator);
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 13:
                    this.binaryReadMap13(message.typedPerFilterConfig, reader, options);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add */ 9:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 12:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 10:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 11:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* envoy.config.route.v3.Tracing tracing */ 15:
                    message.tracing = Tracing.internalBinaryRead(reader, reader.uint32(), options, message.tracing);
                    break;
                case /* google.protobuf.UInt32Value per_request_buffer_limit_bytes */ 16:
                    message.perRequestBufferLimitBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.perRequestBufferLimitBytes);
                    break;
                case /* string stat_prefix */ 19:
                    message.statPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap13(map: Route["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Route["typedPerFilterConfig"] | undefined, val: Route["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.route.v3.Route.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 14; */
        if (message.name !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.name);
        /* envoy.config.route.v3.RouteMatch match = 1; */
        if (message.match)
            RouteMatch.internalBinaryWrite(message.match, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction route = 2; */
        if (message.action.oneofKind === "route")
            RouteAction.internalBinaryWrite(message.action.route, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RedirectAction redirect = 3; */
        if (message.action.oneofKind === "redirect")
            RedirectAction.internalBinaryWrite(message.action.redirect, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.DirectResponseAction direct_response = 7; */
        if (message.action.oneofKind === "directResponse")
            DirectResponseAction.internalBinaryWrite(message.action.directResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.FilterAction filter_action = 17; */
        if (message.action.oneofKind === "filterAction")
            FilterAction.internalBinaryWrite(message.action.filterAction, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.NonForwardingAction non_forwarding_action = 18; */
        if (message.action.oneofKind === "nonForwardingAction")
            NonForwardingAction.internalBinaryWrite(message.action.nonForwardingAction, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata = 4; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.Decorator decorator = 5; */
        if (message.decorator)
            Decorator.internalBinaryWrite(message.decorator, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Any> typed_per_filter_config = 13; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 9; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 12; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 10; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 11; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* envoy.config.route.v3.Tracing tracing = 15; */
        if (message.tracing)
            Tracing.internalBinaryWrite(message.tracing, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16; */
        if (message.perRequestBufferLimitBytes)
            UInt32Value.internalBinaryWrite(message.perRequestBufferLimitBytes, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string stat_prefix = 19; */
        if (message.statPrefix !== "")
            writer.tag(19, WireType.LengthDelimited).string(message.statPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.Route
 */
export const Route = new Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightedCluster$Type extends MessageType<WeightedCluster> {
    constructor() {
        super("envoy.config.route.v3.WeightedCluster", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WeightedCluster_ClusterWeight, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 3, name: "total_weight", kind: "message", T: () => UInt32Value, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 2, name: "runtime_key_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "header_name", kind: "scalar", oneof: "randomValueSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.WeightedCluster" } });
    }
    create(value?: PartialMessage<WeightedCluster>): WeightedCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        message.runtimeKeyPrefix = "";
        message.randomValueSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WeightedCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightedCluster): WeightedCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.WeightedCluster.ClusterWeight clusters */ 1:
                    message.clusters.push(WeightedCluster_ClusterWeight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value total_weight = 3 [deprecated = true];*/ 3:
                    message.totalWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.totalWeight);
                    break;
                case /* string runtime_key_prefix */ 2:
                    message.runtimeKeyPrefix = reader.string();
                    break;
                case /* string header_name */ 4:
                    message.randomValueSpecifier = {
                        oneofKind: "headerName",
                        headerName: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightedCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.WeightedCluster.ClusterWeight clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            WeightedCluster_ClusterWeight.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value total_weight = 3 [deprecated = true]; */
        if (message.totalWeight)
            UInt32Value.internalBinaryWrite(message.totalWeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key_prefix = 2; */
        if (message.runtimeKeyPrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKeyPrefix);
        /* string header_name = 4; */
        if (message.randomValueSpecifier.oneofKind === "headerName")
            writer.tag(4, WireType.LengthDelimited).string(message.randomValueSpecifier.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.WeightedCluster
 */
export const WeightedCluster = new WeightedCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightedCluster_ClusterWeight$Type extends MessageType<WeightedCluster_ClusterWeight> {
    constructor() {
        super("envoy.config.route.v3.WeightedCluster.ClusterWeight", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "udpa.annotations.field_migrate": { oneofPromotion: "cluster_specifier" } } },
            { no: 12, name: "cluster_header", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } }, "udpa.annotations.field_migrate": { oneofPromotion: "cluster_specifier" } } },
            { no: 2, name: "weight", kind: "message", T: () => UInt32Value },
            { no: 3, name: "metadata_match", kind: "message", T: () => Metadata },
            { no: 4, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 9, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 5, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 6, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 10, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 11, name: "host_rewrite_literal", kind: "scalar", oneof: "hostRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.WeightedCluster.ClusterWeight" } });
    }
    create(value?: PartialMessage<WeightedCluster_ClusterWeight>): WeightedCluster_ClusterWeight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.clusterHeader = "";
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        message.typedPerFilterConfig = {};
        message.hostRewriteSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<WeightedCluster_ClusterWeight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightedCluster_ClusterWeight): WeightedCluster_ClusterWeight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string cluster_header */ 12:
                    message.clusterHeader = reader.string();
                    break;
                case /* google.protobuf.UInt32Value weight */ 2:
                    message.weight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.weight);
                    break;
                case /* envoy.config.core.v3.Metadata metadata_match */ 3:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add */ 4:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 9:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add */ 5:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 6:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 10:
                    this.binaryReadMap10(message.typedPerFilterConfig, reader, options);
                    break;
                case /* string host_rewrite_literal */ 11:
                    message.hostRewriteSpecifier = {
                        oneofKind: "hostRewriteLiteral",
                        hostRewriteLiteral: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap10(map: WeightedCluster_ClusterWeight["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeightedCluster_ClusterWeight["typedPerFilterConfig"] | undefined, val: WeightedCluster_ClusterWeight["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: WeightedCluster_ClusterWeight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string cluster_header = 12; */
        if (message.clusterHeader !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.clusterHeader);
        /* google.protobuf.UInt32Value weight = 2; */
        if (message.weight)
            UInt32Value.internalBinaryWrite(message.weight, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata_match = 3; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 4; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 9; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.config.core.v3.HeaderValueOption response_headers_to_add = 5; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 6; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* map<string, google.protobuf.Any> typed_per_filter_config = 10; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* string host_rewrite_literal = 11; */
        if (message.hostRewriteSpecifier.oneofKind === "hostRewriteLiteral")
            writer.tag(11, WireType.LengthDelimited).string(message.hostRewriteSpecifier.hostRewriteLiteral);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.WeightedCluster.ClusterWeight
 */
export const WeightedCluster_ClusterWeight = new WeightedCluster_ClusterWeight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterSpecifierPlugin$Type extends MessageType<ClusterSpecifierPlugin> {
    constructor() {
        super("envoy.config.route.v3.ClusterSpecifierPlugin", [
            { no: 1, name: "extension", kind: "message", T: () => TypedExtensionConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "is_optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ClusterSpecifierPlugin>): ClusterSpecifierPlugin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOptional = false;
        if (value !== undefined)
            reflectionMergePartial<ClusterSpecifierPlugin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterSpecifierPlugin): ClusterSpecifierPlugin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig extension */ 1:
                    message.extension = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.extension);
                    break;
                case /* bool is_optional */ 2:
                    message.isOptional = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterSpecifierPlugin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig extension = 1; */
        if (message.extension)
            TypedExtensionConfig.internalBinaryWrite(message.extension, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_optional = 2; */
        if (message.isOptional !== false)
            writer.tag(2, WireType.Varint).bool(message.isOptional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.ClusterSpecifierPlugin
 */
export const ClusterSpecifierPlugin = new ClusterSpecifierPlugin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch$Type extends MessageType<RouteMatch> {
    constructor() {
        super("envoy.config.route.v3.RouteMatch", [
            { no: 1, name: "prefix", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "safe_regex", kind: "message", oneof: "pathSpecifier", T: () => RegexMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 12, name: "connect_matcher", kind: "message", oneof: "pathSpecifier", T: () => RouteMatch_ConnectMatcher },
            { no: 14, name: "path_separated_prefix", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { pattern: "^[^?#]+[^?#/]$" } } } },
            { no: 15, name: "path_match_policy", kind: "message", oneof: "pathSpecifier", T: () => TypedExtensionConfig },
            { no: 4, name: "case_sensitive", kind: "message", T: () => BoolValue },
            { no: 9, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 6, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 7, name: "query_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryParameterMatcher },
            { no: 8, name: "grpc", kind: "message", T: () => RouteMatch_GrpcRouteMatchOptions },
            { no: 11, name: "tls_context", kind: "message", T: () => RouteMatch_TlsContextMatchOptions },
            { no: 13, name: "dynamic_metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MetadataMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteMatch" } });
    }
    create(value?: PartialMessage<RouteMatch>): RouteMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathSpecifier = { oneofKind: undefined };
        message.headers = [];
        message.queryParameters = [];
        message.dynamicMetadata = [];
        if (value !== undefined)
            reflectionMergePartial<RouteMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch): RouteMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prefix */ 1:
                    message.pathSpecifier = {
                        oneofKind: "prefix",
                        prefix: reader.string()
                    };
                    break;
                case /* string path */ 2:
                    message.pathSpecifier = {
                        oneofKind: "path",
                        path: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.v3.RegexMatcher safe_regex */ 10:
                    message.pathSpecifier = {
                        oneofKind: "safeRegex",
                        safeRegex: RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.pathSpecifier as any).safeRegex)
                    };
                    break;
                case /* envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher */ 12:
                    message.pathSpecifier = {
                        oneofKind: "connectMatcher",
                        connectMatcher: RouteMatch_ConnectMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.pathSpecifier as any).connectMatcher)
                    };
                    break;
                case /* string path_separated_prefix */ 14:
                    message.pathSpecifier = {
                        oneofKind: "pathSeparatedPrefix",
                        pathSeparatedPrefix: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig path_match_policy */ 15:
                    message.pathSpecifier = {
                        oneofKind: "pathMatchPolicy",
                        pathMatchPolicy: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.pathSpecifier as any).pathMatchPolicy)
                    };
                    break;
                case /* google.protobuf.BoolValue case_sensitive */ 4:
                    message.caseSensitive = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.caseSensitive);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction */ 9:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 6:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.route.v3.QueryParameterMatcher query_parameters */ 7:
                    message.queryParameters.push(QueryParameterMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc */ 8:
                    message.grpc = RouteMatch_GrpcRouteMatchOptions.internalBinaryRead(reader, reader.uint32(), options, message.grpc);
                    break;
                case /* envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context */ 11:
                    message.tlsContext = RouteMatch_TlsContextMatchOptions.internalBinaryRead(reader, reader.uint32(), options, message.tlsContext);
                    break;
                case /* repeated envoy.type.matcher.v3.MetadataMatcher dynamic_metadata */ 13:
                    message.dynamicMetadata.push(MetadataMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prefix = 1; */
        if (message.pathSpecifier.oneofKind === "prefix")
            writer.tag(1, WireType.LengthDelimited).string(message.pathSpecifier.prefix);
        /* string path = 2; */
        if (message.pathSpecifier.oneofKind === "path")
            writer.tag(2, WireType.LengthDelimited).string(message.pathSpecifier.path);
        /* envoy.type.matcher.v3.RegexMatcher safe_regex = 10; */
        if (message.pathSpecifier.oneofKind === "safeRegex")
            RegexMatcher.internalBinaryWrite(message.pathSpecifier.safeRegex, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteMatch.ConnectMatcher connect_matcher = 12; */
        if (message.pathSpecifier.oneofKind === "connectMatcher")
            RouteMatch_ConnectMatcher.internalBinaryWrite(message.pathSpecifier.connectMatcher, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string path_separated_prefix = 14; */
        if (message.pathSpecifier.oneofKind === "pathSeparatedPrefix")
            writer.tag(14, WireType.LengthDelimited).string(message.pathSpecifier.pathSeparatedPrefix);
        /* envoy.config.core.v3.TypedExtensionConfig path_match_policy = 15; */
        if (message.pathSpecifier.oneofKind === "pathMatchPolicy")
            TypedExtensionConfig.internalBinaryWrite(message.pathSpecifier.pathMatchPolicy, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue case_sensitive = 4; */
        if (message.caseSensitive)
            BoolValue.internalBinaryWrite(message.caseSensitive, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 9; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 6; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.QueryParameterMatcher query_parameters = 7; */
        for (let i = 0; i < message.queryParameters.length; i++)
            QueryParameterMatcher.internalBinaryWrite(message.queryParameters[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions grpc = 8; */
        if (message.grpc)
            RouteMatch_GrpcRouteMatchOptions.internalBinaryWrite(message.grpc, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteMatch.TlsContextMatchOptions tls_context = 11; */
        if (message.tlsContext)
            RouteMatch_TlsContextMatchOptions.internalBinaryWrite(message.tlsContext, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.matcher.v3.MetadataMatcher dynamic_metadata = 13; */
        for (let i = 0; i < message.dynamicMetadata.length; i++)
            MetadataMatcher.internalBinaryWrite(message.dynamicMetadata[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteMatch
 */
export const RouteMatch = new RouteMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch_GrpcRouteMatchOptions$Type extends MessageType<RouteMatch_GrpcRouteMatchOptions> {
    constructor() {
        super("envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions" } });
    }
    create(value?: PartialMessage<RouteMatch_GrpcRouteMatchOptions>): RouteMatch_GrpcRouteMatchOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteMatch_GrpcRouteMatchOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch_GrpcRouteMatchOptions): RouteMatch_GrpcRouteMatchOptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RouteMatch_GrpcRouteMatchOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions
 */
export const RouteMatch_GrpcRouteMatchOptions = new RouteMatch_GrpcRouteMatchOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch_TlsContextMatchOptions$Type extends MessageType<RouteMatch_TlsContextMatchOptions> {
    constructor() {
        super("envoy.config.route.v3.RouteMatch.TlsContextMatchOptions", [
            { no: 1, name: "presented", kind: "message", T: () => BoolValue },
            { no: 2, name: "validated", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions" } });
    }
    create(value?: PartialMessage<RouteMatch_TlsContextMatchOptions>): RouteMatch_TlsContextMatchOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteMatch_TlsContextMatchOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch_TlsContextMatchOptions): RouteMatch_TlsContextMatchOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue presented */ 1:
                    message.presented = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.presented);
                    break;
                case /* google.protobuf.BoolValue validated */ 2:
                    message.validated = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.validated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMatch_TlsContextMatchOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue presented = 1; */
        if (message.presented)
            BoolValue.internalBinaryWrite(message.presented, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue validated = 2; */
        if (message.validated)
            BoolValue.internalBinaryWrite(message.validated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteMatch.TlsContextMatchOptions
 */
export const RouteMatch_TlsContextMatchOptions = new RouteMatch_TlsContextMatchOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch_ConnectMatcher$Type extends MessageType<RouteMatch_ConnectMatcher> {
    constructor() {
        super("envoy.config.route.v3.RouteMatch.ConnectMatcher", []);
    }
    create(value?: PartialMessage<RouteMatch_ConnectMatcher>): RouteMatch_ConnectMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteMatch_ConnectMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch_ConnectMatcher): RouteMatch_ConnectMatcher {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RouteMatch_ConnectMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteMatch.ConnectMatcher
 */
export const RouteMatch_ConnectMatcher = new RouteMatch_ConnectMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CorsPolicy$Type extends MessageType<CorsPolicy> {
    constructor() {
        super("envoy.config.route.v3.CorsPolicy", [
            { no: 11, name: "allow_origin_string_match", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringMatcher },
            { no: 2, name: "allow_methods", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allow_headers", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expose_headers", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "max_age", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "allow_credentials", kind: "message", T: () => BoolValue },
            { no: 9, name: "filter_enabled", kind: "message", oneof: "enabledSpecifier", T: () => RuntimeFractionalPercent },
            { no: 10, name: "shadow_enabled", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 12, name: "allow_private_network_access", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.CorsPolicy" } });
    }
    create(value?: PartialMessage<CorsPolicy>): CorsPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowOriginStringMatch = [];
        message.allowMethods = "";
        message.allowHeaders = "";
        message.exposeHeaders = "";
        message.maxAge = "";
        message.enabledSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CorsPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CorsPolicy): CorsPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.type.matcher.v3.StringMatcher allow_origin_string_match */ 11:
                    message.allowOriginStringMatch.push(StringMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string allow_methods */ 2:
                    message.allowMethods = reader.string();
                    break;
                case /* string allow_headers */ 3:
                    message.allowHeaders = reader.string();
                    break;
                case /* string expose_headers */ 4:
                    message.exposeHeaders = reader.string();
                    break;
                case /* string max_age */ 5:
                    message.maxAge = reader.string();
                    break;
                case /* google.protobuf.BoolValue allow_credentials */ 6:
                    message.allowCredentials = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowCredentials);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled */ 9:
                    message.enabledSpecifier = {
                        oneofKind: "filterEnabled",
                        filterEnabled: RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, (message.enabledSpecifier as any).filterEnabled)
                    };
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent shadow_enabled */ 10:
                    message.shadowEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.shadowEnabled);
                    break;
                case /* google.protobuf.BoolValue allow_private_network_access */ 12:
                    message.allowPrivateNetworkAccess = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowPrivateNetworkAccess);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CorsPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.type.matcher.v3.StringMatcher allow_origin_string_match = 11; */
        for (let i = 0; i < message.allowOriginStringMatch.length; i++)
            StringMatcher.internalBinaryWrite(message.allowOriginStringMatch[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string allow_methods = 2; */
        if (message.allowMethods !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.allowMethods);
        /* string allow_headers = 3; */
        if (message.allowHeaders !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.allowHeaders);
        /* string expose_headers = 4; */
        if (message.exposeHeaders !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.exposeHeaders);
        /* string max_age = 5; */
        if (message.maxAge !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.maxAge);
        /* google.protobuf.BoolValue allow_credentials = 6; */
        if (message.allowCredentials)
            BoolValue.internalBinaryWrite(message.allowCredentials, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9; */
        if (message.enabledSpecifier.oneofKind === "filterEnabled")
            RuntimeFractionalPercent.internalBinaryWrite(message.enabledSpecifier.filterEnabled, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent shadow_enabled = 10; */
        if (message.shadowEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.shadowEnabled, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue allow_private_network_access = 12; */
        if (message.allowPrivateNetworkAccess)
            BoolValue.internalBinaryWrite(message.allowPrivateNetworkAccess, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.CorsPolicy
 */
export const CorsPolicy = new CorsPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction$Type extends MessageType<RouteAction> {
    constructor() {
        super("envoy.config.route.v3.RouteAction", [
            { no: 1, name: "cluster", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "cluster_header", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 3, name: "weighted_clusters", kind: "message", oneof: "clusterSpecifier", T: () => WeightedCluster },
            { no: 37, name: "cluster_specifier_plugin", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 39, name: "inline_cluster_specifier_plugin", kind: "message", oneof: "clusterSpecifier", T: () => ClusterSpecifierPlugin },
            { no: 20, name: "cluster_not_found_response_code", kind: "enum", T: () => ["envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode", RouteAction_ClusterNotFoundResponseCode], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 4, name: "metadata_match", kind: "message", T: () => Metadata },
            { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 32, name: "regex_rewrite", kind: "message", T: () => RegexMatchAndSubstitute },
            { no: 41, name: "path_rewrite_policy", kind: "message", T: () => TypedExtensionConfig },
            { no: 6, name: "host_rewrite_literal", kind: "scalar", oneof: "hostRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 7, name: "auto_host_rewrite", kind: "message", oneof: "hostRewriteSpecifier", T: () => BoolValue },
            { no: 29, name: "host_rewrite_header", kind: "scalar", oneof: "hostRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 35, name: "host_rewrite_path_regex", kind: "message", oneof: "hostRewriteSpecifier", T: () => RegexMatchAndSubstitute },
            { no: 38, name: "append_x_forwarded_host", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "timeout", kind: "message", T: () => Duration },
            { no: 24, name: "idle_timeout", kind: "message", T: () => Duration },
            { no: 40, name: "early_data_policy", kind: "message", T: () => TypedExtensionConfig },
            { no: 9, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 33, name: "retry_policy_typed_config", kind: "message", T: () => Any },
            { no: 30, name: "request_mirror_policies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_RequestMirrorPolicy },
            { no: 11, name: "priority", kind: "enum", T: () => ["envoy.config.core.v3.RoutingPriority", RoutingPriority], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 13, name: "rate_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit },
            { no: 14, name: "include_vh_rate_limits", kind: "message", T: () => BoolValue, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 15, name: "hash_policy", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_HashPolicy },
            { no: 17, name: "cors", kind: "message", T: () => CorsPolicy, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 23, name: "max_grpc_timeout", kind: "message", T: () => Duration, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 28, name: "grpc_timeout_offset", kind: "message", T: () => Duration, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 25, name: "upgrade_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_UpgradeConfig },
            { no: 34, name: "internal_redirect_policy", kind: "message", T: () => InternalRedirectPolicy },
            { no: 26, name: "internal_redirect_action", kind: "enum", T: () => ["envoy.config.route.v3.RouteAction.InternalRedirectAction", RouteAction_InternalRedirectAction], options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 31, name: "max_internal_redirects", kind: "message", T: () => UInt32Value, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 27, name: "hedge_policy", kind: "message", T: () => HedgePolicy },
            { no: 36, name: "max_stream_duration", kind: "message", T: () => RouteAction_MaxStreamDuration }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction" } });
    }
    create(value?: PartialMessage<RouteAction>): RouteAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterSpecifier = { oneofKind: undefined };
        message.clusterNotFoundResponseCode = 0;
        message.prefixRewrite = "";
        message.hostRewriteSpecifier = { oneofKind: undefined };
        message.appendXForwardedHost = false;
        message.requestMirrorPolicies = [];
        message.priority = 0;
        message.rateLimits = [];
        message.hashPolicy = [];
        message.upgradeConfigs = [];
        message.internalRedirectAction = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction): RouteAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.clusterSpecifier = {
                        oneofKind: "cluster",
                        cluster: reader.string()
                    };
                    break;
                case /* string cluster_header */ 2:
                    message.clusterSpecifier = {
                        oneofKind: "clusterHeader",
                        clusterHeader: reader.string()
                    };
                    break;
                case /* envoy.config.route.v3.WeightedCluster weighted_clusters */ 3:
                    message.clusterSpecifier = {
                        oneofKind: "weightedClusters",
                        weightedClusters: WeightedCluster.internalBinaryRead(reader, reader.uint32(), options, (message.clusterSpecifier as any).weightedClusters)
                    };
                    break;
                case /* string cluster_specifier_plugin */ 37:
                    message.clusterSpecifier = {
                        oneofKind: "clusterSpecifierPlugin",
                        clusterSpecifierPlugin: reader.string()
                    };
                    break;
                case /* envoy.config.route.v3.ClusterSpecifierPlugin inline_cluster_specifier_plugin */ 39:
                    message.clusterSpecifier = {
                        oneofKind: "inlineClusterSpecifierPlugin",
                        inlineClusterSpecifierPlugin: ClusterSpecifierPlugin.internalBinaryRead(reader, reader.uint32(), options, (message.clusterSpecifier as any).inlineClusterSpecifierPlugin)
                    };
                    break;
                case /* envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code */ 20:
                    message.clusterNotFoundResponseCode = reader.int32();
                    break;
                case /* envoy.config.core.v3.Metadata metadata_match */ 4:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                case /* string prefix_rewrite */ 5:
                    message.prefixRewrite = reader.string();
                    break;
                case /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite */ 32:
                    message.regexRewrite = RegexMatchAndSubstitute.internalBinaryRead(reader, reader.uint32(), options, message.regexRewrite);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig path_rewrite_policy */ 41:
                    message.pathRewritePolicy = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.pathRewritePolicy);
                    break;
                case /* string host_rewrite_literal */ 6:
                    message.hostRewriteSpecifier = {
                        oneofKind: "hostRewriteLiteral",
                        hostRewriteLiteral: reader.string()
                    };
                    break;
                case /* google.protobuf.BoolValue auto_host_rewrite */ 7:
                    message.hostRewriteSpecifier = {
                        oneofKind: "autoHostRewrite",
                        autoHostRewrite: BoolValue.internalBinaryRead(reader, reader.uint32(), options, (message.hostRewriteSpecifier as any).autoHostRewrite)
                    };
                    break;
                case /* string host_rewrite_header */ 29:
                    message.hostRewriteSpecifier = {
                        oneofKind: "hostRewriteHeader",
                        hostRewriteHeader: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex */ 35:
                    message.hostRewriteSpecifier = {
                        oneofKind: "hostRewritePathRegex",
                        hostRewritePathRegex: RegexMatchAndSubstitute.internalBinaryRead(reader, reader.uint32(), options, (message.hostRewriteSpecifier as any).hostRewritePathRegex)
                    };
                    break;
                case /* bool append_x_forwarded_host */ 38:
                    message.appendXForwardedHost = reader.bool();
                    break;
                case /* google.protobuf.Duration timeout */ 8:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* google.protobuf.Duration idle_timeout */ 24:
                    message.idleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.idleTimeout);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig early_data_policy */ 40:
                    message.earlyDataPolicy = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.earlyDataPolicy);
                    break;
                case /* envoy.config.route.v3.RetryPolicy retry_policy */ 9:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* google.protobuf.Any retry_policy_typed_config */ 33:
                    message.retryPolicyTypedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicyTypedConfig);
                    break;
                case /* repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies */ 30:
                    message.requestMirrorPolicies.push(RouteAction_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.RoutingPriority priority */ 11:
                    message.priority = reader.int32();
                    break;
                case /* repeated envoy.config.route.v3.RateLimit rate_limits */ 13:
                    message.rateLimits.push(RateLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true];*/ 14:
                    message.includeVhRateLimits = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.includeVhRateLimits);
                    break;
                case /* repeated envoy.config.route.v3.RouteAction.HashPolicy hash_policy */ 15:
                    message.hashPolicy.push(RouteAction_HashPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.route.v3.CorsPolicy cors = 17 [deprecated = true];*/ 17:
                    message.cors = CorsPolicy.internalBinaryRead(reader, reader.uint32(), options, message.cors);
                    break;
                case /* google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true];*/ 23:
                    message.maxGrpcTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxGrpcTimeout);
                    break;
                case /* google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true];*/ 28:
                    message.grpcTimeoutOffset = Duration.internalBinaryRead(reader, reader.uint32(), options, message.grpcTimeoutOffset);
                    break;
                case /* repeated envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs */ 25:
                    message.upgradeConfigs.push(RouteAction_UpgradeConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy */ 34:
                    message.internalRedirectPolicy = InternalRedirectPolicy.internalBinaryRead(reader, reader.uint32(), options, message.internalRedirectPolicy);
                    break;
                case /* envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26 [deprecated = true];*/ 26:
                    message.internalRedirectAction = reader.int32();
                    break;
                case /* google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true];*/ 31:
                    message.maxInternalRedirects = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxInternalRedirects);
                    break;
                case /* envoy.config.route.v3.HedgePolicy hedge_policy */ 27:
                    message.hedgePolicy = HedgePolicy.internalBinaryRead(reader, reader.uint32(), options, message.hedgePolicy);
                    break;
                case /* envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration */ 36:
                    message.maxStreamDuration = RouteAction_MaxStreamDuration.internalBinaryRead(reader, reader.uint32(), options, message.maxStreamDuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.clusterSpecifier.oneofKind === "cluster")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterSpecifier.cluster);
        /* string cluster_header = 2; */
        if (message.clusterSpecifier.oneofKind === "clusterHeader")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterSpecifier.clusterHeader);
        /* envoy.config.route.v3.WeightedCluster weighted_clusters = 3; */
        if (message.clusterSpecifier.oneofKind === "weightedClusters")
            WeightedCluster.internalBinaryWrite(message.clusterSpecifier.weightedClusters, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string cluster_specifier_plugin = 37; */
        if (message.clusterSpecifier.oneofKind === "clusterSpecifierPlugin")
            writer.tag(37, WireType.LengthDelimited).string(message.clusterSpecifier.clusterSpecifierPlugin);
        /* envoy.config.route.v3.ClusterSpecifierPlugin inline_cluster_specifier_plugin = 39; */
        if (message.clusterSpecifier.oneofKind === "inlineClusterSpecifierPlugin")
            ClusterSpecifierPlugin.internalBinaryWrite(message.clusterSpecifier.inlineClusterSpecifierPlugin, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20; */
        if (message.clusterNotFoundResponseCode !== 0)
            writer.tag(20, WireType.Varint).int32(message.clusterNotFoundResponseCode);
        /* envoy.config.core.v3.Metadata metadata_match = 4; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string prefix_rewrite = 5; */
        if (message.prefixRewrite !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.prefixRewrite);
        /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 32; */
        if (message.regexRewrite)
            RegexMatchAndSubstitute.internalBinaryWrite(message.regexRewrite, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig path_rewrite_policy = 41; */
        if (message.pathRewritePolicy)
            TypedExtensionConfig.internalBinaryWrite(message.pathRewritePolicy, writer.tag(41, WireType.LengthDelimited).fork(), options).join();
        /* string host_rewrite_literal = 6; */
        if (message.hostRewriteSpecifier.oneofKind === "hostRewriteLiteral")
            writer.tag(6, WireType.LengthDelimited).string(message.hostRewriteSpecifier.hostRewriteLiteral);
        /* google.protobuf.BoolValue auto_host_rewrite = 7; */
        if (message.hostRewriteSpecifier.oneofKind === "autoHostRewrite")
            BoolValue.internalBinaryWrite(message.hostRewriteSpecifier.autoHostRewrite, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string host_rewrite_header = 29; */
        if (message.hostRewriteSpecifier.oneofKind === "hostRewriteHeader")
            writer.tag(29, WireType.LengthDelimited).string(message.hostRewriteSpecifier.hostRewriteHeader);
        /* envoy.type.matcher.v3.RegexMatchAndSubstitute host_rewrite_path_regex = 35; */
        if (message.hostRewriteSpecifier.oneofKind === "hostRewritePathRegex")
            RegexMatchAndSubstitute.internalBinaryWrite(message.hostRewriteSpecifier.hostRewritePathRegex, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* bool append_x_forwarded_host = 38; */
        if (message.appendXForwardedHost !== false)
            writer.tag(38, WireType.Varint).bool(message.appendXForwardedHost);
        /* google.protobuf.Duration timeout = 8; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration idle_timeout = 24; */
        if (message.idleTimeout)
            Duration.internalBinaryWrite(message.idleTimeout, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig early_data_policy = 40; */
        if (message.earlyDataPolicy)
            TypedExtensionConfig.internalBinaryWrite(message.earlyDataPolicy, writer.tag(40, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RetryPolicy retry_policy = 9; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any retry_policy_typed_config = 33; */
        if (message.retryPolicyTypedConfig)
            Any.internalBinaryWrite(message.retryPolicyTypedConfig, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RouteAction.RequestMirrorPolicy request_mirror_policies = 30; */
        for (let i = 0; i < message.requestMirrorPolicies.length; i++)
            RouteAction_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicies[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RoutingPriority priority = 11; */
        if (message.priority !== 0)
            writer.tag(11, WireType.Varint).int32(message.priority);
        /* repeated envoy.config.route.v3.RateLimit rate_limits = 13; */
        for (let i = 0; i < message.rateLimits.length; i++)
            RateLimit.internalBinaryWrite(message.rateLimits[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue include_vh_rate_limits = 14 [deprecated = true]; */
        if (message.includeVhRateLimits)
            BoolValue.internalBinaryWrite(message.includeVhRateLimits, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RouteAction.HashPolicy hash_policy = 15; */
        for (let i = 0; i < message.hashPolicy.length; i++)
            RouteAction_HashPolicy.internalBinaryWrite(message.hashPolicy[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.CorsPolicy cors = 17 [deprecated = true]; */
        if (message.cors)
            CorsPolicy.internalBinaryWrite(message.cors, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_grpc_timeout = 23 [deprecated = true]; */
        if (message.maxGrpcTimeout)
            Duration.internalBinaryWrite(message.maxGrpcTimeout, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration grpc_timeout_offset = 28 [deprecated = true]; */
        if (message.grpcTimeoutOffset)
            Duration.internalBinaryWrite(message.grpcTimeoutOffset, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RouteAction.UpgradeConfig upgrade_configs = 25; */
        for (let i = 0; i < message.upgradeConfigs.length; i++)
            RouteAction_UpgradeConfig.internalBinaryWrite(message.upgradeConfigs[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.InternalRedirectPolicy internal_redirect_policy = 34; */
        if (message.internalRedirectPolicy)
            InternalRedirectPolicy.internalBinaryWrite(message.internalRedirectPolicy, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.InternalRedirectAction internal_redirect_action = 26 [deprecated = true]; */
        if (message.internalRedirectAction !== 0)
            writer.tag(26, WireType.Varint).int32(message.internalRedirectAction);
        /* google.protobuf.UInt32Value max_internal_redirects = 31 [deprecated = true]; */
        if (message.maxInternalRedirects)
            UInt32Value.internalBinaryWrite(message.maxInternalRedirects, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.HedgePolicy hedge_policy = 27; */
        if (message.hedgePolicy)
            HedgePolicy.internalBinaryWrite(message.hedgePolicy, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.MaxStreamDuration max_stream_duration = 36; */
        if (message.maxStreamDuration)
            RouteAction_MaxStreamDuration.internalBinaryWrite(message.maxStreamDuration, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction
 */
export const RouteAction = new RouteAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_RequestMirrorPolicy$Type extends MessageType<RouteAction_RequestMirrorPolicy> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.RequestMirrorPolicy", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "udpa.annotations.field_migrate": { oneofPromotion: "cluster_specifier" } } },
            { no: 5, name: "cluster_header", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } }, "udpa.annotations.field_migrate": { oneofPromotion: "cluster_specifier" } } },
            { no: 3, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 4, name: "trace_sampled", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.RequestMirrorPolicy" } });
    }
    create(value?: PartialMessage<RouteAction_RequestMirrorPolicy>): RouteAction_RequestMirrorPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.clusterHeader = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_RequestMirrorPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_RequestMirrorPolicy): RouteAction_RequestMirrorPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* string cluster_header */ 5:
                    message.clusterHeader = reader.string();
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction */ 3:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* google.protobuf.BoolValue trace_sampled */ 4:
                    message.traceSampled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.traceSampled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_RequestMirrorPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* string cluster_header = 5; */
        if (message.clusterHeader !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.clusterHeader);
        /* envoy.config.core.v3.RuntimeFractionalPercent runtime_fraction = 3; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue trace_sampled = 4; */
        if (message.traceSampled)
            BoolValue.internalBinaryWrite(message.traceSampled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.RequestMirrorPolicy
 */
export const RouteAction_RequestMirrorPolicy = new RouteAction_RequestMirrorPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy$Type extends MessageType<RouteAction_HashPolicy> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy", [
            { no: 1, name: "header", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_Header },
            { no: 2, name: "cookie", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_Cookie },
            { no: 3, name: "connection_properties", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_ConnectionProperties },
            { no: 5, name: "query_parameter", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_QueryParameter },
            { no: 6, name: "filter_state", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_FilterState },
            { no: 4, name: "terminal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy>): RouteAction_HashPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.policySpecifier = { oneofKind: undefined };
        message.terminal = false;
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy): RouteAction_HashPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.route.v3.RouteAction.HashPolicy.Header header */ 1:
                    message.policySpecifier = {
                        oneofKind: "header",
                        header: RouteAction_HashPolicy_Header.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).header)
                    };
                    break;
                case /* envoy.config.route.v3.RouteAction.HashPolicy.Cookie cookie */ 2:
                    message.policySpecifier = {
                        oneofKind: "cookie",
                        cookie: RouteAction_HashPolicy_Cookie.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).cookie)
                    };
                    break;
                case /* envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties connection_properties */ 3:
                    message.policySpecifier = {
                        oneofKind: "connectionProperties",
                        connectionProperties: RouteAction_HashPolicy_ConnectionProperties.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).connectionProperties)
                    };
                    break;
                case /* envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter query_parameter */ 5:
                    message.policySpecifier = {
                        oneofKind: "queryParameter",
                        queryParameter: RouteAction_HashPolicy_QueryParameter.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).queryParameter)
                    };
                    break;
                case /* envoy.config.route.v3.RouteAction.HashPolicy.FilterState filter_state */ 6:
                    message.policySpecifier = {
                        oneofKind: "filterState",
                        filterState: RouteAction_HashPolicy_FilterState.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).filterState)
                    };
                    break;
                case /* bool terminal */ 4:
                    message.terminal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.route.v3.RouteAction.HashPolicy.Header header = 1; */
        if (message.policySpecifier.oneofKind === "header")
            RouteAction_HashPolicy_Header.internalBinaryWrite(message.policySpecifier.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.HashPolicy.Cookie cookie = 2; */
        if (message.policySpecifier.oneofKind === "cookie")
            RouteAction_HashPolicy_Cookie.internalBinaryWrite(message.policySpecifier.cookie, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3; */
        if (message.policySpecifier.oneofKind === "connectionProperties")
            RouteAction_HashPolicy_ConnectionProperties.internalBinaryWrite(message.policySpecifier.connectionProperties, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter query_parameter = 5; */
        if (message.policySpecifier.oneofKind === "queryParameter")
            RouteAction_HashPolicy_QueryParameter.internalBinaryWrite(message.policySpecifier.queryParameter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.HashPolicy.FilterState filter_state = 6; */
        if (message.policySpecifier.oneofKind === "filterState")
            RouteAction_HashPolicy_FilterState.internalBinaryWrite(message.policySpecifier.filterState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool terminal = 4; */
        if (message.terminal !== false)
            writer.tag(4, WireType.Varint).bool(message.terminal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy
 */
export const RouteAction_HashPolicy = new RouteAction_HashPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_Header$Type extends MessageType<RouteAction_HashPolicy_Header> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.Header", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "regex_rewrite", kind: "message", T: () => RegexMatchAndSubstitute }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy.Header" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_Header>): RouteAction_HashPolicy_Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_Header): RouteAction_HashPolicy_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                case /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite */ 2:
                    message.regexRewrite = RegexMatchAndSubstitute.internalBinaryRead(reader, reader.uint32(), options, message.regexRewrite);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 2; */
        if (message.regexRewrite)
            RegexMatchAndSubstitute.internalBinaryWrite(message.regexRewrite, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.Header
 */
export const RouteAction_HashPolicy_Header = new RouteAction_HashPolicy_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_CookieAttribute$Type extends MessageType<RouteAction_HashPolicy_CookieAttribute> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_CookieAttribute>): RouteAction_HashPolicy_CookieAttribute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_CookieAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_CookieAttribute): RouteAction_HashPolicy_CookieAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_CookieAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute
 */
export const RouteAction_HashPolicy_CookieAttribute = new RouteAction_HashPolicy_CookieAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_Cookie$Type extends MessageType<RouteAction_HashPolicy_Cookie> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.Cookie", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "ttl", kind: "message", T: () => Duration },
            { no: 3, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_HashPolicy_CookieAttribute }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy.Cookie" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_Cookie>): RouteAction_HashPolicy_Cookie {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.path = "";
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_Cookie>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_Cookie): RouteAction_HashPolicy_Cookie {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Duration ttl */ 2:
                    message.ttl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.ttl);
                    break;
                case /* string path */ 3:
                    message.path = reader.string();
                    break;
                case /* repeated envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute attributes */ 4:
                    message.attributes.push(RouteAction_HashPolicy_CookieAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_Cookie, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Duration ttl = 2; */
        if (message.ttl)
            Duration.internalBinaryWrite(message.ttl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string path = 3; */
        if (message.path !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        /* repeated envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute attributes = 4; */
        for (let i = 0; i < message.attributes.length; i++)
            RouteAction_HashPolicy_CookieAttribute.internalBinaryWrite(message.attributes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.Cookie
 */
export const RouteAction_HashPolicy_Cookie = new RouteAction_HashPolicy_Cookie$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_ConnectionProperties$Type extends MessageType<RouteAction_HashPolicy_ConnectionProperties> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties", [
            { no: 1, name: "source_ip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_ConnectionProperties>): RouteAction_HashPolicy_ConnectionProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceIp = false;
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_ConnectionProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_ConnectionProperties): RouteAction_HashPolicy_ConnectionProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool source_ip */ 1:
                    message.sourceIp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_ConnectionProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool source_ip = 1; */
        if (message.sourceIp !== false)
            writer.tag(1, WireType.Varint).bool(message.sourceIp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties
 */
export const RouteAction_HashPolicy_ConnectionProperties = new RouteAction_HashPolicy_ConnectionProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_QueryParameter$Type extends MessageType<RouteAction_HashPolicy_QueryParameter> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_QueryParameter>): RouteAction_HashPolicy_QueryParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_QueryParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_QueryParameter): RouteAction_HashPolicy_QueryParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_QueryParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter
 */
export const RouteAction_HashPolicy_QueryParameter = new RouteAction_HashPolicy_QueryParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_FilterState$Type extends MessageType<RouteAction_HashPolicy_FilterState> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.HashPolicy.FilterState", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.HashPolicy.FilterState" } });
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_FilterState>): RouteAction_HashPolicy_FilterState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_FilterState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_FilterState): RouteAction_HashPolicy_FilterState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_FilterState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.HashPolicy.FilterState
 */
export const RouteAction_HashPolicy_FilterState = new RouteAction_HashPolicy_FilterState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_UpgradeConfig$Type extends MessageType<RouteAction_UpgradeConfig> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.UpgradeConfig", [
            { no: 1, name: "upgrade_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 2, name: "enabled", kind: "message", T: () => BoolValue },
            { no: 3, name: "connect_config", kind: "message", T: () => RouteAction_UpgradeConfig_ConnectConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RouteAction.UpgradeConfig" } });
    }
    create(value?: PartialMessage<RouteAction_UpgradeConfig>): RouteAction_UpgradeConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upgradeType = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_UpgradeConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_UpgradeConfig): RouteAction_UpgradeConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string upgrade_type */ 1:
                    message.upgradeType = reader.string();
                    break;
                case /* google.protobuf.BoolValue enabled */ 2:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig connect_config */ 3:
                    message.connectConfig = RouteAction_UpgradeConfig_ConnectConfig.internalBinaryRead(reader, reader.uint32(), options, message.connectConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_UpgradeConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string upgrade_type = 1; */
        if (message.upgradeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.upgradeType);
        /* google.protobuf.BoolValue enabled = 2; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig connect_config = 3; */
        if (message.connectConfig)
            RouteAction_UpgradeConfig_ConnectConfig.internalBinaryWrite(message.connectConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.UpgradeConfig
 */
export const RouteAction_UpgradeConfig = new RouteAction_UpgradeConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_UpgradeConfig_ConnectConfig$Type extends MessageType<RouteAction_UpgradeConfig_ConnectConfig> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig", [
            { no: 1, name: "proxy_protocol_config", kind: "message", T: () => ProxyProtocolConfig },
            { no: 2, name: "allow_post", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RouteAction_UpgradeConfig_ConnectConfig>): RouteAction_UpgradeConfig_ConnectConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowPost = false;
        if (value !== undefined)
            reflectionMergePartial<RouteAction_UpgradeConfig_ConnectConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_UpgradeConfig_ConnectConfig): RouteAction_UpgradeConfig_ConnectConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ProxyProtocolConfig proxy_protocol_config */ 1:
                    message.proxyProtocolConfig = ProxyProtocolConfig.internalBinaryRead(reader, reader.uint32(), options, message.proxyProtocolConfig);
                    break;
                case /* bool allow_post */ 2:
                    message.allowPost = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_UpgradeConfig_ConnectConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ProxyProtocolConfig proxy_protocol_config = 1; */
        if (message.proxyProtocolConfig)
            ProxyProtocolConfig.internalBinaryWrite(message.proxyProtocolConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_post = 2; */
        if (message.allowPost !== false)
            writer.tag(2, WireType.Varint).bool(message.allowPost);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig
 */
export const RouteAction_UpgradeConfig_ConnectConfig = new RouteAction_UpgradeConfig_ConnectConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_MaxStreamDuration$Type extends MessageType<RouteAction_MaxStreamDuration> {
    constructor() {
        super("envoy.config.route.v3.RouteAction.MaxStreamDuration", [
            { no: 1, name: "max_stream_duration", kind: "message", T: () => Duration },
            { no: 2, name: "grpc_timeout_header_max", kind: "message", T: () => Duration },
            { no: 3, name: "grpc_timeout_header_offset", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<RouteAction_MaxStreamDuration>): RouteAction_MaxStreamDuration {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteAction_MaxStreamDuration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_MaxStreamDuration): RouteAction_MaxStreamDuration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration max_stream_duration */ 1:
                    message.maxStreamDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxStreamDuration);
                    break;
                case /* google.protobuf.Duration grpc_timeout_header_max */ 2:
                    message.grpcTimeoutHeaderMax = Duration.internalBinaryRead(reader, reader.uint32(), options, message.grpcTimeoutHeaderMax);
                    break;
                case /* google.protobuf.Duration grpc_timeout_header_offset */ 3:
                    message.grpcTimeoutHeaderOffset = Duration.internalBinaryRead(reader, reader.uint32(), options, message.grpcTimeoutHeaderOffset);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_MaxStreamDuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration max_stream_duration = 1; */
        if (message.maxStreamDuration)
            Duration.internalBinaryWrite(message.maxStreamDuration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration grpc_timeout_header_max = 2; */
        if (message.grpcTimeoutHeaderMax)
            Duration.internalBinaryWrite(message.grpcTimeoutHeaderMax, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration grpc_timeout_header_offset = 3; */
        if (message.grpcTimeoutHeaderOffset)
            Duration.internalBinaryWrite(message.grpcTimeoutHeaderOffset, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RouteAction.MaxStreamDuration
 */
export const RouteAction_MaxStreamDuration = new RouteAction_MaxStreamDuration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy", [
            { no: 1, name: "retry_on", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num_retries", kind: "message", T: () => UInt32Value, options: { "udpa.annotations.field_migrate": { rename: "max_retries" } } },
            { no: 3, name: "per_try_timeout", kind: "message", T: () => Duration },
            { no: 13, name: "per_try_idle_timeout", kind: "message", T: () => Duration },
            { no: 4, name: "retry_priority", kind: "message", T: () => RetryPolicy_RetryPriority },
            { no: 5, name: "retry_host_predicate", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetryPolicy_RetryHostPredicate },
            { no: 12, name: "retry_options_predicates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 6, name: "host_selection_retry_max_attempts", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "retriable_status_codes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "retry_back_off", kind: "message", T: () => RetryPolicy_RetryBackOff },
            { no: 11, name: "rate_limited_retry_back_off", kind: "message", T: () => RetryPolicy_RateLimitedRetryBackOff },
            { no: 9, name: "retriable_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 10, name: "retriable_request_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RetryPolicy" } });
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retryOn = "";
        message.retryHostPredicate = [];
        message.retryOptionsPredicates = [];
        message.hostSelectionRetryMaxAttempts = 0n;
        message.retriableStatusCodes = [];
        message.retriableHeaders = [];
        message.retriableRequestHeaders = [];
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string retry_on */ 1:
                    message.retryOn = reader.string();
                    break;
                case /* google.protobuf.UInt32Value num_retries */ 2:
                    message.numRetries = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.numRetries);
                    break;
                case /* google.protobuf.Duration per_try_timeout */ 3:
                    message.perTryTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.perTryTimeout);
                    break;
                case /* google.protobuf.Duration per_try_idle_timeout */ 13:
                    message.perTryIdleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.perTryIdleTimeout);
                    break;
                case /* envoy.config.route.v3.RetryPolicy.RetryPriority retry_priority */ 4:
                    message.retryPriority = RetryPolicy_RetryPriority.internalBinaryRead(reader, reader.uint32(), options, message.retryPriority);
                    break;
                case /* repeated envoy.config.route.v3.RetryPolicy.RetryHostPredicate retry_host_predicate */ 5:
                    message.retryHostPredicate.push(RetryPolicy_RetryHostPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig retry_options_predicates */ 12:
                    message.retryOptionsPredicates.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 host_selection_retry_max_attempts */ 6:
                    message.hostSelectionRetryMaxAttempts = reader.int64().toBigInt();
                    break;
                case /* repeated uint32 retriable_status_codes */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.retriableStatusCodes.push(reader.uint32());
                    else
                        message.retriableStatusCodes.push(reader.uint32());
                    break;
                case /* envoy.config.route.v3.RetryPolicy.RetryBackOff retry_back_off */ 8:
                    message.retryBackOff = RetryPolicy_RetryBackOff.internalBinaryRead(reader, reader.uint32(), options, message.retryBackOff);
                    break;
                case /* envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff rate_limited_retry_back_off */ 11:
                    message.rateLimitedRetryBackOff = RetryPolicy_RateLimitedRetryBackOff.internalBinaryRead(reader, reader.uint32(), options, message.rateLimitedRetryBackOff);
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher retriable_headers */ 9:
                    message.retriableHeaders.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher retriable_request_headers */ 10:
                    message.retriableRequestHeaders.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string retry_on = 1; */
        if (message.retryOn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.retryOn);
        /* google.protobuf.UInt32Value num_retries = 2; */
        if (message.numRetries)
            UInt32Value.internalBinaryWrite(message.numRetries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration per_try_timeout = 3; */
        if (message.perTryTimeout)
            Duration.internalBinaryWrite(message.perTryTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration per_try_idle_timeout = 13; */
        if (message.perTryIdleTimeout)
            Duration.internalBinaryWrite(message.perTryIdleTimeout, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RetryPolicy.RetryPriority retry_priority = 4; */
        if (message.retryPriority)
            RetryPolicy_RetryPriority.internalBinaryWrite(message.retryPriority, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.RetryPolicy.RetryHostPredicate retry_host_predicate = 5; */
        for (let i = 0; i < message.retryHostPredicate.length; i++)
            RetryPolicy_RetryHostPredicate.internalBinaryWrite(message.retryHostPredicate[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.TypedExtensionConfig retry_options_predicates = 12; */
        for (let i = 0; i < message.retryOptionsPredicates.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.retryOptionsPredicates[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* int64 host_selection_retry_max_attempts = 6; */
        if (message.hostSelectionRetryMaxAttempts !== 0n)
            writer.tag(6, WireType.Varint).int64(message.hostSelectionRetryMaxAttempts);
        /* repeated uint32 retriable_status_codes = 7; */
        if (message.retriableStatusCodes.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.retriableStatusCodes.length; i++)
                writer.uint32(message.retriableStatusCodes[i]);
            writer.join();
        }
        /* envoy.config.route.v3.RetryPolicy.RetryBackOff retry_back_off = 8; */
        if (message.retryBackOff)
            RetryPolicy_RetryBackOff.internalBinaryWrite(message.retryBackOff, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff rate_limited_retry_back_off = 11; */
        if (message.rateLimitedRetryBackOff)
            RetryPolicy_RateLimitedRetryBackOff.internalBinaryWrite(message.rateLimitedRetryBackOff, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.HeaderMatcher retriable_headers = 9; */
        for (let i = 0; i < message.retriableHeaders.length; i++)
            HeaderMatcher.internalBinaryWrite(message.retriableHeaders[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.HeaderMatcher retriable_request_headers = 10; */
        for (let i = 0; i < message.retriableRequestHeaders.length; i++)
            HeaderMatcher.internalBinaryWrite(message.retriableRequestHeaders[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryPriority$Type extends MessageType<RetryPolicy_RetryPriority> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy.RetryPriority", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RetryPolicy.RetryPriority" } });
    }
    create(value?: PartialMessage<RetryPolicy_RetryPriority>): RetryPolicy_RetryPriority {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryPriority>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryPriority): RetryPolicy_RetryPriority {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryPriority, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy.RetryPriority
 */
export const RetryPolicy_RetryPriority = new RetryPolicy_RetryPriority$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryHostPredicate$Type extends MessageType<RetryPolicy_RetryHostPredicate> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy.RetryHostPredicate", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RetryPolicy.RetryHostPredicate" } });
    }
    create(value?: PartialMessage<RetryPolicy_RetryHostPredicate>): RetryPolicy_RetryHostPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryHostPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryHostPredicate): RetryPolicy_RetryHostPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryHostPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy.RetryHostPredicate
 */
export const RetryPolicy_RetryHostPredicate = new RetryPolicy_RetryHostPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryBackOff$Type extends MessageType<RetryPolicy_RetryBackOff> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy.RetryBackOff", [
            { no: 1, name: "base_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 2, name: "max_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RetryPolicy.RetryBackOff" } });
    }
    create(value?: PartialMessage<RetryPolicy_RetryBackOff>): RetryPolicy_RetryBackOff {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryBackOff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryBackOff): RetryPolicy_RetryBackOff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration base_interval */ 1:
                    message.baseInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.baseInterval);
                    break;
                case /* google.protobuf.Duration max_interval */ 2:
                    message.maxInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryBackOff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration base_interval = 1; */
        if (message.baseInterval)
            Duration.internalBinaryWrite(message.baseInterval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_interval = 2; */
        if (message.maxInterval)
            Duration.internalBinaryWrite(message.maxInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy.RetryBackOff
 */
export const RetryPolicy_RetryBackOff = new RetryPolicy_RetryBackOff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_ResetHeader$Type extends MessageType<RetryPolicy_ResetHeader> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy.ResetHeader", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "format", kind: "enum", T: () => ["envoy.config.route.v3.RetryPolicy.ResetHeaderFormat", RetryPolicy_ResetHeaderFormat], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy_ResetHeader>): RetryPolicy_ResetHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.format = 0;
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_ResetHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_ResetHeader): RetryPolicy_ResetHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.config.route.v3.RetryPolicy.ResetHeaderFormat format */ 2:
                    message.format = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_ResetHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.config.route.v3.RetryPolicy.ResetHeaderFormat format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).int32(message.format);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy.ResetHeader
 */
export const RetryPolicy_ResetHeader = new RetryPolicy_ResetHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RateLimitedRetryBackOff$Type extends MessageType<RetryPolicy_RateLimitedRetryBackOff> {
    constructor() {
        super("envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff", [
            { no: 1, name: "reset_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetryPolicy_ResetHeader, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 2, name: "max_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy_RateLimitedRetryBackOff>): RetryPolicy_RateLimitedRetryBackOff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resetHeaders = [];
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RateLimitedRetryBackOff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RateLimitedRetryBackOff): RetryPolicy_RateLimitedRetryBackOff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.RetryPolicy.ResetHeader reset_headers */ 1:
                    message.resetHeaders.push(RetryPolicy_ResetHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration max_interval */ 2:
                    message.maxInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RateLimitedRetryBackOff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.RetryPolicy.ResetHeader reset_headers = 1; */
        for (let i = 0; i < message.resetHeaders.length; i++)
            RetryPolicy_ResetHeader.internalBinaryWrite(message.resetHeaders[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_interval = 2; */
        if (message.maxInterval)
            Duration.internalBinaryWrite(message.maxInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff
 */
export const RetryPolicy_RateLimitedRetryBackOff = new RetryPolicy_RateLimitedRetryBackOff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HedgePolicy$Type extends MessageType<HedgePolicy> {
    constructor() {
        super("envoy.config.route.v3.HedgePolicy", [
            { no: 1, name: "initial_requests", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 2, name: "additional_request_chance", kind: "message", T: () => FractionalPercent },
            { no: 3, name: "hedge_on_per_try_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.HedgePolicy" } });
    }
    create(value?: PartialMessage<HedgePolicy>): HedgePolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hedgeOnPerTryTimeout = false;
        if (value !== undefined)
            reflectionMergePartial<HedgePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HedgePolicy): HedgePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value initial_requests */ 1:
                    message.initialRequests = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.initialRequests);
                    break;
                case /* envoy.type.v3.FractionalPercent additional_request_chance */ 2:
                    message.additionalRequestChance = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.additionalRequestChance);
                    break;
                case /* bool hedge_on_per_try_timeout */ 3:
                    message.hedgeOnPerTryTimeout = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HedgePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value initial_requests = 1; */
        if (message.initialRequests)
            UInt32Value.internalBinaryWrite(message.initialRequests, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.FractionalPercent additional_request_chance = 2; */
        if (message.additionalRequestChance)
            FractionalPercent.internalBinaryWrite(message.additionalRequestChance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool hedge_on_per_try_timeout = 3; */
        if (message.hedgeOnPerTryTimeout !== false)
            writer.tag(3, WireType.Varint).bool(message.hedgeOnPerTryTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.HedgePolicy
 */
export const HedgePolicy = new HedgePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedirectAction$Type extends MessageType<RedirectAction> {
    constructor() {
        super("envoy.config.route.v3.RedirectAction", [
            { no: 4, name: "https_redirect", kind: "scalar", oneof: "schemeRewriteSpecifier", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "scheme_redirect", kind: "scalar", oneof: "schemeRewriteSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "host_redirect", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 8, name: "port_redirect", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "path_redirect", kind: "scalar", oneof: "pathRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 5, name: "prefix_rewrite", kind: "scalar", oneof: "pathRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 9, name: "regex_rewrite", kind: "message", oneof: "pathRewriteSpecifier", T: () => RegexMatchAndSubstitute },
            { no: 3, name: "response_code", kind: "enum", T: () => ["envoy.config.route.v3.RedirectAction.RedirectResponseCode", RedirectAction_RedirectResponseCode], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 6, name: "strip_query", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RedirectAction" } });
    }
    create(value?: PartialMessage<RedirectAction>): RedirectAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemeRewriteSpecifier = { oneofKind: undefined };
        message.hostRedirect = "";
        message.portRedirect = 0;
        message.pathRewriteSpecifier = { oneofKind: undefined };
        message.responseCode = 0;
        message.stripQuery = false;
        if (value !== undefined)
            reflectionMergePartial<RedirectAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedirectAction): RedirectAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool https_redirect */ 4:
                    message.schemeRewriteSpecifier = {
                        oneofKind: "httpsRedirect",
                        httpsRedirect: reader.bool()
                    };
                    break;
                case /* string scheme_redirect */ 7:
                    message.schemeRewriteSpecifier = {
                        oneofKind: "schemeRedirect",
                        schemeRedirect: reader.string()
                    };
                    break;
                case /* string host_redirect */ 1:
                    message.hostRedirect = reader.string();
                    break;
                case /* uint32 port_redirect */ 8:
                    message.portRedirect = reader.uint32();
                    break;
                case /* string path_redirect */ 2:
                    message.pathRewriteSpecifier = {
                        oneofKind: "pathRedirect",
                        pathRedirect: reader.string()
                    };
                    break;
                case /* string prefix_rewrite */ 5:
                    message.pathRewriteSpecifier = {
                        oneofKind: "prefixRewrite",
                        prefixRewrite: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite */ 9:
                    message.pathRewriteSpecifier = {
                        oneofKind: "regexRewrite",
                        regexRewrite: RegexMatchAndSubstitute.internalBinaryRead(reader, reader.uint32(), options, (message.pathRewriteSpecifier as any).regexRewrite)
                    };
                    break;
                case /* envoy.config.route.v3.RedirectAction.RedirectResponseCode response_code */ 3:
                    message.responseCode = reader.int32();
                    break;
                case /* bool strip_query */ 6:
                    message.stripQuery = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedirectAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool https_redirect = 4; */
        if (message.schemeRewriteSpecifier.oneofKind === "httpsRedirect")
            writer.tag(4, WireType.Varint).bool(message.schemeRewriteSpecifier.httpsRedirect);
        /* string scheme_redirect = 7; */
        if (message.schemeRewriteSpecifier.oneofKind === "schemeRedirect")
            writer.tag(7, WireType.LengthDelimited).string(message.schemeRewriteSpecifier.schemeRedirect);
        /* string host_redirect = 1; */
        if (message.hostRedirect !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostRedirect);
        /* uint32 port_redirect = 8; */
        if (message.portRedirect !== 0)
            writer.tag(8, WireType.Varint).uint32(message.portRedirect);
        /* string path_redirect = 2; */
        if (message.pathRewriteSpecifier.oneofKind === "pathRedirect")
            writer.tag(2, WireType.LengthDelimited).string(message.pathRewriteSpecifier.pathRedirect);
        /* string prefix_rewrite = 5; */
        if (message.pathRewriteSpecifier.oneofKind === "prefixRewrite")
            writer.tag(5, WireType.LengthDelimited).string(message.pathRewriteSpecifier.prefixRewrite);
        /* envoy.type.matcher.v3.RegexMatchAndSubstitute regex_rewrite = 9; */
        if (message.pathRewriteSpecifier.oneofKind === "regexRewrite")
            RegexMatchAndSubstitute.internalBinaryWrite(message.pathRewriteSpecifier.regexRewrite, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RedirectAction.RedirectResponseCode response_code = 3; */
        if (message.responseCode !== 0)
            writer.tag(3, WireType.Varint).int32(message.responseCode);
        /* bool strip_query = 6; */
        if (message.stripQuery !== false)
            writer.tag(6, WireType.Varint).bool(message.stripQuery);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RedirectAction
 */
export const RedirectAction = new RedirectAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DirectResponseAction$Type extends MessageType<DirectResponseAction> {
    constructor() {
        super("envoy.config.route.v3.DirectResponseAction", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lt: 600, gte: 200 } } } },
            { no: 2, name: "body", kind: "message", T: () => DataSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.DirectResponseAction" } });
    }
    create(value?: PartialMessage<DirectResponseAction>): DirectResponseAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<DirectResponseAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DirectResponseAction): DirectResponseAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* envoy.config.core.v3.DataSource body */ 2:
                    message.body = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DirectResponseAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* envoy.config.core.v3.DataSource body = 2; */
        if (message.body)
            DataSource.internalBinaryWrite(message.body, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.DirectResponseAction
 */
export const DirectResponseAction = new DirectResponseAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NonForwardingAction$Type extends MessageType<NonForwardingAction> {
    constructor() {
        super("envoy.config.route.v3.NonForwardingAction", []);
    }
    create(value?: PartialMessage<NonForwardingAction>): NonForwardingAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NonForwardingAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NonForwardingAction): NonForwardingAction {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NonForwardingAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.NonForwardingAction
 */
export const NonForwardingAction = new NonForwardingAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decorator$Type extends MessageType<Decorator> {
    constructor() {
        super("envoy.config.route.v3.Decorator", [
            { no: 1, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "propagate", kind: "message", T: () => BoolValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.Decorator" } });
    }
    create(value?: PartialMessage<Decorator>): Decorator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operation = "";
        if (value !== undefined)
            reflectionMergePartial<Decorator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decorator): Decorator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation */ 1:
                    message.operation = reader.string();
                    break;
                case /* google.protobuf.BoolValue propagate */ 2:
                    message.propagate = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.propagate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decorator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation = 1; */
        if (message.operation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operation);
        /* google.protobuf.BoolValue propagate = 2; */
        if (message.propagate)
            BoolValue.internalBinaryWrite(message.propagate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.Decorator
 */
export const Decorator = new Decorator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tracing$Type extends MessageType<Tracing> {
    constructor() {
        super("envoy.config.route.v3.Tracing", [
            { no: 1, name: "client_sampling", kind: "message", T: () => FractionalPercent },
            { no: 2, name: "random_sampling", kind: "message", T: () => FractionalPercent },
            { no: 3, name: "overall_sampling", kind: "message", T: () => FractionalPercent },
            { no: 4, name: "custom_tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomTag }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.Tracing" } });
    }
    create(value?: PartialMessage<Tracing>): Tracing {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.customTags = [];
        if (value !== undefined)
            reflectionMergePartial<Tracing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tracing): Tracing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.FractionalPercent client_sampling */ 1:
                    message.clientSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.clientSampling);
                    break;
                case /* envoy.type.v3.FractionalPercent random_sampling */ 2:
                    message.randomSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.randomSampling);
                    break;
                case /* envoy.type.v3.FractionalPercent overall_sampling */ 3:
                    message.overallSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.overallSampling);
                    break;
                case /* repeated envoy.type.tracing.v3.CustomTag custom_tags */ 4:
                    message.customTags.push(CustomTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tracing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.FractionalPercent client_sampling = 1; */
        if (message.clientSampling)
            FractionalPercent.internalBinaryWrite(message.clientSampling, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.FractionalPercent random_sampling = 2; */
        if (message.randomSampling)
            FractionalPercent.internalBinaryWrite(message.randomSampling, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.FractionalPercent overall_sampling = 3; */
        if (message.overallSampling)
            FractionalPercent.internalBinaryWrite(message.overallSampling, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.tracing.v3.CustomTag custom_tags = 4; */
        for (let i = 0; i < message.customTags.length; i++)
            CustomTag.internalBinaryWrite(message.customTags[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.Tracing
 */
export const Tracing = new Tracing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VirtualCluster$Type extends MessageType<VirtualCluster> {
    constructor() {
        super("envoy.config.route.v3.VirtualCluster", [
            { no: 4, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.VirtualCluster" } });
    }
    create(value?: PartialMessage<VirtualCluster>): VirtualCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<VirtualCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VirtualCluster): VirtualCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 4:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VirtualCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 4; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.VirtualCluster
 */
export const VirtualCluster = new VirtualCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit$Type extends MessageType<RateLimit> {
    constructor() {
        super("envoy.config.route.v3.RateLimit", [
            { no: 1, name: "stage", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 10 } } } },
            { no: 2, name: "disable_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit_Action, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 4, name: "limit", kind: "message", T: () => RateLimit_Override }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit" } });
    }
    create(value?: PartialMessage<RateLimit>): RateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disableKey = "";
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit): RateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value stage */ 1:
                    message.stage = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.stage);
                    break;
                case /* string disable_key */ 2:
                    message.disableKey = reader.string();
                    break;
                case /* repeated envoy.config.route.v3.RateLimit.Action actions */ 3:
                    message.actions.push(RateLimit_Action.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.route.v3.RateLimit.Override limit */ 4:
                    message.limit = RateLimit_Override.internalBinaryRead(reader, reader.uint32(), options, message.limit);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value stage = 1; */
        if (message.stage)
            UInt32Value.internalBinaryWrite(message.stage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string disable_key = 2; */
        if (message.disableKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.disableKey);
        /* repeated envoy.config.route.v3.RateLimit.Action actions = 3; */
        for (let i = 0; i < message.actions.length; i++)
            RateLimit_Action.internalBinaryWrite(message.actions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Override limit = 4; */
        if (message.limit)
            RateLimit_Override.internalBinaryWrite(message.limit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit
 */
export const RateLimit = new RateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action$Type extends MessageType<RateLimit_Action> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action", [
            { no: 1, name: "source_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_SourceCluster },
            { no: 2, name: "destination_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_DestinationCluster },
            { no: 3, name: "request_headers", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_RequestHeaders },
            { no: 4, name: "remote_address", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_RemoteAddress },
            { no: 5, name: "generic_key", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_GenericKey },
            { no: 6, name: "header_value_match", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_HeaderValueMatch },
            { no: 7, name: "dynamic_metadata", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_DynamicMetaData, options: { "envoy.annotations.disallowed_by_default": true, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 8, name: "metadata", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_MetaData },
            { no: 9, name: "extension", kind: "message", oneof: "actionSpecifier", T: () => TypedExtensionConfig },
            { no: 10, name: "masked_remote_address", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_MaskedRemoteAddress },
            { no: 11, name: "query_parameter_value_match", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_QueryParameterValueMatch }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action" } });
    }
    create(value?: PartialMessage<RateLimit_Action>): RateLimit_Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action): RateLimit_Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.route.v3.RateLimit.Action.SourceCluster source_cluster */ 1:
                    message.actionSpecifier = {
                        oneofKind: "sourceCluster",
                        sourceCluster: RateLimit_Action_SourceCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).sourceCluster)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.DestinationCluster destination_cluster */ 2:
                    message.actionSpecifier = {
                        oneofKind: "destinationCluster",
                        destinationCluster: RateLimit_Action_DestinationCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).destinationCluster)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.RequestHeaders request_headers */ 3:
                    message.actionSpecifier = {
                        oneofKind: "requestHeaders",
                        requestHeaders: RateLimit_Action_RequestHeaders.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).requestHeaders)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.RemoteAddress remote_address */ 4:
                    message.actionSpecifier = {
                        oneofKind: "remoteAddress",
                        remoteAddress: RateLimit_Action_RemoteAddress.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).remoteAddress)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.GenericKey generic_key */ 5:
                    message.actionSpecifier = {
                        oneofKind: "genericKey",
                        genericKey: RateLimit_Action_GenericKey.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).genericKey)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.HeaderValueMatch header_value_match */ 6:
                    message.actionSpecifier = {
                        oneofKind: "headerValueMatch",
                        headerValueMatch: RateLimit_Action_HeaderValueMatch.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).headerValueMatch)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.DynamicMetaData dynamic_metadata = 7 [deprecated = true];*/ 7:
                    message.actionSpecifier = {
                        oneofKind: "dynamicMetadata",
                        dynamicMetadata: RateLimit_Action_DynamicMetaData.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).dynamicMetadata)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.MetaData metadata */ 8:
                    message.actionSpecifier = {
                        oneofKind: "metadata",
                        metadata: RateLimit_Action_MetaData.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).metadata)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig extension */ 9:
                    message.actionSpecifier = {
                        oneofKind: "extension",
                        extension: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).extension)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress masked_remote_address */ 10:
                    message.actionSpecifier = {
                        oneofKind: "maskedRemoteAddress",
                        maskedRemoteAddress: RateLimit_Action_MaskedRemoteAddress.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).maskedRemoteAddress)
                    };
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch query_parameter_value_match */ 11:
                    message.actionSpecifier = {
                        oneofKind: "queryParameterValueMatch",
                        queryParameterValueMatch: RateLimit_Action_QueryParameterValueMatch.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).queryParameterValueMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.route.v3.RateLimit.Action.SourceCluster source_cluster = 1; */
        if (message.actionSpecifier.oneofKind === "sourceCluster")
            RateLimit_Action_SourceCluster.internalBinaryWrite(message.actionSpecifier.sourceCluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.DestinationCluster destination_cluster = 2; */
        if (message.actionSpecifier.oneofKind === "destinationCluster")
            RateLimit_Action_DestinationCluster.internalBinaryWrite(message.actionSpecifier.destinationCluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.RequestHeaders request_headers = 3; */
        if (message.actionSpecifier.oneofKind === "requestHeaders")
            RateLimit_Action_RequestHeaders.internalBinaryWrite(message.actionSpecifier.requestHeaders, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.RemoteAddress remote_address = 4; */
        if (message.actionSpecifier.oneofKind === "remoteAddress")
            RateLimit_Action_RemoteAddress.internalBinaryWrite(message.actionSpecifier.remoteAddress, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.GenericKey generic_key = 5; */
        if (message.actionSpecifier.oneofKind === "genericKey")
            RateLimit_Action_GenericKey.internalBinaryWrite(message.actionSpecifier.genericKey, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.HeaderValueMatch header_value_match = 6; */
        if (message.actionSpecifier.oneofKind === "headerValueMatch")
            RateLimit_Action_HeaderValueMatch.internalBinaryWrite(message.actionSpecifier.headerValueMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.DynamicMetaData dynamic_metadata = 7 [deprecated = true]; */
        if (message.actionSpecifier.oneofKind === "dynamicMetadata")
            RateLimit_Action_DynamicMetaData.internalBinaryWrite(message.actionSpecifier.dynamicMetadata, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.MetaData metadata = 8; */
        if (message.actionSpecifier.oneofKind === "metadata")
            RateLimit_Action_MetaData.internalBinaryWrite(message.actionSpecifier.metadata, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig extension = 9; */
        if (message.actionSpecifier.oneofKind === "extension")
            TypedExtensionConfig.internalBinaryWrite(message.actionSpecifier.extension, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress masked_remote_address = 10; */
        if (message.actionSpecifier.oneofKind === "maskedRemoteAddress")
            RateLimit_Action_MaskedRemoteAddress.internalBinaryWrite(message.actionSpecifier.maskedRemoteAddress, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch query_parameter_value_match = 11; */
        if (message.actionSpecifier.oneofKind === "queryParameterValueMatch")
            RateLimit_Action_QueryParameterValueMatch.internalBinaryWrite(message.actionSpecifier.queryParameterValueMatch, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action
 */
export const RateLimit_Action = new RateLimit_Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_SourceCluster$Type extends MessageType<RateLimit_Action_SourceCluster> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.SourceCluster", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.SourceCluster" } });
    }
    create(value?: PartialMessage<RateLimit_Action_SourceCluster>): RateLimit_Action_SourceCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_SourceCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_SourceCluster): RateLimit_Action_SourceCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_SourceCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.SourceCluster
 */
export const RateLimit_Action_SourceCluster = new RateLimit_Action_SourceCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_DestinationCluster$Type extends MessageType<RateLimit_Action_DestinationCluster> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.DestinationCluster", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.DestinationCluster" } });
    }
    create(value?: PartialMessage<RateLimit_Action_DestinationCluster>): RateLimit_Action_DestinationCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_DestinationCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_DestinationCluster): RateLimit_Action_DestinationCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_DestinationCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.DestinationCluster
 */
export const RateLimit_Action_DestinationCluster = new RateLimit_Action_DestinationCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_RequestHeaders$Type extends MessageType<RateLimit_Action_RequestHeaders> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.RequestHeaders", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "skip_if_absent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.RequestHeaders" } });
    }
    create(value?: PartialMessage<RateLimit_Action_RequestHeaders>): RateLimit_Action_RequestHeaders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        message.descriptorKey = "";
        message.skipIfAbsent = false;
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_RequestHeaders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_RequestHeaders): RateLimit_Action_RequestHeaders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                case /* string descriptor_key */ 2:
                    message.descriptorKey = reader.string();
                    break;
                case /* bool skip_if_absent */ 3:
                    message.skipIfAbsent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_RequestHeaders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        /* string descriptor_key = 2; */
        if (message.descriptorKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.descriptorKey);
        /* bool skip_if_absent = 3; */
        if (message.skipIfAbsent !== false)
            writer.tag(3, WireType.Varint).bool(message.skipIfAbsent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.RequestHeaders
 */
export const RateLimit_Action_RequestHeaders = new RateLimit_Action_RequestHeaders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_RemoteAddress$Type extends MessageType<RateLimit_Action_RemoteAddress> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.RemoteAddress", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.RemoteAddress" } });
    }
    create(value?: PartialMessage<RateLimit_Action_RemoteAddress>): RateLimit_Action_RemoteAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_RemoteAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_RemoteAddress): RateLimit_Action_RemoteAddress {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_RemoteAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.RemoteAddress
 */
export const RateLimit_Action_RemoteAddress = new RateLimit_Action_RemoteAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_MaskedRemoteAddress$Type extends MessageType<RateLimit_Action_MaskedRemoteAddress> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress", [
            { no: 1, name: "v4_prefix_mask_len", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 32 } } } },
            { no: 2, name: "v6_prefix_mask_len", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 128 } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_MaskedRemoteAddress>): RateLimit_Action_MaskedRemoteAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_MaskedRemoteAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_MaskedRemoteAddress): RateLimit_Action_MaskedRemoteAddress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value v4_prefix_mask_len */ 1:
                    message.v4PrefixMaskLen = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.v4PrefixMaskLen);
                    break;
                case /* google.protobuf.UInt32Value v6_prefix_mask_len */ 2:
                    message.v6PrefixMaskLen = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.v6PrefixMaskLen);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_MaskedRemoteAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value v4_prefix_mask_len = 1; */
        if (message.v4PrefixMaskLen)
            UInt32Value.internalBinaryWrite(message.v4PrefixMaskLen, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value v6_prefix_mask_len = 2; */
        if (message.v6PrefixMaskLen)
            UInt32Value.internalBinaryWrite(message.v6PrefixMaskLen, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress
 */
export const RateLimit_Action_MaskedRemoteAddress = new RateLimit_Action_MaskedRemoteAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_GenericKey$Type extends MessageType<RateLimit_Action_GenericKey> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.GenericKey", [
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.GenericKey" } });
    }
    create(value?: PartialMessage<RateLimit_Action_GenericKey>): RateLimit_Action_GenericKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorValue = "";
        message.descriptorKey = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_GenericKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_GenericKey): RateLimit_Action_GenericKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* string descriptor_key */ 2:
                    message.descriptorKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_GenericKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* string descriptor_key = 2; */
        if (message.descriptorKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.descriptorKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.GenericKey
 */
export const RateLimit_Action_GenericKey = new RateLimit_Action_GenericKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_HeaderValueMatch$Type extends MessageType<RateLimit_Action_HeaderValueMatch> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.HeaderValueMatch", [
            { no: 4, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "expect_match", kind: "message", T: () => BoolValue },
            { no: 3, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch" } });
    }
    create(value?: PartialMessage<RateLimit_Action_HeaderValueMatch>): RateLimit_Action_HeaderValueMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorKey = "";
        message.descriptorValue = "";
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_HeaderValueMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_HeaderValueMatch): RateLimit_Action_HeaderValueMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_key */ 4:
                    message.descriptorKey = reader.string();
                    break;
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* google.protobuf.BoolValue expect_match */ 2:
                    message.expectMatch = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.expectMatch);
                    break;
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 3:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_HeaderValueMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_key = 4; */
        if (message.descriptorKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.descriptorKey);
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* google.protobuf.BoolValue expect_match = 2; */
        if (message.expectMatch)
            BoolValue.internalBinaryWrite(message.expectMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 3; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.HeaderValueMatch
 */
export const RateLimit_Action_HeaderValueMatch = new RateLimit_Action_HeaderValueMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_DynamicMetaData$Type extends MessageType<RateLimit_Action_DynamicMetaData> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.DynamicMetaData", [
            { no: 1, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "metadata_key", kind: "message", T: () => MetadataKey, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_DynamicMetaData>): RateLimit_Action_DynamicMetaData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorKey = "";
        message.defaultValue = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_DynamicMetaData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_DynamicMetaData): RateLimit_Action_DynamicMetaData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_key */ 1:
                    message.descriptorKey = reader.string();
                    break;
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 2:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                case /* string default_value */ 3:
                    message.defaultValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_DynamicMetaData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_key = 1; */
        if (message.descriptorKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorKey);
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 2; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string default_value = 3; */
        if (message.defaultValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.DynamicMetaData
 */
export const RateLimit_Action_DynamicMetaData = new RateLimit_Action_DynamicMetaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_MetaData$Type extends MessageType<RateLimit_Action_MetaData> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.MetaData", [
            { no: 1, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "metadata_key", kind: "message", T: () => MetadataKey, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "default_value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "source", kind: "enum", T: () => ["envoy.config.route.v3.RateLimit.Action.MetaData.Source", RateLimit_Action_MetaData_Source], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 5, name: "skip_if_absent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_MetaData>): RateLimit_Action_MetaData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorKey = "";
        message.defaultValue = "";
        message.source = 0;
        message.skipIfAbsent = false;
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_MetaData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_MetaData): RateLimit_Action_MetaData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_key */ 1:
                    message.descriptorKey = reader.string();
                    break;
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 2:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                case /* string default_value */ 3:
                    message.defaultValue = reader.string();
                    break;
                case /* envoy.config.route.v3.RateLimit.Action.MetaData.Source source */ 4:
                    message.source = reader.int32();
                    break;
                case /* bool skip_if_absent */ 5:
                    message.skipIfAbsent = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_MetaData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_key = 1; */
        if (message.descriptorKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorKey);
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 2; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string default_value = 3; */
        if (message.defaultValue !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultValue);
        /* envoy.config.route.v3.RateLimit.Action.MetaData.Source source = 4; */
        if (message.source !== 0)
            writer.tag(4, WireType.Varint).int32(message.source);
        /* bool skip_if_absent = 5; */
        if (message.skipIfAbsent !== false)
            writer.tag(5, WireType.Varint).bool(message.skipIfAbsent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.MetaData
 */
export const RateLimit_Action_MetaData = new RateLimit_Action_MetaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_QueryParameterValueMatch$Type extends MessageType<RateLimit_Action_QueryParameterValueMatch> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch", [
            { no: 4, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "expect_match", kind: "message", T: () => BoolValue },
            { no: 3, name: "query_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryParameterMatcher, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_QueryParameterValueMatch>): RateLimit_Action_QueryParameterValueMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorKey = "";
        message.descriptorValue = "";
        message.queryParameters = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_QueryParameterValueMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_QueryParameterValueMatch): RateLimit_Action_QueryParameterValueMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_key */ 4:
                    message.descriptorKey = reader.string();
                    break;
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* google.protobuf.BoolValue expect_match */ 2:
                    message.expectMatch = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.expectMatch);
                    break;
                case /* repeated envoy.config.route.v3.QueryParameterMatcher query_parameters */ 3:
                    message.queryParameters.push(QueryParameterMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_QueryParameterValueMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_key = 4; */
        if (message.descriptorKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.descriptorKey);
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* google.protobuf.BoolValue expect_match = 2; */
        if (message.expectMatch)
            BoolValue.internalBinaryWrite(message.expectMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.route.v3.QueryParameterMatcher query_parameters = 3; */
        for (let i = 0; i < message.queryParameters.length; i++)
            QueryParameterMatcher.internalBinaryWrite(message.queryParameters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch
 */
export const RateLimit_Action_QueryParameterValueMatch = new RateLimit_Action_QueryParameterValueMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Override$Type extends MessageType<RateLimit_Override> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Override", [
            { no: 1, name: "dynamic_metadata", kind: "message", oneof: "overrideSpecifier", T: () => RateLimit_Override_DynamicMetadata }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Override>): RateLimit_Override {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.overrideSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Override>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Override): RateLimit_Override {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.route.v3.RateLimit.Override.DynamicMetadata dynamic_metadata */ 1:
                    message.overrideSpecifier = {
                        oneofKind: "dynamicMetadata",
                        dynamicMetadata: RateLimit_Override_DynamicMetadata.internalBinaryRead(reader, reader.uint32(), options, (message.overrideSpecifier as any).dynamicMetadata)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Override, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.route.v3.RateLimit.Override.DynamicMetadata dynamic_metadata = 1; */
        if (message.overrideSpecifier.oneofKind === "dynamicMetadata")
            RateLimit_Override_DynamicMetadata.internalBinaryWrite(message.overrideSpecifier.dynamicMetadata, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Override
 */
export const RateLimit_Override = new RateLimit_Override$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Override_DynamicMetadata$Type extends MessageType<RateLimit_Override_DynamicMetadata> {
    constructor() {
        super("envoy.config.route.v3.RateLimit.Override.DynamicMetadata", [
            { no: 1, name: "metadata_key", kind: "message", T: () => MetadataKey, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Override_DynamicMetadata>): RateLimit_Override_DynamicMetadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Override_DynamicMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Override_DynamicMetadata): RateLimit_Override_DynamicMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.metadata.v3.MetadataKey metadata_key */ 1:
                    message.metadataKey = MetadataKey.internalBinaryRead(reader, reader.uint32(), options, message.metadataKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Override_DynamicMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.metadata.v3.MetadataKey metadata_key = 1; */
        if (message.metadataKey)
            MetadataKey.internalBinaryWrite(message.metadataKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.RateLimit.Override.DynamicMetadata
 */
export const RateLimit_Override_DynamicMetadata = new RateLimit_Override_DynamicMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMatcher$Type extends MessageType<HeaderMatcher> {
    constructor() {
        super("envoy.config.route.v3.HeaderMatcher", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 4, name: "exact_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 11, name: "safe_regex_match", kind: "message", oneof: "headerMatchSpecifier", T: () => RegexMatcher, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 6, name: "range_match", kind: "message", oneof: "headerMatchSpecifier", T: () => Int64Range },
            { no: 7, name: "present_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "prefix_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } }, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 10, name: "suffix_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } }, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 12, name: "contains_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } }, "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 13, name: "string_match", kind: "message", oneof: "headerMatchSpecifier", T: () => StringMatcher },
            { no: 8, name: "invert_match", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "treat_missing_header_as_empty", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.HeaderMatcher" } });
    }
    create(value?: PartialMessage<HeaderMatcher>): HeaderMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.headerMatchSpecifier = { oneofKind: undefined };
        message.invertMatch = false;
        message.treatMissingHeaderAsEmpty = false;
        if (value !== undefined)
            reflectionMergePartial<HeaderMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMatcher): HeaderMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string exact_match = 4 [deprecated = true];*/ 4:
                    message.headerMatchSpecifier = {
                        oneofKind: "exactMatch",
                        exactMatch: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.v3.RegexMatcher safe_regex_match = 11 [deprecated = true];*/ 11:
                    message.headerMatchSpecifier = {
                        oneofKind: "safeRegexMatch",
                        safeRegexMatch: RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.headerMatchSpecifier as any).safeRegexMatch)
                    };
                    break;
                case /* envoy.type.v3.Int64Range range_match */ 6:
                    message.headerMatchSpecifier = {
                        oneofKind: "rangeMatch",
                        rangeMatch: Int64Range.internalBinaryRead(reader, reader.uint32(), options, (message.headerMatchSpecifier as any).rangeMatch)
                    };
                    break;
                case /* bool present_match */ 7:
                    message.headerMatchSpecifier = {
                        oneofKind: "presentMatch",
                        presentMatch: reader.bool()
                    };
                    break;
                case /* string prefix_match = 9 [deprecated = true];*/ 9:
                    message.headerMatchSpecifier = {
                        oneofKind: "prefixMatch",
                        prefixMatch: reader.string()
                    };
                    break;
                case /* string suffix_match = 10 [deprecated = true];*/ 10:
                    message.headerMatchSpecifier = {
                        oneofKind: "suffixMatch",
                        suffixMatch: reader.string()
                    };
                    break;
                case /* string contains_match = 12 [deprecated = true];*/ 12:
                    message.headerMatchSpecifier = {
                        oneofKind: "containsMatch",
                        containsMatch: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.v3.StringMatcher string_match */ 13:
                    message.headerMatchSpecifier = {
                        oneofKind: "stringMatch",
                        stringMatch: StringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.headerMatchSpecifier as any).stringMatch)
                    };
                    break;
                case /* bool invert_match */ 8:
                    message.invertMatch = reader.bool();
                    break;
                case /* bool treat_missing_header_as_empty */ 14:
                    message.treatMissingHeaderAsEmpty = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string exact_match = 4 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "exactMatch")
            writer.tag(4, WireType.LengthDelimited).string(message.headerMatchSpecifier.exactMatch);
        /* envoy.type.matcher.v3.RegexMatcher safe_regex_match = 11 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "safeRegexMatch")
            RegexMatcher.internalBinaryWrite(message.headerMatchSpecifier.safeRegexMatch, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Int64Range range_match = 6; */
        if (message.headerMatchSpecifier.oneofKind === "rangeMatch")
            Int64Range.internalBinaryWrite(message.headerMatchSpecifier.rangeMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool present_match = 7; */
        if (message.headerMatchSpecifier.oneofKind === "presentMatch")
            writer.tag(7, WireType.Varint).bool(message.headerMatchSpecifier.presentMatch);
        /* string prefix_match = 9 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "prefixMatch")
            writer.tag(9, WireType.LengthDelimited).string(message.headerMatchSpecifier.prefixMatch);
        /* string suffix_match = 10 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "suffixMatch")
            writer.tag(10, WireType.LengthDelimited).string(message.headerMatchSpecifier.suffixMatch);
        /* string contains_match = 12 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "containsMatch")
            writer.tag(12, WireType.LengthDelimited).string(message.headerMatchSpecifier.containsMatch);
        /* envoy.type.matcher.v3.StringMatcher string_match = 13; */
        if (message.headerMatchSpecifier.oneofKind === "stringMatch")
            StringMatcher.internalBinaryWrite(message.headerMatchSpecifier.stringMatch, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool invert_match = 8; */
        if (message.invertMatch !== false)
            writer.tag(8, WireType.Varint).bool(message.invertMatch);
        /* bool treat_missing_header_as_empty = 14; */
        if (message.treatMissingHeaderAsEmpty !== false)
            writer.tag(14, WireType.Varint).bool(message.treatMissingHeaderAsEmpty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.HeaderMatcher
 */
export const HeaderMatcher = new HeaderMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParameterMatcher$Type extends MessageType<QueryParameterMatcher> {
    constructor() {
        super("envoy.config.route.v3.QueryParameterMatcher", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxBytes: "1024" } } } },
            { no: 5, name: "string_match", kind: "message", oneof: "queryParameterMatchSpecifier", T: () => StringMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "present_match", kind: "scalar", oneof: "queryParameterMatchSpecifier", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.route.QueryParameterMatcher" } });
    }
    create(value?: PartialMessage<QueryParameterMatcher>): QueryParameterMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.queryParameterMatchSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<QueryParameterMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParameterMatcher): QueryParameterMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.type.matcher.v3.StringMatcher string_match */ 5:
                    message.queryParameterMatchSpecifier = {
                        oneofKind: "stringMatch",
                        stringMatch: StringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.queryParameterMatchSpecifier as any).stringMatch)
                    };
                    break;
                case /* bool present_match */ 6:
                    message.queryParameterMatchSpecifier = {
                        oneofKind: "presentMatch",
                        presentMatch: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParameterMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.type.matcher.v3.StringMatcher string_match = 5; */
        if (message.queryParameterMatchSpecifier.oneofKind === "stringMatch")
            StringMatcher.internalBinaryWrite(message.queryParameterMatchSpecifier.stringMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool present_match = 6; */
        if (message.queryParameterMatchSpecifier.oneofKind === "presentMatch")
            writer.tag(6, WireType.Varint).bool(message.queryParameterMatchSpecifier.presentMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.QueryParameterMatcher
 */
export const QueryParameterMatcher = new QueryParameterMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InternalRedirectPolicy$Type extends MessageType<InternalRedirectPolicy> {
    constructor() {
        super("envoy.config.route.v3.InternalRedirectPolicy", [
            { no: 1, name: "max_internal_redirects", kind: "message", T: () => UInt32Value },
            { no: 2, name: "redirect_response_codes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { repeated: { maxItems: "5" } } } },
            { no: 3, name: "predicates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 4, name: "allow_cross_scheme_redirect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InternalRedirectPolicy>): InternalRedirectPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.redirectResponseCodes = [];
        message.predicates = [];
        message.allowCrossSchemeRedirect = false;
        if (value !== undefined)
            reflectionMergePartial<InternalRedirectPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InternalRedirectPolicy): InternalRedirectPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value max_internal_redirects */ 1:
                    message.maxInternalRedirects = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxInternalRedirects);
                    break;
                case /* repeated uint32 redirect_response_codes */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.redirectResponseCodes.push(reader.uint32());
                    else
                        message.redirectResponseCodes.push(reader.uint32());
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig predicates */ 3:
                    message.predicates.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool allow_cross_scheme_redirect */ 4:
                    message.allowCrossSchemeRedirect = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InternalRedirectPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value max_internal_redirects = 1; */
        if (message.maxInternalRedirects)
            UInt32Value.internalBinaryWrite(message.maxInternalRedirects, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 redirect_response_codes = 2; */
        if (message.redirectResponseCodes.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.redirectResponseCodes.length; i++)
                writer.uint32(message.redirectResponseCodes[i]);
            writer.join();
        }
        /* repeated envoy.config.core.v3.TypedExtensionConfig predicates = 3; */
        for (let i = 0; i < message.predicates.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.predicates[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_cross_scheme_redirect = 4; */
        if (message.allowCrossSchemeRedirect !== false)
            writer.tag(4, WireType.Varint).bool(message.allowCrossSchemeRedirect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.InternalRedirectPolicy
 */
export const InternalRedirectPolicy = new InternalRedirectPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterConfig$Type extends MessageType<FilterConfig> {
    constructor() {
        super("envoy.config.route.v3.FilterConfig", [
            { no: 1, name: "config", kind: "message", T: () => Any },
            { no: 2, name: "is_optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FilterConfig>): FilterConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOptional = false;
        message.disabled = false;
        if (value !== undefined)
            reflectionMergePartial<FilterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterConfig): FilterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any config */ 1:
                    message.config = Any.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* bool is_optional */ 2:
                    message.isOptional = reader.bool();
                    break;
                case /* bool disabled */ 3:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any config = 1; */
        if (message.config)
            Any.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_optional = 2; */
        if (message.isOptional !== false)
            writer.tag(2, WireType.Varint).bool(message.isOptional);
        /* bool disabled = 3; */
        if (message.disabled !== false)
            writer.tag(3, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.route.v3.FilterConfig
 */
export const FilterConfig = new FilterConfig$Type();
