// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/route/v3/route_components.proto (package envoy.config.route.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, Duration, proto3, UInt32Value } from "@bufbuild/protobuf";
import { Matcher } from "../../../../xds/type/matcher/v3/matcher_pb.js";
import { DataSource, HeaderValueOption, Metadata, RoutingPriority, RuntimeFractionalPercent } from "../../core/v3/base_pb.js";
import { TypedExtensionConfig } from "../../core/v3/extension_pb.js";
import { RegexMatchAndSubstitute, RegexMatcher } from "../../../type/matcher/v3/regex_pb.js";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata_pb.js";
import { StringMatcher } from "../../../type/matcher/v3/string_pb.js";
import { ProxyProtocolConfig } from "../../core/v3/proxy_protocol_pb.js";
import { FractionalPercent } from "../../../type/v3/percent_pb.js";
import { CustomTag } from "../../../type/tracing/v3/custom_tag_pb.js";
import { MetadataKey } from "../../../type/metadata/v3/metadata_pb.js";
import { Int64Range } from "../../../type/v3/range_pb.js";

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 24]
 *
 * @generated from message envoy.config.route.v3.VirtualHost
 */
export const VirtualHost = proto3.makeMessageType(
  "envoy.config.route.v3.VirtualHost",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "domains", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "routes", kind: "message", T: Route, repeated: true },
    { no: 21, name: "matcher", kind: "message", T: Matcher },
    { no: 4, name: "require_tls", kind: "enum", T: proto3.getEnumType(VirtualHost_TlsRequirementType) },
    { no: 5, name: "virtual_clusters", kind: "message", T: VirtualCluster, repeated: true },
    { no: 6, name: "rate_limits", kind: "message", T: RateLimit, repeated: true },
    { no: 7, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 13, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 11, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "cors", kind: "message", T: CorsPolicy },
    { no: 15, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 14, name: "include_request_attempt_count", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "include_attempt_count_in_response", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 20, name: "retry_policy_typed_config", kind: "message", T: Any },
    { no: 17, name: "hedge_policy", kind: "message", T: HedgePolicy },
    { no: 23, name: "include_is_timeout_retry_header", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "per_request_buffer_limit_bytes", kind: "message", T: UInt32Value },
    { no: 22, name: "request_mirror_policies", kind: "message", T: RouteAction_RequestMirrorPolicy, repeated: true },
  ],
);

/**
 * @generated from enum envoy.config.route.v3.VirtualHost.TlsRequirementType
 */
export const VirtualHost_TlsRequirementType = proto3.makeEnum(
  "envoy.config.route.v3.VirtualHost.TlsRequirementType",
  [
    {no: 0, name: "NONE"},
    {no: 1, name: "EXTERNAL_ONLY"},
    {no: 2, name: "ALL"},
  ],
);

/**
 * A filter-defined action type.
 *
 * @generated from message envoy.config.route.v3.FilterAction
 */
export const FilterAction = proto3.makeMessageType(
  "envoy.config.route.v3.FilterAction",
  () => [
    { no: 1, name: "action", kind: "message", T: Any },
  ],
);

/**
 * This can be used in route matcher :ref:`VirtualHost.matcher <envoy_v3_api_field_config.route.v3.VirtualHost.matcher>`.
 * When the matcher matches, routes will be matched and run.
 *
 * @generated from message envoy.config.route.v3.RouteList
 */
export const RouteList = proto3.makeMessageType(
  "envoy.config.route.v3.RouteList",
  () => [
    { no: 1, name: "routes", kind: "message", T: Route, repeated: true },
  ],
);

/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_v3_api_msg_config.route.v3.HeaderMatcher>`.
 * [#next-free-field: 20]
 *
 * @generated from message envoy.config.route.v3.Route
 */
export const Route = proto3.makeMessageType(
  "envoy.config.route.v3.Route",
  () => [
    { no: 14, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "match", kind: "message", T: RouteMatch },
    { no: 2, name: "route", kind: "message", T: RouteAction, oneof: "action" },
    { no: 3, name: "redirect", kind: "message", T: RedirectAction, oneof: "action" },
    { no: 7, name: "direct_response", kind: "message", T: DirectResponseAction, oneof: "action" },
    { no: 17, name: "filter_action", kind: "message", T: FilterAction, oneof: "action" },
    { no: 18, name: "non_forwarding_action", kind: "message", T: NonForwardingAction, oneof: "action" },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "decorator", kind: "message", T: Decorator },
    { no: 13, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 9, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 12, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 11, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "tracing", kind: "message", T: Tracing },
    { no: 16, name: "per_request_buffer_limit_bytes", kind: "message", T: UInt32Value },
    { no: 19, name: "stat_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Compared to the :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 *
 * @generated from message envoy.config.route.v3.WeightedCluster
 */
export const WeightedCluster = proto3.makeMessageType(
  "envoy.config.route.v3.WeightedCluster",
  () => [
    { no: 1, name: "clusters", kind: "message", T: WeightedCluster_ClusterWeight, repeated: true },
    { no: 3, name: "total_weight", kind: "message", T: UInt32Value },
    { no: 2, name: "runtime_key_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "header_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "random_value_specifier" },
  ],
);

/**
 * [#next-free-field: 13]
 *
 * @generated from message envoy.config.route.v3.WeightedCluster.ClusterWeight
 */
export const WeightedCluster_ClusterWeight = proto3.makeMessageType(
  "envoy.config.route.v3.WeightedCluster.ClusterWeight",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "cluster_header", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "message", T: UInt32Value },
    { no: 3, name: "metadata_match", kind: "message", T: Metadata },
    { no: 4, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 9, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 6, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 11, name: "host_rewrite_literal", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_rewrite_specifier" },
  ],
  {localName: "WeightedCluster_ClusterWeight"},
);

/**
 * Configuration for a cluster specifier plugin.
 *
 * @generated from message envoy.config.route.v3.ClusterSpecifierPlugin
 */
export const ClusterSpecifierPlugin = proto3.makeMessageType(
  "envoy.config.route.v3.ClusterSpecifierPlugin",
  () => [
    { no: 1, name: "extension", kind: "message", T: TypedExtensionConfig },
    { no: 2, name: "is_optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * [#next-free-field: 16]
 *
 * @generated from message envoy.config.route.v3.RouteMatch
 */
export const RouteMatch = proto3.makeMessageType(
  "envoy.config.route.v3.RouteMatch",
  () => [
    { no: 1, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 10, name: "safe_regex", kind: "message", T: RegexMatcher, oneof: "path_specifier" },
    { no: 12, name: "connect_matcher", kind: "message", T: RouteMatch_ConnectMatcher, oneof: "path_specifier" },
    { no: 14, name: "path_separated_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 15, name: "path_match_policy", kind: "message", T: TypedExtensionConfig, oneof: "path_specifier" },
    { no: 4, name: "case_sensitive", kind: "message", T: BoolValue },
    { no: 9, name: "runtime_fraction", kind: "message", T: RuntimeFractionalPercent },
    { no: 6, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 7, name: "query_parameters", kind: "message", T: QueryParameterMatcher, repeated: true },
    { no: 8, name: "grpc", kind: "message", T: RouteMatch_GrpcRouteMatchOptions },
    { no: 11, name: "tls_context", kind: "message", T: RouteMatch_TlsContextMatchOptions },
    { no: 13, name: "dynamic_metadata", kind: "message", T: MetadataMatcher, repeated: true },
  ],
);

/**
 * @generated from message envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions
 */
export const RouteMatch_GrpcRouteMatchOptions = proto3.makeMessageType(
  "envoy.config.route.v3.RouteMatch.GrpcRouteMatchOptions",
  [],
  {localName: "RouteMatch_GrpcRouteMatchOptions"},
);

/**
 * @generated from message envoy.config.route.v3.RouteMatch.TlsContextMatchOptions
 */
export const RouteMatch_TlsContextMatchOptions = proto3.makeMessageType(
  "envoy.config.route.v3.RouteMatch.TlsContextMatchOptions",
  () => [
    { no: 1, name: "presented", kind: "message", T: BoolValue },
    { no: 2, name: "validated", kind: "message", T: BoolValue },
  ],
  {localName: "RouteMatch_TlsContextMatchOptions"},
);

/**
 * An extensible message for matching CONNECT requests.
 *
 * @generated from message envoy.config.route.v3.RouteMatch.ConnectMatcher
 */
export const RouteMatch_ConnectMatcher = proto3.makeMessageType(
  "envoy.config.route.v3.RouteMatch.ConnectMatcher",
  [],
  {localName: "RouteMatch_ConnectMatcher"},
);

/**
 * Cors policy configuration.
 *
 * .. attention::
 *
 *   This message has been deprecated. Please use
 *   :ref:`CorsPolicy in filter extension <envoy_v3_api_msg_extensions.filters.http.cors.v3.CorsPolicy>`
 *   as as alternative.
 *
 * [#next-free-field: 13]
 *
 * @generated from message envoy.config.route.v3.CorsPolicy
 */
export const CorsPolicy = proto3.makeMessageType(
  "envoy.config.route.v3.CorsPolicy",
  () => [
    { no: 11, name: "allow_origin_string_match", kind: "message", T: StringMatcher, repeated: true },
    { no: 2, name: "allow_methods", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "allow_headers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expose_headers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "max_age", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "allow_credentials", kind: "message", T: BoolValue },
    { no: 9, name: "filter_enabled", kind: "message", T: RuntimeFractionalPercent, oneof: "enabled_specifier" },
    { no: 10, name: "shadow_enabled", kind: "message", T: RuntimeFractionalPercent },
    { no: 12, name: "allow_private_network_access", kind: "message", T: BoolValue },
  ],
);

/**
 * [#next-free-field: 42]
 *
 * @generated from message envoy.config.route.v3.RouteAction
 */
export const RouteAction = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction",
  () => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "cluster_specifier" },
    { no: 2, name: "cluster_header", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "cluster_specifier" },
    { no: 3, name: "weighted_clusters", kind: "message", T: WeightedCluster, oneof: "cluster_specifier" },
    { no: 37, name: "cluster_specifier_plugin", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "cluster_specifier" },
    { no: 39, name: "inline_cluster_specifier_plugin", kind: "message", T: ClusterSpecifierPlugin, oneof: "cluster_specifier" },
    { no: 20, name: "cluster_not_found_response_code", kind: "enum", T: proto3.getEnumType(RouteAction_ClusterNotFoundResponseCode) },
    { no: 4, name: "metadata_match", kind: "message", T: Metadata },
    { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 32, name: "regex_rewrite", kind: "message", T: RegexMatchAndSubstitute },
    { no: 41, name: "path_rewrite_policy", kind: "message", T: TypedExtensionConfig },
    { no: 6, name: "host_rewrite_literal", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_rewrite_specifier" },
    { no: 7, name: "auto_host_rewrite", kind: "message", T: BoolValue, oneof: "host_rewrite_specifier" },
    { no: 29, name: "host_rewrite_header", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_rewrite_specifier" },
    { no: 35, name: "host_rewrite_path_regex", kind: "message", T: RegexMatchAndSubstitute, oneof: "host_rewrite_specifier" },
    { no: 38, name: "append_x_forwarded_host", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "timeout", kind: "message", T: Duration },
    { no: 24, name: "idle_timeout", kind: "message", T: Duration },
    { no: 40, name: "early_data_policy", kind: "message", T: TypedExtensionConfig },
    { no: 9, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 33, name: "retry_policy_typed_config", kind: "message", T: Any },
    { no: 30, name: "request_mirror_policies", kind: "message", T: RouteAction_RequestMirrorPolicy, repeated: true },
    { no: 11, name: "priority", kind: "enum", T: proto3.getEnumType(RoutingPriority) },
    { no: 13, name: "rate_limits", kind: "message", T: RateLimit, repeated: true },
    { no: 14, name: "include_vh_rate_limits", kind: "message", T: BoolValue },
    { no: 15, name: "hash_policy", kind: "message", T: RouteAction_HashPolicy, repeated: true },
    { no: 17, name: "cors", kind: "message", T: CorsPolicy },
    { no: 23, name: "max_grpc_timeout", kind: "message", T: Duration },
    { no: 28, name: "grpc_timeout_offset", kind: "message", T: Duration },
    { no: 25, name: "upgrade_configs", kind: "message", T: RouteAction_UpgradeConfig, repeated: true },
    { no: 34, name: "internal_redirect_policy", kind: "message", T: InternalRedirectPolicy },
    { no: 26, name: "internal_redirect_action", kind: "enum", T: proto3.getEnumType(RouteAction_InternalRedirectAction) },
    { no: 31, name: "max_internal_redirects", kind: "message", T: UInt32Value },
    { no: 27, name: "hedge_policy", kind: "message", T: HedgePolicy },
    { no: 36, name: "max_stream_duration", kind: "message", T: RouteAction_MaxStreamDuration },
  ],
);

/**
 * @generated from enum envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode
 */
export const RouteAction_ClusterNotFoundResponseCode = proto3.makeEnum(
  "envoy.config.route.v3.RouteAction.ClusterNotFoundResponseCode",
  [
    {no: 0, name: "SERVICE_UNAVAILABLE"},
    {no: 1, name: "NOT_FOUND"},
    {no: 2, name: "INTERNAL_SERVER_ERROR"},
  ],
);

/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 * [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
 *
 * @generated from enum envoy.config.route.v3.RouteAction.InternalRedirectAction
 * @deprecated
 */
export const RouteAction_InternalRedirectAction = proto3.makeEnum(
  "envoy.config.route.v3.RouteAction.InternalRedirectAction",
  [
    {no: 0, name: "PASS_THROUGH_INTERNAL_REDIRECT"},
    {no: 1, name: "HANDLE_INTERNAL_REDIRECT"},
  ],
);

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that ``-shadow`` is appended. This is
 * useful for logging. For example, ``cluster1`` becomes ``cluster1-shadow``.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * .. note::
 *
 *   Shadowing doesn't support Http CONNECT and upgrades.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.route.v3.RouteAction.RequestMirrorPolicy
 */
export const RouteAction_RequestMirrorPolicy = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.RequestMirrorPolicy",
  () => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cluster_header", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "runtime_fraction", kind: "message", T: RuntimeFractionalPercent },
    { no: 4, name: "trace_sampled", kind: "message", T: BoolValue },
  ],
  {localName: "RouteAction_RequestMirrorPolicy"},
);

/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy
 */
export const RouteAction_HashPolicy = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy",
  () => [
    { no: 1, name: "header", kind: "message", T: RouteAction_HashPolicy_Header, oneof: "policy_specifier" },
    { no: 2, name: "cookie", kind: "message", T: RouteAction_HashPolicy_Cookie, oneof: "policy_specifier" },
    { no: 3, name: "connection_properties", kind: "message", T: RouteAction_HashPolicy_ConnectionProperties, oneof: "policy_specifier" },
    { no: 5, name: "query_parameter", kind: "message", T: RouteAction_HashPolicy_QueryParameter, oneof: "policy_specifier" },
    { no: 6, name: "filter_state", kind: "message", T: RouteAction_HashPolicy_FilterState, oneof: "policy_specifier" },
    { no: 4, name: "terminal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RouteAction_HashPolicy"},
);

/**
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.Header
 */
export const RouteAction_HashPolicy_Header = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.Header",
  () => [
    { no: 1, name: "header_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "regex_rewrite", kind: "message", T: RegexMatchAndSubstitute },
  ],
  {localName: "RouteAction_HashPolicy_Header"},
);

/**
 * CookieAttribute defines an API for adding additional attributes for a HTTP cookie.
 *
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute
 */
export const RouteAction_HashPolicy_CookieAttribute = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.CookieAttribute",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_CookieAttribute"},
);

/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 *
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.Cookie
 */
export const RouteAction_HashPolicy_Cookie = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.Cookie",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ttl", kind: "message", T: Duration },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "attributes", kind: "message", T: RouteAction_HashPolicy_CookieAttribute, repeated: true },
  ],
  {localName: "RouteAction_HashPolicy_Cookie"},
);

/**
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties
 */
export const RouteAction_HashPolicy_ConnectionProperties = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.ConnectionProperties",
  () => [
    { no: 1, name: "source_ip", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RouteAction_HashPolicy_ConnectionProperties"},
);

/**
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter
 */
export const RouteAction_HashPolicy_QueryParameter = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.QueryParameter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_QueryParameter"},
);

/**
 * @generated from message envoy.config.route.v3.RouteAction.HashPolicy.FilterState
 */
export const RouteAction_HashPolicy_FilterState = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.HashPolicy.FilterState",
  () => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_FilterState"},
);

/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 *
 * @generated from message envoy.config.route.v3.RouteAction.UpgradeConfig
 */
export const RouteAction_UpgradeConfig = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.UpgradeConfig",
  () => [
    { no: 1, name: "upgrade_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "message", T: BoolValue },
    { no: 3, name: "connect_config", kind: "message", T: RouteAction_UpgradeConfig_ConnectConfig },
  ],
  {localName: "RouteAction_UpgradeConfig"},
);

/**
 * Configuration for sending data upstream as a raw data payload. This is used for
 * CONNECT or POST requests, when forwarding request payload as raw TCP.
 *
 * @generated from message envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig
 */
export const RouteAction_UpgradeConfig_ConnectConfig = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.UpgradeConfig.ConnectConfig",
  () => [
    { no: 1, name: "proxy_protocol_config", kind: "message", T: ProxyProtocolConfig },
    { no: 2, name: "allow_post", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RouteAction_UpgradeConfig_ConnectConfig"},
);

/**
 * @generated from message envoy.config.route.v3.RouteAction.MaxStreamDuration
 */
export const RouteAction_MaxStreamDuration = proto3.makeMessageType(
  "envoy.config.route.v3.RouteAction.MaxStreamDuration",
  () => [
    { no: 1, name: "max_stream_duration", kind: "message", T: Duration },
    { no: 2, name: "grpc_timeout_header_max", kind: "message", T: Duration },
    { no: 3, name: "grpc_timeout_header_offset", kind: "message", T: Duration },
  ],
  {localName: "RouteAction_MaxStreamDuration"},
);

/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 14]
 *
 * @generated from message envoy.config.route.v3.RetryPolicy
 */
export const RetryPolicy = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy",
  () => [
    { no: 1, name: "retry_on", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "num_retries", kind: "message", T: UInt32Value },
    { no: 3, name: "per_try_timeout", kind: "message", T: Duration },
    { no: 13, name: "per_try_idle_timeout", kind: "message", T: Duration },
    { no: 4, name: "retry_priority", kind: "message", T: RetryPolicy_RetryPriority },
    { no: 5, name: "retry_host_predicate", kind: "message", T: RetryPolicy_RetryHostPredicate, repeated: true },
    { no: 12, name: "retry_options_predicates", kind: "message", T: TypedExtensionConfig, repeated: true },
    { no: 6, name: "host_selection_retry_max_attempts", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "retriable_status_codes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 8, name: "retry_back_off", kind: "message", T: RetryPolicy_RetryBackOff },
    { no: 11, name: "rate_limited_retry_back_off", kind: "message", T: RetryPolicy_RateLimitedRetryBackOff },
    { no: 9, name: "retriable_headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 10, name: "retriable_request_headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
);

/**
 * @generated from enum envoy.config.route.v3.RetryPolicy.ResetHeaderFormat
 */
export const RetryPolicy_ResetHeaderFormat = proto3.makeEnum(
  "envoy.config.route.v3.RetryPolicy.ResetHeaderFormat",
  [
    {no: 0, name: "SECONDS"},
    {no: 1, name: "UNIX_TIMESTAMP"},
  ],
);

/**
 * @generated from message envoy.config.route.v3.RetryPolicy.RetryPriority
 */
export const RetryPolicy_RetryPriority = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy.RetryPriority",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
  {localName: "RetryPolicy_RetryPriority"},
);

/**
 * @generated from message envoy.config.route.v3.RetryPolicy.RetryHostPredicate
 */
export const RetryPolicy_RetryHostPredicate = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy.RetryHostPredicate",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
  {localName: "RetryPolicy_RetryHostPredicate"},
);

/**
 * @generated from message envoy.config.route.v3.RetryPolicy.RetryBackOff
 */
export const RetryPolicy_RetryBackOff = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy.RetryBackOff",
  () => [
    { no: 1, name: "base_interval", kind: "message", T: Duration },
    { no: 2, name: "max_interval", kind: "message", T: Duration },
  ],
  {localName: "RetryPolicy_RetryBackOff"},
);

/**
 * @generated from message envoy.config.route.v3.RetryPolicy.ResetHeader
 */
export const RetryPolicy_ResetHeader = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy.ResetHeader",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "format", kind: "enum", T: proto3.getEnumType(RetryPolicy_ResetHeaderFormat) },
  ],
  {localName: "RetryPolicy_ResetHeader"},
);

/**
 * A retry back-off strategy that applies when the upstream server rate limits
 * the request.
 *
 * Given this configuration:
 *
 * .. code-block:: yaml
 *
 *   rate_limited_retry_back_off:
 *     reset_headers:
 *     - name: Retry-After
 *       format: SECONDS
 *     - name: X-RateLimit-Reset
 *       format: UNIX_TIMESTAMP
 *     max_interval: "300s"
 *
 * The following algorithm will apply:
 *
 *  1. If the response contains the header ``Retry-After`` its value must be on
 *     the form ``120`` (an integer that represents the number of seconds to
 *     wait before retrying). If so, this value is used as the back-off interval.
 *  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
 *     value must be on the form ``1595320702`` (an integer that represents the
 *     point in time at which to retry, as a Unix timestamp in seconds). If so,
 *     the current time is subtracted from this value and the result is used as
 *     the back-off interval.
 *  3. Otherwise, Envoy will use the default
 *     :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
 *     strategy.
 *
 * No matter which format is used, if the resulting back-off interval exceeds
 * ``max_interval`` it is discarded and the next header in ``reset_headers``
 * is tried. If a request timeout is configured for the route it will further
 * limit how long the request will be allowed to run.
 *
 * To prevent many clients retrying at the same point in time jitter is added
 * to the back-off interval, so the resulting interval is decided by taking:
 * ``random(interval, interval * 1.5)``.
 *
 * .. attention::
 *
 *   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
 *   to be retried. You will still need to configure the right retry policy to match
 *   the responses from the upstream server.
 *
 * @generated from message envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff
 */
export const RetryPolicy_RateLimitedRetryBackOff = proto3.makeMessageType(
  "envoy.config.route.v3.RetryPolicy.RateLimitedRetryBackOff",
  () => [
    { no: 1, name: "reset_headers", kind: "message", T: RetryPolicy_ResetHeader, repeated: true },
    { no: 2, name: "max_interval", kind: "message", T: Duration },
  ],
  {localName: "RetryPolicy_RateLimitedRetryBackOff"},
);

/**
 * HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
 *
 * @generated from message envoy.config.route.v3.HedgePolicy
 */
export const HedgePolicy = proto3.makeMessageType(
  "envoy.config.route.v3.HedgePolicy",
  () => [
    { no: 1, name: "initial_requests", kind: "message", T: UInt32Value },
    { no: 2, name: "additional_request_chance", kind: "message", T: FractionalPercent },
    { no: 3, name: "hedge_on_per_try_timeout", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.config.route.v3.RedirectAction
 */
export const RedirectAction = proto3.makeMessageType(
  "envoy.config.route.v3.RedirectAction",
  () => [
    { no: 4, name: "https_redirect", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "scheme_rewrite_specifier" },
    { no: 7, name: "scheme_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "scheme_rewrite_specifier" },
    { no: 1, name: "host_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "port_redirect", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "path_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_rewrite_specifier" },
    { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_rewrite_specifier" },
    { no: 9, name: "regex_rewrite", kind: "message", T: RegexMatchAndSubstitute, oneof: "path_rewrite_specifier" },
    { no: 3, name: "response_code", kind: "enum", T: proto3.getEnumType(RedirectAction_RedirectResponseCode) },
    { no: 6, name: "strip_query", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * @generated from enum envoy.config.route.v3.RedirectAction.RedirectResponseCode
 */
export const RedirectAction_RedirectResponseCode = proto3.makeEnum(
  "envoy.config.route.v3.RedirectAction.RedirectResponseCode",
  [
    {no: 0, name: "MOVED_PERMANENTLY"},
    {no: 1, name: "FOUND"},
    {no: 2, name: "SEE_OTHER"},
    {no: 3, name: "TEMPORARY_REDIRECT"},
    {no: 4, name: "PERMANENT_REDIRECT"},
  ],
);

/**
 * @generated from message envoy.config.route.v3.DirectResponseAction
 */
export const DirectResponseAction = proto3.makeMessageType(
  "envoy.config.route.v3.DirectResponseAction",
  () => [
    { no: 1, name: "status", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "body", kind: "message", T: DataSource },
  ],
);

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.config.route.v3.NonForwardingAction
 */
export const NonForwardingAction = proto3.makeMessageType(
  "envoy.config.route.v3.NonForwardingAction",
  [],
);

/**
 * @generated from message envoy.config.route.v3.Decorator
 */
export const Decorator = proto3.makeMessageType(
  "envoy.config.route.v3.Decorator",
  () => [
    { no: 1, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "propagate", kind: "message", T: BoolValue },
  ],
);

/**
 * @generated from message envoy.config.route.v3.Tracing
 */
export const Tracing = proto3.makeMessageType(
  "envoy.config.route.v3.Tracing",
  () => [
    { no: 1, name: "client_sampling", kind: "message", T: FractionalPercent },
    { no: 2, name: "random_sampling", kind: "message", T: FractionalPercent },
    { no: 3, name: "overall_sampling", kind: "message", T: FractionalPercent },
    { no: 4, name: "custom_tags", kind: "message", T: CustomTag, repeated: true },
  ],
);

/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, it’s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get “perfect” statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 *
 * @generated from message envoy.config.route.v3.VirtualCluster
 */
export const VirtualCluster = proto3.makeMessageType(
  "envoy.config.route.v3.VirtualCluster",
  () => [
    { no: 4, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 * Also applies to Local rate limiting :ref:`using descriptors <config_http_filters_local_rate_limit_descriptors>`.
 *
 * @generated from message envoy.config.route.v3.RateLimit
 */
export const RateLimit = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit",
  () => [
    { no: 1, name: "stage", kind: "message", T: UInt32Value },
    { no: 2, name: "disable_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "actions", kind: "message", T: RateLimit_Action, repeated: true },
    { no: 4, name: "limit", kind: "message", T: RateLimit_Override },
  ],
);

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action
 */
export const RateLimit_Action = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action",
  () => [
    { no: 1, name: "source_cluster", kind: "message", T: RateLimit_Action_SourceCluster, oneof: "action_specifier" },
    { no: 2, name: "destination_cluster", kind: "message", T: RateLimit_Action_DestinationCluster, oneof: "action_specifier" },
    { no: 3, name: "request_headers", kind: "message", T: RateLimit_Action_RequestHeaders, oneof: "action_specifier" },
    { no: 4, name: "remote_address", kind: "message", T: RateLimit_Action_RemoteAddress, oneof: "action_specifier" },
    { no: 5, name: "generic_key", kind: "message", T: RateLimit_Action_GenericKey, oneof: "action_specifier" },
    { no: 6, name: "header_value_match", kind: "message", T: RateLimit_Action_HeaderValueMatch, oneof: "action_specifier" },
    { no: 7, name: "dynamic_metadata", kind: "message", T: RateLimit_Action_DynamicMetaData, oneof: "action_specifier" },
    { no: 8, name: "metadata", kind: "message", T: RateLimit_Action_MetaData, oneof: "action_specifier" },
    { no: 9, name: "extension", kind: "message", T: TypedExtensionConfig, oneof: "action_specifier" },
    { no: 10, name: "masked_remote_address", kind: "message", T: RateLimit_Action_MaskedRemoteAddress, oneof: "action_specifier" },
    { no: 11, name: "query_parameter_value_match", kind: "message", T: RateLimit_Action_QueryParameterValueMatch, oneof: "action_specifier" },
  ],
  {localName: "RateLimit_Action"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.SourceCluster
 */
export const RateLimit_Action_SourceCluster = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.SourceCluster",
  [],
  {localName: "RateLimit_Action_SourceCluster"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_v3_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_v3_api_field_config.route.v3.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_v3_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.DestinationCluster
 */
export const RateLimit_Action_DestinationCluster = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.DestinationCluster",
  [],
  {localName: "RateLimit_Action_DestinationCluster"},
);

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * ``header_name``:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.RequestHeaders
 */
export const RateLimit_Action_RequestHeaders = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.RequestHeaders",
  () => [
    { no: 1, name: "header_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "skip_if_absent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RateLimit_Action_RequestHeaders"},
);

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.RemoteAddress
 */
export const RateLimit_Action_RemoteAddress = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.RemoteAddress",
  [],
  {localName: "RateLimit_Action_RemoteAddress"},
);

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * masked address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("masked_remote_address", "<masked address from x-forwarded-for>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress
 */
export const RateLimit_Action_MaskedRemoteAddress = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.MaskedRemoteAddress",
  () => [
    { no: 1, name: "v4_prefix_mask_len", kind: "message", T: UInt32Value },
    { no: 2, name: "v6_prefix_mask_len", kind: "message", T: UInt32Value },
  ],
  {localName: "RateLimit_Action_MaskedRemoteAddress"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.GenericKey
 */
export const RateLimit_Action_GenericKey = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.GenericKey",
  () => [
    { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RateLimit_Action_GenericKey"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.HeaderValueMatch
 */
export const RateLimit_Action_HeaderValueMatch = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.HeaderValueMatch",
  () => [
    { no: 4, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expect_match", kind: "message", T: BoolValue },
    { no: 3, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
  {localName: "RateLimit_Action_HeaderValueMatch"},
);

/**
 * The following descriptor entry is appended when the
 * :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")
 *
 * .. attention::
 *   This action has been deprecated in favor of the :ref:`metadata <envoy_v3_api_msg_config.route.v3.RateLimit.Action.MetaData>` action
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.DynamicMetaData
 */
export const RateLimit_Action_DynamicMetaData = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.DynamicMetaData",
  () => [
    { no: 1, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata_key", kind: "message", T: MetadataKey },
    { no: 3, name: "default_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RateLimit_Action_DynamicMetaData"},
);

/**
 * The following descriptor entry is appended when the metadata contains a key value:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<value_queried_from_metadata>")
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.MetaData
 */
export const RateLimit_Action_MetaData = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.MetaData",
  () => [
    { no: 1, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata_key", kind: "message", T: MetadataKey },
    { no: 3, name: "default_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "source", kind: "enum", T: proto3.getEnumType(RateLimit_Action_MetaData_Source) },
    { no: 5, name: "skip_if_absent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RateLimit_Action_MetaData"},
);

/**
 * @generated from enum envoy.config.route.v3.RateLimit.Action.MetaData.Source
 */
export const RateLimit_Action_MetaData_Source = proto3.makeEnum(
  "envoy.config.route.v3.RateLimit.Action.MetaData.Source",
  [
    {no: 0, name: "DYNAMIC"},
    {no: 1, name: "ROUTE_ENTRY"},
  ],
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("query_match", "<descriptor_value>")
 *
 * @generated from message envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch
 */
export const RateLimit_Action_QueryParameterValueMatch = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Action.QueryParameterValueMatch",
  () => [
    { no: 4, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expect_match", kind: "message", T: BoolValue },
    { no: 3, name: "query_parameters", kind: "message", T: QueryParameterMatcher, repeated: true },
  ],
  {localName: "RateLimit_Action_QueryParameterValueMatch"},
);

/**
 * @generated from message envoy.config.route.v3.RateLimit.Override
 */
export const RateLimit_Override = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Override",
  () => [
    { no: 1, name: "dynamic_metadata", kind: "message", T: RateLimit_Override_DynamicMetadata, oneof: "override_specifier" },
  ],
  {localName: "RateLimit_Override"},
);

/**
 * Fetches the override from the dynamic metadata.
 *
 * @generated from message envoy.config.route.v3.RateLimit.Override.DynamicMetadata
 */
export const RateLimit_Override_DynamicMetadata = proto3.makeMessageType(
  "envoy.config.route.v3.RateLimit.Override.DynamicMetadata",
  () => [
    { no: 1, name: "metadata_key", kind: "message", T: MetadataKey },
  ],
  {localName: "RateLimit_Override_DynamicMetadata"},
);

/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 ``:authority`` header to represent the HTTP/1 ``Host``
 *   header. Thus, if attempting to match on ``Host``, match on ``:authority`` instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 ``:method`` header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "string_match": {
 *         "exact": "POST"
 *       }
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_v3_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 15]
 *
 * @generated from message envoy.config.route.v3.HeaderMatcher
 */
export const HeaderMatcher = proto3.makeMessageType(
  "envoy.config.route.v3.HeaderMatcher",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "exact_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 11, name: "safe_regex_match", kind: "message", T: RegexMatcher, oneof: "header_match_specifier" },
    { no: 6, name: "range_match", kind: "message", T: Int64Range, oneof: "header_match_specifier" },
    { no: 7, name: "present_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "header_match_specifier" },
    { no: 9, name: "prefix_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 10, name: "suffix_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 12, name: "contains_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 13, name: "string_match", kind: "message", T: StringMatcher, oneof: "header_match_specifier" },
    { no: 8, name: "invert_match", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "treat_missing_header_as_empty", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.route.v3.QueryParameterMatcher
 */
export const QueryParameterMatcher = proto3.makeMessageType(
  "envoy.config.route.v3.QueryParameterMatcher",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "string_match", kind: "message", T: StringMatcher, oneof: "query_parameter_match_specifier" },
    { no: 6, name: "present_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "query_parameter_match_specifier" },
  ],
);

/**
 * HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
 *
 * @generated from message envoy.config.route.v3.InternalRedirectPolicy
 */
export const InternalRedirectPolicy = proto3.makeMessageType(
  "envoy.config.route.v3.InternalRedirectPolicy",
  () => [
    { no: 1, name: "max_internal_redirects", kind: "message", T: UInt32Value },
    { no: 2, name: "redirect_response_codes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 3, name: "predicates", kind: "message", T: TypedExtensionConfig, repeated: true },
    { no: 4, name: "allow_cross_scheme_redirect", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * A simple wrapper for an HTTP filter config. This is intended to be used as a wrapper for the
 * map value in
 * :ref:`VirtualHost.typed_per_filter_config<envoy_v3_api_field_config.route.v3.VirtualHost.typed_per_filter_config>`,
 * :ref:`Route.typed_per_filter_config<envoy_v3_api_field_config.route.v3.Route.typed_per_filter_config>`,
 * or :ref:`WeightedCluster.ClusterWeight.typed_per_filter_config<envoy_v3_api_field_config.route.v3.WeightedCluster.ClusterWeight.typed_per_filter_config>`
 * to add additional flags to the filter.
 *
 * @generated from message envoy.config.route.v3.FilterConfig
 */
export const FilterConfig = proto3.makeMessageType(
  "envoy.config.route.v3.FilterConfig",
  () => [
    { no: 1, name: "config", kind: "message", T: Any },
    { no: 2, name: "is_optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

