// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/route/v3/scoped_route.proto (package envoy.config.route.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { RouteConfiguration } from "./route_pb.js";

/**
 * Specifies a routing scope, which associates a
 * :ref:`Key<envoy_v3_api_msg_config.route.v3.ScopedRouteConfiguration.Key>` to a
 * :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration`.
 * The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` can be obtained dynamically
 * via RDS (:ref:`route_configuration_name<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration_name>`)
 * or specified inline (:ref:`route_configuration<envoy_v3_api_field_config.route.v3.ScopedRouteConfiguration.route_configuration>`).
 *
 * The HTTP connection manager builds up a table consisting of these Key to
 * RouteConfiguration mappings, and looks up the RouteConfiguration to use per
 * request according to the algorithm specified in the
 * :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
 * assigned to the HttpConnectionManager.
 *
 * For example, with the following configurations (in YAML):
 *
 * HttpConnectionManager config:
 *
 * .. code::
 *
 *   ...
 *   scoped_routes:
 *     name: foo-scoped-routes
 *     scope_key_builder:
 *       fragments:
 *         - header_value_extractor:
 *             name: X-Route-Selector
 *             element_separator: ","
 *             element:
 *               separator: =
 *               key: vip
 *
 * ScopedRouteConfiguration resources (specified statically via
 * :ref:`scoped_route_configurations_list<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scoped_route_configurations_list>`
 * or obtained dynamically via SRDS):
 *
 * .. code::
 *
 *  (1)
 *   name: route-scope1
 *   route_configuration_name: route-config1
 *   key:
 *      fragments:
 *        - string_key: 172.10.10.20
 *
 *  (2)
 *   name: route-scope2
 *   route_configuration_name: route-config2
 *   key:
 *     fragments:
 *       - string_key: 172.20.20.30
 *
 * A request from a client such as:
 *
 * .. code::
 *
 *     GET / HTTP/1.1
 *     Host: foo.com
 *     X-Route-Selector: vip=172.10.10.20
 *
 * would result in the routing table defined by the ``route-config1``
 * RouteConfiguration being assigned to the HTTP request/stream.
 *
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.route.v3.ScopedRouteConfiguration
 */
export declare class ScopedRouteConfiguration extends Message<ScopedRouteConfiguration> {
  /**
   * Whether the RouteConfiguration should be loaded on demand.
   *
   * @generated from field: bool on_demand = 4;
   */
  onDemand: boolean;

  /**
   * The name assigned to the routing scope.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The resource name to use for a :ref:`envoy_v3_api_msg_service.discovery.v3.DiscoveryRequest` to an
   * RDS server to fetch the :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated
   * with this scope.
   *
   * @generated from field: string route_configuration_name = 2;
   */
  routeConfigurationName: string;

  /**
   * The :ref:`envoy_v3_api_msg_config.route.v3.RouteConfiguration` associated with the scope.
   *
   * @generated from field: envoy.config.route.v3.RouteConfiguration route_configuration = 5;
   */
  routeConfiguration?: RouteConfiguration;

  /**
   * The key to match against.
   *
   * @generated from field: envoy.config.route.v3.ScopedRouteConfiguration.Key key = 3;
   */
  key?: ScopedRouteConfiguration_Key;

  constructor(data?: PartialMessage<ScopedRouteConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.route.v3.ScopedRouteConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopedRouteConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration;

  static equals(a: ScopedRouteConfiguration | PlainMessage<ScopedRouteConfiguration> | undefined, b: ScopedRouteConfiguration | PlainMessage<ScopedRouteConfiguration> | undefined): boolean;
}

/**
 * Specifies a key which is matched against the output of the
 * :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`
 * specified in the HttpConnectionManager. The matching is done per HTTP
 * request and is dependent on the order of the fragments contained in the
 * Key.
 *
 * @generated from message envoy.config.route.v3.ScopedRouteConfiguration.Key
 */
export declare class ScopedRouteConfiguration_Key extends Message<ScopedRouteConfiguration_Key> {
  /**
   * The ordered set of fragments to match against. The order must match the
   * fragments in the corresponding
   * :ref:`scope_key_builder<envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.ScopedRoutes.scope_key_builder>`.
   *
   * @generated from field: repeated envoy.config.route.v3.ScopedRouteConfiguration.Key.Fragment fragments = 1;
   */
  fragments: ScopedRouteConfiguration_Key_Fragment[];

  constructor(data?: PartialMessage<ScopedRouteConfiguration_Key>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.route.v3.ScopedRouteConfiguration.Key";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopedRouteConfiguration_Key;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration_Key;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration_Key;

  static equals(a: ScopedRouteConfiguration_Key | PlainMessage<ScopedRouteConfiguration_Key> | undefined, b: ScopedRouteConfiguration_Key | PlainMessage<ScopedRouteConfiguration_Key> | undefined): boolean;
}

/**
 * @generated from message envoy.config.route.v3.ScopedRouteConfiguration.Key.Fragment
 */
export declare class ScopedRouteConfiguration_Key_Fragment extends Message<ScopedRouteConfiguration_Key_Fragment> {
  /**
   * @generated from oneof envoy.config.route.v3.ScopedRouteConfiguration.Key.Fragment.type
   */
  type: {
    /**
     * A string to match against.
     *
     * @generated from field: string string_key = 1;
     */
    value: string;
    case: "stringKey";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ScopedRouteConfiguration_Key_Fragment>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.route.v3.ScopedRouteConfiguration.Key.Fragment";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopedRouteConfiguration_Key_Fragment;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration_Key_Fragment;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopedRouteConfiguration_Key_Fragment;

  static equals(a: ScopedRouteConfiguration_Key_Fragment | PlainMessage<ScopedRouteConfiguration_Key_Fragment> | undefined, b: ScopedRouteConfiguration_Key_Fragment | PlainMessage<ScopedRouteConfiguration_Key_Fragment> | undefined): boolean;
}

