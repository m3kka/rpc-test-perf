// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/bootstrap/v3/bootstrap.proto" (package "envoy.config.bootstrap.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Percent } from "../../../type/v3/percent";
import { EventServiceConfig } from "../../core/v3/event_service_config";
import { BindConfig } from "../../core/v3/address";
import { SocketOption } from "../../core/v3/socket_option";
import { Address } from "../../core/v3/address";
import { AccessLog } from "../../accesslog/v3/accesslog";
import { Struct } from "../../../../google/protobuf/struct";
import { Secret } from "../../../extensions/transport_sockets/tls/v3/secret";
import { Cluster } from "../../cluster/v3/cluster";
import { Listener } from "../../listener/v3/listener";
import { ConfigSource } from "../../core/v3/config_source";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { DnsResolutionConfig } from "../../core/v3/resolver";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { OverloadManager } from "../../overload/v3/overload";
import { Tracing } from "../../trace/v3/http_tracer";
import { Duration } from "../../../../google/protobuf/duration";
import { StatsConfig } from "../../metrics/v3/stats";
import { StatsSink } from "../../metrics/v3/stats";
import { ApiConfigSource } from "../../core/v3/config_source";
import { Node } from "../../core/v3/base";
// [#protodoc-title: Bootstrap]
// This proto is supplied via the :option:`-c` CLI flag and acts as the root
// of the Envoy v3 configuration. See the :ref:`v3 configuration overview
// <config_overview_bootstrap>` for more detail.

/**
 * Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
 * [#next-free-field: 40]
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap
 */
export interface Bootstrap {
    /**
     * Node identity to present to the management server and for instance
     * identification purposes (e.g. in generated headers).
     *
     * @generated from protobuf field: envoy.config.core.v3.Node node = 1;
     */
    node?: Node;
    /**
     * A list of :ref:`Node <envoy_v3_api_msg_config.core.v3.Node>` field names
     * that will be included in the context parameters of the effective
     * xdstp:// URL that is sent in a discovery request when resource
     * locators are used for LDS/CDS. Any non-string field will have its JSON
     * encoding set as the context parameter value, with the exception of
     * metadata, which will be flattened (see example below). The supported field
     * names are:
     * - "cluster"
     * - "id"
     * - "locality.region"
     * - "locality.sub_zone"
     * - "locality.zone"
     * - "metadata"
     * - "user_agent_build_version.metadata"
     * - "user_agent_build_version.version"
     * - "user_agent_name"
     * - "user_agent_version"
     *
     * The node context parameters act as a base layer dictionary for the context
     * parameters (i.e. more specific resource specific context parameters will
     * override). Field names will be prefixed with “udpa.node.” when included in
     * context parameters.
     *
     * For example, if node_context_params is ``["user_agent_name", "metadata"]``,
     * the implied context parameters might be::
     *
     *   node.user_agent_name: "envoy"
     *   node.metadata.foo: "{\"bar\": \"baz\"}"
     *   node.metadata.some: "42"
     *   node.metadata.thing: "\"thing\""
     *
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated string node_context_params = 26;
     */
    nodeContextParams: string[];
    /**
     * Statically specified resources.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap.StaticResources static_resources = 2;
     */
    staticResources?: Bootstrap_StaticResources;
    /**
     * xDS configuration sources.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap.DynamicResources dynamic_resources = 3;
     */
    dynamicResources?: Bootstrap_DynamicResources;
    /**
     * Configuration for the cluster manager which owns all upstream clusters
     * within the server.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.ClusterManager cluster_manager = 4;
     */
    clusterManager?: ClusterManager;
    /**
     * Health discovery service config option.
     * (:ref:`core.ApiConfigSource <envoy_v3_api_msg_config.core.v3.ApiConfigSource>`)
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiConfigSource hds_config = 14;
     */
    hdsConfig?: ApiConfigSource;
    /**
     * Optional file system path to search for startup flag files.
     *
     * @generated from protobuf field: string flags_path = 5;
     */
    flagsPath: string;
    /**
     * Optional set of stats sinks.
     *
     * @generated from protobuf field: repeated envoy.config.metrics.v3.StatsSink stats_sinks = 6;
     */
    statsSinks: StatsSink[];
    /**
     * Options to control behaviors of deferred creation compatible stats.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions deferred_stat_options = 39;
     */
    deferredStatOptions?: Bootstrap_DeferredStatOptions;
    /**
     * Configuration for internal processing of stats.
     *
     * @generated from protobuf field: envoy.config.metrics.v3.StatsConfig stats_config = 13;
     */
    statsConfig?: StatsConfig;
    /**
     * Optional duration between flushes to configured stats sinks. For
     * performance reasons Envoy latches counters and only flushes counters and
     * gauges at a periodic interval. If not specified the default is 5000ms (5
     * seconds). Only one of ``stats_flush_interval`` or ``stats_flush_on_admin``
     * can be set.
     * Duration must be at least 1ms and at most 5 min.
     *
     * @generated from protobuf field: google.protobuf.Duration stats_flush_interval = 7;
     */
    statsFlushInterval?: Duration;
    /**
     * @generated from protobuf oneof: stats_flush
     */
    statsFlush: {
        oneofKind: "statsFlushOnAdmin";
        /**
         * Flush stats to sinks only when queried for on the admin interface. If set,
         * a flush timer is not created. Only one of ``stats_flush_on_admin`` or
         * ``stats_flush_interval`` can be set.
         *
         * @generated from protobuf field: bool stats_flush_on_admin = 29;
         */
        statsFlushOnAdmin: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional watchdog configuration.
     * This is for a single watchdog configuration for the entire system.
     * Deprecated in favor of ``watchdogs`` which has finer granularity.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.bootstrap.v3.Watchdog watchdog = 8 [deprecated = true];
     */
    watchdog?: Watchdog;
    /**
     * Optional watchdogs configuration.
     * This is used for specifying different watchdogs for the different subsystems.
     * [#extension-category: envoy.guarddog_actions]
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Watchdogs watchdogs = 27;
     */
    watchdogs?: Watchdogs;
    /**
     * Configuration for an external tracing provider.
     *
     * .. attention::
     *  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
     *  <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.trace.v3.Tracing tracing = 9 [deprecated = true];
     */
    tracing?: Tracing;
    /**
     * Configuration for the runtime configuration provider. If not
     * specified, a “null” provider will be used which will result in all defaults
     * being used.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.LayeredRuntime layered_runtime = 17;
     */
    layeredRuntime?: LayeredRuntime;
    /**
     * Configuration for the local administration HTTP server.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Admin admin = 12;
     */
    admin?: Admin;
    /**
     * Optional overload manager configuration.
     *
     * @generated from protobuf field: envoy.config.overload.v3.OverloadManager overload_manager = 15;
     */
    overloadManager?: OverloadManager;
    /**
     * Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
     * Note that this records a value for each iteration of the event loop on every thread. This
     * should normally be minimal overhead, but when using
     * :ref:`statsd <envoy_v3_api_msg_config.metrics.v3.StatsdSink>`, it will send each observed value
     * over the wire individually because the statsd protocol doesn't have any way to represent a
     * histogram summary. Be aware that this can be a very large volume of data.
     *
     * @generated from protobuf field: bool enable_dispatcher_stats = 16;
     */
    enableDispatcherStats: boolean;
    /**
     * Optional string which will be used in lieu of x-envoy in prefixing headers.
     *
     * For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
     * transformed into x-foo-retry-on etc.
     *
     * Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
     * headers Envoy will trust for core code and core extensions only. Be VERY careful making
     * changes to this string, especially in multi-layer Envoy deployments or deployments using
     * extensions which are not upstream.
     *
     * @generated from protobuf field: string header_prefix = 18;
     */
    headerPrefix: string;
    /**
     * Optional proxy version which will be used to set the value of :ref:`server.version statistic
     * <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
     * :ref:`stats sinks <envoy_v3_api_msg_config.metrics.v3.StatsSink>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value stats_server_version_override = 19;
     */
    statsServerVersionOverride?: UInt64Value;
    /**
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * This may be overridden on a per-cluster basis in cds_config,
     * when :ref:`dns_resolvers <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolvers>` and
     * :ref:`use_tcp_for_dns_lookups <envoy_v3_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups>` are
     * specified.
     * This field is deprecated in favor of ``dns_resolution_config``
     * which aggregates all of the DNS resolver configuration in a single message.
     *
     * @deprecated
     * @generated from protobuf field: bool use_tcp_for_dns_lookups = 20 [deprecated = true];
     */
    useTcpForDnsLookups: boolean;
    /**
     * DNS resolution configuration which includes the underlying dns resolver addresses and options.
     * This may be overridden on a per-cluster basis in cds_config, when
     * :ref:`dns_resolution_config <envoy_v3_api_field_config.cluster.v3.Cluster.dns_resolution_config>`
     * is specified.
     * This field is deprecated in favor of
     * :ref:`typed_dns_resolver_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.typed_dns_resolver_config>`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 30 [deprecated = true];
     */
    dnsResolutionConfig?: DnsResolutionConfig;
    /**
     * DNS resolver type configuration extension. This extension can be used to configure c-ares, apple,
     * or any other DNS resolver types and the related parameters.
     * For example, an object of
     * :ref:`CaresDnsResolverConfig <envoy_v3_api_msg_extensions.network.dns_resolver.cares.v3.CaresDnsResolverConfig>`
     * can be packed into this ``typed_dns_resolver_config``. This configuration replaces the
     * :ref:`dns_resolution_config <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.dns_resolution_config>`
     * configuration.
     * During the transition period when both ``dns_resolution_config`` and ``typed_dns_resolver_config`` exists,
     * when ``typed_dns_resolver_config`` is in place, Envoy will use it and ignore ``dns_resolution_config``.
     * When ``typed_dns_resolver_config`` is missing, the default behavior is in place.
     * [#extension-category: envoy.network.dns_resolver]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 31;
     */
    typedDnsResolverConfig?: TypedExtensionConfig;
    /**
     * Specifies optional bootstrap extensions to be instantiated at startup time.
     * Each item contains extension specific configuration.
     * [#extension-category: envoy.bootstrap]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig bootstrap_extensions = 21;
     */
    bootstrapExtensions: TypedExtensionConfig[];
    /**
     * Specifies optional extensions instantiated at startup time and
     * invoked during crash time on the request that caused the crash.
     *
     * @generated from protobuf field: repeated envoy.config.bootstrap.v3.FatalAction fatal_actions = 28;
     */
    fatalActions: FatalAction[];
    /**
     * Configuration sources that will participate in
     * xdstp:// URL authority resolution. The algorithm is as
     * follows:
     * 1. The authority field is taken from the xdstp:// URL, call
     *    this ``resource_authority``.
     * 2. ``resource_authority`` is compared against the authorities in any peer
     *    ``ConfigSource``. The peer ``ConfigSource`` is the configuration source
     *    message which would have been used unconditionally for resolution
     *    with opaque resource names. If there is a match with an authority, the
     *    peer ``ConfigSource`` message is used.
     * 3. ``resource_authority`` is compared sequentially with the authorities in
     *    each configuration source in ``config_sources``. The first ``ConfigSource``
     *    to match wins.
     * 4. As a fallback, if no configuration source matches, then
     *    ``default_config_source`` is used.
     * 5. If ``default_config_source`` is not specified, resolution fails.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.ConfigSource config_sources = 22;
     */
    configSources: ConfigSource[];
    /**
     * Default configuration source for xdstp:// URLs if all
     * other resolution fails.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource default_config_source = 23;
     */
    defaultConfigSource?: ConfigSource;
    /**
     * Optional overriding of default socket interface. The value must be the name of one of the
     * socket interface factories initialized through a bootstrap extension
     *
     * @generated from protobuf field: string default_socket_interface = 24;
     */
    defaultSocketInterface: string;
    /**
     * Global map of CertificateProvider instances. These instances are referred to by name in the
     * :ref:`CommonTlsContext.CertificateProviderInstance.instance_name
     * <envoy_v3_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.instance_name>`
     * field.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: map<string, envoy.config.core.v3.TypedExtensionConfig> certificate_provider_instances = 25;
     */
    certificateProviderInstances: {
        [key: string]: TypedExtensionConfig;
    };
    /**
     * Specifies a set of headers that need to be registered as inline header. This configuration
     * allows users to customize the inline headers on-demand at Envoy startup without modifying
     * Envoy's source code.
     *
     * Note that the 'set-cookie' header cannot be registered as inline header.
     *
     * @generated from protobuf field: repeated envoy.config.bootstrap.v3.CustomInlineHeader inline_headers = 32;
     */
    inlineHeaders: CustomInlineHeader[];
    /**
     * Optional path to a file with performance tracing data created by "Perfetto" SDK in binary
     * ProtoBuf format. The default value is "envoy.pftrace".
     *
     * @generated from protobuf field: string perf_tracing_file_path = 33;
     */
    perfTracingFilePath: string;
    /**
     * Optional overriding of default regex engine.
     * If the value is not specified, Google RE2 will be used by default.
     * [#extension-category: envoy.regex_engines]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig default_regex_engine = 34;
     */
    defaultRegexEngine?: TypedExtensionConfig;
    /**
     * Optional XdsResourcesDelegate configuration, which allows plugging custom logic into both
     * fetch and load events during xDS processing.
     * If a value is not specified, no XdsResourcesDelegate will be used.
     * TODO(abeyad): Add public-facing documentation.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig xds_delegate_extension = 35;
     */
    xdsDelegateExtension?: TypedExtensionConfig;
    /**
     * Optional XdsConfigTracker configuration, which allows tracking xDS responses in external components,
     * e.g., external tracer or monitor. It provides the process point when receive, ingest, or fail to
     * process xDS resources and messages. If a value is not specified, no XdsConfigTracker will be used.
     *
     * .. note::
     *
     *    There are no in-repo extensions currently, and the :repo:`XdsConfigTracker <envoy/config/xds_config_tracker.h>`
     *    interface should be implemented before using.
     *    See :repo:`xds_config_tracker_integration_test <test/integration/xds_config_tracker_integration_test.cc>`
     *    for an example usage of the interface.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig xds_config_tracker_extension = 36;
     */
    xdsConfigTrackerExtension?: TypedExtensionConfig;
    /**
     * [#not-implemented-hide:]
     * This controls the type of listener manager configured for Envoy. Currently
     * Envoy only supports ListenerManager for this field and Envoy Mobile
     * supports ApiListenerManager.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig listener_manager = 37;
     */
    listenerManager?: TypedExtensionConfig;
    /**
     * Optional application log configuration.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig application_log_config = 38;
     */
    applicationLogConfig?: Bootstrap_ApplicationLogConfig;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap.StaticResources
 */
export interface Bootstrap_StaticResources {
    /**
     * Static :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>`. These listeners are
     * available regardless of LDS configuration.
     *
     * @generated from protobuf field: repeated envoy.config.listener.v3.Listener listeners = 1;
     */
    listeners: Listener[];
    /**
     * If a network based configuration source is specified for :ref:`cds_config
     * <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.DynamicResources.cds_config>`, it's necessary
     * to have some initial cluster definitions available to allow Envoy to know
     * how to speak to the management server. These cluster definitions may not
     * use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
     * IP or DNS-based).
     *
     * @generated from protobuf field: repeated envoy.config.cluster.v3.Cluster clusters = 2;
     */
    clusters: Cluster[];
    /**
     * These static secrets can be used by :ref:`SdsSecretConfig
     * <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.SdsSecretConfig>`
     *
     * @generated from protobuf field: repeated envoy.extensions.transport_sockets.tls.v3.Secret secrets = 3;
     */
    secrets: Secret[];
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap.DynamicResources
 */
export interface Bootstrap_DynamicResources {
    /**
     * All :ref:`Listeners <envoy_v3_api_msg_config.listener.v3.Listener>` are provided by a single
     * :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource lds_config = 1;
     */
    ldsConfig?: ConfigSource;
    /**
     * xdstp:// resource locator for listener collection.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string lds_resources_locator = 5;
     */
    ldsResourcesLocator: string;
    /**
     * All post-bootstrap :ref:`Cluster <envoy_v3_api_msg_config.cluster.v3.Cluster>` definitions are
     * provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
     * configuration source.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource cds_config = 2;
     */
    cdsConfig?: ConfigSource;
    /**
     * xdstp:// resource locator for cluster collection.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string cds_resources_locator = 6;
     */
    cdsResourcesLocator: string;
    /**
     * A single :ref:`ADS <config_overview_ads>` source may be optionally
     * specified. This must have :ref:`api_type
     * <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
     * <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`. Only
     * :ref:`ConfigSources <envoy_v3_api_msg_config.core.v3.ConfigSource>` that have
     * the :ref:`ads <envoy_v3_api_field_config.core.v3.ConfigSource.ads>` field set will be
     * streamed on the ADS channel.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiConfigSource ads_config = 3;
     */
    adsConfig?: ApiConfigSource;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig
 */
export interface Bootstrap_ApplicationLogConfig {
    /**
     * Optional field to set the application logs format. If this field is set, it will override
     * the default log format. Setting both this field and :option:`--log-format` command line
     * option is not allowed, and will cause a bootstrap error.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat log_format = 1;
     */
    logFormat?: Bootstrap_ApplicationLogConfig_LogFormat;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat
 */
export interface Bootstrap_ApplicationLogConfig_LogFormat {
    /**
     * @generated from protobuf oneof: log_format
     */
    logFormat: {
        oneofKind: "jsonFormat";
        /**
         * Flush application logs in JSON format. The configured JSON struct can
         * support all the format flags specified in the :option:`--log-format`
         * command line options section, except for the ``%v`` and ``%_`` flags.
         *
         * @generated from protobuf field: google.protobuf.Struct json_format = 1;
         */
        jsonFormat: Struct;
    } | {
        oneofKind: "textFormat";
        /**
         * Flush application log in a format defined by a string. The text format
         * can support all the format flags specified in the :option:`--log-format`
         * command line option section.
         *
         * @generated from protobuf field: string text_format = 2;
         */
        textFormat: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions
 */
export interface Bootstrap_DeferredStatOptions {
    /**
     * When the flag is enabled, Envoy will lazily initialize a subset of the stats (see below).
     * This will save memory and CPU cycles when creating the objects that own these stats, if those
     * stats are never referenced throughout the lifetime of the process. However, it will incur additional
     * memory overhead for these objects, and a small increase of CPU usage when a at least one of the stats
     * is updated for the first time.
     * Groups of stats that will be lazily initialized:
     * - Cluster traffic stats: a subgroup of the :ref:`cluster statistics <config_cluster_manager_cluster_stats>`
     * that are used when requests are routed to the cluster.
     *
     * @generated from protobuf field: bool enable_deferred_creation_stats = 1;
     */
    enableDeferredCreationStats: boolean;
}
/**
 * Administration interface :ref:`operations documentation
 * <operations_admin_interface>`.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Admin
 */
export interface Admin {
    /**
     * Configuration for :ref:`access logs <arch_overview_access_logs>`
     * emitted by the administration server.
     *
     * @generated from protobuf field: repeated envoy.config.accesslog.v3.AccessLog access_log = 5;
     */
    accessLog: AccessLog[];
    /**
     * The path to write the access log for the administration server. If no
     * access log is desired specify ‘/dev/null’. This is only required if
     * :ref:`address <envoy_v3_api_field_config.bootstrap.v3.Admin.address>` is set.
     * Deprecated in favor of ``access_log`` which offers more options.
     *
     * @deprecated
     * @generated from protobuf field: string access_log_path = 1 [deprecated = true];
     */
    accessLogPath: string;
    /**
     * The cpu profiler output path for the administration server. If no profile
     * path is specified, the default is ‘/var/log/envoy/envoy.prof’.
     *
     * @generated from protobuf field: string profile_path = 2;
     */
    profilePath: string;
    /**
     * The TCP address that the administration server will listen on.
     * If not specified, Envoy will not start an administration server.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 3;
     */
    address?: Address;
    /**
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.SocketOption socket_options = 4;
     */
    socketOptions: SocketOption[];
    /**
     * Indicates whether :ref:`global_downstream_max_connections <config_overload_manager_limiting_connections>`
     * should apply to the admin interface or not.
     *
     * @generated from protobuf field: bool ignore_global_conn_limit = 6;
     */
    ignoreGlobalConnLimit: boolean;
}
/**
 * Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.ClusterManager
 */
export interface ClusterManager {
    /**
     * Name of the local cluster (i.e., the cluster that owns the Envoy running
     * this configuration). In order to enable :ref:`zone aware routing
     * <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
     * If ``local_cluster_name`` is defined then :ref:`clusters
     * <envoy_v3_api_msg_config.cluster.v3.Cluster>` must be defined in the :ref:`Bootstrap
     * static cluster resources
     * <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.StaticResources.clusters>`. This is unrelated to
     * the :option:`--service-cluster` option which does not `affect zone aware
     * routing <https://github.com/envoyproxy/envoy/issues/774>`_.
     *
     * @generated from protobuf field: string local_cluster_name = 1;
     */
    localClusterName: string;
    /**
     * Optional global configuration for outlier detection.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.ClusterManager.OutlierDetection outlier_detection = 2;
     */
    outlierDetection?: ClusterManager_OutlierDetection;
    /**
     * Optional configuration used to bind newly established upstream connections.
     * This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
     *
     * @generated from protobuf field: envoy.config.core.v3.BindConfig upstream_bind_config = 3;
     */
    upstreamBindConfig?: BindConfig;
    /**
     * A management server endpoint to stream load stats to via
     * ``StreamLoadStats``. This must have :ref:`api_type
     * <envoy_v3_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
     * <envoy_v3_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`.
     *
     * @generated from protobuf field: envoy.config.core.v3.ApiConfigSource load_stats_config = 4;
     */
    loadStatsConfig?: ApiConfigSource;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.ClusterManager.OutlierDetection
 */
export interface ClusterManager_OutlierDetection {
    /**
     * Specifies the path to the outlier event log.
     *
     * @generated from protobuf field: string event_log_path = 1;
     */
    eventLogPath: string;
    /**
     * [#not-implemented-hide:]
     * The gRPC service for the outlier detection event service.
     * If empty, outlier detection events won't be sent to a remote endpoint.
     *
     * @generated from protobuf field: envoy.config.core.v3.EventServiceConfig event_service = 2;
     */
    eventService?: EventServiceConfig;
}
/**
 * Allows you to specify different watchdog configs for different subsystems.
 * This allows finer tuned policies for the watchdog. If a subsystem is omitted
 * the default values for that system will be used.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Watchdogs
 */
export interface Watchdogs {
    /**
     * Watchdog for the main thread.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Watchdog main_thread_watchdog = 1;
     */
    mainThreadWatchdog?: Watchdog;
    /**
     * Watchdog for the worker threads.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.Watchdog worker_watchdog = 2;
     */
    workerWatchdog?: Watchdog;
}
/**
 * Envoy process watchdog configuration. When configured, this monitors for
 * nonresponsive threads and kills the process after the configured thresholds.
 * See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Watchdog
 */
export interface Watchdog {
    /**
     * Register actions that will fire on given WatchDog events.
     * See ``WatchDogAction`` for priority of events.
     *
     * @generated from protobuf field: repeated envoy.config.bootstrap.v3.Watchdog.WatchdogAction actions = 7;
     */
    actions: Watchdog_WatchdogAction[];
    /**
     * The duration after which Envoy counts a nonresponsive thread in the
     * ``watchdog_miss`` statistic. If not specified the default is 200ms.
     *
     * @generated from protobuf field: google.protobuf.Duration miss_timeout = 1;
     */
    missTimeout?: Duration;
    /**
     * The duration after which Envoy counts a nonresponsive thread in the
     * ``watchdog_mega_miss`` statistic. If not specified the default is
     * 1000ms.
     *
     * @generated from protobuf field: google.protobuf.Duration megamiss_timeout = 2;
     */
    megamissTimeout?: Duration;
    /**
     * If a watched thread has been nonresponsive for this duration, assume a
     * programming error and kill the entire Envoy process. Set to 0 to disable
     * kill behavior. If not specified the default is 0 (disabled).
     *
     * @generated from protobuf field: google.protobuf.Duration kill_timeout = 3;
     */
    killTimeout?: Duration;
    /**
     * Defines the maximum jitter used to adjust the ``kill_timeout`` if ``kill_timeout`` is
     * enabled. Enabling this feature would help to reduce risk of synchronized
     * watchdog kill events across proxies due to external triggers. Set to 0 to
     * disable. If not specified the default is 0 (disabled).
     *
     * @generated from protobuf field: google.protobuf.Duration max_kill_timeout_jitter = 6;
     */
    maxKillTimeoutJitter?: Duration;
    /**
     * If ``max(2, ceil(registered_threads * Fraction(*multikill_threshold*)))``
     * threads have been nonresponsive for at least this duration kill the entire
     * Envoy process. Set to 0 to disable this behavior. If not specified the
     * default is 0 (disabled).
     *
     * @generated from protobuf field: google.protobuf.Duration multikill_timeout = 4;
     */
    multikillTimeout?: Duration;
    /**
     * Sets the threshold for ``multikill_timeout`` in terms of the percentage of
     * nonresponsive threads required for the ``multikill_timeout``.
     * If not specified the default is 0.
     *
     * @generated from protobuf field: envoy.type.v3.Percent multikill_threshold = 5;
     */
    multikillThreshold?: Percent;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v3.Watchdog.WatchdogAction
 */
export interface Watchdog_WatchdogAction {
    /**
     * Extension specific configuration for the action.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig config = 1;
     */
    config?: TypedExtensionConfig;
    /**
     * @generated from protobuf field: envoy.config.bootstrap.v3.Watchdog.WatchdogAction.WatchdogEvent event = 2;
     */
    event: Watchdog_WatchdogAction_WatchdogEvent;
}
/**
 * The events are fired in this order: KILL, MULTIKILL, MEGAMISS, MISS.
 * Within an event type, actions execute in the order they are configured.
 * For KILL/MULTIKILL there is a default PANIC that will run after the
 * registered actions and kills the process if it wasn't already killed.
 * It might be useful to specify several debug actions, and possibly an
 * alternate FATAL action.
 *
 * @generated from protobuf enum envoy.config.bootstrap.v3.Watchdog.WatchdogAction.WatchdogEvent
 */
export enum Watchdog_WatchdogAction_WatchdogEvent {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: KILL = 1;
     */
    KILL = 1,
    /**
     * @generated from protobuf enum value: MULTIKILL = 2;
     */
    MULTIKILL = 2,
    /**
     * @generated from protobuf enum value: MEGAMISS = 3;
     */
    MEGAMISS = 3,
    /**
     * @generated from protobuf enum value: MISS = 4;
     */
    MISS = 4
}
/**
 * Fatal actions to run while crashing. Actions can be safe (meaning they are
 * async-signal safe) or unsafe. We run all safe actions before we run unsafe actions.
 * If using an unsafe action that could get stuck or deadlock, it important to
 * have an out of band system to terminate the process.
 *
 * The interface for the extension is ``Envoy::Server::Configuration::FatalAction``.
 * ``FatalAction`` extensions live in the ``envoy.extensions.fatal_actions`` API
 * namespace.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.FatalAction
 */
export interface FatalAction {
    /**
     * Extension specific configuration for the action. It's expected to conform
     * to the ``Envoy::Server::Configuration::FatalAction`` interface.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig config = 1;
     */
    config?: TypedExtensionConfig;
}
/**
 * Runtime :ref:`configuration overview <config_runtime>` (deprecated).
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.Runtime
 */
export interface Runtime {
    /**
     * The implementation assumes that the file system tree is accessed via a
     * symbolic link. An atomic link swap is used when a new tree should be
     * switched to. This parameter specifies the path to the symbolic link. Envoy
     * will watch the location for changes and reload the file system tree when
     * they happen. If this parameter is not set, there will be no disk based
     * runtime.
     *
     * @generated from protobuf field: string symlink_root = 1;
     */
    symlinkRoot: string;
    /**
     * Specifies the subdirectory to load within the root directory. This is
     * useful if multiple systems share the same delivery mechanism. Envoy
     * configuration elements can be contained in a dedicated subdirectory.
     *
     * @generated from protobuf field: string subdirectory = 2;
     */
    subdirectory: string;
    /**
     * Specifies an optional subdirectory to load within the root directory. If
     * specified and the directory exists, configuration values within this
     * directory will override those found in the primary subdirectory. This is
     * useful when Envoy is deployed across many different types of servers.
     * Sometimes it is useful to have a per service cluster directory for runtime
     * configuration. See below for exactly how the override directory is used.
     *
     * @generated from protobuf field: string override_subdirectory = 3;
     */
    overrideSubdirectory: string;
    /**
     * Static base runtime. This will be :ref:`overridden
     * <config_runtime_layering>` by other runtime layers, e.g.
     * disk or admin. This follows the :ref:`runtime protobuf JSON representation
     * encoding <config_runtime_proto_json>`.
     *
     * @generated from protobuf field: google.protobuf.Struct base = 4;
     */
    base?: Struct;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.RuntimeLayer
 */
export interface RuntimeLayer {
    /**
     * Descriptive name for the runtime layer. This is only used for the runtime
     * :http:get:`/runtime` output.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: layer_specifier
     */
    layerSpecifier: {
        oneofKind: "staticLayer";
        /**
         * :ref:`Static runtime <config_runtime_bootstrap>` layer.
         * This follows the :ref:`runtime protobuf JSON representation encoding
         * <config_runtime_proto_json>`. Unlike static xDS resources, this static
         * layer is overridable by later layers in the runtime virtual filesystem.
         *
         * @generated from protobuf field: google.protobuf.Struct static_layer = 2;
         */
        staticLayer: Struct;
    } | {
        oneofKind: "diskLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer disk_layer = 3;
         */
        diskLayer: RuntimeLayer_DiskLayer;
    } | {
        oneofKind: "adminLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer admin_layer = 4;
         */
        adminLayer: RuntimeLayer_AdminLayer;
    } | {
        oneofKind: "rtdsLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer rtds_layer = 5;
         */
        rtdsLayer: RuntimeLayer_RtdsLayer;
    } | {
        oneofKind: undefined;
    };
}
/**
 * :ref:`Disk runtime <config_runtime_local_disk>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer
 */
export interface RuntimeLayer_DiskLayer {
    /**
     * The implementation assumes that the file system tree is accessed via a
     * symbolic link. An atomic link swap is used when a new tree should be
     * switched to. This parameter specifies the path to the symbolic link.
     * Envoy will watch the location for changes and reload the file system tree
     * when they happen. See documentation on runtime :ref:`atomicity
     * <config_runtime_atomicity>` for further details on how reloads are
     * treated.
     *
     * @generated from protobuf field: string symlink_root = 1;
     */
    symlinkRoot: string;
    /**
     * Specifies the subdirectory to load within the root directory. This is
     * useful if multiple systems share the same delivery mechanism. Envoy
     * configuration elements can be contained in a dedicated subdirectory.
     *
     * @generated from protobuf field: string subdirectory = 3;
     */
    subdirectory: string;
    /**
     * :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
     * service cluster to the path under symlink root.
     *
     * @generated from protobuf field: bool append_service_cluster = 2;
     */
    appendServiceCluster: boolean;
}
/**
 * :ref:`Admin console runtime <config_runtime_admin>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer
 */
export interface RuntimeLayer_AdminLayer {
}
/**
 * :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer
 */
export interface RuntimeLayer_RtdsLayer {
    /**
     * Resource to subscribe to at ``rtds_config`` for the RTDS layer.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * RTDS configuration source.
     *
     * @generated from protobuf field: envoy.config.core.v3.ConfigSource rtds_config = 2;
     */
    rtdsConfig?: ConfigSource;
}
/**
 * Runtime :ref:`configuration overview <config_runtime>`.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.LayeredRuntime
 */
export interface LayeredRuntime {
    /**
     * The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
     * such that later layers in the list overlay earlier entries.
     *
     * @generated from protobuf field: repeated envoy.config.bootstrap.v3.RuntimeLayer layers = 1;
     */
    layers: RuntimeLayer[];
}
/**
 * Used to specify the header that needs to be registered as an inline header.
 *
 * If request or response contain multiple headers with the same name and the header
 * name is registered as an inline header. Then multiple headers will be folded
 * into one, and multiple header values will be concatenated by a suitable delimiter.
 * The delimiter is generally a comma.
 *
 * For example, if 'foo' is registered as an inline header, and the headers contains
 * the following two headers:
 *
 * .. code-block:: text
 *
 *   foo: bar
 *   foo: eep
 *
 * Then they will eventually be folded into:
 *
 * .. code-block:: text
 *
 *   foo: bar, eep
 *
 * Inline headers provide O(1) search performance, but each inline header imposes
 * an additional memory overhead on all instances of the corresponding type of
 * HeaderMap or TrailerMap.
 *
 * @generated from protobuf message envoy.config.bootstrap.v3.CustomInlineHeader
 */
export interface CustomInlineHeader {
    /**
     * The name of the header that is expected to be set as the inline header.
     *
     * @generated from protobuf field: string inline_header_name = 1;
     */
    inlineHeaderName: string;
    /**
     * The type of the header that is expected to be set as the inline header.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v3.CustomInlineHeader.InlineHeaderType inline_header_type = 2;
     */
    inlineHeaderType: CustomInlineHeader_InlineHeaderType;
}
/**
 * @generated from protobuf enum envoy.config.bootstrap.v3.CustomInlineHeader.InlineHeaderType
 */
export enum CustomInlineHeader_InlineHeaderType {
    /**
     * @generated from protobuf enum value: REQUEST_HEADER = 0;
     */
    REQUEST_HEADER = 0,
    /**
     * @generated from protobuf enum value: REQUEST_TRAILER = 1;
     */
    REQUEST_TRAILER = 1,
    /**
     * @generated from protobuf enum value: RESPONSE_HEADER = 2;
     */
    RESPONSE_HEADER = 2,
    /**
     * @generated from protobuf enum value: RESPONSE_TRAILER = 3;
     */
    RESPONSE_TRAILER = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap$Type extends MessageType<Bootstrap> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 26, name: "node_context_params", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "static_resources", kind: "message", T: () => Bootstrap_StaticResources },
            { no: 3, name: "dynamic_resources", kind: "message", T: () => Bootstrap_DynamicResources },
            { no: 4, name: "cluster_manager", kind: "message", T: () => ClusterManager },
            { no: 14, name: "hds_config", kind: "message", T: () => ApiConfigSource },
            { no: 5, name: "flags_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "stats_sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatsSink },
            { no: 39, name: "deferred_stat_options", kind: "message", T: () => Bootstrap_DeferredStatOptions },
            { no: 13, name: "stats_config", kind: "message", T: () => StatsConfig },
            { no: 7, name: "stats_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lt: { seconds: "300" }, gte: { nanos: 1000000 } } }, "udpa.annotations.field_migrate": { oneofPromotion: "stats_flush" } } },
            { no: 29, name: "stats_flush_on_admin", kind: "scalar", oneof: "statsFlush", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 8, name: "watchdog", kind: "message", T: () => Watchdog, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 27, name: "watchdogs", kind: "message", T: () => Watchdogs },
            { no: 9, name: "tracing", kind: "message", T: () => Tracing, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 17, name: "layered_runtime", kind: "message", T: () => LayeredRuntime },
            { no: 12, name: "admin", kind: "message", T: () => Admin },
            { no: 15, name: "overload_manager", kind: "message", T: () => OverloadManager, options: { "udpa.annotations.security": { configureForUntrustedDownstream: true, configureForUntrustedUpstream: true } } },
            { no: 16, name: "enable_dispatcher_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "header_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "stats_server_version_override", kind: "message", T: () => UInt64Value },
            { no: 20, name: "use_tcp_for_dns_lookups", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 30, name: "dns_resolution_config", kind: "message", T: () => DnsResolutionConfig, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 31, name: "typed_dns_resolver_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 21, name: "bootstrap_extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 28, name: "fatal_actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FatalAction },
            { no: 22, name: "config_sources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConfigSource },
            { no: 23, name: "default_config_source", kind: "message", T: () => ConfigSource },
            { no: 24, name: "default_socket_interface", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "certificate_provider_instances", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TypedExtensionConfig } },
            { no: 32, name: "inline_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomInlineHeader },
            { no: 33, name: "perf_tracing_file_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "default_regex_engine", kind: "message", T: () => TypedExtensionConfig },
            { no: 35, name: "xds_delegate_extension", kind: "message", T: () => TypedExtensionConfig },
            { no: 36, name: "xds_config_tracker_extension", kind: "message", T: () => TypedExtensionConfig },
            { no: 37, name: "listener_manager", kind: "message", T: () => TypedExtensionConfig },
            { no: 38, name: "application_log_config", kind: "message", T: () => Bootstrap_ApplicationLogConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Bootstrap" } });
    }
    create(value?: PartialMessage<Bootstrap>): Bootstrap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeContextParams = [];
        message.flagsPath = "";
        message.statsSinks = [];
        message.statsFlush = { oneofKind: undefined };
        message.enableDispatcherStats = false;
        message.headerPrefix = "";
        message.useTcpForDnsLookups = false;
        message.bootstrapExtensions = [];
        message.fatalActions = [];
        message.configSources = [];
        message.defaultSocketInterface = "";
        message.certificateProviderInstances = {};
        message.inlineHeaders = [];
        message.perfTracingFilePath = "";
        if (value !== undefined)
            reflectionMergePartial<Bootstrap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap): Bootstrap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* repeated string node_context_params */ 26:
                    message.nodeContextParams.push(reader.string());
                    break;
                case /* envoy.config.bootstrap.v3.Bootstrap.StaticResources static_resources */ 2:
                    message.staticResources = Bootstrap_StaticResources.internalBinaryRead(reader, reader.uint32(), options, message.staticResources);
                    break;
                case /* envoy.config.bootstrap.v3.Bootstrap.DynamicResources dynamic_resources */ 3:
                    message.dynamicResources = Bootstrap_DynamicResources.internalBinaryRead(reader, reader.uint32(), options, message.dynamicResources);
                    break;
                case /* envoy.config.bootstrap.v3.ClusterManager cluster_manager */ 4:
                    message.clusterManager = ClusterManager.internalBinaryRead(reader, reader.uint32(), options, message.clusterManager);
                    break;
                case /* envoy.config.core.v3.ApiConfigSource hds_config */ 14:
                    message.hdsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.hdsConfig);
                    break;
                case /* string flags_path */ 5:
                    message.flagsPath = reader.string();
                    break;
                case /* repeated envoy.config.metrics.v3.StatsSink stats_sinks */ 6:
                    message.statsSinks.push(StatsSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions deferred_stat_options */ 39:
                    message.deferredStatOptions = Bootstrap_DeferredStatOptions.internalBinaryRead(reader, reader.uint32(), options, message.deferredStatOptions);
                    break;
                case /* envoy.config.metrics.v3.StatsConfig stats_config */ 13:
                    message.statsConfig = StatsConfig.internalBinaryRead(reader, reader.uint32(), options, message.statsConfig);
                    break;
                case /* google.protobuf.Duration stats_flush_interval */ 7:
                    message.statsFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.statsFlushInterval);
                    break;
                case /* bool stats_flush_on_admin */ 29:
                    message.statsFlush = {
                        oneofKind: "statsFlushOnAdmin",
                        statsFlushOnAdmin: reader.bool()
                    };
                    break;
                case /* envoy.config.bootstrap.v3.Watchdog watchdog = 8 [deprecated = true];*/ 8:
                    message.watchdog = Watchdog.internalBinaryRead(reader, reader.uint32(), options, message.watchdog);
                    break;
                case /* envoy.config.bootstrap.v3.Watchdogs watchdogs */ 27:
                    message.watchdogs = Watchdogs.internalBinaryRead(reader, reader.uint32(), options, message.watchdogs);
                    break;
                case /* envoy.config.trace.v3.Tracing tracing = 9 [deprecated = true];*/ 9:
                    message.tracing = Tracing.internalBinaryRead(reader, reader.uint32(), options, message.tracing);
                    break;
                case /* envoy.config.bootstrap.v3.LayeredRuntime layered_runtime */ 17:
                    message.layeredRuntime = LayeredRuntime.internalBinaryRead(reader, reader.uint32(), options, message.layeredRuntime);
                    break;
                case /* envoy.config.bootstrap.v3.Admin admin */ 12:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                case /* envoy.config.overload.v3.OverloadManager overload_manager */ 15:
                    message.overloadManager = OverloadManager.internalBinaryRead(reader, reader.uint32(), options, message.overloadManager);
                    break;
                case /* bool enable_dispatcher_stats */ 16:
                    message.enableDispatcherStats = reader.bool();
                    break;
                case /* string header_prefix */ 18:
                    message.headerPrefix = reader.string();
                    break;
                case /* google.protobuf.UInt64Value stats_server_version_override */ 19:
                    message.statsServerVersionOverride = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.statsServerVersionOverride);
                    break;
                case /* bool use_tcp_for_dns_lookups = 20 [deprecated = true];*/ 20:
                    message.useTcpForDnsLookups = reader.bool();
                    break;
                case /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 30 [deprecated = true];*/ 30:
                    message.dnsResolutionConfig = DnsResolutionConfig.internalBinaryRead(reader, reader.uint32(), options, message.dnsResolutionConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config */ 31:
                    message.typedDnsResolverConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.typedDnsResolverConfig);
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig bootstrap_extensions */ 21:
                    message.bootstrapExtensions.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.bootstrap.v3.FatalAction fatal_actions */ 28:
                    message.fatalActions.push(FatalAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.core.v3.ConfigSource config_sources */ 22:
                    message.configSources.push(ConfigSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.ConfigSource default_config_source */ 23:
                    message.defaultConfigSource = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.defaultConfigSource);
                    break;
                case /* string default_socket_interface */ 24:
                    message.defaultSocketInterface = reader.string();
                    break;
                case /* map<string, envoy.config.core.v3.TypedExtensionConfig> certificate_provider_instances */ 25:
                    this.binaryReadMap25(message.certificateProviderInstances, reader, options);
                    break;
                case /* repeated envoy.config.bootstrap.v3.CustomInlineHeader inline_headers */ 32:
                    message.inlineHeaders.push(CustomInlineHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string perf_tracing_file_path */ 33:
                    message.perfTracingFilePath = reader.string();
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig default_regex_engine */ 34:
                    message.defaultRegexEngine = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.defaultRegexEngine);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig xds_delegate_extension */ 35:
                    message.xdsDelegateExtension = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.xdsDelegateExtension);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig xds_config_tracker_extension */ 36:
                    message.xdsConfigTrackerExtension = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.xdsConfigTrackerExtension);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig listener_manager */ 37:
                    message.listenerManager = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.listenerManager);
                    break;
                case /* envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig application_log_config */ 38:
                    message.applicationLogConfig = Bootstrap_ApplicationLogConfig.internalBinaryRead(reader, reader.uint32(), options, message.applicationLogConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap25(map: Bootstrap["certificateProviderInstances"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Bootstrap["certificateProviderInstances"] | undefined, val: Bootstrap["certificateProviderInstances"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.bootstrap.v3.Bootstrap.certificate_provider_instances");
            }
        }
        map[key ?? ""] = val ?? TypedExtensionConfig.create();
    }
    internalBinaryWrite(message: Bootstrap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string node_context_params = 26; */
        for (let i = 0; i < message.nodeContextParams.length; i++)
            writer.tag(26, WireType.LengthDelimited).string(message.nodeContextParams[i]);
        /* envoy.config.bootstrap.v3.Bootstrap.StaticResources static_resources = 2; */
        if (message.staticResources)
            Bootstrap_StaticResources.internalBinaryWrite(message.staticResources, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Bootstrap.DynamicResources dynamic_resources = 3; */
        if (message.dynamicResources)
            Bootstrap_DynamicResources.internalBinaryWrite(message.dynamicResources, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.ClusterManager cluster_manager = 4; */
        if (message.clusterManager)
            ClusterManager.internalBinaryWrite(message.clusterManager, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ApiConfigSource hds_config = 14; */
        if (message.hdsConfig)
            ApiConfigSource.internalBinaryWrite(message.hdsConfig, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string flags_path = 5; */
        if (message.flagsPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.flagsPath);
        /* repeated envoy.config.metrics.v3.StatsSink stats_sinks = 6; */
        for (let i = 0; i < message.statsSinks.length; i++)
            StatsSink.internalBinaryWrite(message.statsSinks[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions deferred_stat_options = 39; */
        if (message.deferredStatOptions)
            Bootstrap_DeferredStatOptions.internalBinaryWrite(message.deferredStatOptions, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.metrics.v3.StatsConfig stats_config = 13; */
        if (message.statsConfig)
            StatsConfig.internalBinaryWrite(message.statsConfig, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration stats_flush_interval = 7; */
        if (message.statsFlushInterval)
            Duration.internalBinaryWrite(message.statsFlushInterval, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool stats_flush_on_admin = 29; */
        if (message.statsFlush.oneofKind === "statsFlushOnAdmin")
            writer.tag(29, WireType.Varint).bool(message.statsFlush.statsFlushOnAdmin);
        /* envoy.config.bootstrap.v3.Watchdog watchdog = 8 [deprecated = true]; */
        if (message.watchdog)
            Watchdog.internalBinaryWrite(message.watchdog, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Watchdogs watchdogs = 27; */
        if (message.watchdogs)
            Watchdogs.internalBinaryWrite(message.watchdogs, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.trace.v3.Tracing tracing = 9 [deprecated = true]; */
        if (message.tracing)
            Tracing.internalBinaryWrite(message.tracing, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.LayeredRuntime layered_runtime = 17; */
        if (message.layeredRuntime)
            LayeredRuntime.internalBinaryWrite(message.layeredRuntime, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Admin admin = 12; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.overload.v3.OverloadManager overload_manager = 15; */
        if (message.overloadManager)
            OverloadManager.internalBinaryWrite(message.overloadManager, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_dispatcher_stats = 16; */
        if (message.enableDispatcherStats !== false)
            writer.tag(16, WireType.Varint).bool(message.enableDispatcherStats);
        /* string header_prefix = 18; */
        if (message.headerPrefix !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.headerPrefix);
        /* google.protobuf.UInt64Value stats_server_version_override = 19; */
        if (message.statsServerVersionOverride)
            UInt64Value.internalBinaryWrite(message.statsServerVersionOverride, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* bool use_tcp_for_dns_lookups = 20 [deprecated = true]; */
        if (message.useTcpForDnsLookups !== false)
            writer.tag(20, WireType.Varint).bool(message.useTcpForDnsLookups);
        /* envoy.config.core.v3.DnsResolutionConfig dns_resolution_config = 30 [deprecated = true]; */
        if (message.dnsResolutionConfig)
            DnsResolutionConfig.internalBinaryWrite(message.dnsResolutionConfig, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig typed_dns_resolver_config = 31; */
        if (message.typedDnsResolverConfig)
            TypedExtensionConfig.internalBinaryWrite(message.typedDnsResolverConfig, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.TypedExtensionConfig bootstrap_extensions = 21; */
        for (let i = 0; i < message.bootstrapExtensions.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.bootstrapExtensions[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.bootstrap.v3.FatalAction fatal_actions = 28; */
        for (let i = 0; i < message.fatalActions.length; i++)
            FatalAction.internalBinaryWrite(message.fatalActions[i], writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.ConfigSource config_sources = 22; */
        for (let i = 0; i < message.configSources.length; i++)
            ConfigSource.internalBinaryWrite(message.configSources[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ConfigSource default_config_source = 23; */
        if (message.defaultConfigSource)
            ConfigSource.internalBinaryWrite(message.defaultConfigSource, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* string default_socket_interface = 24; */
        if (message.defaultSocketInterface !== "")
            writer.tag(24, WireType.LengthDelimited).string(message.defaultSocketInterface);
        /* map<string, envoy.config.core.v3.TypedExtensionConfig> certificate_provider_instances = 25; */
        for (let k of globalThis.Object.keys(message.certificateProviderInstances)) {
            writer.tag(25, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TypedExtensionConfig.internalBinaryWrite(message.certificateProviderInstances[k], writer, options);
            writer.join().join();
        }
        /* repeated envoy.config.bootstrap.v3.CustomInlineHeader inline_headers = 32; */
        for (let i = 0; i < message.inlineHeaders.length; i++)
            CustomInlineHeader.internalBinaryWrite(message.inlineHeaders[i], writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* string perf_tracing_file_path = 33; */
        if (message.perfTracingFilePath !== "")
            writer.tag(33, WireType.LengthDelimited).string(message.perfTracingFilePath);
        /* envoy.config.core.v3.TypedExtensionConfig default_regex_engine = 34; */
        if (message.defaultRegexEngine)
            TypedExtensionConfig.internalBinaryWrite(message.defaultRegexEngine, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig xds_delegate_extension = 35; */
        if (message.xdsDelegateExtension)
            TypedExtensionConfig.internalBinaryWrite(message.xdsDelegateExtension, writer.tag(35, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig xds_config_tracker_extension = 36; */
        if (message.xdsConfigTrackerExtension)
            TypedExtensionConfig.internalBinaryWrite(message.xdsConfigTrackerExtension, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig listener_manager = 37; */
        if (message.listenerManager)
            TypedExtensionConfig.internalBinaryWrite(message.listenerManager, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig application_log_config = 38; */
        if (message.applicationLogConfig)
            Bootstrap_ApplicationLogConfig.internalBinaryWrite(message.applicationLogConfig, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap
 */
export const Bootstrap = new Bootstrap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_StaticResources$Type extends MessageType<Bootstrap_StaticResources> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap.StaticResources", [
            { no: 1, name: "listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Listener },
            { no: 2, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster },
            { no: 3, name: "secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Secret }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Bootstrap.StaticResources" } });
    }
    create(value?: PartialMessage<Bootstrap_StaticResources>): Bootstrap_StaticResources {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.listeners = [];
        message.clusters = [];
        message.secrets = [];
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_StaticResources>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_StaticResources): Bootstrap_StaticResources {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.listener.v3.Listener listeners */ 1:
                    message.listeners.push(Listener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.cluster.v3.Cluster clusters */ 2:
                    message.clusters.push(Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.extensions.transport_sockets.tls.v3.Secret secrets */ 3:
                    message.secrets.push(Secret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_StaticResources, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.listener.v3.Listener listeners = 1; */
        for (let i = 0; i < message.listeners.length; i++)
            Listener.internalBinaryWrite(message.listeners[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.cluster.v3.Cluster clusters = 2; */
        for (let i = 0; i < message.clusters.length; i++)
            Cluster.internalBinaryWrite(message.clusters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.transport_sockets.tls.v3.Secret secrets = 3; */
        for (let i = 0; i < message.secrets.length; i++)
            Secret.internalBinaryWrite(message.secrets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap.StaticResources
 */
export const Bootstrap_StaticResources = new Bootstrap_StaticResources$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_DynamicResources$Type extends MessageType<Bootstrap_DynamicResources> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap.DynamicResources", [
            { no: 1, name: "lds_config", kind: "message", T: () => ConfigSource },
            { no: 5, name: "lds_resources_locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cds_config", kind: "message", T: () => ConfigSource },
            { no: 6, name: "cds_resources_locator", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ads_config", kind: "message", T: () => ApiConfigSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Bootstrap.DynamicResources" } });
    }
    create(value?: PartialMessage<Bootstrap_DynamicResources>): Bootstrap_DynamicResources {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ldsResourcesLocator = "";
        message.cdsResourcesLocator = "";
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_DynamicResources>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_DynamicResources): Bootstrap_DynamicResources {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.ConfigSource lds_config */ 1:
                    message.ldsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.ldsConfig);
                    break;
                case /* string lds_resources_locator */ 5:
                    message.ldsResourcesLocator = reader.string();
                    break;
                case /* envoy.config.core.v3.ConfigSource cds_config */ 2:
                    message.cdsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.cdsConfig);
                    break;
                case /* string cds_resources_locator */ 6:
                    message.cdsResourcesLocator = reader.string();
                    break;
                case /* envoy.config.core.v3.ApiConfigSource ads_config */ 3:
                    message.adsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.adsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_DynamicResources, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.ConfigSource lds_config = 1; */
        if (message.ldsConfig)
            ConfigSource.internalBinaryWrite(message.ldsConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string lds_resources_locator = 5; */
        if (message.ldsResourcesLocator !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.ldsResourcesLocator);
        /* envoy.config.core.v3.ConfigSource cds_config = 2; */
        if (message.cdsConfig)
            ConfigSource.internalBinaryWrite(message.cdsConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string cds_resources_locator = 6; */
        if (message.cdsResourcesLocator !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.cdsResourcesLocator);
        /* envoy.config.core.v3.ApiConfigSource ads_config = 3; */
        if (message.adsConfig)
            ApiConfigSource.internalBinaryWrite(message.adsConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap.DynamicResources
 */
export const Bootstrap_DynamicResources = new Bootstrap_DynamicResources$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_ApplicationLogConfig$Type extends MessageType<Bootstrap_ApplicationLogConfig> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig", [
            { no: 1, name: "log_format", kind: "message", T: () => Bootstrap_ApplicationLogConfig_LogFormat }
        ]);
    }
    create(value?: PartialMessage<Bootstrap_ApplicationLogConfig>): Bootstrap_ApplicationLogConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_ApplicationLogConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_ApplicationLogConfig): Bootstrap_ApplicationLogConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat log_format */ 1:
                    message.logFormat = Bootstrap_ApplicationLogConfig_LogFormat.internalBinaryRead(reader, reader.uint32(), options, message.logFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_ApplicationLogConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat log_format = 1; */
        if (message.logFormat)
            Bootstrap_ApplicationLogConfig_LogFormat.internalBinaryWrite(message.logFormat, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig
 */
export const Bootstrap_ApplicationLogConfig = new Bootstrap_ApplicationLogConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_ApplicationLogConfig_LogFormat$Type extends MessageType<Bootstrap_ApplicationLogConfig_LogFormat> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat", [
            { no: 1, name: "json_format", kind: "message", oneof: "logFormat", T: () => Struct },
            { no: 2, name: "text_format", kind: "scalar", oneof: "logFormat", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Bootstrap_ApplicationLogConfig_LogFormat>): Bootstrap_ApplicationLogConfig_LogFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.logFormat = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_ApplicationLogConfig_LogFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_ApplicationLogConfig_LogFormat): Bootstrap_ApplicationLogConfig_LogFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Struct json_format */ 1:
                    message.logFormat = {
                        oneofKind: "jsonFormat",
                        jsonFormat: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.logFormat as any).jsonFormat)
                    };
                    break;
                case /* string text_format */ 2:
                    message.logFormat = {
                        oneofKind: "textFormat",
                        textFormat: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_ApplicationLogConfig_LogFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Struct json_format = 1; */
        if (message.logFormat.oneofKind === "jsonFormat")
            Struct.internalBinaryWrite(message.logFormat.jsonFormat, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string text_format = 2; */
        if (message.logFormat.oneofKind === "textFormat")
            writer.tag(2, WireType.LengthDelimited).string(message.logFormat.textFormat);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap.ApplicationLogConfig.LogFormat
 */
export const Bootstrap_ApplicationLogConfig_LogFormat = new Bootstrap_ApplicationLogConfig_LogFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_DeferredStatOptions$Type extends MessageType<Bootstrap_DeferredStatOptions> {
    constructor() {
        super("envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions", [
            { no: 1, name: "enable_deferred_creation_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Bootstrap_DeferredStatOptions>): Bootstrap_DeferredStatOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableDeferredCreationStats = false;
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_DeferredStatOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_DeferredStatOptions): Bootstrap_DeferredStatOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enable_deferred_creation_stats */ 1:
                    message.enableDeferredCreationStats = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_DeferredStatOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enable_deferred_creation_stats = 1; */
        if (message.enableDeferredCreationStats !== false)
            writer.tag(1, WireType.Varint).bool(message.enableDeferredCreationStats);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Bootstrap.DeferredStatOptions
 */
export const Bootstrap_DeferredStatOptions = new Bootstrap_DeferredStatOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Admin$Type extends MessageType<Admin> {
    constructor() {
        super("envoy.config.bootstrap.v3.Admin", [
            { no: 5, name: "access_log", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLog },
            { no: 1, name: "access_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 2, name: "profile_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "message", T: () => Address },
            { no: 4, name: "socket_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SocketOption },
            { no: 6, name: "ignore_global_conn_limit", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Admin" } });
    }
    create(value?: PartialMessage<Admin>): Admin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLog = [];
        message.accessLogPath = "";
        message.profilePath = "";
        message.socketOptions = [];
        message.ignoreGlobalConnLimit = false;
        if (value !== undefined)
            reflectionMergePartial<Admin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Admin): Admin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.accesslog.v3.AccessLog access_log */ 5:
                    message.accessLog.push(AccessLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string access_log_path = 1 [deprecated = true];*/ 1:
                    message.accessLogPath = reader.string();
                    break;
                case /* string profile_path */ 2:
                    message.profilePath = reader.string();
                    break;
                case /* envoy.config.core.v3.Address address */ 3:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* repeated envoy.config.core.v3.SocketOption socket_options */ 4:
                    message.socketOptions.push(SocketOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool ignore_global_conn_limit */ 6:
                    message.ignoreGlobalConnLimit = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Admin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.accesslog.v3.AccessLog access_log = 5; */
        for (let i = 0; i < message.accessLog.length; i++)
            AccessLog.internalBinaryWrite(message.accessLog[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string access_log_path = 1 [deprecated = true]; */
        if (message.accessLogPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessLogPath);
        /* string profile_path = 2; */
        if (message.profilePath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.profilePath);
        /* envoy.config.core.v3.Address address = 3; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.SocketOption socket_options = 4; */
        for (let i = 0; i < message.socketOptions.length; i++)
            SocketOption.internalBinaryWrite(message.socketOptions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool ignore_global_conn_limit = 6; */
        if (message.ignoreGlobalConnLimit !== false)
            writer.tag(6, WireType.Varint).bool(message.ignoreGlobalConnLimit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Admin
 */
export const Admin = new Admin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterManager$Type extends MessageType<ClusterManager> {
    constructor() {
        super("envoy.config.bootstrap.v3.ClusterManager", [
            { no: 1, name: "local_cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "outlier_detection", kind: "message", T: () => ClusterManager_OutlierDetection },
            { no: 3, name: "upstream_bind_config", kind: "message", T: () => BindConfig },
            { no: 4, name: "load_stats_config", kind: "message", T: () => ApiConfigSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.ClusterManager" } });
    }
    create(value?: PartialMessage<ClusterManager>): ClusterManager {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localClusterName = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterManager>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterManager): ClusterManager {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string local_cluster_name */ 1:
                    message.localClusterName = reader.string();
                    break;
                case /* envoy.config.bootstrap.v3.ClusterManager.OutlierDetection outlier_detection */ 2:
                    message.outlierDetection = ClusterManager_OutlierDetection.internalBinaryRead(reader, reader.uint32(), options, message.outlierDetection);
                    break;
                case /* envoy.config.core.v3.BindConfig upstream_bind_config */ 3:
                    message.upstreamBindConfig = BindConfig.internalBinaryRead(reader, reader.uint32(), options, message.upstreamBindConfig);
                    break;
                case /* envoy.config.core.v3.ApiConfigSource load_stats_config */ 4:
                    message.loadStatsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.loadStatsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterManager, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string local_cluster_name = 1; */
        if (message.localClusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localClusterName);
        /* envoy.config.bootstrap.v3.ClusterManager.OutlierDetection outlier_detection = 2; */
        if (message.outlierDetection)
            ClusterManager_OutlierDetection.internalBinaryWrite(message.outlierDetection, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.BindConfig upstream_bind_config = 3; */
        if (message.upstreamBindConfig)
            BindConfig.internalBinaryWrite(message.upstreamBindConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ApiConfigSource load_stats_config = 4; */
        if (message.loadStatsConfig)
            ApiConfigSource.internalBinaryWrite(message.loadStatsConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.ClusterManager
 */
export const ClusterManager = new ClusterManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterManager_OutlierDetection$Type extends MessageType<ClusterManager_OutlierDetection> {
    constructor() {
        super("envoy.config.bootstrap.v3.ClusterManager.OutlierDetection", [
            { no: 1, name: "event_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event_service", kind: "message", T: () => EventServiceConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.ClusterManager.OutlierDetection" } });
    }
    create(value?: PartialMessage<ClusterManager_OutlierDetection>): ClusterManager_OutlierDetection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventLogPath = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterManager_OutlierDetection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterManager_OutlierDetection): ClusterManager_OutlierDetection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event_log_path */ 1:
                    message.eventLogPath = reader.string();
                    break;
                case /* envoy.config.core.v3.EventServiceConfig event_service */ 2:
                    message.eventService = EventServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.eventService);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterManager_OutlierDetection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_log_path = 1; */
        if (message.eventLogPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.eventLogPath);
        /* envoy.config.core.v3.EventServiceConfig event_service = 2; */
        if (message.eventService)
            EventServiceConfig.internalBinaryWrite(message.eventService, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.ClusterManager.OutlierDetection
 */
export const ClusterManager_OutlierDetection = new ClusterManager_OutlierDetection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Watchdogs$Type extends MessageType<Watchdogs> {
    constructor() {
        super("envoy.config.bootstrap.v3.Watchdogs", [
            { no: 1, name: "main_thread_watchdog", kind: "message", T: () => Watchdog },
            { no: 2, name: "worker_watchdog", kind: "message", T: () => Watchdog }
        ]);
    }
    create(value?: PartialMessage<Watchdogs>): Watchdogs {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Watchdogs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Watchdogs): Watchdogs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.bootstrap.v3.Watchdog main_thread_watchdog */ 1:
                    message.mainThreadWatchdog = Watchdog.internalBinaryRead(reader, reader.uint32(), options, message.mainThreadWatchdog);
                    break;
                case /* envoy.config.bootstrap.v3.Watchdog worker_watchdog */ 2:
                    message.workerWatchdog = Watchdog.internalBinaryRead(reader, reader.uint32(), options, message.workerWatchdog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Watchdogs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.bootstrap.v3.Watchdog main_thread_watchdog = 1; */
        if (message.mainThreadWatchdog)
            Watchdog.internalBinaryWrite(message.mainThreadWatchdog, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Watchdog worker_watchdog = 2; */
        if (message.workerWatchdog)
            Watchdog.internalBinaryWrite(message.workerWatchdog, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Watchdogs
 */
export const Watchdogs = new Watchdogs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Watchdog$Type extends MessageType<Watchdog> {
    constructor() {
        super("envoy.config.bootstrap.v3.Watchdog", [
            { no: 7, name: "actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Watchdog_WatchdogAction },
            { no: 1, name: "miss_timeout", kind: "message", T: () => Duration },
            { no: 2, name: "megamiss_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "kill_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "max_kill_timeout_jitter", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gte: {} } } } },
            { no: 4, name: "multikill_timeout", kind: "message", T: () => Duration },
            { no: 5, name: "multikill_threshold", kind: "message", T: () => Percent }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Watchdog" } });
    }
    create(value?: PartialMessage<Watchdog>): Watchdog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<Watchdog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Watchdog): Watchdog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.bootstrap.v3.Watchdog.WatchdogAction actions */ 7:
                    message.actions.push(Watchdog_WatchdogAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration miss_timeout */ 1:
                    message.missTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.missTimeout);
                    break;
                case /* google.protobuf.Duration megamiss_timeout */ 2:
                    message.megamissTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.megamissTimeout);
                    break;
                case /* google.protobuf.Duration kill_timeout */ 3:
                    message.killTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.killTimeout);
                    break;
                case /* google.protobuf.Duration max_kill_timeout_jitter */ 6:
                    message.maxKillTimeoutJitter = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxKillTimeoutJitter);
                    break;
                case /* google.protobuf.Duration multikill_timeout */ 4:
                    message.multikillTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.multikillTimeout);
                    break;
                case /* envoy.type.v3.Percent multikill_threshold */ 5:
                    message.multikillThreshold = Percent.internalBinaryRead(reader, reader.uint32(), options, message.multikillThreshold);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Watchdog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.bootstrap.v3.Watchdog.WatchdogAction actions = 7; */
        for (let i = 0; i < message.actions.length; i++)
            Watchdog_WatchdogAction.internalBinaryWrite(message.actions[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration miss_timeout = 1; */
        if (message.missTimeout)
            Duration.internalBinaryWrite(message.missTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration megamiss_timeout = 2; */
        if (message.megamissTimeout)
            Duration.internalBinaryWrite(message.megamissTimeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration kill_timeout = 3; */
        if (message.killTimeout)
            Duration.internalBinaryWrite(message.killTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_kill_timeout_jitter = 6; */
        if (message.maxKillTimeoutJitter)
            Duration.internalBinaryWrite(message.maxKillTimeoutJitter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration multikill_timeout = 4; */
        if (message.multikillTimeout)
            Duration.internalBinaryWrite(message.multikillTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent multikill_threshold = 5; */
        if (message.multikillThreshold)
            Percent.internalBinaryWrite(message.multikillThreshold, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Watchdog
 */
export const Watchdog = new Watchdog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Watchdog_WatchdogAction$Type extends MessageType<Watchdog_WatchdogAction> {
    constructor() {
        super("envoy.config.bootstrap.v3.Watchdog.WatchdogAction", [
            { no: 1, name: "config", kind: "message", T: () => TypedExtensionConfig },
            { no: 2, name: "event", kind: "enum", T: () => ["envoy.config.bootstrap.v3.Watchdog.WatchdogAction.WatchdogEvent", Watchdog_WatchdogAction_WatchdogEvent], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<Watchdog_WatchdogAction>): Watchdog_WatchdogAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = 0;
        if (value !== undefined)
            reflectionMergePartial<Watchdog_WatchdogAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Watchdog_WatchdogAction): Watchdog_WatchdogAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig config */ 1:
                    message.config = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                case /* envoy.config.bootstrap.v3.Watchdog.WatchdogAction.WatchdogEvent event */ 2:
                    message.event = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Watchdog_WatchdogAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig config = 1; */
        if (message.config)
            TypedExtensionConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.Watchdog.WatchdogAction.WatchdogEvent event = 2; */
        if (message.event !== 0)
            writer.tag(2, WireType.Varint).int32(message.event);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Watchdog.WatchdogAction
 */
export const Watchdog_WatchdogAction = new Watchdog_WatchdogAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FatalAction$Type extends MessageType<FatalAction> {
    constructor() {
        super("envoy.config.bootstrap.v3.FatalAction", [
            { no: 1, name: "config", kind: "message", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<FatalAction>): FatalAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FatalAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FatalAction): FatalAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig config */ 1:
                    message.config = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FatalAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig config = 1; */
        if (message.config)
            TypedExtensionConfig.internalBinaryWrite(message.config, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.FatalAction
 */
export const FatalAction = new FatalAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Runtime$Type extends MessageType<Runtime> {
    constructor() {
        super("envoy.config.bootstrap.v3.Runtime", [
            { no: 1, name: "symlink_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "override_subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base", kind: "message", T: () => Struct }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.Runtime" } });
    }
    create(value?: PartialMessage<Runtime>): Runtime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symlinkRoot = "";
        message.subdirectory = "";
        message.overrideSubdirectory = "";
        if (value !== undefined)
            reflectionMergePartial<Runtime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Runtime): Runtime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symlink_root */ 1:
                    message.symlinkRoot = reader.string();
                    break;
                case /* string subdirectory */ 2:
                    message.subdirectory = reader.string();
                    break;
                case /* string override_subdirectory */ 3:
                    message.overrideSubdirectory = reader.string();
                    break;
                case /* google.protobuf.Struct base */ 4:
                    message.base = Struct.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Runtime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symlink_root = 1; */
        if (message.symlinkRoot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symlinkRoot);
        /* string subdirectory = 2; */
        if (message.subdirectory !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subdirectory);
        /* string override_subdirectory = 3; */
        if (message.overrideSubdirectory !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.overrideSubdirectory);
        /* google.protobuf.Struct base = 4; */
        if (message.base)
            Struct.internalBinaryWrite(message.base, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.Runtime
 */
export const Runtime = new Runtime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer$Type extends MessageType<RuntimeLayer> {
    constructor() {
        super("envoy.config.bootstrap.v3.RuntimeLayer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "static_layer", kind: "message", oneof: "layerSpecifier", T: () => Struct },
            { no: 3, name: "disk_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_DiskLayer },
            { no: 4, name: "admin_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_AdminLayer },
            { no: 5, name: "rtds_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_RtdsLayer }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.RuntimeLayer" } });
    }
    create(value?: PartialMessage<RuntimeLayer>): RuntimeLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.layerSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer): RuntimeLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct static_layer */ 2:
                    message.layerSpecifier = {
                        oneofKind: "staticLayer",
                        staticLayer: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).staticLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer disk_layer */ 3:
                    message.layerSpecifier = {
                        oneofKind: "diskLayer",
                        diskLayer: RuntimeLayer_DiskLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).diskLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer admin_layer */ 4:
                    message.layerSpecifier = {
                        oneofKind: "adminLayer",
                        adminLayer: RuntimeLayer_AdminLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).adminLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer rtds_layer */ 5:
                    message.layerSpecifier = {
                        oneofKind: "rtdsLayer",
                        rtdsLayer: RuntimeLayer_RtdsLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).rtdsLayer)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct static_layer = 2; */
        if (message.layerSpecifier.oneofKind === "staticLayer")
            Struct.internalBinaryWrite(message.layerSpecifier.staticLayer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer disk_layer = 3; */
        if (message.layerSpecifier.oneofKind === "diskLayer")
            RuntimeLayer_DiskLayer.internalBinaryWrite(message.layerSpecifier.diskLayer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer admin_layer = 4; */
        if (message.layerSpecifier.oneofKind === "adminLayer")
            RuntimeLayer_AdminLayer.internalBinaryWrite(message.layerSpecifier.adminLayer, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer rtds_layer = 5; */
        if (message.layerSpecifier.oneofKind === "rtdsLayer")
            RuntimeLayer_RtdsLayer.internalBinaryWrite(message.layerSpecifier.rtdsLayer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.RuntimeLayer
 */
export const RuntimeLayer = new RuntimeLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_DiskLayer$Type extends MessageType<RuntimeLayer_DiskLayer> {
    constructor() {
        super("envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer", [
            { no: 1, name: "symlink_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "append_service_cluster", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer" } });
    }
    create(value?: PartialMessage<RuntimeLayer_DiskLayer>): RuntimeLayer_DiskLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symlinkRoot = "";
        message.subdirectory = "";
        message.appendServiceCluster = false;
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_DiskLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_DiskLayer): RuntimeLayer_DiskLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symlink_root */ 1:
                    message.symlinkRoot = reader.string();
                    break;
                case /* string subdirectory */ 3:
                    message.subdirectory = reader.string();
                    break;
                case /* bool append_service_cluster */ 2:
                    message.appendServiceCluster = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer_DiskLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symlink_root = 1; */
        if (message.symlinkRoot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symlinkRoot);
        /* string subdirectory = 3; */
        if (message.subdirectory !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subdirectory);
        /* bool append_service_cluster = 2; */
        if (message.appendServiceCluster !== false)
            writer.tag(2, WireType.Varint).bool(message.appendServiceCluster);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.RuntimeLayer.DiskLayer
 */
export const RuntimeLayer_DiskLayer = new RuntimeLayer_DiskLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_AdminLayer$Type extends MessageType<RuntimeLayer_AdminLayer> {
    constructor() {
        super("envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer" } });
    }
    create(value?: PartialMessage<RuntimeLayer_AdminLayer>): RuntimeLayer_AdminLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_AdminLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_AdminLayer): RuntimeLayer_AdminLayer {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RuntimeLayer_AdminLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.RuntimeLayer.AdminLayer
 */
export const RuntimeLayer_AdminLayer = new RuntimeLayer_AdminLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_RtdsLayer$Type extends MessageType<RuntimeLayer_RtdsLayer> {
    constructor() {
        super("envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rtds_config", kind: "message", T: () => ConfigSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer" } });
    }
    create(value?: PartialMessage<RuntimeLayer_RtdsLayer>): RuntimeLayer_RtdsLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_RtdsLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_RtdsLayer): RuntimeLayer_RtdsLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.config.core.v3.ConfigSource rtds_config */ 2:
                    message.rtdsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.rtdsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer_RtdsLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.config.core.v3.ConfigSource rtds_config = 2; */
        if (message.rtdsConfig)
            ConfigSource.internalBinaryWrite(message.rtdsConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayer
 */
export const RuntimeLayer_RtdsLayer = new RuntimeLayer_RtdsLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayeredRuntime$Type extends MessageType<LayeredRuntime> {
    constructor() {
        super("envoy.config.bootstrap.v3.LayeredRuntime", [
            { no: 1, name: "layers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RuntimeLayer }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.bootstrap.v2.LayeredRuntime" } });
    }
    create(value?: PartialMessage<LayeredRuntime>): LayeredRuntime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layers = [];
        if (value !== undefined)
            reflectionMergePartial<LayeredRuntime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayeredRuntime): LayeredRuntime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.bootstrap.v3.RuntimeLayer layers */ 1:
                    message.layers.push(RuntimeLayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayeredRuntime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.bootstrap.v3.RuntimeLayer layers = 1; */
        for (let i = 0; i < message.layers.length; i++)
            RuntimeLayer.internalBinaryWrite(message.layers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.LayeredRuntime
 */
export const LayeredRuntime = new LayeredRuntime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomInlineHeader$Type extends MessageType<CustomInlineHeader> {
    constructor() {
        super("envoy.config.bootstrap.v3.CustomInlineHeader", [
            { no: 1, name: "inline_header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "inline_header_type", kind: "enum", T: () => ["envoy.config.bootstrap.v3.CustomInlineHeader.InlineHeaderType", CustomInlineHeader_InlineHeaderType], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<CustomInlineHeader>): CustomInlineHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inlineHeaderName = "";
        message.inlineHeaderType = 0;
        if (value !== undefined)
            reflectionMergePartial<CustomInlineHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomInlineHeader): CustomInlineHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string inline_header_name */ 1:
                    message.inlineHeaderName = reader.string();
                    break;
                case /* envoy.config.bootstrap.v3.CustomInlineHeader.InlineHeaderType inline_header_type */ 2:
                    message.inlineHeaderType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomInlineHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string inline_header_name = 1; */
        if (message.inlineHeaderName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.inlineHeaderName);
        /* envoy.config.bootstrap.v3.CustomInlineHeader.InlineHeaderType inline_header_type = 2; */
        if (message.inlineHeaderType !== 0)
            writer.tag(2, WireType.Varint).int32(message.inlineHeaderType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v3.CustomInlineHeader
 */
export const CustomInlineHeader = new CustomInlineHeader$Type();
