// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/bootstrap/v2/bootstrap.proto" (package "envoy.config.bootstrap.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Struct } from "../../../../google/protobuf/struct";
import { EventServiceConfig } from "../../../api/v2/core/event_service_config";
import { BindConfig } from "../../../api/v2/core/address";
import { SocketOption } from "../../../api/v2/core/socket_option";
import { Address } from "../../../api/v2/core/address";
import { ConfigSource } from "../../../api/v2/core/config_source";
import { Secret } from "../../../api/v2/auth/secret";
import { Cluster } from "../../../api/v2/cluster";
import { Listener } from "../../../api/v2/listener";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { OverloadManager } from "../../overload/v2alpha/overload";
import { Tracing } from "../../trace/v2/http_tracer";
import { Duration } from "../../../../google/protobuf/duration";
import { StatsConfig } from "../../metrics/v2/stats";
import { StatsSink } from "../../metrics/v2/stats";
import { ApiConfigSource } from "../../../api/v2/core/config_source";
import { Node } from "../../../api/v2/core/base";
// [#protodoc-title: Bootstrap]
// This proto is supplied via the :option:`-c` CLI flag and acts as the root
// of the Envoy v2 configuration. See the :ref:`v2 configuration overview
// <config_overview_bootstrap>` for more detail.

/**
 * Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
 * [#next-free-field: 21]
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.Bootstrap
 */
export interface Bootstrap {
    /**
     * Node identity to present to the management server and for instance
     * identification purposes (e.g. in generated headers).
     *
     * @generated from protobuf field: envoy.api.v2.core.Node node = 1;
     */
    node?: Node;
    /**
     * Statically specified resources.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.Bootstrap.StaticResources static_resources = 2;
     */
    staticResources?: Bootstrap_StaticResources;
    /**
     * xDS configuration sources.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.Bootstrap.DynamicResources dynamic_resources = 3;
     */
    dynamicResources?: Bootstrap_DynamicResources;
    /**
     * Configuration for the cluster manager which owns all upstream clusters
     * within the server.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.ClusterManager cluster_manager = 4;
     */
    clusterManager?: ClusterManager;
    /**
     * Health discovery service config option.
     * (:ref:`core.ApiConfigSource <envoy_api_msg_core.ApiConfigSource>`)
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiConfigSource hds_config = 14;
     */
    hdsConfig?: ApiConfigSource;
    /**
     * Optional file system path to search for startup flag files.
     *
     * @generated from protobuf field: string flags_path = 5;
     */
    flagsPath: string;
    /**
     * Optional set of stats sinks.
     *
     * @generated from protobuf field: repeated envoy.config.metrics.v2.StatsSink stats_sinks = 6;
     */
    statsSinks: StatsSink[];
    /**
     * Configuration for internal processing of stats.
     *
     * @generated from protobuf field: envoy.config.metrics.v2.StatsConfig stats_config = 13;
     */
    statsConfig?: StatsConfig;
    /**
     * Optional duration between flushes to configured stats sinks. For
     * performance reasons Envoy latches counters and only flushes counters and
     * gauges at a periodic interval. If not specified the default is 5000ms (5
     * seconds).
     * Duration must be at least 1ms and at most 5 min.
     *
     * @generated from protobuf field: google.protobuf.Duration stats_flush_interval = 7;
     */
    statsFlushInterval?: Duration;
    /**
     * Optional watchdog configuration.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.Watchdog watchdog = 8;
     */
    watchdog?: Watchdog;
    /**
     * Configuration for an external tracing provider.
     *
     * .. attention::
     *  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
     *  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.provider>`.
     *
     * @generated from protobuf field: envoy.config.trace.v2.Tracing tracing = 9;
     */
    tracing?: Tracing;
    /**
     * Configuration for the runtime configuration provider (deprecated). If not
     * specified, a “null” provider will be used which will result in all defaults
     * being used.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.bootstrap.v2.Runtime runtime = 11 [deprecated = true];
     */
    runtime?: Runtime;
    /**
     * Configuration for the runtime configuration provider. If not
     * specified, a “null” provider will be used which will result in all defaults
     * being used.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.LayeredRuntime layered_runtime = 17;
     */
    layeredRuntime?: LayeredRuntime;
    /**
     * Configuration for the local administration HTTP server.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.Admin admin = 12;
     */
    admin?: Admin;
    /**
     * Optional overload manager configuration.
     *
     * @generated from protobuf field: envoy.config.overload.v2alpha.OverloadManager overload_manager = 15;
     */
    overloadManager?: OverloadManager;
    /**
     * Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
     * Note that this records a value for each iteration of the event loop on every thread. This
     * should normally be minimal overhead, but when using
     * :ref:`statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`, it will send each observed value
     * over the wire individually because the statsd protocol doesn't have any way to represent a
     * histogram summary. Be aware that this can be a very large volume of data.
     *
     * @generated from protobuf field: bool enable_dispatcher_stats = 16;
     */
    enableDispatcherStats: boolean;
    /**
     * Optional string which will be used in lieu of x-envoy in prefixing headers.
     *
     * For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
     * transformed into x-foo-retry-on etc.
     *
     * Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
     * headers Envoy will trust for core code and core extensions only. Be VERY careful making
     * changes to this string, especially in multi-layer Envoy deployments or deployments using
     * extensions which are not upstream.
     *
     * @generated from protobuf field: string header_prefix = 18;
     */
    headerPrefix: string;
    /**
     * Optional proxy version which will be used to set the value of :ref:`server.version statistic
     * <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
     * :ref:`stats sinks <envoy_api_msg_config.metrics.v2.StatsSink>`.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value stats_server_version_override = 19;
     */
    statsServerVersionOverride?: UInt64Value;
    /**
     * Always use TCP queries instead of UDP queries for DNS lookups.
     * This may be overridden on a per-cluster basis in cds_config,
     * when :ref:`dns_resolvers <envoy_api_field_Cluster.dns_resolvers>` and
     * :ref:`use_tcp_for_dns_lookups <envoy_api_field_Cluster.use_tcp_for_dns_lookups>` are
     * specified.
     * Setting this value causes failure if the
     * ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
     * server startup. Apple' API only uses UDP for DNS resolution.
     *
     * @generated from protobuf field: bool use_tcp_for_dns_lookups = 20;
     */
    useTcpForDnsLookups: boolean;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v2.Bootstrap.StaticResources
 */
export interface Bootstrap_StaticResources {
    /**
     * Static :ref:`Listeners <envoy_api_msg_Listener>`. These listeners are
     * available regardless of LDS configuration.
     *
     * @generated from protobuf field: repeated envoy.api.v2.Listener listeners = 1;
     */
    listeners: Listener[];
    /**
     * If a network based configuration source is specified for :ref:`cds_config
     * <envoy_api_field_config.bootstrap.v2.Bootstrap.DynamicResources.cds_config>`, it's necessary
     * to have some initial cluster definitions available to allow Envoy to know
     * how to speak to the management server. These cluster definitions may not
     * use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
     * IP or DNS-based).
     *
     * @generated from protobuf field: repeated envoy.api.v2.Cluster clusters = 2;
     */
    clusters: Cluster[];
    /**
     * These static secrets can be used by :ref:`SdsSecretConfig
     * <envoy_api_msg_auth.SdsSecretConfig>`
     *
     * @generated from protobuf field: repeated envoy.api.v2.auth.Secret secrets = 3;
     */
    secrets: Secret[];
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v2.Bootstrap.DynamicResources
 */
export interface Bootstrap_DynamicResources {
    /**
     * All :ref:`Listeners <envoy_api_msg_Listener>` are provided by a single
     * :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
     *
     * @generated from protobuf field: envoy.api.v2.core.ConfigSource lds_config = 1;
     */
    ldsConfig?: ConfigSource;
    /**
     * All post-bootstrap :ref:`Cluster <envoy_api_msg_Cluster>` definitions are
     * provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
     * configuration source.
     *
     * @generated from protobuf field: envoy.api.v2.core.ConfigSource cds_config = 2;
     */
    cdsConfig?: ConfigSource;
    /**
     * A single :ref:`ADS <config_overview_ads>` source may be optionally
     * specified. This must have :ref:`api_type
     * <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
     * <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`. Only
     * :ref:`ConfigSources <envoy_api_msg_core.ConfigSource>` that have
     * the :ref:`ads <envoy_api_field_core.ConfigSource.ads>` field set will be
     * streamed on the ADS channel.
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiConfigSource ads_config = 3;
     */
    adsConfig?: ApiConfigSource;
}
/**
 * Administration interface :ref:`operations documentation
 * <operations_admin_interface>`.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.Admin
 */
export interface Admin {
    /**
     * The path to write the access log for the administration server. If no
     * access log is desired specify ‘/dev/null’. This is only required if
     * :ref:`address <envoy_api_field_config.bootstrap.v2.Admin.address>` is set.
     *
     * @generated from protobuf field: string access_log_path = 1;
     */
    accessLogPath: string;
    /**
     * The cpu profiler output path for the administration server. If no profile
     * path is specified, the default is ‘/var/log/envoy/envoy.prof’.
     *
     * @generated from protobuf field: string profile_path = 2;
     */
    profilePath: string;
    /**
     * The TCP address that the administration server will listen on.
     * If not specified, Envoy will not start an administration server.
     *
     * @generated from protobuf field: envoy.api.v2.core.Address address = 3;
     */
    address?: Address;
    /**
     * Additional socket options that may not be present in Envoy source code or
     * precompiled binaries.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.SocketOption socket_options = 4;
     */
    socketOptions: SocketOption[];
}
/**
 * Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.ClusterManager
 */
export interface ClusterManager {
    /**
     * Name of the local cluster (i.e., the cluster that owns the Envoy running
     * this configuration). In order to enable :ref:`zone aware routing
     * <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
     * If *local_cluster_name* is defined then :ref:`clusters
     * <envoy_api_msg_Cluster>` must be defined in the :ref:`Bootstrap
     * static cluster resources
     * <envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`. This is unrelated to
     * the :option:`--service-cluster` option which does not `affect zone aware
     * routing <https://github.com/envoyproxy/envoy/issues/774>`_.
     *
     * @generated from protobuf field: string local_cluster_name = 1;
     */
    localClusterName: string;
    /**
     * Optional global configuration for outlier detection.
     *
     * @generated from protobuf field: envoy.config.bootstrap.v2.ClusterManager.OutlierDetection outlier_detection = 2;
     */
    outlierDetection?: ClusterManager_OutlierDetection;
    /**
     * Optional configuration used to bind newly established upstream connections.
     * This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
     *
     * @generated from protobuf field: envoy.api.v2.core.BindConfig upstream_bind_config = 3;
     */
    upstreamBindConfig?: BindConfig;
    /**
     * A management server endpoint to stream load stats to via
     * *StreamLoadStats*. This must have :ref:`api_type
     * <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
     * <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`.
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiConfigSource load_stats_config = 4;
     */
    loadStatsConfig?: ApiConfigSource;
}
/**
 * @generated from protobuf message envoy.config.bootstrap.v2.ClusterManager.OutlierDetection
 */
export interface ClusterManager_OutlierDetection {
    /**
     * Specifies the path to the outlier event log.
     *
     * @generated from protobuf field: string event_log_path = 1;
     */
    eventLogPath: string;
    /**
     * [#not-implemented-hide:]
     * The gRPC service for the outlier detection event service.
     * If empty, outlier detection events won't be sent to a remote endpoint.
     *
     * @generated from protobuf field: envoy.api.v2.core.EventServiceConfig event_service = 2;
     */
    eventService?: EventServiceConfig;
}
/**
 * Envoy process watchdog configuration. When configured, this monitors for
 * nonresponsive threads and kills the process after the configured thresholds.
 * See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.Watchdog
 */
export interface Watchdog {
    /**
     * The duration after which Envoy counts a nonresponsive thread in the
     * *watchdog_miss* statistic. If not specified the default is 200ms.
     *
     * @generated from protobuf field: google.protobuf.Duration miss_timeout = 1;
     */
    missTimeout?: Duration;
    /**
     * The duration after which Envoy counts a nonresponsive thread in the
     * *watchdog_mega_miss* statistic. If not specified the default is
     * 1000ms.
     *
     * @generated from protobuf field: google.protobuf.Duration megamiss_timeout = 2;
     */
    megamissTimeout?: Duration;
    /**
     * If a watched thread has been nonresponsive for this duration, assume a
     * programming error and kill the entire Envoy process. Set to 0 to disable
     * kill behavior. If not specified the default is 0 (disabled).
     *
     * @generated from protobuf field: google.protobuf.Duration kill_timeout = 3;
     */
    killTimeout?: Duration;
    /**
     * If at least two watched threads have been nonresponsive for at least this
     * duration assume a true deadlock and kill the entire Envoy process. Set to 0
     * to disable this behavior. If not specified the default is 0 (disabled).
     *
     * @generated from protobuf field: google.protobuf.Duration multikill_timeout = 4;
     */
    multikillTimeout?: Duration;
}
/**
 * Runtime :ref:`configuration overview <config_runtime>` (deprecated).
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.Runtime
 */
export interface Runtime {
    /**
     * The implementation assumes that the file system tree is accessed via a
     * symbolic link. An atomic link swap is used when a new tree should be
     * switched to. This parameter specifies the path to the symbolic link. Envoy
     * will watch the location for changes and reload the file system tree when
     * they happen. If this parameter is not set, there will be no disk based
     * runtime.
     *
     * @generated from protobuf field: string symlink_root = 1;
     */
    symlinkRoot: string;
    /**
     * Specifies the subdirectory to load within the root directory. This is
     * useful if multiple systems share the same delivery mechanism. Envoy
     * configuration elements can be contained in a dedicated subdirectory.
     *
     * @generated from protobuf field: string subdirectory = 2;
     */
    subdirectory: string;
    /**
     * Specifies an optional subdirectory to load within the root directory. If
     * specified and the directory exists, configuration values within this
     * directory will override those found in the primary subdirectory. This is
     * useful when Envoy is deployed across many different types of servers.
     * Sometimes it is useful to have a per service cluster directory for runtime
     * configuration. See below for exactly how the override directory is used.
     *
     * @generated from protobuf field: string override_subdirectory = 3;
     */
    overrideSubdirectory: string;
    /**
     * Static base runtime. This will be :ref:`overridden
     * <config_runtime_layering>` by other runtime layers, e.g.
     * disk or admin. This follows the :ref:`runtime protobuf JSON representation
     * encoding <config_runtime_proto_json>`.
     *
     * @generated from protobuf field: google.protobuf.Struct base = 4;
     */
    base?: Struct;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.RuntimeLayer
 */
export interface RuntimeLayer {
    /**
     * Descriptive name for the runtime layer. This is only used for the runtime
     * :http:get:`/runtime` output.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: layer_specifier
     */
    layerSpecifier: {
        oneofKind: "staticLayer";
        /**
         * :ref:`Static runtime <config_runtime_bootstrap>` layer.
         * This follows the :ref:`runtime protobuf JSON representation encoding
         * <config_runtime_proto_json>`. Unlike static xDS resources, this static
         * layer is overridable by later layers in the runtime virtual filesystem.
         *
         * @generated from protobuf field: google.protobuf.Struct static_layer = 2;
         */
        staticLayer: Struct;
    } | {
        oneofKind: "diskLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer disk_layer = 3;
         */
        diskLayer: RuntimeLayer_DiskLayer;
    } | {
        oneofKind: "adminLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer admin_layer = 4;
         */
        adminLayer: RuntimeLayer_AdminLayer;
    } | {
        oneofKind: "rtdsLayer";
        /**
         * @generated from protobuf field: envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer rtds_layer = 5;
         */
        rtdsLayer: RuntimeLayer_RtdsLayer;
    } | {
        oneofKind: undefined;
    };
}
/**
 * :ref:`Disk runtime <config_runtime_local_disk>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer
 */
export interface RuntimeLayer_DiskLayer {
    /**
     * The implementation assumes that the file system tree is accessed via a
     * symbolic link. An atomic link swap is used when a new tree should be
     * switched to. This parameter specifies the path to the symbolic link.
     * Envoy will watch the location for changes and reload the file system tree
     * when they happen. See documentation on runtime :ref:`atomicity
     * <config_runtime_atomicity>` for further details on how reloads are
     * treated.
     *
     * @generated from protobuf field: string symlink_root = 1;
     */
    symlinkRoot: string;
    /**
     * Specifies the subdirectory to load within the root directory. This is
     * useful if multiple systems share the same delivery mechanism. Envoy
     * configuration elements can be contained in a dedicated subdirectory.
     *
     * @generated from protobuf field: string subdirectory = 3;
     */
    subdirectory: string;
    /**
     * :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
     * service cluster to the path under symlink root.
     *
     * @generated from protobuf field: bool append_service_cluster = 2;
     */
    appendServiceCluster: boolean;
}
/**
 * :ref:`Admin console runtime <config_runtime_admin>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer
 */
export interface RuntimeLayer_AdminLayer {
}
/**
 * :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer
 */
export interface RuntimeLayer_RtdsLayer {
    /**
     * Resource to subscribe to at *rtds_config* for the RTDS layer.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * RTDS configuration source.
     *
     * @generated from protobuf field: envoy.api.v2.core.ConfigSource rtds_config = 2;
     */
    rtdsConfig?: ConfigSource;
}
/**
 * Runtime :ref:`configuration overview <config_runtime>`.
 *
 * @generated from protobuf message envoy.config.bootstrap.v2.LayeredRuntime
 */
export interface LayeredRuntime {
    /**
     * The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
     * such that later layers in the list overlay earlier entries.
     *
     * @generated from protobuf field: repeated envoy.config.bootstrap.v2.RuntimeLayer layers = 1;
     */
    layers: RuntimeLayer[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap$Type extends MessageType<Bootstrap> {
    constructor() {
        super("envoy.config.bootstrap.v2.Bootstrap", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "static_resources", kind: "message", T: () => Bootstrap_StaticResources },
            { no: 3, name: "dynamic_resources", kind: "message", T: () => Bootstrap_DynamicResources },
            { no: 4, name: "cluster_manager", kind: "message", T: () => ClusterManager },
            { no: 14, name: "hds_config", kind: "message", T: () => ApiConfigSource },
            { no: 5, name: "flags_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "stats_sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StatsSink },
            { no: 13, name: "stats_config", kind: "message", T: () => StatsConfig },
            { no: 7, name: "stats_flush_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { lt: { seconds: "300" }, gte: { nanos: 1000000 } } } } },
            { no: 8, name: "watchdog", kind: "message", T: () => Watchdog },
            { no: 9, name: "tracing", kind: "message", T: () => Tracing },
            { no: 11, name: "runtime", kind: "message", T: () => Runtime, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 17, name: "layered_runtime", kind: "message", T: () => LayeredRuntime },
            { no: 12, name: "admin", kind: "message", T: () => Admin },
            { no: 15, name: "overload_manager", kind: "message", T: () => OverloadManager },
            { no: 16, name: "enable_dispatcher_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "header_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "stats_server_version_override", kind: "message", T: () => UInt64Value },
            { no: 20, name: "use_tcp_for_dns_lookups", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Bootstrap>): Bootstrap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flagsPath = "";
        message.statsSinks = [];
        message.enableDispatcherStats = false;
        message.headerPrefix = "";
        message.useTcpForDnsLookups = false;
        if (value !== undefined)
            reflectionMergePartial<Bootstrap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap): Bootstrap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* envoy.config.bootstrap.v2.Bootstrap.StaticResources static_resources */ 2:
                    message.staticResources = Bootstrap_StaticResources.internalBinaryRead(reader, reader.uint32(), options, message.staticResources);
                    break;
                case /* envoy.config.bootstrap.v2.Bootstrap.DynamicResources dynamic_resources */ 3:
                    message.dynamicResources = Bootstrap_DynamicResources.internalBinaryRead(reader, reader.uint32(), options, message.dynamicResources);
                    break;
                case /* envoy.config.bootstrap.v2.ClusterManager cluster_manager */ 4:
                    message.clusterManager = ClusterManager.internalBinaryRead(reader, reader.uint32(), options, message.clusterManager);
                    break;
                case /* envoy.api.v2.core.ApiConfigSource hds_config */ 14:
                    message.hdsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.hdsConfig);
                    break;
                case /* string flags_path */ 5:
                    message.flagsPath = reader.string();
                    break;
                case /* repeated envoy.config.metrics.v2.StatsSink stats_sinks */ 6:
                    message.statsSinks.push(StatsSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.metrics.v2.StatsConfig stats_config */ 13:
                    message.statsConfig = StatsConfig.internalBinaryRead(reader, reader.uint32(), options, message.statsConfig);
                    break;
                case /* google.protobuf.Duration stats_flush_interval */ 7:
                    message.statsFlushInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.statsFlushInterval);
                    break;
                case /* envoy.config.bootstrap.v2.Watchdog watchdog */ 8:
                    message.watchdog = Watchdog.internalBinaryRead(reader, reader.uint32(), options, message.watchdog);
                    break;
                case /* envoy.config.trace.v2.Tracing tracing */ 9:
                    message.tracing = Tracing.internalBinaryRead(reader, reader.uint32(), options, message.tracing);
                    break;
                case /* envoy.config.bootstrap.v2.Runtime runtime = 11 [deprecated = true];*/ 11:
                    message.runtime = Runtime.internalBinaryRead(reader, reader.uint32(), options, message.runtime);
                    break;
                case /* envoy.config.bootstrap.v2.LayeredRuntime layered_runtime */ 17:
                    message.layeredRuntime = LayeredRuntime.internalBinaryRead(reader, reader.uint32(), options, message.layeredRuntime);
                    break;
                case /* envoy.config.bootstrap.v2.Admin admin */ 12:
                    message.admin = Admin.internalBinaryRead(reader, reader.uint32(), options, message.admin);
                    break;
                case /* envoy.config.overload.v2alpha.OverloadManager overload_manager */ 15:
                    message.overloadManager = OverloadManager.internalBinaryRead(reader, reader.uint32(), options, message.overloadManager);
                    break;
                case /* bool enable_dispatcher_stats */ 16:
                    message.enableDispatcherStats = reader.bool();
                    break;
                case /* string header_prefix */ 18:
                    message.headerPrefix = reader.string();
                    break;
                case /* google.protobuf.UInt64Value stats_server_version_override */ 19:
                    message.statsServerVersionOverride = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.statsServerVersionOverride);
                    break;
                case /* bool use_tcp_for_dns_lookups */ 20:
                    message.useTcpForDnsLookups = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.Bootstrap.StaticResources static_resources = 2; */
        if (message.staticResources)
            Bootstrap_StaticResources.internalBinaryWrite(message.staticResources, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.Bootstrap.DynamicResources dynamic_resources = 3; */
        if (message.dynamicResources)
            Bootstrap_DynamicResources.internalBinaryWrite(message.dynamicResources, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.ClusterManager cluster_manager = 4; */
        if (message.clusterManager)
            ClusterManager.internalBinaryWrite(message.clusterManager, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.ApiConfigSource hds_config = 14; */
        if (message.hdsConfig)
            ApiConfigSource.internalBinaryWrite(message.hdsConfig, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* string flags_path = 5; */
        if (message.flagsPath !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.flagsPath);
        /* repeated envoy.config.metrics.v2.StatsSink stats_sinks = 6; */
        for (let i = 0; i < message.statsSinks.length; i++)
            StatsSink.internalBinaryWrite(message.statsSinks[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.metrics.v2.StatsConfig stats_config = 13; */
        if (message.statsConfig)
            StatsConfig.internalBinaryWrite(message.statsConfig, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration stats_flush_interval = 7; */
        if (message.statsFlushInterval)
            Duration.internalBinaryWrite(message.statsFlushInterval, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.Watchdog watchdog = 8; */
        if (message.watchdog)
            Watchdog.internalBinaryWrite(message.watchdog, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.trace.v2.Tracing tracing = 9; */
        if (message.tracing)
            Tracing.internalBinaryWrite(message.tracing, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.Runtime runtime = 11 [deprecated = true]; */
        if (message.runtime)
            Runtime.internalBinaryWrite(message.runtime, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.LayeredRuntime layered_runtime = 17; */
        if (message.layeredRuntime)
            LayeredRuntime.internalBinaryWrite(message.layeredRuntime, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.Admin admin = 12; */
        if (message.admin)
            Admin.internalBinaryWrite(message.admin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.overload.v2alpha.OverloadManager overload_manager = 15; */
        if (message.overloadManager)
            OverloadManager.internalBinaryWrite(message.overloadManager, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_dispatcher_stats = 16; */
        if (message.enableDispatcherStats !== false)
            writer.tag(16, WireType.Varint).bool(message.enableDispatcherStats);
        /* string header_prefix = 18; */
        if (message.headerPrefix !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.headerPrefix);
        /* google.protobuf.UInt64Value stats_server_version_override = 19; */
        if (message.statsServerVersionOverride)
            UInt64Value.internalBinaryWrite(message.statsServerVersionOverride, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* bool use_tcp_for_dns_lookups = 20; */
        if (message.useTcpForDnsLookups !== false)
            writer.tag(20, WireType.Varint).bool(message.useTcpForDnsLookups);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Bootstrap
 */
export const Bootstrap = new Bootstrap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_StaticResources$Type extends MessageType<Bootstrap_StaticResources> {
    constructor() {
        super("envoy.config.bootstrap.v2.Bootstrap.StaticResources", [
            { no: 1, name: "listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Listener },
            { no: 2, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Cluster },
            { no: 3, name: "secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Secret }
        ]);
    }
    create(value?: PartialMessage<Bootstrap_StaticResources>): Bootstrap_StaticResources {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.listeners = [];
        message.clusters = [];
        message.secrets = [];
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_StaticResources>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_StaticResources): Bootstrap_StaticResources {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.Listener listeners */ 1:
                    message.listeners.push(Listener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.Cluster clusters */ 2:
                    message.clusters.push(Cluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.auth.Secret secrets */ 3:
                    message.secrets.push(Secret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_StaticResources, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.Listener listeners = 1; */
        for (let i = 0; i < message.listeners.length; i++)
            Listener.internalBinaryWrite(message.listeners[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.Cluster clusters = 2; */
        for (let i = 0; i < message.clusters.length; i++)
            Cluster.internalBinaryWrite(message.clusters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.auth.Secret secrets = 3; */
        for (let i = 0; i < message.secrets.length; i++)
            Secret.internalBinaryWrite(message.secrets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Bootstrap.StaticResources
 */
export const Bootstrap_StaticResources = new Bootstrap_StaticResources$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bootstrap_DynamicResources$Type extends MessageType<Bootstrap_DynamicResources> {
    constructor() {
        super("envoy.config.bootstrap.v2.Bootstrap.DynamicResources", [
            { no: 1, name: "lds_config", kind: "message", T: () => ConfigSource },
            { no: 2, name: "cds_config", kind: "message", T: () => ConfigSource },
            { no: 3, name: "ads_config", kind: "message", T: () => ApiConfigSource }
        ]);
    }
    create(value?: PartialMessage<Bootstrap_DynamicResources>): Bootstrap_DynamicResources {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Bootstrap_DynamicResources>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bootstrap_DynamicResources): Bootstrap_DynamicResources {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.ConfigSource lds_config */ 1:
                    message.ldsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.ldsConfig);
                    break;
                case /* envoy.api.v2.core.ConfigSource cds_config */ 2:
                    message.cdsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.cdsConfig);
                    break;
                case /* envoy.api.v2.core.ApiConfigSource ads_config */ 3:
                    message.adsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.adsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Bootstrap_DynamicResources, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.ConfigSource lds_config = 1; */
        if (message.ldsConfig)
            ConfigSource.internalBinaryWrite(message.ldsConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.ConfigSource cds_config = 2; */
        if (message.cdsConfig)
            ConfigSource.internalBinaryWrite(message.cdsConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.ApiConfigSource ads_config = 3; */
        if (message.adsConfig)
            ApiConfigSource.internalBinaryWrite(message.adsConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Bootstrap.DynamicResources
 */
export const Bootstrap_DynamicResources = new Bootstrap_DynamicResources$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Admin$Type extends MessageType<Admin> {
    constructor() {
        super("envoy.config.bootstrap.v2.Admin", [
            { no: 1, name: "access_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "profile_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "message", T: () => Address },
            { no: 4, name: "socket_options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SocketOption }
        ]);
    }
    create(value?: PartialMessage<Admin>): Admin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accessLogPath = "";
        message.profilePath = "";
        message.socketOptions = [];
        if (value !== undefined)
            reflectionMergePartial<Admin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Admin): Admin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string access_log_path */ 1:
                    message.accessLogPath = reader.string();
                    break;
                case /* string profile_path */ 2:
                    message.profilePath = reader.string();
                    break;
                case /* envoy.api.v2.core.Address address */ 3:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* repeated envoy.api.v2.core.SocketOption socket_options */ 4:
                    message.socketOptions.push(SocketOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Admin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string access_log_path = 1; */
        if (message.accessLogPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accessLogPath);
        /* string profile_path = 2; */
        if (message.profilePath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.profilePath);
        /* envoy.api.v2.core.Address address = 3; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.SocketOption socket_options = 4; */
        for (let i = 0; i < message.socketOptions.length; i++)
            SocketOption.internalBinaryWrite(message.socketOptions[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Admin
 */
export const Admin = new Admin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterManager$Type extends MessageType<ClusterManager> {
    constructor() {
        super("envoy.config.bootstrap.v2.ClusterManager", [
            { no: 1, name: "local_cluster_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "outlier_detection", kind: "message", T: () => ClusterManager_OutlierDetection },
            { no: 3, name: "upstream_bind_config", kind: "message", T: () => BindConfig },
            { no: 4, name: "load_stats_config", kind: "message", T: () => ApiConfigSource }
        ]);
    }
    create(value?: PartialMessage<ClusterManager>): ClusterManager {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localClusterName = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterManager>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterManager): ClusterManager {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string local_cluster_name */ 1:
                    message.localClusterName = reader.string();
                    break;
                case /* envoy.config.bootstrap.v2.ClusterManager.OutlierDetection outlier_detection */ 2:
                    message.outlierDetection = ClusterManager_OutlierDetection.internalBinaryRead(reader, reader.uint32(), options, message.outlierDetection);
                    break;
                case /* envoy.api.v2.core.BindConfig upstream_bind_config */ 3:
                    message.upstreamBindConfig = BindConfig.internalBinaryRead(reader, reader.uint32(), options, message.upstreamBindConfig);
                    break;
                case /* envoy.api.v2.core.ApiConfigSource load_stats_config */ 4:
                    message.loadStatsConfig = ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.loadStatsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterManager, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string local_cluster_name = 1; */
        if (message.localClusterName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.localClusterName);
        /* envoy.config.bootstrap.v2.ClusterManager.OutlierDetection outlier_detection = 2; */
        if (message.outlierDetection)
            ClusterManager_OutlierDetection.internalBinaryWrite(message.outlierDetection, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.BindConfig upstream_bind_config = 3; */
        if (message.upstreamBindConfig)
            BindConfig.internalBinaryWrite(message.upstreamBindConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.ApiConfigSource load_stats_config = 4; */
        if (message.loadStatsConfig)
            ApiConfigSource.internalBinaryWrite(message.loadStatsConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.ClusterManager
 */
export const ClusterManager = new ClusterManager$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterManager_OutlierDetection$Type extends MessageType<ClusterManager_OutlierDetection> {
    constructor() {
        super("envoy.config.bootstrap.v2.ClusterManager.OutlierDetection", [
            { no: 1, name: "event_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "event_service", kind: "message", T: () => EventServiceConfig }
        ]);
    }
    create(value?: PartialMessage<ClusterManager_OutlierDetection>): ClusterManager_OutlierDetection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventLogPath = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterManager_OutlierDetection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterManager_OutlierDetection): ClusterManager_OutlierDetection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event_log_path */ 1:
                    message.eventLogPath = reader.string();
                    break;
                case /* envoy.api.v2.core.EventServiceConfig event_service */ 2:
                    message.eventService = EventServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.eventService);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterManager_OutlierDetection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_log_path = 1; */
        if (message.eventLogPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.eventLogPath);
        /* envoy.api.v2.core.EventServiceConfig event_service = 2; */
        if (message.eventService)
            EventServiceConfig.internalBinaryWrite(message.eventService, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.ClusterManager.OutlierDetection
 */
export const ClusterManager_OutlierDetection = new ClusterManager_OutlierDetection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Watchdog$Type extends MessageType<Watchdog> {
    constructor() {
        super("envoy.config.bootstrap.v2.Watchdog", [
            { no: 1, name: "miss_timeout", kind: "message", T: () => Duration },
            { no: 2, name: "megamiss_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "kill_timeout", kind: "message", T: () => Duration },
            { no: 4, name: "multikill_timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<Watchdog>): Watchdog {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Watchdog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Watchdog): Watchdog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration miss_timeout */ 1:
                    message.missTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.missTimeout);
                    break;
                case /* google.protobuf.Duration megamiss_timeout */ 2:
                    message.megamissTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.megamissTimeout);
                    break;
                case /* google.protobuf.Duration kill_timeout */ 3:
                    message.killTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.killTimeout);
                    break;
                case /* google.protobuf.Duration multikill_timeout */ 4:
                    message.multikillTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.multikillTimeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Watchdog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration miss_timeout = 1; */
        if (message.missTimeout)
            Duration.internalBinaryWrite(message.missTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration megamiss_timeout = 2; */
        if (message.megamissTimeout)
            Duration.internalBinaryWrite(message.megamissTimeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration kill_timeout = 3; */
        if (message.killTimeout)
            Duration.internalBinaryWrite(message.killTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration multikill_timeout = 4; */
        if (message.multikillTimeout)
            Duration.internalBinaryWrite(message.multikillTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Watchdog
 */
export const Watchdog = new Watchdog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Runtime$Type extends MessageType<Runtime> {
    constructor() {
        super("envoy.config.bootstrap.v2.Runtime", [
            { no: 1, name: "symlink_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "override_subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Runtime>): Runtime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symlinkRoot = "";
        message.subdirectory = "";
        message.overrideSubdirectory = "";
        if (value !== undefined)
            reflectionMergePartial<Runtime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Runtime): Runtime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symlink_root */ 1:
                    message.symlinkRoot = reader.string();
                    break;
                case /* string subdirectory */ 2:
                    message.subdirectory = reader.string();
                    break;
                case /* string override_subdirectory */ 3:
                    message.overrideSubdirectory = reader.string();
                    break;
                case /* google.protobuf.Struct base */ 4:
                    message.base = Struct.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Runtime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symlink_root = 1; */
        if (message.symlinkRoot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symlinkRoot);
        /* string subdirectory = 2; */
        if (message.subdirectory !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subdirectory);
        /* string override_subdirectory = 3; */
        if (message.overrideSubdirectory !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.overrideSubdirectory);
        /* google.protobuf.Struct base = 4; */
        if (message.base)
            Struct.internalBinaryWrite(message.base, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.Runtime
 */
export const Runtime = new Runtime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer$Type extends MessageType<RuntimeLayer> {
    constructor() {
        super("envoy.config.bootstrap.v2.RuntimeLayer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "static_layer", kind: "message", oneof: "layerSpecifier", T: () => Struct },
            { no: 3, name: "disk_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_DiskLayer },
            { no: 4, name: "admin_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_AdminLayer },
            { no: 5, name: "rtds_layer", kind: "message", oneof: "layerSpecifier", T: () => RuntimeLayer_RtdsLayer }
        ]);
    }
    create(value?: PartialMessage<RuntimeLayer>): RuntimeLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.layerSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer): RuntimeLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct static_layer */ 2:
                    message.layerSpecifier = {
                        oneofKind: "staticLayer",
                        staticLayer: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).staticLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer disk_layer */ 3:
                    message.layerSpecifier = {
                        oneofKind: "diskLayer",
                        diskLayer: RuntimeLayer_DiskLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).diskLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer admin_layer */ 4:
                    message.layerSpecifier = {
                        oneofKind: "adminLayer",
                        adminLayer: RuntimeLayer_AdminLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).adminLayer)
                    };
                    break;
                case /* envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer rtds_layer */ 5:
                    message.layerSpecifier = {
                        oneofKind: "rtdsLayer",
                        rtdsLayer: RuntimeLayer_RtdsLayer.internalBinaryRead(reader, reader.uint32(), options, (message.layerSpecifier as any).rtdsLayer)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct static_layer = 2; */
        if (message.layerSpecifier.oneofKind === "staticLayer")
            Struct.internalBinaryWrite(message.layerSpecifier.staticLayer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer disk_layer = 3; */
        if (message.layerSpecifier.oneofKind === "diskLayer")
            RuntimeLayer_DiskLayer.internalBinaryWrite(message.layerSpecifier.diskLayer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer admin_layer = 4; */
        if (message.layerSpecifier.oneofKind === "adminLayer")
            RuntimeLayer_AdminLayer.internalBinaryWrite(message.layerSpecifier.adminLayer, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer rtds_layer = 5; */
        if (message.layerSpecifier.oneofKind === "rtdsLayer")
            RuntimeLayer_RtdsLayer.internalBinaryWrite(message.layerSpecifier.rtdsLayer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.RuntimeLayer
 */
export const RuntimeLayer = new RuntimeLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_DiskLayer$Type extends MessageType<RuntimeLayer_DiskLayer> {
    constructor() {
        super("envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer", [
            { no: 1, name: "symlink_root", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subdirectory", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "append_service_cluster", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeLayer_DiskLayer>): RuntimeLayer_DiskLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symlinkRoot = "";
        message.subdirectory = "";
        message.appendServiceCluster = false;
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_DiskLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_DiskLayer): RuntimeLayer_DiskLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string symlink_root */ 1:
                    message.symlinkRoot = reader.string();
                    break;
                case /* string subdirectory */ 3:
                    message.subdirectory = reader.string();
                    break;
                case /* bool append_service_cluster */ 2:
                    message.appendServiceCluster = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer_DiskLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string symlink_root = 1; */
        if (message.symlinkRoot !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.symlinkRoot);
        /* string subdirectory = 3; */
        if (message.subdirectory !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subdirectory);
        /* bool append_service_cluster = 2; */
        if (message.appendServiceCluster !== false)
            writer.tag(2, WireType.Varint).bool(message.appendServiceCluster);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer
 */
export const RuntimeLayer_DiskLayer = new RuntimeLayer_DiskLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_AdminLayer$Type extends MessageType<RuntimeLayer_AdminLayer> {
    constructor() {
        super("envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer", []);
    }
    create(value?: PartialMessage<RuntimeLayer_AdminLayer>): RuntimeLayer_AdminLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_AdminLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_AdminLayer): RuntimeLayer_AdminLayer {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RuntimeLayer_AdminLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer
 */
export const RuntimeLayer_AdminLayer = new RuntimeLayer_AdminLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeLayer_RtdsLayer$Type extends MessageType<RuntimeLayer_RtdsLayer> {
    constructor() {
        super("envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rtds_config", kind: "message", T: () => ConfigSource }
        ]);
    }
    create(value?: PartialMessage<RuntimeLayer_RtdsLayer>): RuntimeLayer_RtdsLayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeLayer_RtdsLayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeLayer_RtdsLayer): RuntimeLayer_RtdsLayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.api.v2.core.ConfigSource rtds_config */ 2:
                    message.rtdsConfig = ConfigSource.internalBinaryRead(reader, reader.uint32(), options, message.rtdsConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeLayer_RtdsLayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.api.v2.core.ConfigSource rtds_config = 2; */
        if (message.rtdsConfig)
            ConfigSource.internalBinaryWrite(message.rtdsConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer
 */
export const RuntimeLayer_RtdsLayer = new RuntimeLayer_RtdsLayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayeredRuntime$Type extends MessageType<LayeredRuntime> {
    constructor() {
        super("envoy.config.bootstrap.v2.LayeredRuntime", [
            { no: 1, name: "layers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RuntimeLayer }
        ]);
    }
    create(value?: PartialMessage<LayeredRuntime>): LayeredRuntime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.layers = [];
        if (value !== undefined)
            reflectionMergePartial<LayeredRuntime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayeredRuntime): LayeredRuntime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.bootstrap.v2.RuntimeLayer layers */ 1:
                    message.layers.push(RuntimeLayer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayeredRuntime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.bootstrap.v2.RuntimeLayer layers = 1; */
        for (let i = 0; i < message.layers.length; i++)
            RuntimeLayer.internalBinaryWrite(message.layers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.bootstrap.v2.LayeredRuntime
 */
export const LayeredRuntime = new LayeredRuntime$Type();
