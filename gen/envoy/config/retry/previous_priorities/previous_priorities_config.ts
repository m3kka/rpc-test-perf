// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/retry/previous_priorities/previous_priorities_config.proto" (package "envoy.config.retry.previous_priorities", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// [#protodoc-title: Previous priorities retry selector]

/**
 * A retry host selector that attempts to spread retries between priorities, even if certain
 * priorities would not normally be attempted due to higher priorities being available.
 *
 * As priorities get excluded, load will be distributed amongst the remaining healthy priorities
 * based on the relative health of the priorities, matching how load is distributed during regular
 * host selection. For example, given priority healths of {100, 50, 50}, the original load will be
 * {100, 0, 0} (since P0 has capacity to handle 100% of the traffic). If P0 is excluded, the load
 * changes to {0, 50, 50}, because P1 is only able to handle 50% of the traffic, causing the
 * remaining to spill over to P2.
 *
 * Each priority attempted will be excluded until there are no healthy priorities left, at which
 * point the list of attempted priorities will be reset, essentially starting from the beginning.
 * For example, given three priorities P0, P1, P2 with healthy % of 100, 0 and 50 respectively, the
 * following sequence of priorities would be selected (assuming update_frequency = 1):
 * Attempt 1: P0 (P0 is 100% healthy)
 * Attempt 2: P2 (P0 already attempted, P2 only healthy priority)
 * Attempt 3: P0 (no healthy priorities, reset)
 * Attempt 4: P2
 *
 * In the case of all upstream hosts being unhealthy, no adjustments will be made to the original
 * priority load, so behavior should be identical to not using this plugin.
 *
 * Using this PriorityFilter requires rebuilding the priority load, which runs in O(# of
 * priorities), which might incur significant overhead for clusters with many priorities.
 * [#extension: envoy.retry_priorities.previous_priorities]
 *
 * @generated from protobuf message envoy.config.retry.previous_priorities.PreviousPrioritiesConfig
 */
export interface PreviousPrioritiesConfig {
    /**
     * How often the priority load should be updated based on previously attempted priorities. Useful
     * to allow each priorities to receive more than one request before being excluded or to reduce
     * the number of times that the priority load has to be recomputed.
     *
     * For example, by setting this to 2, then the first two attempts (initial attempt and first
     * retry) will use the unmodified priority load. The third and fourth attempt will use priority
     * load which excludes the priorities routed to with the first two attempts, and the fifth and
     * sixth attempt will use the priority load excluding the priorities used for the first four
     * attempts.
     *
     * Must be greater than 0.
     *
     * @generated from protobuf field: int32 update_frequency = 1;
     */
    updateFrequency: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class PreviousPrioritiesConfig$Type extends MessageType<PreviousPrioritiesConfig> {
    constructor() {
        super("envoy.config.retry.previous_priorities.PreviousPrioritiesConfig", [
            { no: 1, name: "update_frequency", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<PreviousPrioritiesConfig>): PreviousPrioritiesConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateFrequency = 0;
        if (value !== undefined)
            reflectionMergePartial<PreviousPrioritiesConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviousPrioritiesConfig): PreviousPrioritiesConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 update_frequency */ 1:
                    message.updateFrequency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreviousPrioritiesConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 update_frequency = 1; */
        if (message.updateFrequency !== 0)
            writer.tag(1, WireType.Varint).int32(message.updateFrequency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.retry.previous_priorities.PreviousPrioritiesConfig
 */
export const PreviousPrioritiesConfig = new PreviousPrioritiesConfig$Type();
