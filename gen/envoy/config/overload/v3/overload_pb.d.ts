// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/overload/v3/overload.proto (package envoy.config.overload.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Percent } from "../../../type/v3/percent_pb.js";

/**
 * @generated from message envoy.config.overload.v3.ResourceMonitor
 */
export declare class ResourceMonitor extends Message<ResourceMonitor> {
  /**
   * The name of the resource monitor to instantiate. Must match a registered
   * resource monitor type.
   * See the :ref:`extensions listed in typed_config below <extension_category_envoy.resource_monitors>` for the default list of available resource monitor.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Configuration for the resource monitor being instantiated.
   * [#extension-category: envoy.resource_monitors]
   *
   * @generated from oneof envoy.config.overload.v3.ResourceMonitor.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ResourceMonitor>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.ResourceMonitor";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMonitor;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMonitor;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMonitor;

  static equals(a: ResourceMonitor | PlainMessage<ResourceMonitor> | undefined, b: ResourceMonitor | PlainMessage<ResourceMonitor> | undefined): boolean;
}

/**
 * @generated from message envoy.config.overload.v3.ThresholdTrigger
 */
export declare class ThresholdTrigger extends Message<ThresholdTrigger> {
  /**
   * If the resource pressure is greater than or equal to this value, the trigger
   * will enter saturation.
   *
   * @generated from field: double value = 1;
   */
  value: number;

  constructor(data?: PartialMessage<ThresholdTrigger>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.ThresholdTrigger";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThresholdTrigger;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThresholdTrigger;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThresholdTrigger;

  static equals(a: ThresholdTrigger | PlainMessage<ThresholdTrigger> | undefined, b: ThresholdTrigger | PlainMessage<ThresholdTrigger> | undefined): boolean;
}

/**
 * @generated from message envoy.config.overload.v3.ScaledTrigger
 */
export declare class ScaledTrigger extends Message<ScaledTrigger> {
  /**
   * If the resource pressure is greater than this value, the trigger will be in the
   * :ref:`scaling <arch_overview_overload_manager-triggers-state>` state with value
   * ``(pressure - scaling_threshold) / (saturation_threshold - scaling_threshold)``.
   *
   * @generated from field: double scaling_threshold = 1;
   */
  scalingThreshold: number;

  /**
   * If the resource pressure is greater than this value, the trigger will enter saturation.
   *
   * @generated from field: double saturation_threshold = 2;
   */
  saturationThreshold: number;

  constructor(data?: PartialMessage<ScaledTrigger>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.ScaledTrigger";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScaledTrigger;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScaledTrigger;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScaledTrigger;

  static equals(a: ScaledTrigger | PlainMessage<ScaledTrigger> | undefined, b: ScaledTrigger | PlainMessage<ScaledTrigger> | undefined): boolean;
}

/**
 * @generated from message envoy.config.overload.v3.Trigger
 */
export declare class Trigger extends Message<Trigger> {
  /**
   * The name of the resource this is a trigger for.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.config.overload.v3.Trigger.trigger_oneof
   */
  triggerOneof: {
    /**
     * @generated from field: envoy.config.overload.v3.ThresholdTrigger threshold = 2;
     */
    value: ThresholdTrigger;
    case: "threshold";
  } | {
    /**
     * @generated from field: envoy.config.overload.v3.ScaledTrigger scaled = 3;
     */
    value: ScaledTrigger;
    case: "scaled";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Trigger>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.Trigger";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trigger;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trigger;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trigger;

  static equals(a: Trigger | PlainMessage<Trigger> | undefined, b: Trigger | PlainMessage<Trigger> | undefined): boolean;
}

/**
 * Typed configuration for the "envoy.overload_actions.reduce_timeouts" action. See
 * :ref:`the docs <config_overload_manager_reducing_timeouts>` for an example of how to configure
 * the action with different timeouts and minimum values.
 *
 * @generated from message envoy.config.overload.v3.ScaleTimersOverloadActionConfig
 */
export declare class ScaleTimersOverloadActionConfig extends Message<ScaleTimersOverloadActionConfig> {
  /**
   * A set of timer scaling rules to be applied.
   *
   * @generated from field: repeated envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer timer_scale_factors = 1;
   */
  timerScaleFactors: ScaleTimersOverloadActionConfig_ScaleTimer[];

  constructor(data?: PartialMessage<ScaleTimersOverloadActionConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.ScaleTimersOverloadActionConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScaleTimersOverloadActionConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScaleTimersOverloadActionConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScaleTimersOverloadActionConfig;

  static equals(a: ScaleTimersOverloadActionConfig | PlainMessage<ScaleTimersOverloadActionConfig> | undefined, b: ScaleTimersOverloadActionConfig | PlainMessage<ScaleTimersOverloadActionConfig> | undefined): boolean;
}

/**
 * @generated from enum envoy.config.overload.v3.ScaleTimersOverloadActionConfig.TimerType
 */
export declare enum ScaleTimersOverloadActionConfig_TimerType {
  /**
   * Unsupported value; users must explicitly specify the timer they want scaled.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Adjusts the idle timer for downstream HTTP connections that takes effect when there are no active streams.
   * This affects the value of :ref:`HttpConnectionManager.common_http_protocol_options.idle_timeout
   * <envoy_v3_api_field_config.core.v3.HttpProtocolOptions.idle_timeout>`
   *
   * @generated from enum value: HTTP_DOWNSTREAM_CONNECTION_IDLE = 1;
   */
  HTTP_DOWNSTREAM_CONNECTION_IDLE = 1,

  /**
   * Adjusts the idle timer for HTTP streams initiated by downstream clients.
   * This affects the value of :ref:`RouteAction.idle_timeout <envoy_v3_api_field_config.route.v3.RouteAction.idle_timeout>` and
   * :ref:`HttpConnectionManager.stream_idle_timeout
   * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
   *
   * @generated from enum value: HTTP_DOWNSTREAM_STREAM_IDLE = 2;
   */
  HTTP_DOWNSTREAM_STREAM_IDLE = 2,

  /**
   * Adjusts the timer for how long downstream clients have to finish transport-level negotiations
   * before the connection is closed.
   * This affects the value of
   * :ref:`FilterChain.transport_socket_connect_timeout <envoy_v3_api_field_config.listener.v3.FilterChain.transport_socket_connect_timeout>`.
   *
   * @generated from enum value: TRANSPORT_SOCKET_CONNECT = 3;
   */
  TRANSPORT_SOCKET_CONNECT = 3,
}

/**
 * @generated from message envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer
 */
export declare class ScaleTimersOverloadActionConfig_ScaleTimer extends Message<ScaleTimersOverloadActionConfig_ScaleTimer> {
  /**
   * The type of timer this minimum applies to.
   *
   * @generated from field: envoy.config.overload.v3.ScaleTimersOverloadActionConfig.TimerType timer = 1;
   */
  timer: ScaleTimersOverloadActionConfig_TimerType;

  /**
   * @generated from oneof envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer.overload_adjust
   */
  overloadAdjust: {
    /**
     * Sets the minimum duration as an absolute value.
     *
     * @generated from field: google.protobuf.Duration min_timeout = 2;
     */
    value: Duration;
    case: "minTimeout";
  } | {
    /**
     * Sets the minimum duration as a percentage of the maximum value.
     *
     * @generated from field: envoy.type.v3.Percent min_scale = 3;
     */
    value: Percent;
    case: "minScale";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ScaleTimersOverloadActionConfig_ScaleTimer>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.ScaleTimersOverloadActionConfig.ScaleTimer";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScaleTimersOverloadActionConfig_ScaleTimer;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScaleTimersOverloadActionConfig_ScaleTimer;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScaleTimersOverloadActionConfig_ScaleTimer;

  static equals(a: ScaleTimersOverloadActionConfig_ScaleTimer | PlainMessage<ScaleTimersOverloadActionConfig_ScaleTimer> | undefined, b: ScaleTimersOverloadActionConfig_ScaleTimer | PlainMessage<ScaleTimersOverloadActionConfig_ScaleTimer> | undefined): boolean;
}

/**
 * @generated from message envoy.config.overload.v3.OverloadAction
 */
export declare class OverloadAction extends Message<OverloadAction> {
  /**
   * The name of the overload action. This is just a well-known string that listeners can
   * use for registering callbacks. Custom overload actions should be named using reverse
   * DNS to ensure uniqueness.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A set of triggers for this action. The state of the action is the maximum
   * state of all triggers, which can be scalar values between 0 and 1 or
   * saturated. Listeners are notified when the overload action changes state.
   * An overload manager action can only have one trigger for a given resource
   * e.g. :ref:`Trigger.name
   * <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique
   * in this list.
   *
   * @generated from field: repeated envoy.config.overload.v3.Trigger triggers = 2;
   */
  triggers: Trigger[];

  /**
   * Configuration for the action being instantiated.
   *
   * @generated from field: google.protobuf.Any typed_config = 3;
   */
  typedConfig?: Any;

  constructor(data?: PartialMessage<OverloadAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.OverloadAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverloadAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverloadAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverloadAction;

  static equals(a: OverloadAction | PlainMessage<OverloadAction> | undefined, b: OverloadAction | PlainMessage<OverloadAction> | undefined): boolean;
}

/**
 * A point within the connection or request lifecycle that provides context on
 * whether to shed load at that given stage for the current entity at the
 * point.
 *
 * @generated from message envoy.config.overload.v3.LoadShedPoint
 */
export declare class LoadShedPoint extends Message<LoadShedPoint> {
  /**
   * This is just a well-known string for the LoadShedPoint.
   * Deployment specific LoadShedPoints e.g. within a custom extension should
   * be prefixed by the company / deployment name to avoid colliding with any
   * open source LoadShedPoints.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A set of triggers for this LoadShedPoint. The LoadShedPoint will use the
   * the maximum state of all triggers, which can be scalar values between 0 and
   * 1 or saturated. A LoadShedPoint can only have one trigger for a given
   * resource e.g. :ref:`Trigger.name
   * <envoy_v3_api_field_config.overload.v3.Trigger.name>` must be unique in
   * this list.
   *
   * @generated from field: repeated envoy.config.overload.v3.Trigger triggers = 2;
   */
  triggers: Trigger[];

  constructor(data?: PartialMessage<LoadShedPoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.LoadShedPoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoadShedPoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoadShedPoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoadShedPoint;

  static equals(a: LoadShedPoint | PlainMessage<LoadShedPoint> | undefined, b: LoadShedPoint | PlainMessage<LoadShedPoint> | undefined): boolean;
}

/**
 * Configuration for which accounts the WatermarkBuffer Factories should
 * track.
 *
 * @generated from message envoy.config.overload.v3.BufferFactoryConfig
 */
export declare class BufferFactoryConfig extends Message<BufferFactoryConfig> {
  /**
   * The minimum power of two at which Envoy starts tracking an account.
   *
   * Envoy has 8 power of two buckets starting with the provided exponent below.
   * Concretely the 1st bucket contains accounts for streams that use
   * [2^minimum_account_to_track_power_of_two,
   * 2^(minimum_account_to_track_power_of_two + 1)) bytes.
   * With the 8th bucket tracking accounts
   * >= 128 * 2^minimum_account_to_track_power_of_two.
   *
   * The maximum value is 56, since we're using uint64_t for bytes counting,
   * and that's the last value that would use the 8 buckets. In practice,
   * we don't expect the proxy to be holding 2^56 bytes.
   *
   * If omitted, Envoy should not do any tracking.
   *
   * @generated from field: uint32 minimum_account_to_track_power_of_two = 1;
   */
  minimumAccountToTrackPowerOfTwo: number;

  constructor(data?: PartialMessage<BufferFactoryConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.BufferFactoryConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BufferFactoryConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BufferFactoryConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BufferFactoryConfig;

  static equals(a: BufferFactoryConfig | PlainMessage<BufferFactoryConfig> | undefined, b: BufferFactoryConfig | PlainMessage<BufferFactoryConfig> | undefined): boolean;
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.overload.v3.OverloadManager
 */
export declare class OverloadManager extends Message<OverloadManager> {
  /**
   * The interval for refreshing resource usage.
   *
   * @generated from field: google.protobuf.Duration refresh_interval = 1;
   */
  refreshInterval?: Duration;

  /**
   * The set of resources to monitor.
   *
   * @generated from field: repeated envoy.config.overload.v3.ResourceMonitor resource_monitors = 2;
   */
  resourceMonitors: ResourceMonitor[];

  /**
   * The set of overload actions.
   *
   * @generated from field: repeated envoy.config.overload.v3.OverloadAction actions = 3;
   */
  actions: OverloadAction[];

  /**
   * The set of load shed points.
   *
   * @generated from field: repeated envoy.config.overload.v3.LoadShedPoint loadshed_points = 5;
   */
  loadshedPoints: LoadShedPoint[];

  /**
   * Configuration for buffer factory.
   *
   * @generated from field: envoy.config.overload.v3.BufferFactoryConfig buffer_factory_config = 4;
   */
  bufferFactoryConfig?: BufferFactoryConfig;

  constructor(data?: PartialMessage<OverloadManager>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.overload.v3.OverloadManager";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OverloadManager;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OverloadManager;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OverloadManager;

  static equals(a: OverloadManager | PlainMessage<OverloadManager> | undefined, b: OverloadManager | PlainMessage<OverloadManager> | undefined): boolean;
}

