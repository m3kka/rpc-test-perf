// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/cluster/v3/cluster.proto (package envoy.config.cluster.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, DoubleValue, Duration, proto3, Struct, UInt32Value, UInt64Value } from "@bufbuild/protobuf";
import { CollectionEntry } from "../../../../xds/core/v3/collection_entry_pb.js";
import { ClusterLoadAssignment } from "../../endpoint/v3/endpoint_pb.js";
import { HealthCheck, HealthStatusSet } from "../../core/v3/health_check_pb.js";
import { CircuitBreakers } from "./circuit_breaker_pb.js";
import { Http1ProtocolOptions, Http2ProtocolOptions, HttpProtocolOptions, UpstreamHttpProtocolOptions } from "../../core/v3/protocol_pb.js";
import { Address, BindConfig, TcpKeepalive } from "../../core/v3/address_pb.js";
import { DnsResolutionConfig } from "../../core/v3/resolver_pb.js";
import { TypedExtensionConfig } from "../../core/v3/extension_pb.js";
import { OutlierDetection } from "./outlier_detection_pb.js";
import { Metadata, RuntimeDouble, TransportSocket } from "../../core/v3/base_pb.js";
import { Filter } from "./filter_pb.js";
import { ConfigSource } from "../../core/v3/config_source_pb.js";
import { Percent } from "../../../type/v3/percent_pb.js";
import { MetadataKey } from "../../../type/metadata/v3/metadata_pb.js";

/**
 * Cluster list collections. Entries are ``Cluster`` resources or references.
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.config.cluster.v3.ClusterCollection
 */
export const ClusterCollection = proto3.makeMessageType(
  "envoy.config.cluster.v3.ClusterCollection",
  () => [
    { no: 1, name: "entries", kind: "message", T: CollectionEntry },
  ],
);

/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 57]
 *
 * @generated from message envoy.config.cluster.v3.Cluster
 */
export const Cluster = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster",
  () => [
    { no: 43, name: "transport_socket_matches", kind: "message", T: Cluster_TransportSocketMatch, repeated: true },
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 28, name: "alt_stat_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Cluster_DiscoveryType), oneof: "cluster_discovery_type" },
    { no: 38, name: "cluster_type", kind: "message", T: Cluster_CustomClusterType, oneof: "cluster_discovery_type" },
    { no: 3, name: "eds_cluster_config", kind: "message", T: Cluster_EdsClusterConfig },
    { no: 4, name: "connect_timeout", kind: "message", T: Duration },
    { no: 5, name: "per_connection_buffer_limit_bytes", kind: "message", T: UInt32Value },
    { no: 6, name: "lb_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbPolicy) },
    { no: 33, name: "load_assignment", kind: "message", T: ClusterLoadAssignment },
    { no: 8, name: "health_checks", kind: "message", T: HealthCheck, repeated: true },
    { no: 9, name: "max_requests_per_connection", kind: "message", T: UInt32Value },
    { no: 10, name: "circuit_breakers", kind: "message", T: CircuitBreakers },
    { no: 46, name: "upstream_http_protocol_options", kind: "message", T: UpstreamHttpProtocolOptions },
    { no: 29, name: "common_http_protocol_options", kind: "message", T: HttpProtocolOptions },
    { no: 13, name: "http_protocol_options", kind: "message", T: Http1ProtocolOptions },
    { no: 14, name: "http2_protocol_options", kind: "message", T: Http2ProtocolOptions },
    { no: 36, name: "typed_extension_protocol_options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 16, name: "dns_refresh_rate", kind: "message", T: Duration },
    { no: 44, name: "dns_failure_refresh_rate", kind: "message", T: Cluster_RefreshRate },
    { no: 39, name: "respect_dns_ttl", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "dns_lookup_family", kind: "enum", T: proto3.getEnumType(Cluster_DnsLookupFamily) },
    { no: 18, name: "dns_resolvers", kind: "message", T: Address, repeated: true },
    { no: 45, name: "use_tcp_for_dns_lookups", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 53, name: "dns_resolution_config", kind: "message", T: DnsResolutionConfig },
    { no: 55, name: "typed_dns_resolver_config", kind: "message", T: TypedExtensionConfig },
    { no: 54, name: "wait_for_warm_on_init", kind: "message", T: BoolValue },
    { no: 19, name: "outlier_detection", kind: "message", T: OutlierDetection },
    { no: 20, name: "cleanup_interval", kind: "message", T: Duration },
    { no: 21, name: "upstream_bind_config", kind: "message", T: BindConfig },
    { no: 22, name: "lb_subset_config", kind: "message", T: Cluster_LbSubsetConfig },
    { no: 23, name: "ring_hash_lb_config", kind: "message", T: Cluster_RingHashLbConfig, oneof: "lb_config" },
    { no: 52, name: "maglev_lb_config", kind: "message", T: Cluster_MaglevLbConfig, oneof: "lb_config" },
    { no: 34, name: "original_dst_lb_config", kind: "message", T: Cluster_OriginalDstLbConfig, oneof: "lb_config" },
    { no: 37, name: "least_request_lb_config", kind: "message", T: Cluster_LeastRequestLbConfig, oneof: "lb_config" },
    { no: 56, name: "round_robin_lb_config", kind: "message", T: Cluster_RoundRobinLbConfig, oneof: "lb_config" },
    { no: 27, name: "common_lb_config", kind: "message", T: Cluster_CommonLbConfig },
    { no: 24, name: "transport_socket", kind: "message", T: TransportSocket },
    { no: 25, name: "metadata", kind: "message", T: Metadata },
    { no: 26, name: "protocol_selection", kind: "enum", T: proto3.getEnumType(Cluster_ClusterProtocolSelection) },
    { no: 30, name: "upstream_connection_options", kind: "message", T: UpstreamConnectionOptions },
    { no: 31, name: "close_connections_on_host_health_failure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 32, name: "ignore_health_on_host_removal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 40, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 41, name: "load_balancing_policy", kind: "message", T: LoadBalancingPolicy },
    { no: 42, name: "lrs_server", kind: "message", T: ConfigSource },
    { no: 47, name: "track_timeout_budgets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 48, name: "upstream_config", kind: "message", T: TypedExtensionConfig },
    { no: 49, name: "track_cluster_stats", kind: "message", T: TrackClusterStats },
    { no: 50, name: "preconnect_policy", kind: "message", T: Cluster_PreconnectPolicy },
    { no: 51, name: "connection_pool_per_downstream_connection", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.DiscoveryType
 */
export const Cluster_DiscoveryType = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.DiscoveryType",
  [
    {no: 0, name: "STATIC"},
    {no: 1, name: "STRICT_DNS"},
    {no: 2, name: "LOGICAL_DNS"},
    {no: 3, name: "EDS"},
    {no: 4, name: "ORIGINAL_DST"},
  ],
);

/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbPolicy
 */
export const Cluster_LbPolicy = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.LbPolicy",
  [
    {no: 0, name: "ROUND_ROBIN"},
    {no: 1, name: "LEAST_REQUEST"},
    {no: 2, name: "RING_HASH"},
    {no: 3, name: "RANDOM"},
    {no: 5, name: "MAGLEV"},
    {no: 6, name: "CLUSTER_PROVIDED"},
    {no: 7, name: "LOAD_BALANCING_POLICY_CONFIG"},
  ],
);

/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * This is semantically equivalent to a non-existent V6_PREFERRED option.
 * AUTO is a legacy name that is more opaque than
 * necessary and will be deprecated in favor of V6_PREFERRED in a future major version of the API.
 * If V4_PREFERRED is specified, the DNS resolver will first perform a lookup for addresses in the
 * IPv4 family and fallback to a lookup for addresses in the IPv6 family. i.e., the callback
 * target will only get v6 addresses if there were NO v4 addresses to return.
 * If ALL is specified, the DNS resolver will perform a lookup for both IPv4 and IPv6 families,
 * and return all resolved addresses. When this is used, Happy Eyeballs will be enabled for
 * upstream connections. Refer to :ref:`Happy Eyeballs Support <arch_overview_happy_eyeballs>`
 * for more information.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_v3_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 * [#next-major-version: deprecate AUTO in favor of a V6_PREFERRED option.]
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.DnsLookupFamily
 */
export const Cluster_DnsLookupFamily = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.DnsLookupFamily",
  [
    {no: 0, name: "AUTO"},
    {no: 1, name: "V4_ONLY"},
    {no: 2, name: "V6_ONLY"},
    {no: 3, name: "V4_PREFERRED"},
    {no: 4, name: "ALL"},
  ],
);

/**
 * @generated from enum envoy.config.cluster.v3.Cluster.ClusterProtocolSelection
 */
export const Cluster_ClusterProtocolSelection = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.ClusterProtocolSelection",
  [
    {no: 0, name: "USE_CONFIGURED_PROTOCOL"},
    {no: 1, name: "USE_DOWNSTREAM_PROTOCOL"},
  ],
);

/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.TransportSocketMatch
 */
export const Cluster_TransportSocketMatch = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.TransportSocketMatch",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "match", kind: "message", T: Struct },
    { no: 3, name: "transport_socket", kind: "message", T: TransportSocket },
  ],
  {localName: "Cluster_TransportSocketMatch"},
);

/**
 * Extended cluster type.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CustomClusterType
 */
export const Cluster_CustomClusterType = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.CustomClusterType",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "typed_config", kind: "message", T: Any },
  ],
  {localName: "Cluster_CustomClusterType"},
);

/**
 * Only valid when discovery type is EDS.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.EdsClusterConfig
 */
export const Cluster_EdsClusterConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.EdsClusterConfig",
  () => [
    { no: 1, name: "eds_config", kind: "message", T: ConfigSource },
    { no: 2, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "Cluster_EdsClusterConfig"},
);

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LbSubsetConfig
 */
export const Cluster_LbSubsetConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig",
  () => [
    { no: 1, name: "fallback_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) },
    { no: 2, name: "default_subset", kind: "message", T: Struct },
    { no: 3, name: "subset_selectors", kind: "message", T: Cluster_LbSubsetConfig_LbSubsetSelector, repeated: true },
    { no: 4, name: "locality_weight_aware", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "scale_locality_weight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "panic_mode_any", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "list_as_any", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "metadata_fallback_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy) },
  ],
  {localName: "Cluster_LbSubsetConfig"},
);

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
 */
export const Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy",
  [
    {no: 0, name: "NO_FALLBACK"},
    {no: 1, name: "ANY_ENDPOINT"},
    {no: 2, name: "DEFAULT_SUBSET"},
  ],
);

/**
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy
 */
export const Cluster_LbSubsetConfig_LbSubsetMetadataFallbackPolicy = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetMetadataFallbackPolicy",
  [
    {no: 0, name: "METADATA_NO_FALLBACK"},
    {no: 1, name: "FALLBACK_LIST"},
  ],
);

/**
 * Specifications for subsets.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector
 */
export const Cluster_LbSubsetConfig_LbSubsetSelector = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector",
  () => [
    { no: 1, name: "keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "single_host_per_subset", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "fallback_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) },
    { no: 3, name: "fallback_keys_subset", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
  {localName: "Cluster_LbSubsetConfig_LbSubsetSelector"},
);

/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export const Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy",
  [
    {no: 0, name: "NOT_DEFINED"},
    {no: 1, name: "NO_FALLBACK"},
    {no: 2, name: "ANY_ENDPOINT"},
    {no: 3, name: "DEFAULT_SUBSET"},
    {no: 4, name: "KEYS_SUBSET"},
  ],
);

/**
 * Configuration for :ref:`slow start mode <arch_overview_load_balancing_slow_start>`.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.SlowStartConfig
 */
export const Cluster_SlowStartConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.SlowStartConfig",
  () => [
    { no: 1, name: "slow_start_window", kind: "message", T: Duration },
    { no: 2, name: "aggression", kind: "message", T: RuntimeDouble },
    { no: 3, name: "min_weight_percent", kind: "message", T: Percent },
  ],
  {localName: "Cluster_SlowStartConfig"},
);

/**
 * Specific configuration for the RoundRobin load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.RoundRobinLbConfig
 */
export const Cluster_RoundRobinLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.RoundRobinLbConfig",
  () => [
    { no: 1, name: "slow_start_config", kind: "message", T: Cluster_SlowStartConfig },
  ],
  {localName: "Cluster_RoundRobinLbConfig"},
);

/**
 * Specific configuration for the LeastRequest load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.LeastRequestLbConfig
 */
export const Cluster_LeastRequestLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.LeastRequestLbConfig",
  () => [
    { no: 1, name: "choice_count", kind: "message", T: UInt32Value },
    { no: 2, name: "active_request_bias", kind: "message", T: RuntimeDouble },
    { no: 3, name: "slow_start_config", kind: "message", T: Cluster_SlowStartConfig },
  ],
  {localName: "Cluster_LeastRequestLbConfig"},
);

/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.RingHashLbConfig
 */
export const Cluster_RingHashLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.RingHashLbConfig",
  () => [
    { no: 1, name: "minimum_ring_size", kind: "message", T: UInt64Value },
    { no: 3, name: "hash_function", kind: "enum", T: proto3.getEnumType(Cluster_RingHashLbConfig_HashFunction) },
    { no: 4, name: "maximum_ring_size", kind: "message", T: UInt64Value },
  ],
  {localName: "Cluster_RingHashLbConfig"},
);

/**
 * The hash function used to hash hosts onto the ketama ring.
 *
 * @generated from enum envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction
 */
export const Cluster_RingHashLbConfig_HashFunction = proto3.makeEnum(
  "envoy.config.cluster.v3.Cluster.RingHashLbConfig.HashFunction",
  [
    {no: 0, name: "XX_HASH"},
    {no: 1, name: "MURMUR_HASH_2"},
  ],
);

/**
 * Specific configuration for the :ref:`Maglev<arch_overview_load_balancing_types_maglev>`
 * load balancing policy.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.MaglevLbConfig
 */
export const Cluster_MaglevLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.MaglevLbConfig",
  () => [
    { no: 1, name: "table_size", kind: "message", T: UInt64Value },
  ],
  {localName: "Cluster_MaglevLbConfig"},
);

/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 * [#extension: envoy.clusters.original_dst]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.OriginalDstLbConfig
 */
export const Cluster_OriginalDstLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.OriginalDstLbConfig",
  () => [
    { no: 1, name: "use_http_header", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "http_header_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "upstream_port_override", kind: "message", T: UInt32Value },
    { no: 4, name: "metadata_key", kind: "message", T: MetadataKey },
  ],
  {localName: "Cluster_OriginalDstLbConfig"},
);

/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig
 */
export const Cluster_CommonLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.CommonLbConfig",
  () => [
    { no: 1, name: "healthy_panic_threshold", kind: "message", T: Percent },
    { no: 2, name: "zone_aware_lb_config", kind: "message", T: Cluster_CommonLbConfig_ZoneAwareLbConfig, oneof: "locality_config_specifier" },
    { no: 3, name: "locality_weighted_lb_config", kind: "message", T: Cluster_CommonLbConfig_LocalityWeightedLbConfig, oneof: "locality_config_specifier" },
    { no: 4, name: "update_merge_window", kind: "message", T: Duration },
    { no: 5, name: "ignore_new_hosts_until_first_hc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "close_connections_on_host_set_change", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "consistent_hashing_lb_config", kind: "message", T: Cluster_CommonLbConfig_ConsistentHashingLbConfig },
    { no: 8, name: "override_host_status", kind: "message", T: HealthStatusSet },
  ],
  {localName: "Cluster_CommonLbConfig"},
);

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig
 */
export const Cluster_CommonLbConfig_ZoneAwareLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.ZoneAwareLbConfig",
  () => [
    { no: 1, name: "routing_enabled", kind: "message", T: Percent },
    { no: 2, name: "min_cluster_size", kind: "message", T: UInt64Value },
    { no: 3, name: "fail_traffic_on_panic", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Cluster_CommonLbConfig_ZoneAwareLbConfig"},
);

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig
 */
export const Cluster_CommonLbConfig_LocalityWeightedLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.LocalityWeightedLbConfig",
  [],
  {localName: "Cluster_CommonLbConfig_LocalityWeightedLbConfig"},
);

/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from message envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig
 */
export const Cluster_CommonLbConfig_ConsistentHashingLbConfig = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.CommonLbConfig.ConsistentHashingLbConfig",
  () => [
    { no: 1, name: "use_hostname_for_hashing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "hash_balance_factor", kind: "message", T: UInt32Value },
  ],
  {localName: "Cluster_CommonLbConfig_ConsistentHashingLbConfig"},
);

/**
 * @generated from message envoy.config.cluster.v3.Cluster.RefreshRate
 */
export const Cluster_RefreshRate = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.RefreshRate",
  () => [
    { no: 1, name: "base_interval", kind: "message", T: Duration },
    { no: 2, name: "max_interval", kind: "message", T: Duration },
  ],
  {localName: "Cluster_RefreshRate"},
);

/**
 * @generated from message envoy.config.cluster.v3.Cluster.PreconnectPolicy
 */
export const Cluster_PreconnectPolicy = proto3.makeMessageType(
  "envoy.config.cluster.v3.Cluster.PreconnectPolicy",
  () => [
    { no: 1, name: "per_upstream_preconnect_ratio", kind: "message", T: DoubleValue },
    { no: 2, name: "predictive_preconnect_ratio", kind: "message", T: DoubleValue },
  ],
  {localName: "Cluster_PreconnectPolicy"},
);

/**
 * Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 *
 * @generated from message envoy.config.cluster.v3.LoadBalancingPolicy
 */
export const LoadBalancingPolicy = proto3.makeMessageType(
  "envoy.config.cluster.v3.LoadBalancingPolicy",
  () => [
    { no: 1, name: "policies", kind: "message", T: LoadBalancingPolicy_Policy, repeated: true },
  ],
);

/**
 * @generated from message envoy.config.cluster.v3.LoadBalancingPolicy.Policy
 */
export const LoadBalancingPolicy_Policy = proto3.makeMessageType(
  "envoy.config.cluster.v3.LoadBalancingPolicy.Policy",
  () => [
    { no: 4, name: "typed_extension_config", kind: "message", T: TypedExtensionConfig },
  ],
  {localName: "LoadBalancingPolicy_Policy"},
);

/**
 * @generated from message envoy.config.cluster.v3.UpstreamConnectionOptions
 */
export const UpstreamConnectionOptions = proto3.makeMessageType(
  "envoy.config.cluster.v3.UpstreamConnectionOptions",
  () => [
    { no: 1, name: "tcp_keepalive", kind: "message", T: TcpKeepalive },
    { no: 2, name: "set_local_interface_name_on_upstream_connections", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * @generated from message envoy.config.cluster.v3.TrackClusterStats
 */
export const TrackClusterStats = proto3.makeMessageType(
  "envoy.config.cluster.v3.TrackClusterStats",
  () => [
    { no: 1, name: "timeout_budgets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "request_response_sizes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

