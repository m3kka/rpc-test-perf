// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/rbac/v3/rbac.proto (package envoy.config.rbac.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { TypedExtensionConfig } from "../../core/v3/extension_pb.js";
import { Expr } from "../../../../google/api/expr/v1alpha1/syntax_pb.js";
import { CheckedExpr } from "../../../../google/api/expr/v1alpha1/checked_pb.js";
import { HeaderMatcher } from "../../route/v3/route_components_pb.js";
import { PathMatcher } from "../../../type/matcher/v3/path_pb.js";
import { CidrRange } from "../../core/v3/address_pb.js";
import { Int32Range } from "../../../type/v3/range_pb.js";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata_pb.js";
import { StringMatcher } from "../../../type/matcher/v3/string_pb.js";
import { FilterStateMatcher } from "../../../type/matcher/v3/filter_state_pb.js";

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
 * found. For instance, if the action is ALLOW and a matching policy is found the request should be
 * allowed.
 *
 * RBAC can also be used to make access logging decisions by communicating with access loggers
 * through dynamic metadata. When the action is LOG and at least one policy matches, the
 * ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
 * the request should be logged.
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header:
 *                     name: ":method"
 *                     string_match:
 *                       exact: "GET"
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 *
 *
 * @generated from message envoy.config.rbac.v3.RBAC
 */
export const RBAC = proto3.makeMessageType(
  "envoy.config.rbac.v3.RBAC",
  () => [
    { no: 1, name: "action", kind: "enum", T: proto3.getEnumType(RBAC_Action) },
    { no: 2, name: "policies", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Policy} },
    { no: 3, name: "audit_logging_options", kind: "message", T: RBAC_AuditLoggingOptions },
  ],
);

/**
 * Should we do safe-list or block-list style access control?
 *
 * @generated from enum envoy.config.rbac.v3.RBAC.Action
 */
export const RBAC_Action = proto3.makeEnum(
  "envoy.config.rbac.v3.RBAC.Action",
  [
    {no: 0, name: "ALLOW"},
    {no: 1, name: "DENY"},
    {no: 2, name: "LOG"},
  ],
);

/**
 * @generated from message envoy.config.rbac.v3.RBAC.AuditLoggingOptions
 */
export const RBAC_AuditLoggingOptions = proto3.makeMessageType(
  "envoy.config.rbac.v3.RBAC.AuditLoggingOptions",
  () => [
    { no: 1, name: "audit_condition", kind: "enum", T: proto3.getEnumType(RBAC_AuditLoggingOptions_AuditCondition) },
    { no: 2, name: "logger_configs", kind: "message", T: RBAC_AuditLoggingOptions_AuditLoggerConfig, repeated: true },
  ],
  {localName: "RBAC_AuditLoggingOptions"},
);

/**
 * Deny and allow here refer to RBAC decisions, not actions.
 *
 * @generated from enum envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition
 */
export const RBAC_AuditLoggingOptions_AuditCondition = proto3.makeEnum(
  "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition",
  [
    {no: 0, name: "NONE"},
    {no: 1, name: "ON_DENY"},
    {no: 2, name: "ON_ALLOW"},
    {no: 3, name: "ON_DENY_AND_ALLOW"},
  ],
);

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig
 */
export const RBAC_AuditLoggingOptions_AuditLoggerConfig = proto3.makeMessageType(
  "envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig",
  () => [
    { no: 1, name: "audit_logger", kind: "message", T: TypedExtensionConfig },
    { no: 2, name: "is_optional", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RBAC_AuditLoggingOptions_AuditLoggerConfig"},
);

/**
 * Policy specifies a role and the principals that are assigned/denied the role.
 * A policy matches if and only if at least one of its permissions match the
 * action taking place AND at least one of its principals match the downstream
 * AND the condition is true if specified.
 *
 * @generated from message envoy.config.rbac.v3.Policy
 */
export const Policy = proto3.makeMessageType(
  "envoy.config.rbac.v3.Policy",
  () => [
    { no: 1, name: "permissions", kind: "message", T: Permission, repeated: true },
    { no: 2, name: "principals", kind: "message", T: Principal, repeated: true },
    { no: 3, name: "condition", kind: "message", T: Expr },
    { no: 4, name: "checked_condition", kind: "message", T: CheckedExpr },
  ],
);

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 13]
 *
 * @generated from message envoy.config.rbac.v3.Permission
 */
export const Permission = proto3.makeMessageType(
  "envoy.config.rbac.v3.Permission",
  () => [
    { no: 1, name: "and_rules", kind: "message", T: Permission_Set, oneof: "rule" },
    { no: 2, name: "or_rules", kind: "message", T: Permission_Set, oneof: "rule" },
    { no: 3, name: "any", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 4, name: "header", kind: "message", T: HeaderMatcher, oneof: "rule" },
    { no: 10, name: "url_path", kind: "message", T: PathMatcher, oneof: "rule" },
    { no: 5, name: "destination_ip", kind: "message", T: CidrRange, oneof: "rule" },
    { no: 6, name: "destination_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "rule" },
    { no: 11, name: "destination_port_range", kind: "message", T: Int32Range, oneof: "rule" },
    { no: 7, name: "metadata", kind: "message", T: MetadataMatcher, oneof: "rule" },
    { no: 8, name: "not_rule", kind: "message", T: Permission, oneof: "rule" },
    { no: 9, name: "requested_server_name", kind: "message", T: StringMatcher, oneof: "rule" },
    { no: 12, name: "matcher", kind: "message", T: TypedExtensionConfig, oneof: "rule" },
  ],
);

/**
 * Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v3.Permission.Set
 */
export const Permission_Set = proto3.makeMessageType(
  "envoy.config.rbac.v3.Permission.Set",
  () => [
    { no: 1, name: "rules", kind: "message", T: Permission, repeated: true },
  ],
  {localName: "Permission_Set"},
);

/**
 * Principal defines an identity or a group of identities for a downstream
 * subject.
 * [#next-free-field: 13]
 *
 * @generated from message envoy.config.rbac.v3.Principal
 */
export const Principal = proto3.makeMessageType(
  "envoy.config.rbac.v3.Principal",
  () => [
    { no: 1, name: "and_ids", kind: "message", T: Principal_Set, oneof: "identifier" },
    { no: 2, name: "or_ids", kind: "message", T: Principal_Set, oneof: "identifier" },
    { no: 3, name: "any", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "identifier" },
    { no: 4, name: "authenticated", kind: "message", T: Principal_Authenticated, oneof: "identifier" },
    { no: 5, name: "source_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 10, name: "direct_remote_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 11, name: "remote_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 6, name: "header", kind: "message", T: HeaderMatcher, oneof: "identifier" },
    { no: 9, name: "url_path", kind: "message", T: PathMatcher, oneof: "identifier" },
    { no: 7, name: "metadata", kind: "message", T: MetadataMatcher, oneof: "identifier" },
    { no: 12, name: "filter_state", kind: "message", T: FilterStateMatcher, oneof: "identifier" },
    { no: 8, name: "not_id", kind: "message", T: Principal, oneof: "identifier" },
  ],
);

/**
 * Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
 * Depending on the context, each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v3.Principal.Set
 */
export const Principal_Set = proto3.makeMessageType(
  "envoy.config.rbac.v3.Principal.Set",
  () => [
    { no: 1, name: "ids", kind: "message", T: Principal, repeated: true },
  ],
  {localName: "Principal_Set"},
);

/**
 * Authentication attributes for a downstream.
 *
 * @generated from message envoy.config.rbac.v3.Principal.Authenticated
 */
export const Principal_Authenticated = proto3.makeMessageType(
  "envoy.config.rbac.v3.Principal.Authenticated",
  () => [
    { no: 2, name: "principal_name", kind: "message", T: StringMatcher },
  ],
  {localName: "Principal_Authenticated"},
);

/**
 * Action defines the result of allowance or denial when a request matches the matcher.
 *
 * @generated from message envoy.config.rbac.v3.Action
 */
export const Action = proto3.makeMessageType(
  "envoy.config.rbac.v3.Action",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action", kind: "enum", T: proto3.getEnumType(RBAC_Action) },
  ],
);

