// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/rbac/v3/rbac.proto" (package "envoy.config.rbac.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FilterStateMatcher } from "../../../type/matcher/v3/filter_state";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { MetadataMatcher } from "../../../type/matcher/v3/metadata";
import { Int32Range } from "../../../type/v3/range";
import { CidrRange } from "../../core/v3/address";
import { PathMatcher } from "../../../type/matcher/v3/path";
import { HeaderMatcher } from "../../route/v3/route_components";
import { CheckedExpr } from "../../../../google/api/expr/v1alpha1/checked";
import { Expr } from "../../../../google/api/expr/v1alpha1/syntax";
import { TypedExtensionConfig } from "../../core/v3/extension";
// [#protodoc-title: Role Based Access Control (RBAC)]

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. Requests are allowed or denied based on the ``action`` and whether a matching policy is
 * found. For instance, if the action is ALLOW and a matching policy is found the request should be
 * allowed.
 *
 * RBAC can also be used to make access logging decisions by communicating with access loggers
 * through dynamic metadata. When the action is LOG and at least one policy matches, the
 * ``access_log_hint`` value in the shared key namespace 'envoy.common' is set to ``true`` indicating
 * the request should be logged.
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account ``cluster.local/ns/default/sa/admin`` has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read (``GET``) the service at paths with prefix ``/products``, so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header:
 *                     name: ":method"
 *                     string_match:
 *                       exact: "GET"
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 *
 *
 * @generated from protobuf message envoy.config.rbac.v3.RBAC
 */
export interface RBAC {
    /**
     * The action to take if a policy matches. Every action either allows or denies a request,
     * and can also carry out action-specific operations.
     *
     * Actions:
     *
     *  * ``ALLOW``: Allows the request if and only if there is a policy that matches
     *    the request.
     *  * ``DENY``: Allows the request if and only if there are no policies that
     *    match the request.
     *  * ``LOG``: Allows all requests. If at least one policy matches, the dynamic
     *    metadata key ``access_log_hint`` is set to the value ``true`` under the shared
     *    key namespace ``envoy.common``. If no policies match, it is set to ``false``.
     *    Other actions do not modify this key.
     *
     *
     * @generated from protobuf field: envoy.config.rbac.v3.RBAC.Action action = 1;
     */
    action: RBAC_Action;
    /**
     * Maps from policy name to policy. A match occurs when at least one policy matches the request.
     * The policies are evaluated in lexicographic order of the policy name.
     *
     * @generated from protobuf field: map<string, envoy.config.rbac.v3.Policy> policies = 2;
     */
    policies: {
        [key: string]: Policy;
    };
    /**
     * Audit logging options that include the condition for audit logging to happen
     * and audit logger configurations.
     *
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.config.rbac.v3.RBAC.AuditLoggingOptions audit_logging_options = 3;
     */
    auditLoggingOptions?: RBAC_AuditLoggingOptions;
}
/**
 * @generated from protobuf message envoy.config.rbac.v3.RBAC.AuditLoggingOptions
 */
export interface RBAC_AuditLoggingOptions {
    /**
     * Condition for the audit logging to happen.
     * If this condition is met, all the audit loggers configured here will be invoked.
     *
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition audit_condition = 1;
     */
    auditCondition: RBAC_AuditLoggingOptions_AuditCondition;
    /**
     * Configurations for RBAC-based authorization audit loggers.
     *
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig logger_configs = 2;
     */
    loggerConfigs: RBAC_AuditLoggingOptions_AuditLoggerConfig[];
}
/**
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig
 */
export interface RBAC_AuditLoggingOptions_AuditLoggerConfig {
    /**
     * Typed logger configuration.
     *
     * [#extension-category: envoy.rbac.audit_loggers]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig audit_logger = 1;
     */
    auditLogger?: TypedExtensionConfig;
    /**
     * If true, when the logger is not supported, the data plane will not NACK but simply ignore it.
     *
     * @generated from protobuf field: bool is_optional = 2;
     */
    isOptional: boolean;
}
/**
 * Deny and allow here refer to RBAC decisions, not actions.
 *
 * @generated from protobuf enum envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition
 */
export enum RBAC_AuditLoggingOptions_AuditCondition {
    /**
     * Never audit.
     *
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * Audit when RBAC denies the request.
     *
     * @generated from protobuf enum value: ON_DENY = 1;
     */
    ON_DENY = 1,
    /**
     * Audit when RBAC allows the request.
     *
     * @generated from protobuf enum value: ON_ALLOW = 2;
     */
    ON_ALLOW = 2,
    /**
     * Audit whether RBAC allows or denies the request.
     *
     * @generated from protobuf enum value: ON_DENY_AND_ALLOW = 3;
     */
    ON_DENY_AND_ALLOW = 3
}
/**
 * Should we do safe-list or block-list style access control?
 *
 * @generated from protobuf enum envoy.config.rbac.v3.RBAC.Action
 */
export enum RBAC_Action {
    /**
     * The policies grant access to principals. The rest are denied. This is safe-list style
     * access control. This is the default type.
     *
     * @generated from protobuf enum value: ALLOW = 0;
     */
    ALLOW = 0,
    /**
     * The policies deny access to principals. The rest are allowed. This is block-list style
     * access control.
     *
     * @generated from protobuf enum value: DENY = 1;
     */
    DENY = 1,
    /**
     * The policies set the ``access_log_hint`` dynamic metadata key based on if requests match.
     * All requests are allowed.
     *
     * @generated from protobuf enum value: LOG = 2;
     */
    LOG = 2
}
/**
 * Policy specifies a role and the principals that are assigned/denied the role.
 * A policy matches if and only if at least one of its permissions match the
 * action taking place AND at least one of its principals match the downstream
 * AND the condition is true if specified.
 *
 * @generated from protobuf message envoy.config.rbac.v3.Policy
 */
export interface Policy {
    /**
     * Required. The set of permissions that define a role. Each permission is
     * matched with OR semantics. To match all actions for this policy, a single
     * Permission with the ``any`` field set to true should be used.
     *
     * @generated from protobuf field: repeated envoy.config.rbac.v3.Permission permissions = 1;
     */
    permissions: Permission[];
    /**
     * Required. The set of principals that are assigned/denied the role based on
     * “action”. Each principal is matched with OR semantics. To match all
     * downstreams for this policy, a single Principal with the ``any`` field set to
     * true should be used.
     *
     * @generated from protobuf field: repeated envoy.config.rbac.v3.Principal principals = 2;
     */
    principals: Principal[];
    /**
     * An optional symbolic expression specifying an access control
     * :ref:`condition <arch_overview_condition>`. The condition is combined
     * with the permissions and the principals as a clause with AND semantics.
     * Only be used when checked_condition is not used.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr condition = 3;
     */
    condition?: Expr;
    /**
     * [#not-implemented-hide:]
     * An optional symbolic expression that has been successfully type checked.
     * Only be used when condition is not used.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.CheckedExpr checked_condition = 4;
     */
    checkedCondition?: CheckedExpr;
}
/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.config.rbac.v3.Permission
 */
export interface Permission {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "andRules";
        /**
         * A set of rules that all must match in order to define the action.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Permission.Set and_rules = 1;
         */
        andRules: Permission_Set;
    } | {
        oneofKind: "orRules";
        /**
         * A set of rules where at least one must match in order to define the action.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Permission.Set or_rules = 2;
         */
        orRules: Permission_Set;
    } | {
        oneofKind: "any";
        /**
         * When any is set, it matches any action.
         *
         * @generated from protobuf field: bool any = 3;
         */
        any: boolean;
    } | {
        oneofKind: "header";
        /**
         * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
         * available for HTTP request.
         * Note: the pseudo-header :path includes the query and fragment string. Use the ``url_path``
         * field if you want to match the URL path without the query and fragment string.
         *
         * @generated from protobuf field: envoy.config.route.v3.HeaderMatcher header = 4;
         */
        header: HeaderMatcher;
    } | {
        oneofKind: "urlPath";
        /**
         * A URL path on the incoming HTTP request. Only available for HTTP.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.PathMatcher url_path = 10;
         */
        urlPath: PathMatcher;
    } | {
        oneofKind: "destinationIp";
        /**
         * A CIDR block that describes the destination IP.
         *
         * @generated from protobuf field: envoy.config.core.v3.CidrRange destination_ip = 5;
         */
        destinationIp: CidrRange;
    } | {
        oneofKind: "destinationPort";
        /**
         * A port number that describes the destination port connecting to.
         *
         * @generated from protobuf field: uint32 destination_port = 6;
         */
        destinationPort: number;
    } | {
        oneofKind: "destinationPortRange";
        /**
         * A port number range that describes a range of destination ports connecting to.
         *
         * @generated from protobuf field: envoy.type.v3.Int32Range destination_port_range = 11;
         */
        destinationPortRange: Int32Range;
    } | {
        oneofKind: "metadata";
        /**
         * Metadata that describes additional information about the action.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.MetadataMatcher metadata = 7;
         */
        metadata: MetadataMatcher;
    } | {
        oneofKind: "notRule";
        /**
         * Negates matching the provided permission. For instance, if the value of
         * ``not_rule`` would match, this permission would not match. Conversely, if
         * the value of ``not_rule`` would not match, this permission would match.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Permission not_rule = 8;
         */
        notRule: Permission;
    } | {
        oneofKind: "requestedServerName";
        /**
         * The request server from the client's connection request. This is
         * typically TLS SNI.
         *
         * .. attention::
         *
         *   The behavior of this field may be affected by how Envoy is configured
         *   as explained below.
         *
         *   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
         *     filter is not added, and if a ``FilterChainMatch`` is not defined for
         *     the :ref:`server name
         *     <envoy_v3_api_field_config.listener.v3.FilterChainMatch.server_names>`,
         *     a TLS connection's requested SNI server name will be treated as if it
         *     wasn't present.
         *
         *   * A :ref:`listener filter <arch_overview_listener_filters>` may
         *     overwrite a connection's requested server name within Envoy.
         *
         * Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
         * setup SNI.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher requested_server_name = 9;
         */
        requestedServerName: StringMatcher;
    } | {
        oneofKind: "matcher";
        /**
         * Extension for configuring custom matchers for RBAC.
         * [#extension-category: envoy.rbac.matchers]
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig matcher = 12;
         */
        matcher: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Used in the ``and_rules`` and ``or_rules`` fields in the ``rule`` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from protobuf message envoy.config.rbac.v3.Permission.Set
 */
export interface Permission_Set {
    /**
     * @generated from protobuf field: repeated envoy.config.rbac.v3.Permission rules = 1;
     */
    rules: Permission[];
}
/**
 * Principal defines an identity or a group of identities for a downstream
 * subject.
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.config.rbac.v3.Principal
 */
export interface Principal {
    /**
     * @generated from protobuf oneof: identifier
     */
    identifier: {
        oneofKind: "andIds";
        /**
         * A set of identifiers that all must match in order to define the
         * downstream.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Principal.Set and_ids = 1;
         */
        andIds: Principal_Set;
    } | {
        oneofKind: "orIds";
        /**
         * A set of identifiers at least one must match in order to define the
         * downstream.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Principal.Set or_ids = 2;
         */
        orIds: Principal_Set;
    } | {
        oneofKind: "any";
        /**
         * When any is set, it matches any downstream.
         *
         * @generated from protobuf field: bool any = 3;
         */
        any: boolean;
    } | {
        oneofKind: "authenticated";
        /**
         * Authenticated attributes that identify the downstream.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Principal.Authenticated authenticated = 4;
         */
        authenticated: Principal_Authenticated;
    } | {
        oneofKind: "sourceIp";
        /**
         * A CIDR block that describes the downstream IP.
         * This address will honor proxy protocol, but will not honor XFF.
         *
         * This field is deprecated; either use :ref:`remote_ip
         * <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` for the same
         * behavior, or use
         * :ref:`direct_remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`.
         *
         * @deprecated
         * @generated from protobuf field: envoy.config.core.v3.CidrRange source_ip = 5 [deprecated = true];
         */
        sourceIp: CidrRange;
    } | {
        oneofKind: "directRemoteIp";
        /**
         * A CIDR block that describes the downstream remote/origin address.
         * Note: This is always the physical peer even if the
         * :ref:`remote_ip <envoy_v3_api_field_config.rbac.v3.Principal.remote_ip>` is
         * inferred from for example the x-forwarder-for header, proxy protocol,
         * etc.
         *
         * @generated from protobuf field: envoy.config.core.v3.CidrRange direct_remote_ip = 10;
         */
        directRemoteIp: CidrRange;
    } | {
        oneofKind: "remoteIp";
        /**
         * A CIDR block that describes the downstream remote/origin address.
         * Note: This may not be the physical peer and could be different from the
         * :ref:`direct_remote_ip
         * <envoy_v3_api_field_config.rbac.v3.Principal.direct_remote_ip>`. E.g, if the
         * remote ip is inferred from for example the x-forwarder-for header, proxy
         * protocol, etc.
         *
         * @generated from protobuf field: envoy.config.core.v3.CidrRange remote_ip = 11;
         */
        remoteIp: CidrRange;
    } | {
        oneofKind: "header";
        /**
         * A header (or pseudo-header such as :path or :method) on the incoming HTTP
         * request. Only available for HTTP request. Note: the pseudo-header :path
         * includes the query and fragment string. Use the ``url_path`` field if you
         * want to match the URL path without the query and fragment string.
         *
         * @generated from protobuf field: envoy.config.route.v3.HeaderMatcher header = 6;
         */
        header: HeaderMatcher;
    } | {
        oneofKind: "urlPath";
        /**
         * A URL path on the incoming HTTP request. Only available for HTTP.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.PathMatcher url_path = 9;
         */
        urlPath: PathMatcher;
    } | {
        oneofKind: "metadata";
        /**
         * Metadata that describes additional information about the principal.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.MetadataMatcher metadata = 7;
         */
        metadata: MetadataMatcher;
    } | {
        oneofKind: "filterState";
        /**
         * Identifies the principal using a filter state object.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.FilterStateMatcher filter_state = 12;
         */
        filterState: FilterStateMatcher;
    } | {
        oneofKind: "notId";
        /**
         * Negates matching the provided principal. For instance, if the value of
         * ``not_id`` would match, this principal would not match. Conversely, if the
         * value of ``not_id`` would not match, this principal would match.
         *
         * @generated from protobuf field: envoy.config.rbac.v3.Principal not_id = 8;
         */
        notId: Principal;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Used in the ``and_ids`` and ``or_ids`` fields in the ``identifier`` oneof.
 * Depending on the context, each are applied with the associated behavior.
 *
 * @generated from protobuf message envoy.config.rbac.v3.Principal.Set
 */
export interface Principal_Set {
    /**
     * @generated from protobuf field: repeated envoy.config.rbac.v3.Principal ids = 1;
     */
    ids: Principal[];
}
/**
 * Authentication attributes for a downstream.
 *
 * @generated from protobuf message envoy.config.rbac.v3.Principal.Authenticated
 */
export interface Principal_Authenticated {
    /**
     * The name of the principal. If set, The URI SAN or DNS SAN in that order
     * is used from the certificate, otherwise the subject field is used. If
     * unset, it applies to any user that is authenticated.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher principal_name = 2;
     */
    principalName?: StringMatcher;
}
/**
 * Action defines the result of allowance or denial when a request matches the matcher.
 *
 * @generated from protobuf message envoy.config.rbac.v3.Action
 */
export interface Action {
    /**
     * The name indicates the policy name.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The action to take if the matcher matches. Every action either allows or denies a request,
     * and can also carry out action-specific operations.
     *
     * Actions:
     *
     *  * ``ALLOW``: If the request gets matched on ALLOW, it is permitted.
     *  * ``DENY``: If the request gets matched on DENY, it is not permitted.
     *  * ``LOG``: If the request gets matched on LOG, it is permitted. Besides, the
     *    dynamic metadata key ``access_log_hint`` under the shared key namespace
     *    ``envoy.common`` will be set to the value ``true``.
     *  * If the request cannot get matched, it will fallback to ``DENY``.
     *
     * Log behavior:
     *
     *  If the RBAC matcher contains at least one LOG action, the dynamic
     *  metadata key ``access_log_hint`` will be set based on if the request
     *  get matched on the LOG action.
     *
     *
     * @generated from protobuf field: envoy.config.rbac.v3.RBAC.Action action = 2;
     */
    action: RBAC_Action;
}
// @generated message type with reflection information, may provide speed optimized methods
class RBAC$Type extends MessageType<RBAC> {
    constructor() {
        super("envoy.config.rbac.v3.RBAC", [
            { no: 1, name: "action", kind: "enum", T: () => ["envoy.config.rbac.v3.RBAC.Action", RBAC_Action], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "policies", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Policy } },
            { no: 3, name: "audit_logging_options", kind: "message", T: () => RBAC_AuditLoggingOptions }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.RBAC" } });
    }
    create(value?: PartialMessage<RBAC>): RBAC {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = 0;
        message.policies = {};
        if (value !== undefined)
            reflectionMergePartial<RBAC>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RBAC): RBAC {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.rbac.v3.RBAC.Action action */ 1:
                    message.action = reader.int32();
                    break;
                case /* map<string, envoy.config.rbac.v3.Policy> policies */ 2:
                    this.binaryReadMap2(message.policies, reader, options);
                    break;
                case /* envoy.config.rbac.v3.RBAC.AuditLoggingOptions audit_logging_options */ 3:
                    message.auditLoggingOptions = RBAC_AuditLoggingOptions.internalBinaryRead(reader, reader.uint32(), options, message.auditLoggingOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: RBAC["policies"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RBAC["policies"] | undefined, val: RBAC["policies"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Policy.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.rbac.v3.RBAC.policies");
            }
        }
        map[key ?? ""] = val ?? Policy.create();
    }
    internalBinaryWrite(message: RBAC, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.rbac.v3.RBAC.Action action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        /* map<string, envoy.config.rbac.v3.Policy> policies = 2; */
        for (let k of globalThis.Object.keys(message.policies)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Policy.internalBinaryWrite(message.policies[k], writer, options);
            writer.join().join();
        }
        /* envoy.config.rbac.v3.RBAC.AuditLoggingOptions audit_logging_options = 3; */
        if (message.auditLoggingOptions)
            RBAC_AuditLoggingOptions.internalBinaryWrite(message.auditLoggingOptions, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.RBAC
 */
export const RBAC = new RBAC$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RBAC_AuditLoggingOptions$Type extends MessageType<RBAC_AuditLoggingOptions> {
    constructor() {
        super("envoy.config.rbac.v3.RBAC.AuditLoggingOptions", [
            { no: 1, name: "audit_condition", kind: "enum", T: () => ["envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition", RBAC_AuditLoggingOptions_AuditCondition], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "logger_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RBAC_AuditLoggingOptions_AuditLoggerConfig }
        ]);
    }
    create(value?: PartialMessage<RBAC_AuditLoggingOptions>): RBAC_AuditLoggingOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.auditCondition = 0;
        message.loggerConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<RBAC_AuditLoggingOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RBAC_AuditLoggingOptions): RBAC_AuditLoggingOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition audit_condition */ 1:
                    message.auditCondition = reader.int32();
                    break;
                case /* repeated envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig logger_configs */ 2:
                    message.loggerConfigs.push(RBAC_AuditLoggingOptions_AuditLoggerConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RBAC_AuditLoggingOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditCondition audit_condition = 1; */
        if (message.auditCondition !== 0)
            writer.tag(1, WireType.Varint).int32(message.auditCondition);
        /* repeated envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig logger_configs = 2; */
        for (let i = 0; i < message.loggerConfigs.length; i++)
            RBAC_AuditLoggingOptions_AuditLoggerConfig.internalBinaryWrite(message.loggerConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.RBAC.AuditLoggingOptions
 */
export const RBAC_AuditLoggingOptions = new RBAC_AuditLoggingOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RBAC_AuditLoggingOptions_AuditLoggerConfig$Type extends MessageType<RBAC_AuditLoggingOptions_AuditLoggerConfig> {
    constructor() {
        super("envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig", [
            { no: 1, name: "audit_logger", kind: "message", T: () => TypedExtensionConfig },
            { no: 2, name: "is_optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RBAC_AuditLoggingOptions_AuditLoggerConfig>): RBAC_AuditLoggingOptions_AuditLoggerConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isOptional = false;
        if (value !== undefined)
            reflectionMergePartial<RBAC_AuditLoggingOptions_AuditLoggerConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RBAC_AuditLoggingOptions_AuditLoggerConfig): RBAC_AuditLoggingOptions_AuditLoggerConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig audit_logger */ 1:
                    message.auditLogger = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.auditLogger);
                    break;
                case /* bool is_optional */ 2:
                    message.isOptional = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RBAC_AuditLoggingOptions_AuditLoggerConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig audit_logger = 1; */
        if (message.auditLogger)
            TypedExtensionConfig.internalBinaryWrite(message.auditLogger, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool is_optional = 2; */
        if (message.isOptional !== false)
            writer.tag(2, WireType.Varint).bool(message.isOptional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.RBAC.AuditLoggingOptions.AuditLoggerConfig
 */
export const RBAC_AuditLoggingOptions_AuditLoggerConfig = new RBAC_AuditLoggingOptions_AuditLoggerConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Policy$Type extends MessageType<Policy> {
    constructor() {
        super("envoy.config.rbac.v3.Policy", [
            { no: 1, name: "permissions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Permission, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 2, name: "principals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Principal, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 3, name: "condition", kind: "message", T: () => Expr, options: { "udpa.annotations.field_migrate": { oneofPromotion: "expression_specifier" } } },
            { no: 4, name: "checked_condition", kind: "message", T: () => CheckedExpr, options: { "udpa.annotations.field_migrate": { oneofPromotion: "expression_specifier" } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Policy" } });
    }
    create(value?: PartialMessage<Policy>): Policy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permissions = [];
        message.principals = [];
        if (value !== undefined)
            reflectionMergePartial<Policy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Policy): Policy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.rbac.v3.Permission permissions */ 1:
                    message.permissions.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.config.rbac.v3.Principal principals */ 2:
                    message.principals.push(Principal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.api.expr.v1alpha1.Expr condition */ 3:
                    message.condition = Expr.internalBinaryRead(reader, reader.uint32(), options, message.condition);
                    break;
                case /* google.api.expr.v1alpha1.CheckedExpr checked_condition */ 4:
                    message.checkedCondition = CheckedExpr.internalBinaryRead(reader, reader.uint32(), options, message.checkedCondition);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Policy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.rbac.v3.Permission permissions = 1; */
        for (let i = 0; i < message.permissions.length; i++)
            Permission.internalBinaryWrite(message.permissions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.rbac.v3.Principal principals = 2; */
        for (let i = 0; i < message.principals.length; i++)
            Principal.internalBinaryWrite(message.principals[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr condition = 3; */
        if (message.condition)
            Expr.internalBinaryWrite(message.condition, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.CheckedExpr checked_condition = 4; */
        if (message.checkedCondition)
            CheckedExpr.internalBinaryWrite(message.checkedCondition, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Policy
 */
export const Policy = new Policy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Permission$Type extends MessageType<Permission> {
    constructor() {
        super("envoy.config.rbac.v3.Permission", [
            { no: 1, name: "and_rules", kind: "message", oneof: "rule", T: () => Permission_Set },
            { no: 2, name: "or_rules", kind: "message", oneof: "rule", T: () => Permission_Set },
            { no: 3, name: "any", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 4, name: "header", kind: "message", oneof: "rule", T: () => HeaderMatcher },
            { no: 10, name: "url_path", kind: "message", oneof: "rule", T: () => PathMatcher },
            { no: 5, name: "destination_ip", kind: "message", oneof: "rule", T: () => CidrRange },
            { no: 6, name: "destination_port", kind: "scalar", oneof: "rule", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 65535 } } } },
            { no: 11, name: "destination_port_range", kind: "message", oneof: "rule", T: () => Int32Range },
            { no: 7, name: "metadata", kind: "message", oneof: "rule", T: () => MetadataMatcher },
            { no: 8, name: "not_rule", kind: "message", oneof: "rule", T: () => Permission },
            { no: 9, name: "requested_server_name", kind: "message", oneof: "rule", T: () => StringMatcher },
            { no: 12, name: "matcher", kind: "message", oneof: "rule", T: () => TypedExtensionConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Permission" } });
    }
    create(value?: PartialMessage<Permission>): Permission {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Permission>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permission): Permission {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.rbac.v3.Permission.Set and_rules */ 1:
                    message.rule = {
                        oneofKind: "andRules",
                        andRules: Permission_Set.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andRules)
                    };
                    break;
                case /* envoy.config.rbac.v3.Permission.Set or_rules */ 2:
                    message.rule = {
                        oneofKind: "orRules",
                        orRules: Permission_Set.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orRules)
                    };
                    break;
                case /* bool any */ 3:
                    message.rule = {
                        oneofKind: "any",
                        any: reader.bool()
                    };
                    break;
                case /* envoy.config.route.v3.HeaderMatcher header */ 4:
                    message.rule = {
                        oneofKind: "header",
                        header: HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).header)
                    };
                    break;
                case /* envoy.type.matcher.v3.PathMatcher url_path */ 10:
                    message.rule = {
                        oneofKind: "urlPath",
                        urlPath: PathMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).urlPath)
                    };
                    break;
                case /* envoy.config.core.v3.CidrRange destination_ip */ 5:
                    message.rule = {
                        oneofKind: "destinationIp",
                        destinationIp: CidrRange.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).destinationIp)
                    };
                    break;
                case /* uint32 destination_port */ 6:
                    message.rule = {
                        oneofKind: "destinationPort",
                        destinationPort: reader.uint32()
                    };
                    break;
                case /* envoy.type.v3.Int32Range destination_port_range */ 11:
                    message.rule = {
                        oneofKind: "destinationPortRange",
                        destinationPortRange: Int32Range.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).destinationPortRange)
                    };
                    break;
                case /* envoy.type.matcher.v3.MetadataMatcher metadata */ 7:
                    message.rule = {
                        oneofKind: "metadata",
                        metadata: MetadataMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).metadata)
                    };
                    break;
                case /* envoy.config.rbac.v3.Permission not_rule */ 8:
                    message.rule = {
                        oneofKind: "notRule",
                        notRule: Permission.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notRule)
                    };
                    break;
                case /* envoy.type.matcher.v3.StringMatcher requested_server_name */ 9:
                    message.rule = {
                        oneofKind: "requestedServerName",
                        requestedServerName: StringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).requestedServerName)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig matcher */ 12:
                    message.rule = {
                        oneofKind: "matcher",
                        matcher: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).matcher)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.rbac.v3.Permission.Set and_rules = 1; */
        if (message.rule.oneofKind === "andRules")
            Permission_Set.internalBinaryWrite(message.rule.andRules, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.rbac.v3.Permission.Set or_rules = 2; */
        if (message.rule.oneofKind === "orRules")
            Permission_Set.internalBinaryWrite(message.rule.orRules, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool any = 3; */
        if (message.rule.oneofKind === "any")
            writer.tag(3, WireType.Varint).bool(message.rule.any);
        /* envoy.config.route.v3.HeaderMatcher header = 4; */
        if (message.rule.oneofKind === "header")
            HeaderMatcher.internalBinaryWrite(message.rule.header, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.PathMatcher url_path = 10; */
        if (message.rule.oneofKind === "urlPath")
            PathMatcher.internalBinaryWrite(message.rule.urlPath, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.CidrRange destination_ip = 5; */
        if (message.rule.oneofKind === "destinationIp")
            CidrRange.internalBinaryWrite(message.rule.destinationIp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 destination_port = 6; */
        if (message.rule.oneofKind === "destinationPort")
            writer.tag(6, WireType.Varint).uint32(message.rule.destinationPort);
        /* envoy.type.v3.Int32Range destination_port_range = 11; */
        if (message.rule.oneofKind === "destinationPortRange")
            Int32Range.internalBinaryWrite(message.rule.destinationPortRange, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.MetadataMatcher metadata = 7; */
        if (message.rule.oneofKind === "metadata")
            MetadataMatcher.internalBinaryWrite(message.rule.metadata, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.rbac.v3.Permission not_rule = 8; */
        if (message.rule.oneofKind === "notRule")
            Permission.internalBinaryWrite(message.rule.notRule, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.StringMatcher requested_server_name = 9; */
        if (message.rule.oneofKind === "requestedServerName")
            StringMatcher.internalBinaryWrite(message.rule.requestedServerName, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig matcher = 12; */
        if (message.rule.oneofKind === "matcher")
            TypedExtensionConfig.internalBinaryWrite(message.rule.matcher, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Permission
 */
export const Permission = new Permission$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Permission_Set$Type extends MessageType<Permission_Set> {
    constructor() {
        super("envoy.config.rbac.v3.Permission.Set", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Permission, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Permission.Set" } });
    }
    create(value?: PartialMessage<Permission_Set>): Permission_Set {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<Permission_Set>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Permission_Set): Permission_Set {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.rbac.v3.Permission rules */ 1:
                    message.rules.push(Permission.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Permission_Set, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.rbac.v3.Permission rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            Permission.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Permission.Set
 */
export const Permission_Set = new Permission_Set$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Principal$Type extends MessageType<Principal> {
    constructor() {
        super("envoy.config.rbac.v3.Principal", [
            { no: 1, name: "and_ids", kind: "message", oneof: "identifier", T: () => Principal_Set },
            { no: 2, name: "or_ids", kind: "message", oneof: "identifier", T: () => Principal_Set },
            { no: 3, name: "any", kind: "scalar", oneof: "identifier", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 4, name: "authenticated", kind: "message", oneof: "identifier", T: () => Principal_Authenticated },
            { no: 5, name: "source_ip", kind: "message", oneof: "identifier", T: () => CidrRange, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 10, name: "direct_remote_ip", kind: "message", oneof: "identifier", T: () => CidrRange },
            { no: 11, name: "remote_ip", kind: "message", oneof: "identifier", T: () => CidrRange },
            { no: 6, name: "header", kind: "message", oneof: "identifier", T: () => HeaderMatcher },
            { no: 9, name: "url_path", kind: "message", oneof: "identifier", T: () => PathMatcher },
            { no: 7, name: "metadata", kind: "message", oneof: "identifier", T: () => MetadataMatcher },
            { no: 12, name: "filter_state", kind: "message", oneof: "identifier", T: () => FilterStateMatcher },
            { no: 8, name: "not_id", kind: "message", oneof: "identifier", T: () => Principal }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Principal" } });
    }
    create(value?: PartialMessage<Principal>): Principal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.identifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Principal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Principal): Principal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.rbac.v3.Principal.Set and_ids */ 1:
                    message.identifier = {
                        oneofKind: "andIds",
                        andIds: Principal_Set.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).andIds)
                    };
                    break;
                case /* envoy.config.rbac.v3.Principal.Set or_ids */ 2:
                    message.identifier = {
                        oneofKind: "orIds",
                        orIds: Principal_Set.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).orIds)
                    };
                    break;
                case /* bool any */ 3:
                    message.identifier = {
                        oneofKind: "any",
                        any: reader.bool()
                    };
                    break;
                case /* envoy.config.rbac.v3.Principal.Authenticated authenticated */ 4:
                    message.identifier = {
                        oneofKind: "authenticated",
                        authenticated: Principal_Authenticated.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).authenticated)
                    };
                    break;
                case /* envoy.config.core.v3.CidrRange source_ip = 5 [deprecated = true];*/ 5:
                    message.identifier = {
                        oneofKind: "sourceIp",
                        sourceIp: CidrRange.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).sourceIp)
                    };
                    break;
                case /* envoy.config.core.v3.CidrRange direct_remote_ip */ 10:
                    message.identifier = {
                        oneofKind: "directRemoteIp",
                        directRemoteIp: CidrRange.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).directRemoteIp)
                    };
                    break;
                case /* envoy.config.core.v3.CidrRange remote_ip */ 11:
                    message.identifier = {
                        oneofKind: "remoteIp",
                        remoteIp: CidrRange.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).remoteIp)
                    };
                    break;
                case /* envoy.config.route.v3.HeaderMatcher header */ 6:
                    message.identifier = {
                        oneofKind: "header",
                        header: HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).header)
                    };
                    break;
                case /* envoy.type.matcher.v3.PathMatcher url_path */ 9:
                    message.identifier = {
                        oneofKind: "urlPath",
                        urlPath: PathMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).urlPath)
                    };
                    break;
                case /* envoy.type.matcher.v3.MetadataMatcher metadata */ 7:
                    message.identifier = {
                        oneofKind: "metadata",
                        metadata: MetadataMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).metadata)
                    };
                    break;
                case /* envoy.type.matcher.v3.FilterStateMatcher filter_state */ 12:
                    message.identifier = {
                        oneofKind: "filterState",
                        filterState: FilterStateMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).filterState)
                    };
                    break;
                case /* envoy.config.rbac.v3.Principal not_id */ 8:
                    message.identifier = {
                        oneofKind: "notId",
                        notId: Principal.internalBinaryRead(reader, reader.uint32(), options, (message.identifier as any).notId)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Principal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.rbac.v3.Principal.Set and_ids = 1; */
        if (message.identifier.oneofKind === "andIds")
            Principal_Set.internalBinaryWrite(message.identifier.andIds, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.rbac.v3.Principal.Set or_ids = 2; */
        if (message.identifier.oneofKind === "orIds")
            Principal_Set.internalBinaryWrite(message.identifier.orIds, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool any = 3; */
        if (message.identifier.oneofKind === "any")
            writer.tag(3, WireType.Varint).bool(message.identifier.any);
        /* envoy.config.rbac.v3.Principal.Authenticated authenticated = 4; */
        if (message.identifier.oneofKind === "authenticated")
            Principal_Authenticated.internalBinaryWrite(message.identifier.authenticated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.CidrRange source_ip = 5 [deprecated = true]; */
        if (message.identifier.oneofKind === "sourceIp")
            CidrRange.internalBinaryWrite(message.identifier.sourceIp, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.CidrRange direct_remote_ip = 10; */
        if (message.identifier.oneofKind === "directRemoteIp")
            CidrRange.internalBinaryWrite(message.identifier.directRemoteIp, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.CidrRange remote_ip = 11; */
        if (message.identifier.oneofKind === "remoteIp")
            CidrRange.internalBinaryWrite(message.identifier.remoteIp, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.route.v3.HeaderMatcher header = 6; */
        if (message.identifier.oneofKind === "header")
            HeaderMatcher.internalBinaryWrite(message.identifier.header, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.PathMatcher url_path = 9; */
        if (message.identifier.oneofKind === "urlPath")
            PathMatcher.internalBinaryWrite(message.identifier.urlPath, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.MetadataMatcher metadata = 7; */
        if (message.identifier.oneofKind === "metadata")
            MetadataMatcher.internalBinaryWrite(message.identifier.metadata, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.FilterStateMatcher filter_state = 12; */
        if (message.identifier.oneofKind === "filterState")
            FilterStateMatcher.internalBinaryWrite(message.identifier.filterState, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.rbac.v3.Principal not_id = 8; */
        if (message.identifier.oneofKind === "notId")
            Principal.internalBinaryWrite(message.identifier.notId, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Principal
 */
export const Principal = new Principal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Principal_Set$Type extends MessageType<Principal_Set> {
    constructor() {
        super("envoy.config.rbac.v3.Principal.Set", [
            { no: 1, name: "ids", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Principal, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Principal.Set" } });
    }
    create(value?: PartialMessage<Principal_Set>): Principal_Set {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<Principal_Set>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Principal_Set): Principal_Set {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.rbac.v3.Principal ids */ 1:
                    message.ids.push(Principal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Principal_Set, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.rbac.v3.Principal ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            Principal.internalBinaryWrite(message.ids[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Principal.Set
 */
export const Principal_Set = new Principal_Set$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Principal_Authenticated$Type extends MessageType<Principal_Authenticated> {
    constructor() {
        super("envoy.config.rbac.v3.Principal.Authenticated", [
            { no: 2, name: "principal_name", kind: "message", T: () => StringMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.rbac.v2.Principal.Authenticated" } });
    }
    create(value?: PartialMessage<Principal_Authenticated>): Principal_Authenticated {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Principal_Authenticated>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Principal_Authenticated): Principal_Authenticated {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.v3.StringMatcher principal_name */ 2:
                    message.principalName = StringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.principalName);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Principal_Authenticated, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.v3.StringMatcher principal_name = 2; */
        if (message.principalName)
            StringMatcher.internalBinaryWrite(message.principalName, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Principal.Authenticated
 */
export const Principal_Authenticated = new Principal_Authenticated$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Action$Type extends MessageType<Action> {
    constructor() {
        super("envoy.config.rbac.v3.Action", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "action", kind: "enum", T: () => ["envoy.config.rbac.v3.RBAC.Action", RBAC_Action] }
        ]);
    }
    create(value?: PartialMessage<Action>): Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.action = 0;
        if (value !== undefined)
            reflectionMergePartial<Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Action): Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.config.rbac.v3.RBAC.Action action */ 2:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.config.rbac.v3.RBAC.Action action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.rbac.v3.Action
 */
export const Action = new Action$Type();
