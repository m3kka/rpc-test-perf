// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/rbac/v2/rbac.proto (package envoy.config.rbac.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Expr } from "../../../../google/api/expr/v1alpha1/syntax_pb.js";
import type { HeaderMatcher } from "../../../api/v2/route/route_components_pb.js";
import type { PathMatcher } from "../../../type/matcher/path_pb.js";
import type { CidrRange } from "../../../api/v2/core/address_pb.js";
import type { MetadataMatcher } from "../../../type/matcher/metadata_pb.js";
import type { StringMatcher } from "../../../type/matcher/string_pb.js";

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. RBAC policies are additive. The policies are examined in order. A request is allowed
 * once a matching policy is found (suppose the `action` is ALLOW).
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read ("GET") the service at paths with prefix "/products", so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header: { name: ":method", exact_match: "GET" }
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 *
 *
 * @generated from message envoy.config.rbac.v2.RBAC
 */
export declare class RBAC extends Message<RBAC> {
  /**
   * The action to take if a policy matches. The request is allowed if and only if:
   *
   *   * `action` is "ALLOWED" and at least one policy matches
   *   * `action` is "DENY" and none of the policies match
   *
   * @generated from field: envoy.config.rbac.v2.RBAC.Action action = 1;
   */
  action: RBAC_Action;

  /**
   * Maps from policy name to policy. A match occurs when at least one policy matches the request.
   *
   * @generated from field: map<string, envoy.config.rbac.v2.Policy> policies = 2;
   */
  policies: { [key: string]: Policy };

  constructor(data?: PartialMessage<RBAC>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.RBAC";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RBAC;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RBAC;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RBAC;

  static equals(a: RBAC | PlainMessage<RBAC> | undefined, b: RBAC | PlainMessage<RBAC> | undefined): boolean;
}

/**
 * Should we do safe-list or block-list style access control?
 *
 * @generated from enum envoy.config.rbac.v2.RBAC.Action
 */
export declare enum RBAC_Action {
  /**
   * The policies grant access to principals. The rest is denied. This is safe-list style
   * access control. This is the default type.
   *
   * @generated from enum value: ALLOW = 0;
   */
  ALLOW = 0,

  /**
   * The policies deny access to principals. The rest is allowed. This is block-list style
   * access control.
   *
   * @generated from enum value: DENY = 1;
   */
  DENY = 1,
}

/**
 * Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
 * and only if at least one of its permissions match the action taking place AND at least one of its
 * principals match the downstream AND the condition is true if specified.
 *
 * @generated from message envoy.config.rbac.v2.Policy
 */
export declare class Policy extends Message<Policy> {
  /**
   * Required. The set of permissions that define a role. Each permission is matched with OR
   * semantics. To match all actions for this policy, a single Permission with the `any` field set
   * to true should be used.
   *
   * @generated from field: repeated envoy.config.rbac.v2.Permission permissions = 1;
   */
  permissions: Permission[];

  /**
   * Required. The set of principals that are assigned/denied the role based on “action”. Each
   * principal is matched with OR semantics. To match all downstreams for this policy, a single
   * Principal with the `any` field set to true should be used.
   *
   * @generated from field: repeated envoy.config.rbac.v2.Principal principals = 2;
   */
  principals: Principal[];

  /**
   * An optional symbolic expression specifying an access control
   * :ref:`condition <arch_overview_condition>`. The condition is combined
   * with the permissions and the principals as a clause with AND semantics.
   *
   * @generated from field: google.api.expr.v1alpha1.Expr condition = 3;
   */
  condition?: Expr;

  constructor(data?: PartialMessage<Policy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Policy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Policy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Policy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Policy;

  static equals(a: Policy | PlainMessage<Policy> | undefined, b: Policy | PlainMessage<Policy> | undefined): boolean;
}

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.rbac.v2.Permission
 */
export declare class Permission extends Message<Permission> {
  /**
   * @generated from oneof envoy.config.rbac.v2.Permission.rule
   */
  rule: {
    /**
     * A set of rules that all must match in order to define the action.
     *
     * @generated from field: envoy.config.rbac.v2.Permission.Set and_rules = 1;
     */
    value: Permission_Set;
    case: "andRules";
  } | {
    /**
     * A set of rules where at least one must match in order to define the action.
     *
     * @generated from field: envoy.config.rbac.v2.Permission.Set or_rules = 2;
     */
    value: Permission_Set;
    case: "orRules";
  } | {
    /**
     * When any is set, it matches any action.
     *
     * @generated from field: bool any = 3;
     */
    value: boolean;
    case: "any";
  } | {
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
     * available for HTTP request.
     * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
     * field if you want to match the URL path without the query and fragment string.
     *
     * @generated from field: envoy.api.v2.route.HeaderMatcher header = 4;
     */
    value: HeaderMatcher;
    case: "header";
  } | {
    /**
     * A URL path on the incoming HTTP request. Only available for HTTP.
     *
     * @generated from field: envoy.type.matcher.PathMatcher url_path = 10;
     */
    value: PathMatcher;
    case: "urlPath";
  } | {
    /**
     * A CIDR block that describes the destination IP.
     *
     * @generated from field: envoy.api.v2.core.CidrRange destination_ip = 5;
     */
    value: CidrRange;
    case: "destinationIp";
  } | {
    /**
     * A port number that describes the destination port connecting to.
     *
     * @generated from field: uint32 destination_port = 6;
     */
    value: number;
    case: "destinationPort";
  } | {
    /**
     * Metadata that describes additional information about the action.
     *
     * @generated from field: envoy.type.matcher.MetadataMatcher metadata = 7;
     */
    value: MetadataMatcher;
    case: "metadata";
  } | {
    /**
     * Negates matching the provided permission. For instance, if the value of `not_rule` would
     * match, this permission would not match. Conversely, if the value of `not_rule` would not
     * match, this permission would match.
     *
     * @generated from field: envoy.config.rbac.v2.Permission not_rule = 8;
     */
    value: Permission;
    case: "notRule";
  } | {
    /**
     * The request server from the client's connection request. This is
     * typically TLS SNI.
     *
     * .. attention::
     *
     *   The behavior of this field may be affected by how Envoy is configured
     *   as explained below.
     *
     *   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
     *     filter is not added, and if a `FilterChainMatch` is not defined for
     *     the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
     *     a TLS connection's requested SNI server name will be treated as if it
     *     wasn't present.
     *
     *   * A :ref:`listener filter <arch_overview_listener_filters>` may
     *     overwrite a connection's requested server name within Envoy.
     *
     * Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
     * setup SNI.
     *
     * @generated from field: envoy.type.matcher.StringMatcher requested_server_name = 9;
     */
    value: StringMatcher;
    case: "requestedServerName";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Permission>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Permission";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Permission;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Permission;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Permission;

  static equals(a: Permission | PlainMessage<Permission> | undefined, b: Permission | PlainMessage<Permission> | undefined): boolean;
}

/**
 * Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v2.Permission.Set
 */
export declare class Permission_Set extends Message<Permission_Set> {
  /**
   * @generated from field: repeated envoy.config.rbac.v2.Permission rules = 1;
   */
  rules: Permission[];

  constructor(data?: PartialMessage<Permission_Set>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Permission.Set";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Permission_Set;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Permission_Set;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Permission_Set;

  static equals(a: Permission_Set | PlainMessage<Permission_Set> | undefined, b: Permission_Set | PlainMessage<Permission_Set> | undefined): boolean;
}

/**
 * Principal defines an identity or a group of identities for a downstream subject.
 * [#next-free-field: 12]
 *
 * @generated from message envoy.config.rbac.v2.Principal
 */
export declare class Principal extends Message<Principal> {
  /**
   * @generated from oneof envoy.config.rbac.v2.Principal.identifier
   */
  identifier: {
    /**
     * A set of identifiers that all must match in order to define the downstream.
     *
     * @generated from field: envoy.config.rbac.v2.Principal.Set and_ids = 1;
     */
    value: Principal_Set;
    case: "andIds";
  } | {
    /**
     * A set of identifiers at least one must match in order to define the downstream.
     *
     * @generated from field: envoy.config.rbac.v2.Principal.Set or_ids = 2;
     */
    value: Principal_Set;
    case: "orIds";
  } | {
    /**
     * When any is set, it matches any downstream.
     *
     * @generated from field: bool any = 3;
     */
    value: boolean;
    case: "any";
  } | {
    /**
     * Authenticated attributes that identify the downstream.
     *
     * @generated from field: envoy.config.rbac.v2.Principal.Authenticated authenticated = 4;
     */
    value: Principal_Authenticated;
    case: "authenticated";
  } | {
    /**
     * A CIDR block that describes the downstream IP.
     * This address will honor proxy protocol, but will not honor XFF.
     *
     * @generated from field: envoy.api.v2.core.CidrRange source_ip = 5 [deprecated = true];
     * @deprecated
     */
    value: CidrRange;
    case: "sourceIp";
  } | {
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This is always the physical peer even if the
     * :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
     * from for example the x-forwarder-for header, proxy protocol, etc.
     *
     * @generated from field: envoy.api.v2.core.CidrRange direct_remote_ip = 10;
     */
    value: CidrRange;
    case: "directRemoteIp";
  } | {
    /**
     * A CIDR block that describes the downstream remote/origin address.
     * Note: This may not be the physical peer and could be different from the
     * :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
     * E.g, if the remote ip is inferred from for example the x-forwarder-for header,
     * proxy protocol, etc.
     *
     * @generated from field: envoy.api.v2.core.CidrRange remote_ip = 11;
     */
    value: CidrRange;
    case: "remoteIp";
  } | {
    /**
     * A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
     * available for HTTP request.
     * Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
     * field if you want to match the URL path without the query and fragment string.
     *
     * @generated from field: envoy.api.v2.route.HeaderMatcher header = 6;
     */
    value: HeaderMatcher;
    case: "header";
  } | {
    /**
     * A URL path on the incoming HTTP request. Only available for HTTP.
     *
     * @generated from field: envoy.type.matcher.PathMatcher url_path = 9;
     */
    value: PathMatcher;
    case: "urlPath";
  } | {
    /**
     * Metadata that describes additional information about the principal.
     *
     * @generated from field: envoy.type.matcher.MetadataMatcher metadata = 7;
     */
    value: MetadataMatcher;
    case: "metadata";
  } | {
    /**
     * Negates matching the provided principal. For instance, if the value of `not_id` would match,
     * this principal would not match. Conversely, if the value of `not_id` would not match, this
     * principal would match.
     *
     * @generated from field: envoy.config.rbac.v2.Principal not_id = 8;
     */
    value: Principal;
    case: "notId";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Principal>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Principal";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Principal;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Principal;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Principal;

  static equals(a: Principal | PlainMessage<Principal> | undefined, b: Principal | PlainMessage<Principal> | undefined): boolean;
}

/**
 * Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v2.Principal.Set
 */
export declare class Principal_Set extends Message<Principal_Set> {
  /**
   * @generated from field: repeated envoy.config.rbac.v2.Principal ids = 1;
   */
  ids: Principal[];

  constructor(data?: PartialMessage<Principal_Set>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Principal.Set";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Principal_Set;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Principal_Set;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Principal_Set;

  static equals(a: Principal_Set | PlainMessage<Principal_Set> | undefined, b: Principal_Set | PlainMessage<Principal_Set> | undefined): boolean;
}

/**
 * Authentication attributes for a downstream.
 *
 * @generated from message envoy.config.rbac.v2.Principal.Authenticated
 */
export declare class Principal_Authenticated extends Message<Principal_Authenticated> {
  /**
   * The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
   * certificate, otherwise the subject field is used. If unset, it applies to any user that is
   * authenticated.
   *
   * @generated from field: envoy.type.matcher.StringMatcher principal_name = 2;
   */
  principalName?: StringMatcher;

  constructor(data?: PartialMessage<Principal_Authenticated>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.rbac.v2.Principal.Authenticated";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Principal_Authenticated;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Principal_Authenticated;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Principal_Authenticated;

  static equals(a: Principal_Authenticated | PlainMessage<Principal_Authenticated> | undefined, b: Principal_Authenticated | PlainMessage<Principal_Authenticated> | undefined): boolean;
}

