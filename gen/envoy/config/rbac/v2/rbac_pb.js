// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/rbac/v2/rbac.proto (package envoy.config.rbac.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { Expr } from "../../../../google/api/expr/v1alpha1/syntax_pb.js";
import { HeaderMatcher } from "../../../api/v2/route/route_components_pb.js";
import { PathMatcher } from "../../../type/matcher/path_pb.js";
import { CidrRange } from "../../../api/v2/core/address_pb.js";
import { MetadataMatcher } from "../../../type/matcher/metadata_pb.js";
import { StringMatcher } from "../../../type/matcher/string_pb.js";

/**
 * Role Based Access Control (RBAC) provides service-level and method-level access control for a
 * service. RBAC policies are additive. The policies are examined in order. A request is allowed
 * once a matching policy is found (suppose the `action` is ALLOW).
 *
 * Here is an example of RBAC configuration. It has two policies:
 *
 * * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
 *   does "cluster.local/ns/default/sa/superuser".
 *
 * * Any user can read ("GET") the service at paths with prefix "/products", so long as the
 *   destination port is either 80 or 443.
 *
 *  .. code-block:: yaml
 *
 *   action: ALLOW
 *   policies:
 *     "service-admin":
 *       permissions:
 *         - any: true
 *       principals:
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/admin"
 *         - authenticated:
 *             principal_name:
 *               exact: "cluster.local/ns/default/sa/superuser"
 *     "product-viewer":
 *       permissions:
 *           - and_rules:
 *               rules:
 *                 - header: { name: ":method", exact_match: "GET" }
 *                 - url_path:
 *                     path: { prefix: "/products" }
 *                 - or_rules:
 *                     rules:
 *                       - destination_port: 80
 *                       - destination_port: 443
 *       principals:
 *         - any: true
 *
 *
 * @generated from message envoy.config.rbac.v2.RBAC
 */
export const RBAC = proto3.makeMessageType(
  "envoy.config.rbac.v2.RBAC",
  () => [
    { no: 1, name: "action", kind: "enum", T: proto3.getEnumType(RBAC_Action) },
    { no: 2, name: "policies", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Policy} },
  ],
);

/**
 * Should we do safe-list or block-list style access control?
 *
 * @generated from enum envoy.config.rbac.v2.RBAC.Action
 */
export const RBAC_Action = proto3.makeEnum(
  "envoy.config.rbac.v2.RBAC.Action",
  [
    {no: 0, name: "ALLOW"},
    {no: 1, name: "DENY"},
  ],
);

/**
 * Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
 * and only if at least one of its permissions match the action taking place AND at least one of its
 * principals match the downstream AND the condition is true if specified.
 *
 * @generated from message envoy.config.rbac.v2.Policy
 */
export const Policy = proto3.makeMessageType(
  "envoy.config.rbac.v2.Policy",
  () => [
    { no: 1, name: "permissions", kind: "message", T: Permission, repeated: true },
    { no: 2, name: "principals", kind: "message", T: Principal, repeated: true },
    { no: 3, name: "condition", kind: "message", T: Expr },
  ],
);

/**
 * Permission defines an action (or actions) that a principal can take.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.rbac.v2.Permission
 */
export const Permission = proto3.makeMessageType(
  "envoy.config.rbac.v2.Permission",
  () => [
    { no: 1, name: "and_rules", kind: "message", T: Permission_Set, oneof: "rule" },
    { no: 2, name: "or_rules", kind: "message", T: Permission_Set, oneof: "rule" },
    { no: 3, name: "any", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 4, name: "header", kind: "message", T: HeaderMatcher, oneof: "rule" },
    { no: 10, name: "url_path", kind: "message", T: PathMatcher, oneof: "rule" },
    { no: 5, name: "destination_ip", kind: "message", T: CidrRange, oneof: "rule" },
    { no: 6, name: "destination_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */, oneof: "rule" },
    { no: 7, name: "metadata", kind: "message", T: MetadataMatcher, oneof: "rule" },
    { no: 8, name: "not_rule", kind: "message", T: Permission, oneof: "rule" },
    { no: 9, name: "requested_server_name", kind: "message", T: StringMatcher, oneof: "rule" },
  ],
);

/**
 * Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v2.Permission.Set
 */
export const Permission_Set = proto3.makeMessageType(
  "envoy.config.rbac.v2.Permission.Set",
  () => [
    { no: 1, name: "rules", kind: "message", T: Permission, repeated: true },
  ],
  {localName: "Permission_Set"},
);

/**
 * Principal defines an identity or a group of identities for a downstream subject.
 * [#next-free-field: 12]
 *
 * @generated from message envoy.config.rbac.v2.Principal
 */
export const Principal = proto3.makeMessageType(
  "envoy.config.rbac.v2.Principal",
  () => [
    { no: 1, name: "and_ids", kind: "message", T: Principal_Set, oneof: "identifier" },
    { no: 2, name: "or_ids", kind: "message", T: Principal_Set, oneof: "identifier" },
    { no: 3, name: "any", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "identifier" },
    { no: 4, name: "authenticated", kind: "message", T: Principal_Authenticated, oneof: "identifier" },
    { no: 5, name: "source_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 10, name: "direct_remote_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 11, name: "remote_ip", kind: "message", T: CidrRange, oneof: "identifier" },
    { no: 6, name: "header", kind: "message", T: HeaderMatcher, oneof: "identifier" },
    { no: 9, name: "url_path", kind: "message", T: PathMatcher, oneof: "identifier" },
    { no: 7, name: "metadata", kind: "message", T: MetadataMatcher, oneof: "identifier" },
    { no: 8, name: "not_id", kind: "message", T: Principal, oneof: "identifier" },
  ],
);

/**
 * Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
 * each are applied with the associated behavior.
 *
 * @generated from message envoy.config.rbac.v2.Principal.Set
 */
export const Principal_Set = proto3.makeMessageType(
  "envoy.config.rbac.v2.Principal.Set",
  () => [
    { no: 1, name: "ids", kind: "message", T: Principal, repeated: true },
  ],
  {localName: "Principal_Set"},
);

/**
 * Authentication attributes for a downstream.
 *
 * @generated from message envoy.config.rbac.v2.Principal.Authenticated
 */
export const Principal_Authenticated = proto3.makeMessageType(
  "envoy.config.rbac.v2.Principal.Authenticated",
  () => [
    { no: 2, name: "principal_name", kind: "message", T: StringMatcher },
  ],
  {localName: "Principal_Authenticated"},
);

