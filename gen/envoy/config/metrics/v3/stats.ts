// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/metrics/v3/stats.proto" (package "envoy.config.metrics.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { Address } from "../../core/v3/address";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { ListStringMatcher } from "../../../type/matcher/v3/string";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
// [#protodoc-title: Stats]
// Statistics :ref:`architecture overview <arch_overview_statistics>`.

/**
 * Configuration for pluggable stats sinks.
 *
 * @generated from protobuf message envoy.config.metrics.v3.StatsSink
 */
export interface StatsSink {
    /**
     * The name of the stats sink to instantiate. The name must match a supported
     * stats sink.
     * See the :ref:`extensions listed in typed_config below <extension_category_envoy.stats_sinks>` for the default list of available stats sink.
     * Sinks optionally support tagged/multiple dimensional metrics.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Statistics configuration such as tagging.
 *
 * @generated from protobuf message envoy.config.metrics.v3.StatsConfig
 */
export interface StatsConfig {
    /**
     * Each stat name is independently processed through these tag specifiers. When a tag is
     * matched, the first capture group is not immediately removed from the name, so later
     * :ref:`TagSpecifiers <envoy_v3_api_msg_config.metrics.v3.TagSpecifier>` can also match that
     * same portion of the match. After all tag matching is complete, a tag-extracted version of
     * the name is produced and is used in stats sinks that represent tags, such as Prometheus.
     *
     * @generated from protobuf field: repeated envoy.config.metrics.v3.TagSpecifier stats_tags = 1;
     */
    statsTags: TagSpecifier[];
    /**
     * Use all default tag regexes specified in Envoy. These can be combined with
     * custom tags specified in :ref:`stats_tags
     * <envoy_v3_api_field_config.metrics.v3.StatsConfig.stats_tags>`. They will be processed before
     * the custom tags.
     *
     * .. note::
     *
     *   If any default tags are specified twice, the config will be considered
     *   invalid.
     *
     * See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
     * default tags in Envoy.
     *
     * If not provided, the value is assumed to be true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue use_all_default_tags = 2;
     */
    useAllDefaultTags?: BoolValue;
    /**
     * Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
     * as normal. Preventing the instantiation of certain families of stats can improve memory
     * performance for Envoys running especially large configs.
     *
     * .. warning::
     *   Excluding stats may affect Envoy's behavior in undocumented ways. See
     *   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
     *   If any unexpected behavior changes are observed, please open a new issue immediately.
     *
     * @generated from protobuf field: envoy.config.metrics.v3.StatsMatcher stats_matcher = 3;
     */
    statsMatcher?: StatsMatcher;
    /**
     * Defines rules for setting the histogram buckets. Rules are evaluated in order, and the first
     * match is applied. If no match is found (or if no rules are set), the following default buckets
     * are used:
     *
     *   .. code-block:: json
     *
     *     [
     *       0.5,
     *       1,
     *       5,
     *       10,
     *       25,
     *       50,
     *       100,
     *       250,
     *       500,
     *       1000,
     *       2500,
     *       5000,
     *       10000,
     *       30000,
     *       60000,
     *       300000,
     *       600000,
     *       1800000,
     *       3600000
     *     ]
     *
     * @generated from protobuf field: repeated envoy.config.metrics.v3.HistogramBucketSettings histogram_bucket_settings = 4;
     */
    histogramBucketSettings: HistogramBucketSettings[];
}
/**
 * Configuration for disabling stat instantiation.
 *
 * The instantiation of stats is unrestricted by default. If the goal is to configure Envoy to
 * instantiate all stats, there is no need to construct a StatsMatcher.
 *
 * However, StatsMatcher can be used to limit the creation of families of stats in order to
 * conserve memory. Stats can either be disabled entirely, or they can be
 * limited by either an exclusion or an inclusion list of :ref:`StringMatcher
 * <envoy_v3_api_msg_type.matcher.v3.StringMatcher>` protos:
 *
 * * If ``reject_all`` is set to `true`, no stats will be instantiated. If ``reject_all`` is set to
 *   `false`, all stats will be instantiated.
 *
 * * If an exclusion list is supplied, any stat name matching *any* of the StringMatchers in the
 *   list will not instantiate.
 *
 * * If an inclusion list is supplied, no stats will instantiate, except those matching *any* of
 *   the StringMatchers in the list.
 *
 *
 * A StringMatcher can be used to match against an exact string, a suffix / prefix, or a regex.
 * **NB:** For performance reasons, it is highly recommended to use a prefix- or suffix-based
 * matcher rather than a regex-based matcher.
 *
 * Example 1. Excluding all stats.
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "rejectAll": "true"
 *     }
 *   }
 *
 * Example 2. Excluding all cluster-specific stats, but not cluster-manager stats:
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "exclusionList": {
 *         "patterns": [
 *           {
 *             "prefix": "cluster."
 *           }
 *         ]
 *       }
 *     }
 *   }
 *
 * Example 3. Including only manager-related stats:
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "inclusionList": {
 *         "patterns": [
 *           {
 *             "prefix": "cluster_manager."
 *           },
 *           {
 *             "prefix": "listener_manager."
 *           }
 *         ]
 *       }
 *     }
 *   }
 *
 *
 * @generated from protobuf message envoy.config.metrics.v3.StatsMatcher
 */
export interface StatsMatcher {
    /**
     * @generated from protobuf oneof: stats_matcher
     */
    statsMatcher: {
        oneofKind: "rejectAll";
        /**
         * If ``reject_all`` is true, then all stats are disabled. If ``reject_all`` is false, then all
         * stats are enabled.
         *
         * @generated from protobuf field: bool reject_all = 1;
         */
        rejectAll: boolean;
    } | {
        oneofKind: "exclusionList";
        /**
         * Exclusive match. All stats are enabled except for those matching one of the supplied
         * StringMatcher protos.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher exclusion_list = 2;
         */
        exclusionList: ListStringMatcher;
    } | {
        oneofKind: "inclusionList";
        /**
         * Inclusive match. No stats are enabled except for those matching one of the supplied
         * StringMatcher protos.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.ListStringMatcher inclusion_list = 3;
         */
        inclusionList: ListStringMatcher;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Designates a tag name and value pair. The value may be either a fixed value
 * or a regex providing the value via capture groups. The specified tag will be
 * unconditionally set if a fixed value, otherwise it will only be set if one
 * or more capture groups in the regex match.
 *
 * @generated from protobuf message envoy.config.metrics.v3.TagSpecifier
 */
export interface TagSpecifier {
    /**
     * Attaches an identifier to the tag values to identify the tag being in the
     * sink. Envoy has a set of default names and regexes to extract dynamic
     * portions of existing stats, which can be found in :repo:`well_known_names.h
     * <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
     * <envoy_v3_api_field_config.metrics.v3.TagSpecifier.tag_name>` is provided in the config and
     * neither :ref:`regex <envoy_v3_api_field_config.metrics.v3.TagSpecifier.regex>` or
     * :ref:`fixed_value <envoy_v3_api_field_config.metrics.v3.TagSpecifier.fixed_value>` were specified,
     * Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
     *
     * .. note::
     *
     *   A stat name may be spelled in such a way that it matches two different
     *   tag extractors for the same tag name. In that case, all but one of the
     *   tag values will be dropped. It is not specified which tag value will be
     *   retained. The extraction will only occur for one of the extractors, and
     *   only the matched extraction will be removed from the tag name.
     *
     * @generated from protobuf field: string tag_name = 1;
     */
    tagName: string;
    /**
     * @generated from protobuf oneof: tag_value
     */
    tagValue: {
        oneofKind: "regex";
        /**
         * Designates a tag to strip from the tag extracted name and provide as a named
         * tag value for all statistics. This will only occur if any part of the name
         * matches the regex provided with one or more capture groups.
         *
         * The first capture group identifies the portion of the name to remove. The
         * second capture group (which will normally be nested inside the first) will
         * designate the value of the tag for the statistic. If no second capture
         * group is provided, the first will also be used to set the value of the tag.
         * All other capture groups will be ignored.
         *
         * Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
         * one tag specifier:
         *
         * .. code-block:: json
         *
         *   {
         *     "tag_name": "envoy.cluster_name",
         *     "regex": "^cluster\\.((.+?)\\.)"
         *   }
         *
         * Note that the regex will remove ``foo_cluster.`` making the tag extracted
         * name ``cluster.upstream_rq_timeout`` and the tag value for
         * ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
         * ``.`` character because of the second capture group).
         *
         * Example 2. a stat name
         * ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
         * tag specifiers:
         *
         * .. code-block:: json
         *
         *   [
         *     {
         *       "tag_name": "envoy.http_user_agent",
         *       "regex": "^http(?=\\.).*?\\.user_agent\\.((.+?)\\.)\\w+?$"
         *     },
         *     {
         *       "tag_name": "envoy.http_conn_manager_prefix",
         *       "regex": "^http\\.((.*?)\\.)"
         *     }
         *   ]
         *
         * The two regexes of the specifiers will be processed from the elaborated
         * stat name.
         *
         * The first regex will save ``ios.`` as the tag value for ``envoy.http_user_agent``. It will
         * leave it in the name for potential matching with additional tag specifiers. After all tag
         * specifiers are processed the tags will be removed from the name.
         *
         * The second regex will populate tag ``envoy.http_conn_manager_prefix`` with value
         * ``connection_manager_1.``, based on the original stat name.
         *
         * As a final step, the matched tags are removed, leaving
         * ``http.user_agent.downstream_cx_total`` as the tag extracted name.
         *
         * @generated from protobuf field: string regex = 2;
         */
        regex: string;
    } | {
        oneofKind: "fixedValue";
        /**
         * Specifies a fixed tag value for the ``tag_name``.
         *
         * @generated from protobuf field: string fixed_value = 3;
         */
        fixedValue: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies a matcher for stats and the buckets that matching stats should use.
 *
 * @generated from protobuf message envoy.config.metrics.v3.HistogramBucketSettings
 */
export interface HistogramBucketSettings {
    /**
     * The stats that this rule applies to. The match is applied to the original stat name
     * before tag-extraction, for example ``cluster.exampleclustername.upstream_cx_length_ms``.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher match = 1;
     */
    match?: StringMatcher;
    /**
     * Each value is the upper bound of a bucket. Each bucket must be greater than 0 and unique.
     * The order of the buckets does not matter.
     *
     * @generated from protobuf field: repeated double buckets = 2;
     */
    buckets: number[];
}
/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.statsd`` sink. This sink does not support
 * tagged metrics.
 * [#extension: envoy.stat_sinks.statsd]
 *
 * @generated from protobuf message envoy.config.metrics.v3.StatsdSink
 */
export interface StatsdSink {
    /**
     * @generated from protobuf oneof: statsd_specifier
     */
    statsdSpecifier: {
        oneofKind: "address";
        /**
         * The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
         * compliant listener. If specified, statistics will be flushed to this
         * address.
         *
         * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
         */
        address: Address;
    } | {
        oneofKind: "tcpClusterName";
        /**
         * The name of a cluster that is running a TCP `statsd
         * <https://github.com/etsy/statsd>`_ compliant listener. If specified,
         * Envoy will connect to this cluster to flush statistics.
         *
         * @generated from protobuf field: string tcp_cluster_name = 2;
         */
        tcpClusterName: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional custom prefix for StatsdSink. If
     * specified, this will override the default prefix.
     * For example:
     *
     * .. code-block:: json
     *
     *   {
     *     "prefix" : "envoy-prod"
     *   }
     *
     * will change emitted stats to
     *
     * .. code-block:: cpp
     *
     *   envoy-prod.test_counter:1|c
     *   envoy-prod.test_timer:5|ms
     *
     * Note that the default prefix, "envoy", will be used if a prefix is not
     * specified.
     *
     * Stats with default prefix:
     *
     * .. code-block:: cpp
     *
     *   envoy.test_counter:1|c
     *   envoy.test_timer:5|ms
     *
     * @generated from protobuf field: string prefix = 3;
     */
    prefix: string;
}
/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.dog_statsd`` sink.
 * The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
 * compatible tags. Tags are configurable via :ref:`StatsConfig
 * <envoy_v3_api_msg_config.metrics.v3.StatsConfig>`.
 * [#extension: envoy.stat_sinks.dog_statsd]
 *
 * @generated from protobuf message envoy.config.metrics.v3.DogStatsdSink
 */
export interface DogStatsdSink {
    /**
     * @generated from protobuf oneof: dog_statsd_specifier
     */
    dogStatsdSpecifier: {
        oneofKind: "address";
        /**
         * The UDP address of a running DogStatsD compliant listener. If specified,
         * statistics will be flushed to this address.
         *
         * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
         */
        address: Address;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
     * <envoy_v3_api_field_config.metrics.v3.StatsdSink.prefix>` for more details.
     *
     * @generated from protobuf field: string prefix = 3;
     */
    prefix: string;
    /**
     * Optional max datagram size to use when sending UDP messages. By default Envoy
     * will emit one metric per datagram. By specifying a max-size larger than a single
     * metric, Envoy will emit multiple, new-line separated metrics. The max datagram
     * size should not exceed your network's MTU.
     *
     * Note that this value may not be respected if smaller than a single metric.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value max_bytes_per_datagram = 4;
     */
    maxBytesPerDatagram?: UInt64Value;
}
/**
 * Stats configuration proto schema for built-in ``envoy.stat_sinks.hystrix`` sink.
 * The sink emits stats in `text/event-stream
 * <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
 * formatted stream for use by `Hystrix dashboard
 * <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
 *
 * Note that only a single HystrixSink should be configured.
 *
 * Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
 * [#extension: envoy.stat_sinks.hystrix]
 *
 * @generated from protobuf message envoy.config.metrics.v3.HystrixSink
 */
export interface HystrixSink {
    /**
     * The number of buckets the rolling statistical window is divided into.
     *
     * Each time the sink is flushed, all relevant Envoy statistics are sampled and
     * added to the rolling window (removing the oldest samples in the window
     * in the process). The sink then outputs the aggregate statistics across the
     * current rolling window to the event stream(s).
     *
     * ``rolling_window(ms)`` = ``stats_flush_interval(ms)`` * ``num_of_buckets``
     *
     * More detailed explanation can be found in `Hystrix wiki
     * <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
     *
     * @generated from protobuf field: int64 num_buckets = 1;
     */
    numBuckets: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class StatsSink$Type extends MessageType<StatsSink> {
    constructor() {
        super("envoy.config.metrics.v3.StatsSink", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.StatsSink" } });
    }
    create(value?: PartialMessage<StatsSink>): StatsSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StatsSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsSink): StatsSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.StatsSink
 */
export const StatsSink = new StatsSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsConfig$Type extends MessageType<StatsConfig> {
    constructor() {
        super("envoy.config.metrics.v3.StatsConfig", [
            { no: 1, name: "stats_tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TagSpecifier },
            { no: 2, name: "use_all_default_tags", kind: "message", T: () => BoolValue },
            { no: 3, name: "stats_matcher", kind: "message", T: () => StatsMatcher },
            { no: 4, name: "histogram_bucket_settings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HistogramBucketSettings }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.StatsConfig" } });
    }
    create(value?: PartialMessage<StatsConfig>): StatsConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsTags = [];
        message.histogramBucketSettings = [];
        if (value !== undefined)
            reflectionMergePartial<StatsConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsConfig): StatsConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.metrics.v3.TagSpecifier stats_tags */ 1:
                    message.statsTags.push(TagSpecifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue use_all_default_tags */ 2:
                    message.useAllDefaultTags = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.useAllDefaultTags);
                    break;
                case /* envoy.config.metrics.v3.StatsMatcher stats_matcher */ 3:
                    message.statsMatcher = StatsMatcher.internalBinaryRead(reader, reader.uint32(), options, message.statsMatcher);
                    break;
                case /* repeated envoy.config.metrics.v3.HistogramBucketSettings histogram_bucket_settings */ 4:
                    message.histogramBucketSettings.push(HistogramBucketSettings.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.metrics.v3.TagSpecifier stats_tags = 1; */
        for (let i = 0; i < message.statsTags.length; i++)
            TagSpecifier.internalBinaryWrite(message.statsTags[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue use_all_default_tags = 2; */
        if (message.useAllDefaultTags)
            BoolValue.internalBinaryWrite(message.useAllDefaultTags, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.metrics.v3.StatsMatcher stats_matcher = 3; */
        if (message.statsMatcher)
            StatsMatcher.internalBinaryWrite(message.statsMatcher, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.metrics.v3.HistogramBucketSettings histogram_bucket_settings = 4; */
        for (let i = 0; i < message.histogramBucketSettings.length; i++)
            HistogramBucketSettings.internalBinaryWrite(message.histogramBucketSettings[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.StatsConfig
 */
export const StatsConfig = new StatsConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsMatcher$Type extends MessageType<StatsMatcher> {
    constructor() {
        super("envoy.config.metrics.v3.StatsMatcher", [
            { no: 1, name: "reject_all", kind: "scalar", oneof: "statsMatcher", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "exclusion_list", kind: "message", oneof: "statsMatcher", T: () => ListStringMatcher },
            { no: 3, name: "inclusion_list", kind: "message", oneof: "statsMatcher", T: () => ListStringMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.StatsMatcher" } });
    }
    create(value?: PartialMessage<StatsMatcher>): StatsMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsMatcher = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StatsMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsMatcher): StatsMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool reject_all */ 1:
                    message.statsMatcher = {
                        oneofKind: "rejectAll",
                        rejectAll: reader.bool()
                    };
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher exclusion_list */ 2:
                    message.statsMatcher = {
                        oneofKind: "exclusionList",
                        exclusionList: ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.statsMatcher as any).exclusionList)
                    };
                    break;
                case /* envoy.type.matcher.v3.ListStringMatcher inclusion_list */ 3:
                    message.statsMatcher = {
                        oneofKind: "inclusionList",
                        inclusionList: ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.statsMatcher as any).inclusionList)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool reject_all = 1; */
        if (message.statsMatcher.oneofKind === "rejectAll")
            writer.tag(1, WireType.Varint).bool(message.statsMatcher.rejectAll);
        /* envoy.type.matcher.v3.ListStringMatcher exclusion_list = 2; */
        if (message.statsMatcher.oneofKind === "exclusionList")
            ListStringMatcher.internalBinaryWrite(message.statsMatcher.exclusionList, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.ListStringMatcher inclusion_list = 3; */
        if (message.statsMatcher.oneofKind === "inclusionList")
            ListStringMatcher.internalBinaryWrite(message.statsMatcher.inclusionList, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.StatsMatcher
 */
export const StatsMatcher = new StatsMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagSpecifier$Type extends MessageType<TagSpecifier> {
    constructor() {
        super("envoy.config.metrics.v3.TagSpecifier", [
            { no: 1, name: "tag_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "regex", kind: "scalar", oneof: "tagValue", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024" } } } },
            { no: 3, name: "fixed_value", kind: "scalar", oneof: "tagValue", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.TagSpecifier" } });
    }
    create(value?: PartialMessage<TagSpecifier>): TagSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagName = "";
        message.tagValue = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TagSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagSpecifier): TagSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_name */ 1:
                    message.tagName = reader.string();
                    break;
                case /* string regex */ 2:
                    message.tagValue = {
                        oneofKind: "regex",
                        regex: reader.string()
                    };
                    break;
                case /* string fixed_value */ 3:
                    message.tagValue = {
                        oneofKind: "fixedValue",
                        fixedValue: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_name = 1; */
        if (message.tagName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagName);
        /* string regex = 2; */
        if (message.tagValue.oneofKind === "regex")
            writer.tag(2, WireType.LengthDelimited).string(message.tagValue.regex);
        /* string fixed_value = 3; */
        if (message.tagValue.oneofKind === "fixedValue")
            writer.tag(3, WireType.LengthDelimited).string(message.tagValue.fixedValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.TagSpecifier
 */
export const TagSpecifier = new TagSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistogramBucketSettings$Type extends MessageType<HistogramBucketSettings> {
    constructor() {
        super("envoy.config.metrics.v3.HistogramBucketSettings", [
            { no: 1, name: "match", kind: "message", T: () => StringMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "buckets", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/, options: { "validate.rules": { repeated: { minItems: "1", unique: true, items: { double: { gt: 0 } } } } } }
        ]);
    }
    create(value?: PartialMessage<HistogramBucketSettings>): HistogramBucketSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.buckets = [];
        if (value !== undefined)
            reflectionMergePartial<HistogramBucketSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistogramBucketSettings): HistogramBucketSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.v3.StringMatcher match */ 1:
                    message.match = StringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* repeated double buckets */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.buckets.push(reader.double());
                    else
                        message.buckets.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistogramBucketSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.v3.StringMatcher match = 1; */
        if (message.match)
            StringMatcher.internalBinaryWrite(message.match, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated double buckets = 2; */
        if (message.buckets.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.buckets.length; i++)
                writer.double(message.buckets[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.HistogramBucketSettings
 */
export const HistogramBucketSettings = new HistogramBucketSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsdSink$Type extends MessageType<StatsdSink> {
    constructor() {
        super("envoy.config.metrics.v3.StatsdSink", [
            { no: 1, name: "address", kind: "message", oneof: "statsdSpecifier", T: () => Address },
            { no: 2, name: "tcp_cluster_name", kind: "scalar", oneof: "statsdSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.StatsdSink" } });
    }
    create(value?: PartialMessage<StatsdSink>): StatsdSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsdSpecifier = { oneofKind: undefined };
        message.prefix = "";
        if (value !== undefined)
            reflectionMergePartial<StatsdSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsdSink): StatsdSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.statsdSpecifier = {
                        oneofKind: "address",
                        address: Address.internalBinaryRead(reader, reader.uint32(), options, (message.statsdSpecifier as any).address)
                    };
                    break;
                case /* string tcp_cluster_name */ 2:
                    message.statsdSpecifier = {
                        oneofKind: "tcpClusterName",
                        tcpClusterName: reader.string()
                    };
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsdSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.statsdSpecifier.oneofKind === "address")
            Address.internalBinaryWrite(message.statsdSpecifier.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string tcp_cluster_name = 2; */
        if (message.statsdSpecifier.oneofKind === "tcpClusterName")
            writer.tag(2, WireType.LengthDelimited).string(message.statsdSpecifier.tcpClusterName);
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.StatsdSink
 */
export const StatsdSink = new StatsdSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DogStatsdSink$Type extends MessageType<DogStatsdSink> {
    constructor() {
        super("envoy.config.metrics.v3.DogStatsdSink", [
            { no: 1, name: "address", kind: "message", oneof: "dogStatsdSpecifier", T: () => Address },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "max_bytes_per_datagram", kind: "message", T: () => UInt64Value, options: { "validate.rules": { uint64: { gt: "0" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.DogStatsdSink" } });
    }
    create(value?: PartialMessage<DogStatsdSink>): DogStatsdSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dogStatsdSpecifier = { oneofKind: undefined };
        message.prefix = "";
        if (value !== undefined)
            reflectionMergePartial<DogStatsdSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DogStatsdSink): DogStatsdSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.dogStatsdSpecifier = {
                        oneofKind: "address",
                        address: Address.internalBinaryRead(reader, reader.uint32(), options, (message.dogStatsdSpecifier as any).address)
                    };
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                case /* google.protobuf.UInt64Value max_bytes_per_datagram */ 4:
                    message.maxBytesPerDatagram = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.maxBytesPerDatagram);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DogStatsdSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.dogStatsdSpecifier.oneofKind === "address")
            Address.internalBinaryWrite(message.dogStatsdSpecifier.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        /* google.protobuf.UInt64Value max_bytes_per_datagram = 4; */
        if (message.maxBytesPerDatagram)
            UInt64Value.internalBinaryWrite(message.maxBytesPerDatagram, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.DogStatsdSink
 */
export const DogStatsdSink = new DogStatsdSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HystrixSink$Type extends MessageType<HystrixSink> {
    constructor() {
        super("envoy.config.metrics.v3.HystrixSink", [
            { no: 1, name: "num_buckets", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.config.metrics.v2.HystrixSink" } });
    }
    create(value?: PartialMessage<HystrixSink>): HystrixSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numBuckets = 0n;
        if (value !== undefined)
            reflectionMergePartial<HystrixSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HystrixSink): HystrixSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_buckets */ 1:
                    message.numBuckets = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HystrixSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_buckets = 1; */
        if (message.numBuckets !== 0n)
            writer.tag(1, WireType.Varint).int64(message.numBuckets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v3.HystrixSink
 */
export const HystrixSink = new HystrixSink$Type();
