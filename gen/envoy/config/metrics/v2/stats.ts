// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/metrics/v2/stats.proto" (package "envoy.config.metrics.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Address } from "../../../api/v2/core/address";
import { ListStringMatcher } from "../../../type/matcher/string";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
// [#protodoc-title: Stats]
// Statistics :ref:`architecture overview <arch_overview_statistics>`.

/**
 * Configuration for pluggable stats sinks.
 *
 * @generated from protobuf message envoy.config.metrics.v2.StatsSink
 */
export interface StatsSink {
    /**
     * The name of the stats sink to instantiate. The name must match a supported
     * stats sink. The built-in stats sinks are:
     *
     * * :ref:`envoy.stat_sinks.statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`
     * * :ref:`envoy.stat_sinks.dog_statsd <envoy_api_msg_config.metrics.v2.DogStatsdSink>`
     * * :ref:`envoy.stat_sinks.metrics_service <envoy_api_msg_config.metrics.v2.MetricsServiceConfig>`
     * * :ref:`envoy.stat_sinks.hystrix <envoy_api_msg_config.metrics.v2.HystrixSink>`
     *
     * Sinks optionally support tagged/multiple dimensional metrics.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Statistics configuration such as tagging.
 *
 * @generated from protobuf message envoy.config.metrics.v2.StatsConfig
 */
export interface StatsConfig {
    /**
     * Each stat name is iteratively processed through these tag specifiers.
     * When a tag is matched, the first capture group is removed from the name so
     * later :ref:`TagSpecifiers <envoy_api_msg_config.metrics.v2.TagSpecifier>` cannot match that
     * same portion of the match.
     *
     * @generated from protobuf field: repeated envoy.config.metrics.v2.TagSpecifier stats_tags = 1;
     */
    statsTags: TagSpecifier[];
    /**
     * Use all default tag regexes specified in Envoy. These can be combined with
     * custom tags specified in :ref:`stats_tags
     * <envoy_api_field_config.metrics.v2.StatsConfig.stats_tags>`. They will be processed before
     * the custom tags.
     *
     * .. note::
     *
     *   If any default tags are specified twice, the config will be considered
     *   invalid.
     *
     * See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
     * default tags in Envoy.
     *
     * If not provided, the value is assumed to be true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue use_all_default_tags = 2;
     */
    useAllDefaultTags?: BoolValue;
    /**
     * Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
     * as normal. Preventing the instantiation of certain families of stats can improve memory
     * performance for Envoys running especially large configs.
     *
     * .. warning::
     *   Excluding stats may affect Envoy's behavior in undocumented ways. See
     *   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
     *   If any unexpected behavior changes are observed, please open a new issue immediately.
     *
     * @generated from protobuf field: envoy.config.metrics.v2.StatsMatcher stats_matcher = 3;
     */
    statsMatcher?: StatsMatcher;
}
/**
 * Configuration for disabling stat instantiation.
 *
 * The instantiation of stats is unrestricted by default. If the goal is to configure Envoy to
 * instantiate all stats, there is no need to construct a StatsMatcher.
 *
 * However, StatsMatcher can be used to limit the creation of families of stats in order to
 * conserve memory. Stats can either be disabled entirely, or they can be
 * limited by either an exclusion or an inclusion list of :ref:`StringMatcher
 * <envoy_api_msg_type.matcher.StringMatcher>` protos:
 *
 * * If ``reject_all`` is set to ``true``, no stats will be instantiated. If ``reject_all`` is set to
 *   ``false``, all stats will be instantiated.
 *
 * * If an exclusion list is supplied, any stat name matching *any* of the StringMatchers in the
 *   list will not instantiate.
 *
 * * If an inclusion list is supplied, no stats will instantiate, except those matching *any* of
 *   the StringMatchers in the list.
 *
 *
 * A StringMatcher can be used to match against an exact string, a suffix / prefix, or a regex.
 * **NB:** For performance reasons, it is highly recommended to use a prefix- or suffix-based
 * matcher rather than a regex-based matcher.
 *
 * Example 1. Excluding all stats.
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "rejectAll": "true"
 *     }
 *   }
 *
 * Example 2. Excluding all cluster-specific stats, but not cluster-manager stats:
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "exclusionList": {
 *         "patterns": [
 *           {
 *             "prefix": "cluster."
 *           }
 *         ]
 *       }
 *     }
 *   }
 *
 * Example 3. Including only manager-related stats:
 *
 * .. code-block:: json
 *
 *   {
 *     "statsMatcher": {
 *       "inclusionList": {
 *         "patterns": [
 *           {
 *             "prefix": "cluster_manager."
 *           },
 *           {
 *             "prefix": "listener_manager."
 *           }
 *         ]
 *       }
 *     }
 *   }
 *
 *
 * @generated from protobuf message envoy.config.metrics.v2.StatsMatcher
 */
export interface StatsMatcher {
    /**
     * @generated from protobuf oneof: stats_matcher
     */
    statsMatcher: {
        oneofKind: "rejectAll";
        /**
         * If `reject_all` is true, then all stats are disabled. If `reject_all` is false, then all
         * stats are enabled.
         *
         * @generated from protobuf field: bool reject_all = 1;
         */
        rejectAll: boolean;
    } | {
        oneofKind: "exclusionList";
        /**
         * Exclusive match. All stats are enabled except for those matching one of the supplied
         * StringMatcher protos.
         *
         * @generated from protobuf field: envoy.type.matcher.ListStringMatcher exclusion_list = 2;
         */
        exclusionList: ListStringMatcher;
    } | {
        oneofKind: "inclusionList";
        /**
         * Inclusive match. No stats are enabled except for those matching one of the supplied
         * StringMatcher protos.
         *
         * @generated from protobuf field: envoy.type.matcher.ListStringMatcher inclusion_list = 3;
         */
        inclusionList: ListStringMatcher;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Designates a tag name and value pair. The value may be either a fixed value
 * or a regex providing the value via capture groups. The specified tag will be
 * unconditionally set if a fixed value, otherwise it will only be set if one
 * or more capture groups in the regex match.
 *
 * @generated from protobuf message envoy.config.metrics.v2.TagSpecifier
 */
export interface TagSpecifier {
    /**
     * Attaches an identifier to the tag values to identify the tag being in the
     * sink. Envoy has a set of default names and regexes to extract dynamic
     * portions of existing stats, which can be found in :repo:`well_known_names.h
     * <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
     * <envoy_api_field_config.metrics.v2.TagSpecifier.tag_name>` is provided in the config and
     * neither :ref:`regex <envoy_api_field_config.metrics.v2.TagSpecifier.regex>` or
     * :ref:`fixed_value <envoy_api_field_config.metrics.v2.TagSpecifier.fixed_value>` were specified,
     * Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
     *
     * .. note::
     *
     *   It is invalid to specify the same tag name twice in a config.
     *
     * @generated from protobuf field: string tag_name = 1;
     */
    tagName: string;
    /**
     * @generated from protobuf oneof: tag_value
     */
    tagValue: {
        oneofKind: "regex";
        /**
         * Designates a tag to strip from the tag extracted name and provide as a named
         * tag value for all statistics. This will only occur if any part of the name
         * matches the regex provided with one or more capture groups.
         *
         * The first capture group identifies the portion of the name to remove. The
         * second capture group (which will normally be nested inside the first) will
         * designate the value of the tag for the statistic. If no second capture
         * group is provided, the first will also be used to set the value of the tag.
         * All other capture groups will be ignored.
         *
         * Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
         * one tag specifier:
         *
         * .. code-block:: json
         *
         *   {
         *     "tag_name": "envoy.cluster_name",
         *     "regex": "^cluster\\.((.+?)\\.)"
         *   }
         *
         * Note that the regex will remove ``foo_cluster.`` making the tag extracted
         * name ``cluster.upstream_rq_timeout`` and the tag value for
         * ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
         * ``.`` character because of the second capture group).
         *
         * Example 2. a stat name
         * ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
         * tag specifiers:
         *
         * .. code-block:: json
         *
         *   [
         *     {
         *       "tag_name": "envoy.http_user_agent",
         *       "regex": "^http(?=\\.).*?\\.user_agent\\.((.+?)\\.)\\w+?$"
         *     },
         *     {
         *       "tag_name": "envoy.http_conn_manager_prefix",
         *       "regex": "^http\\.((.*?)\\.)"
         *     }
         *   ]
         *
         * The two regexes of the specifiers will be processed in the definition order.
         *
         * The first regex will remove ``ios.``, leaving the tag extracted name
         * ``http.connection_manager_1.user_agent.downstream_cx_total``. The tag
         * ``envoy.http_user_agent`` will be added with tag value ``ios``.
         *
         * The second regex will remove ``connection_manager_1.`` from the tag
         * extracted name produced by the first regex
         * ``http.connection_manager_1.user_agent.downstream_cx_total``, leaving
         * ``http.user_agent.downstream_cx_total`` as the tag extracted name. The tag
         * ``envoy.http_conn_manager_prefix`` will be added with the tag value
         * ``connection_manager_1``.
         *
         * @generated from protobuf field: string regex = 2;
         */
        regex: string;
    } | {
        oneofKind: "fixedValue";
        /**
         * Specifies a fixed tag value for the ``tag_name``.
         *
         * @generated from protobuf field: string fixed_value = 3;
         */
        fixedValue: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Stats configuration proto schema for built-in *envoy.stat_sinks.statsd* sink. This sink does not support
 * tagged metrics.
 * [#extension: envoy.stat_sinks.statsd]
 *
 * @generated from protobuf message envoy.config.metrics.v2.StatsdSink
 */
export interface StatsdSink {
    /**
     * @generated from protobuf oneof: statsd_specifier
     */
    statsdSpecifier: {
        oneofKind: "address";
        /**
         * The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
         * compliant listener. If specified, statistics will be flushed to this
         * address.
         *
         * @generated from protobuf field: envoy.api.v2.core.Address address = 1;
         */
        address: Address;
    } | {
        oneofKind: "tcpClusterName";
        /**
         * The name of a cluster that is running a TCP `statsd
         * <https://github.com/etsy/statsd>`_ compliant listener. If specified,
         * Envoy will connect to this cluster to flush statistics.
         *
         * @generated from protobuf field: string tcp_cluster_name = 2;
         */
        tcpClusterName: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional custom prefix for StatsdSink. If
     * specified, this will override the default prefix.
     * For example:
     *
     * .. code-block:: json
     *
     *   {
     *     "prefix" : "envoy-prod"
     *   }
     *
     * will change emitted stats to
     *
     * .. code-block:: cpp
     *
     *   envoy-prod.test_counter:1|c
     *   envoy-prod.test_timer:5|ms
     *
     * Note that the default prefix, "envoy", will be used if a prefix is not
     * specified.
     *
     * Stats with default prefix:
     *
     * .. code-block:: cpp
     *
     *   envoy.test_counter:1|c
     *   envoy.test_timer:5|ms
     *
     * @generated from protobuf field: string prefix = 3;
     */
    prefix: string;
}
/**
 * Stats configuration proto schema for built-in *envoy.stat_sinks.dog_statsd* sink.
 * The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
 * compatible tags. Tags are configurable via :ref:`StatsConfig
 * <envoy_api_msg_config.metrics.v2.StatsConfig>`.
 * [#extension: envoy.stat_sinks.dog_statsd]
 *
 * @generated from protobuf message envoy.config.metrics.v2.DogStatsdSink
 */
export interface DogStatsdSink {
    /**
     * @generated from protobuf oneof: dog_statsd_specifier
     */
    dogStatsdSpecifier: {
        oneofKind: "address";
        /**
         * The UDP address of a running DogStatsD compliant listener. If specified,
         * statistics will be flushed to this address.
         *
         * @generated from protobuf field: envoy.api.v2.core.Address address = 1;
         */
        address: Address;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
     * <envoy_api_field_config.metrics.v2.StatsdSink.prefix>` for more details.
     *
     * @generated from protobuf field: string prefix = 3;
     */
    prefix: string;
}
/**
 * Stats configuration proto schema for built-in *envoy.stat_sinks.hystrix* sink.
 * The sink emits stats in `text/event-stream
 * <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
 * formatted stream for use by `Hystrix dashboard
 * <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
 *
 * Note that only a single HystrixSink should be configured.
 *
 * Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
 * [#extension: envoy.stat_sinks.hystrix]
 *
 * @generated from protobuf message envoy.config.metrics.v2.HystrixSink
 */
export interface HystrixSink {
    /**
     * The number of buckets the rolling statistical window is divided into.
     *
     * Each time the sink is flushed, all relevant Envoy statistics are sampled and
     * added to the rolling window (removing the oldest samples in the window
     * in the process). The sink then outputs the aggregate statistics across the
     * current rolling window to the event stream(s).
     *
     * rolling_window(ms) = stats_flush_interval(ms) * num_of_buckets
     *
     * More detailed explanation can be found in `Hystrix wiki
     * <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
     *
     * @generated from protobuf field: int64 num_buckets = 1;
     */
    numBuckets: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class StatsSink$Type extends MessageType<StatsSink> {
    constructor() {
        super("envoy.config.metrics.v2.StatsSink", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<StatsSink>): StatsSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StatsSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsSink): StatsSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.StatsSink
 */
export const StatsSink = new StatsSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsConfig$Type extends MessageType<StatsConfig> {
    constructor() {
        super("envoy.config.metrics.v2.StatsConfig", [
            { no: 1, name: "stats_tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TagSpecifier },
            { no: 2, name: "use_all_default_tags", kind: "message", T: () => BoolValue },
            { no: 3, name: "stats_matcher", kind: "message", T: () => StatsMatcher }
        ]);
    }
    create(value?: PartialMessage<StatsConfig>): StatsConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsTags = [];
        if (value !== undefined)
            reflectionMergePartial<StatsConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsConfig): StatsConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.metrics.v2.TagSpecifier stats_tags */ 1:
                    message.statsTags.push(TagSpecifier.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue use_all_default_tags */ 2:
                    message.useAllDefaultTags = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.useAllDefaultTags);
                    break;
                case /* envoy.config.metrics.v2.StatsMatcher stats_matcher */ 3:
                    message.statsMatcher = StatsMatcher.internalBinaryRead(reader, reader.uint32(), options, message.statsMatcher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.metrics.v2.TagSpecifier stats_tags = 1; */
        for (let i = 0; i < message.statsTags.length; i++)
            TagSpecifier.internalBinaryWrite(message.statsTags[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue use_all_default_tags = 2; */
        if (message.useAllDefaultTags)
            BoolValue.internalBinaryWrite(message.useAllDefaultTags, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.metrics.v2.StatsMatcher stats_matcher = 3; */
        if (message.statsMatcher)
            StatsMatcher.internalBinaryWrite(message.statsMatcher, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.StatsConfig
 */
export const StatsConfig = new StatsConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsMatcher$Type extends MessageType<StatsMatcher> {
    constructor() {
        super("envoy.config.metrics.v2.StatsMatcher", [
            { no: 1, name: "reject_all", kind: "scalar", oneof: "statsMatcher", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "exclusion_list", kind: "message", oneof: "statsMatcher", T: () => ListStringMatcher },
            { no: 3, name: "inclusion_list", kind: "message", oneof: "statsMatcher", T: () => ListStringMatcher }
        ]);
    }
    create(value?: PartialMessage<StatsMatcher>): StatsMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsMatcher = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<StatsMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsMatcher): StatsMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool reject_all */ 1:
                    message.statsMatcher = {
                        oneofKind: "rejectAll",
                        rejectAll: reader.bool()
                    };
                    break;
                case /* envoy.type.matcher.ListStringMatcher exclusion_list */ 2:
                    message.statsMatcher = {
                        oneofKind: "exclusionList",
                        exclusionList: ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.statsMatcher as any).exclusionList)
                    };
                    break;
                case /* envoy.type.matcher.ListStringMatcher inclusion_list */ 3:
                    message.statsMatcher = {
                        oneofKind: "inclusionList",
                        inclusionList: ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.statsMatcher as any).inclusionList)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool reject_all = 1; */
        if (message.statsMatcher.oneofKind === "rejectAll")
            writer.tag(1, WireType.Varint).bool(message.statsMatcher.rejectAll);
        /* envoy.type.matcher.ListStringMatcher exclusion_list = 2; */
        if (message.statsMatcher.oneofKind === "exclusionList")
            ListStringMatcher.internalBinaryWrite(message.statsMatcher.exclusionList, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.ListStringMatcher inclusion_list = 3; */
        if (message.statsMatcher.oneofKind === "inclusionList")
            ListStringMatcher.internalBinaryWrite(message.statsMatcher.inclusionList, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.StatsMatcher
 */
export const StatsMatcher = new StatsMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagSpecifier$Type extends MessageType<TagSpecifier> {
    constructor() {
        super("envoy.config.metrics.v2.TagSpecifier", [
            { no: 1, name: "tag_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "regex", kind: "scalar", oneof: "tagValue", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024" } } } },
            { no: 3, name: "fixed_value", kind: "scalar", oneof: "tagValue", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagSpecifier>): TagSpecifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagName = "";
        message.tagValue = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TagSpecifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagSpecifier): TagSpecifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tag_name */ 1:
                    message.tagName = reader.string();
                    break;
                case /* string regex */ 2:
                    message.tagValue = {
                        oneofKind: "regex",
                        regex: reader.string()
                    };
                    break;
                case /* string fixed_value */ 3:
                    message.tagValue = {
                        oneofKind: "fixedValue",
                        fixedValue: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagSpecifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tag_name = 1; */
        if (message.tagName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tagName);
        /* string regex = 2; */
        if (message.tagValue.oneofKind === "regex")
            writer.tag(2, WireType.LengthDelimited).string(message.tagValue.regex);
        /* string fixed_value = 3; */
        if (message.tagValue.oneofKind === "fixedValue")
            writer.tag(3, WireType.LengthDelimited).string(message.tagValue.fixedValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.TagSpecifier
 */
export const TagSpecifier = new TagSpecifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatsdSink$Type extends MessageType<StatsdSink> {
    constructor() {
        super("envoy.config.metrics.v2.StatsdSink", [
            { no: 1, name: "address", kind: "message", oneof: "statsdSpecifier", T: () => Address },
            { no: 2, name: "tcp_cluster_name", kind: "scalar", oneof: "statsdSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatsdSink>): StatsdSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statsdSpecifier = { oneofKind: undefined };
        message.prefix = "";
        if (value !== undefined)
            reflectionMergePartial<StatsdSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatsdSink): StatsdSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Address address */ 1:
                    message.statsdSpecifier = {
                        oneofKind: "address",
                        address: Address.internalBinaryRead(reader, reader.uint32(), options, (message.statsdSpecifier as any).address)
                    };
                    break;
                case /* string tcp_cluster_name */ 2:
                    message.statsdSpecifier = {
                        oneofKind: "tcpClusterName",
                        tcpClusterName: reader.string()
                    };
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatsdSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Address address = 1; */
        if (message.statsdSpecifier.oneofKind === "address")
            Address.internalBinaryWrite(message.statsdSpecifier.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string tcp_cluster_name = 2; */
        if (message.statsdSpecifier.oneofKind === "tcpClusterName")
            writer.tag(2, WireType.LengthDelimited).string(message.statsdSpecifier.tcpClusterName);
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.StatsdSink
 */
export const StatsdSink = new StatsdSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DogStatsdSink$Type extends MessageType<DogStatsdSink> {
    constructor() {
        super("envoy.config.metrics.v2.DogStatsdSink", [
            { no: 1, name: "address", kind: "message", oneof: "dogStatsdSpecifier", T: () => Address },
            { no: 3, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DogStatsdSink>): DogStatsdSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dogStatsdSpecifier = { oneofKind: undefined };
        message.prefix = "";
        if (value !== undefined)
            reflectionMergePartial<DogStatsdSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DogStatsdSink): DogStatsdSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Address address */ 1:
                    message.dogStatsdSpecifier = {
                        oneofKind: "address",
                        address: Address.internalBinaryRead(reader, reader.uint32(), options, (message.dogStatsdSpecifier as any).address)
                    };
                    break;
                case /* string prefix */ 3:
                    message.prefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DogStatsdSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Address address = 1; */
        if (message.dogStatsdSpecifier.oneofKind === "address")
            Address.internalBinaryWrite(message.dogStatsdSpecifier.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string prefix = 3; */
        if (message.prefix !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.prefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.DogStatsdSink
 */
export const DogStatsdSink = new DogStatsdSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HystrixSink$Type extends MessageType<HystrixSink> {
    constructor() {
        super("envoy.config.metrics.v2.HystrixSink", [
            { no: 1, name: "num_buckets", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HystrixSink>): HystrixSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.numBuckets = 0n;
        if (value !== undefined)
            reflectionMergePartial<HystrixSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HystrixSink): HystrixSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_buckets */ 1:
                    message.numBuckets = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HystrixSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_buckets = 1; */
        if (message.numBuckets !== 0n)
            writer.tag(1, WireType.Varint).int64(message.numBuckets);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.metrics.v2.HystrixSink
 */
export const HystrixSink = new HystrixSink$Type();
