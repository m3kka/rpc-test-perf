// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/listener/v3/listener_components.proto" (package "envoy.config.listener.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int32Range } from "../../../type/v3/range";
import { Duration } from "../../../../google/protobuf/duration";
import { TransportSocket } from "../../core/v3/base";
import { Metadata } from "../../core/v3/base";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { CidrRange } from "../../core/v3/address";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { ExtensionConfigSource } from "../../core/v3/config_source";
import { Any } from "../../../../google/protobuf/any";
// [#protodoc-title: Listener components]
// Listener :ref:`configuration overview <config_listeners>`

/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.listener.v3.Filter
 */
export interface Filter {
    /**
     * The name of the filter configuration.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * Filter specific configuration which depends on the filter being
         * instantiated. See the supported filters for further documentation.
         * [#extension-category: envoy.filters.network]
         *
         * @generated from protobuf field: google.protobuf.Any typed_config = 4;
         */
        typedConfig: Any;
    } | {
        oneofKind: "configDiscovery";
        /**
         * Configuration source specifier for an extension configuration discovery
         * service. In case of a failure and without the default configuration, the
         * listener closes the connections.
         * [#not-implemented-hide:]
         *
         * @generated from protobuf field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 5;
         */
        configDiscovery: ExtensionConfigSource;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Directly connected source IP address (this will only be different from the source IP address
 *    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
 *    listener filter <config_listener_filters_proxy_protocol>`).
 * 7. Source type (e.g. any, local or external network).
 * 8. Source IP address.
 * 9. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * A different way to reason about the filter chain matches:
 * Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
 * In each step, filter chains which most specifically matches the attributes continue to the next step.
 * The listener guarantees at most 1 filter chain is left after all of the steps.
 *
 * Example:
 *
 * For destination port, filter chains specifying the destination port of incoming traffic are the
 * most specific match. If none of the filter chains specifies the exact destination port, the filter
 * chains which do not specify ports are the most specific match. Filter chains specifying the
 * wrong port can never be the most specific match.
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 14]
 *
 * @generated from protobuf message envoy.config.listener.v3.FilterChainMatch
 */
export interface FilterChainMatch {
    /**
     * Optional destination port to consider when use_original_dst is set on the
     * listener in determining a filter chain match.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value destination_port = 8;
     */
    destinationPort?: UInt32Value;
    /**
     * If non-empty, an IP address and prefix length to match addresses when the
     * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange prefix_ranges = 3;
     */
    prefixRanges: CidrRange[];
    /**
     * If non-empty, an IP address and suffix length to match addresses when the
     * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string address_suffix = 4;
     */
    addressSuffix: string;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value suffix_len = 5;
     */
    suffixLen?: UInt32Value;
    /**
     * The criteria is satisfied if the directly connected source IP address of the downstream
     * connection is contained in at least one of the specified subnets. If the parameter is not
     * specified or the list is empty, the directly connected source IP address is ignored.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange direct_source_prefix_ranges = 13;
     */
    directSourcePrefixRanges: CidrRange[];
    /**
     * Specifies the connection source IP match type. Can be any, local or external network.
     *
     * @generated from protobuf field: envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type = 12;
     */
    sourceType: FilterChainMatch_ConnectionSourceType;
    /**
     * The criteria is satisfied if the source IP address of the downstream
     * connection is contained in at least one of the specified subnets. If the
     * parameter is not specified or the list is empty, the source IP address is
     * ignored.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.CidrRange source_prefix_ranges = 6;
     */
    sourcePrefixRanges: CidrRange[];
    /**
     * The criteria is satisfied if the source port of the downstream connection
     * is contained in at least one of the specified ports. If the parameter is
     * not specified, the source port is ignored.
     *
     * @generated from protobuf field: repeated uint32 source_ports = 7;
     */
    sourcePorts: number[];
    /**
     * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
     * a filter chain match. Those values will be compared against the server names of a new
     * connection, when detected by one of the listener filters.
     *
     * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
     * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
     *
     * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
     * The value ``*`` is also not supported, and ``server_names`` should be omitted instead.
     *
     * .. attention::
     *
     *   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
     *   information.
     *
     * @generated from protobuf field: repeated string server_names = 11;
     */
    serverNames: string[];
    /**
     * If non-empty, a transport protocol to consider when determining a filter chain match.
     * This value will be compared against the transport protocol of a new connection, when
     * it's detected by one of the listener filters.
     *
     * Suggested values include:
     *
     * * ``raw_buffer`` - default, used when no transport protocol is detected,
     * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
     *   when TLS protocol is detected.
     *
     * @generated from protobuf field: string transport_protocol = 9;
     */
    transportProtocol: string;
    /**
     * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
     * determining a filter chain match. Those values will be compared against the application
     * protocols of a new connection, when detected by one of the listener filters.
     *
     * Suggested values include:
     *
     * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
     *   <config_listener_filters_tls_inspector>`,
     * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
     *
     * .. attention::
     *
     *   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
     *   application protocol detection based on the requested
     *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
     *
     *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
     *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
     *   unless all connecting clients are known to use ALPN.
     *
     * @generated from protobuf field: repeated string application_protocols = 10;
     */
    applicationProtocols: string[];
}
/**
 * @generated from protobuf enum envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType
 */
export enum FilterChainMatch_ConnectionSourceType {
    /**
     * Any connection source matches.
     *
     * @generated from protobuf enum value: ANY = 0;
     */
    ANY = 0,
    /**
     * Match a connection originating from the same host.
     *
     * @generated from protobuf enum value: SAME_IP_OR_LOOPBACK = 1;
     */
    SAME_IP_OR_LOOPBACK = 1,
    /**
     * Match a connection originating from a different host.
     *
     * @generated from protobuf enum value: EXTERNAL = 2;
     */
    EXTERNAL = 2
}
/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.config.listener.v3.FilterChain
 */
export interface FilterChain {
    /**
     * The criteria to use when matching a connection to this filter chain.
     *
     * @generated from protobuf field: envoy.config.listener.v3.FilterChainMatch filter_chain_match = 1;
     */
    filterChainMatch?: FilterChainMatch;
    /**
     * A list of individual network filters that make up the filter chain for
     * connections established with the listener. Order matters as the filters are
     * processed sequentially as connection events happen. Note: If the filter
     * list is empty, the connection will close by default.
     *
     * For QUIC listeners, network filters other than HTTP Connection Manager (HCM)
     * can be created, but due to differences in the connection implementation compared
     * to TCP, the onData() method will never be called. Therefore, network filters
     * for QUIC listeners should only expect to do work at the start of a new connection
     * (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain.
     *
     * @generated from protobuf field: repeated envoy.config.listener.v3.Filter filters = 3;
     */
    filters: Filter[];
    /**
     * Whether the listener should expect a PROXY protocol V1 header on new
     * connections. If this option is enabled, the listener will assume that that
     * remote address of the connection is the one specified in the header. Some
     * load balancers including the AWS ELB support this option. If the option is
     * absent or set to false, Envoy will use the physical peer address of the
     * connection as the remote address.
     *
     * This field is deprecated. Add a
     * :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>`
     * explicitly instead.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.BoolValue use_proxy_proto = 4 [deprecated = true];
     */
    useProxyProto?: BoolValue;
    /**
     * [#not-implemented-hide:] filter chain metadata.
     *
     * @generated from protobuf field: envoy.config.core.v3.Metadata metadata = 5;
     */
    metadata?: Metadata;
    /**
     * Optional custom transport socket implementation to use for downstream connections.
     * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
     * :ref:`DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` in the ``typed_config``.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     * [#extension-category: envoy.transport_sockets.downstream]
     *
     * @generated from protobuf field: envoy.config.core.v3.TransportSocket transport_socket = 6;
     */
    transportSocket?: TransportSocket;
    /**
     * If present and nonzero, the amount of time to allow incoming connections to complete any
     * transport socket negotiations. If this expires before the transport reports connection
     * establishment, the connection is summarily closed.
     *
     * @generated from protobuf field: google.protobuf.Duration transport_socket_connect_timeout = 9;
     */
    transportSocketConnectTimeout?: Duration;
    /**
     * The unique name (or empty) by which this filter chain is known.
     * Note: :ref:`filter_chain_matcher
     * <envoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher>`
     * requires that filter chains are uniquely named within a listener.
     *
     * @generated from protobuf field: string name = 7;
     */
    name: string;
    /**
     * [#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand.
     * If this field is not empty, the filter chain will be built on-demand.
     * Otherwise, the filter chain will be built normally and block listener warming.
     *
     * @generated from protobuf field: envoy.config.listener.v3.FilterChain.OnDemandConfiguration on_demand_configuration = 8;
     */
    onDemandConfiguration?: FilterChain_OnDemandConfiguration;
}
/**
 * The configuration for on-demand filter chain. If this field is not empty in FilterChain message,
 * a filter chain will be built on-demand.
 * On-demand filter chains help speedup the warming up of listeners since the building and initialization of
 * an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain.
 * Filter chains that are not often used can be set as on-demand.
 *
 * @generated from protobuf message envoy.config.listener.v3.FilterChain.OnDemandConfiguration
 */
export interface FilterChain_OnDemandConfiguration {
    /**
     * The timeout to wait for filter chain placeholders to complete rebuilding.
     * 1. If this field is set to 0, timeout is disabled.
     * 2. If not specified, a default timeout of 15s is used.
     * Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached.
     * Upon failure or timeout, all connections related to this filter chain will be closed.
     * Rebuilding will start again on the next new connection.
     *
     * @generated from protobuf field: google.protobuf.Duration rebuild_timeout = 1;
     */
    rebuildTimeout?: Duration;
}
/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.listener.v3.ListenerFilterChainMatchPredicate
 */
export interface ListenerFilterChainMatchPredicate {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "orMatch";
        /**
         * A set that describes a logical OR. If any member of the set matches, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet or_match = 1;
         */
        orMatch: ListenerFilterChainMatchPredicate_MatchSet;
    } | {
        oneofKind: "andMatch";
        /**
         * A set that describes a logical AND. If all members of the set match, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet and_match = 2;
         */
        andMatch: ListenerFilterChainMatchPredicate_MatchSet;
    } | {
        oneofKind: "notMatch";
        /**
         * A negation match. The match configuration will match if the negated match condition matches.
         *
         * @generated from protobuf field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate not_match = 3;
         */
        notMatch: ListenerFilterChainMatchPredicate;
    } | {
        oneofKind: "anyMatch";
        /**
         * The match configuration will always match.
         *
         * @generated from protobuf field: bool any_match = 4;
         */
        anyMatch: boolean;
    } | {
        oneofKind: "destinationPortRange";
        /**
         * Match destination port. Particularly, the match evaluation must use the recovered local port if
         * the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
         *
         * @generated from protobuf field: envoy.type.v3.Int32Range destination_port_range = 5;
         */
        destinationPortRange: Int32Range;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of match configurations used for logical operations.
 *
 * @generated from protobuf message envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet
 */
export interface ListenerFilterChainMatchPredicate_MatchSet {
    /**
     * The list of rules that make up the set.
     *
     * @generated from protobuf field: repeated envoy.config.listener.v3.ListenerFilterChainMatchPredicate rules = 1;
     */
    rules: ListenerFilterChainMatchPredicate[];
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.listener.v3.ListenerFilter
 */
export interface ListenerFilter {
    /**
     * The name of the filter configuration.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * Filter specific configuration which depends on the filter being
         * instantiated. See the supported filters for further documentation.
         * [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]
         *
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: "configDiscovery";
        /**
         * Configuration source specifier for an extension configuration discovery
         * service. In case of a failure and without the default configuration, the
         * listener closes the connections.
         *
         * @generated from protobuf field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 5;
         */
        configDiscovery: ExtensionConfigSource;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
     * See :ref:`ListenerFilterChainMatchPredicate <envoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate>`
     * for further examples.
     *
     * @generated from protobuf field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate filter_disabled = 4;
     */
    filterDisabled?: ListenerFilterChainMatchPredicate;
}
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends MessageType<Filter> {
    constructor() {
        super("envoy.config.listener.v3.Filter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 4, name: "typed_config", kind: "message", oneof: "configType", T: () => Any },
            { no: 5, name: "config_discovery", kind: "message", oneof: "configType", T: () => ExtensionConfigSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.Filter" } });
    }
    create(value?: PartialMessage<Filter>): Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter): Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 4:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                case /* envoy.config.core.v3.ExtensionConfigSource config_discovery */ 5:
                    message.configType = {
                        oneofKind: "configDiscovery",
                        configDiscovery: ExtensionConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).configDiscovery)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 4; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ExtensionConfigSource config_discovery = 5; */
        if (message.configType.oneofKind === "configDiscovery")
            ExtensionConfigSource.internalBinaryWrite(message.configType.configDiscovery, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.Filter
 */
export const Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterChainMatch$Type extends MessageType<FilterChainMatch> {
    constructor() {
        super("envoy.config.listener.v3.FilterChainMatch", [
            { no: 8, name: "destination_port", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 65535, gte: 1 } } } },
            { no: 3, name: "prefix_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 4, name: "address_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "suffix_len", kind: "message", T: () => UInt32Value },
            { no: 13, name: "direct_source_prefix_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 12, name: "source_type", kind: "enum", T: () => ["envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType", FilterChainMatch_ConnectionSourceType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 6, name: "source_prefix_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 7, name: "source_ports", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { repeated: { items: { uint32: { lte: 65535, gte: 1 } } } } } },
            { no: 11, name: "server_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "transport_protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "application_protocols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.FilterChainMatch" } });
    }
    create(value?: PartialMessage<FilterChainMatch>): FilterChainMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefixRanges = [];
        message.addressSuffix = "";
        message.directSourcePrefixRanges = [];
        message.sourceType = 0;
        message.sourcePrefixRanges = [];
        message.sourcePorts = [];
        message.serverNames = [];
        message.transportProtocol = "";
        message.applicationProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<FilterChainMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterChainMatch): FilterChainMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value destination_port */ 8:
                    message.destinationPort = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.destinationPort);
                    break;
                case /* repeated envoy.config.core.v3.CidrRange prefix_ranges */ 3:
                    message.prefixRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string address_suffix */ 4:
                    message.addressSuffix = reader.string();
                    break;
                case /* google.protobuf.UInt32Value suffix_len */ 5:
                    message.suffixLen = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.suffixLen);
                    break;
                case /* repeated envoy.config.core.v3.CidrRange direct_source_prefix_ranges */ 13:
                    message.directSourcePrefixRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type */ 12:
                    message.sourceType = reader.int32();
                    break;
                case /* repeated envoy.config.core.v3.CidrRange source_prefix_ranges */ 6:
                    message.sourcePrefixRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 source_ports */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sourcePorts.push(reader.uint32());
                    else
                        message.sourcePorts.push(reader.uint32());
                    break;
                case /* repeated string server_names */ 11:
                    message.serverNames.push(reader.string());
                    break;
                case /* string transport_protocol */ 9:
                    message.transportProtocol = reader.string();
                    break;
                case /* repeated string application_protocols */ 10:
                    message.applicationProtocols.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterChainMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value destination_port = 8; */
        if (message.destinationPort)
            UInt32Value.internalBinaryWrite(message.destinationPort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.CidrRange prefix_ranges = 3; */
        for (let i = 0; i < message.prefixRanges.length; i++)
            CidrRange.internalBinaryWrite(message.prefixRanges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string address_suffix = 4; */
        if (message.addressSuffix !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.addressSuffix);
        /* google.protobuf.UInt32Value suffix_len = 5; */
        if (message.suffixLen)
            UInt32Value.internalBinaryWrite(message.suffixLen, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.CidrRange direct_source_prefix_ranges = 13; */
        for (let i = 0; i < message.directSourcePrefixRanges.length; i++)
            CidrRange.internalBinaryWrite(message.directSourcePrefixRanges[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type = 12; */
        if (message.sourceType !== 0)
            writer.tag(12, WireType.Varint).int32(message.sourceType);
        /* repeated envoy.config.core.v3.CidrRange source_prefix_ranges = 6; */
        for (let i = 0; i < message.sourcePrefixRanges.length; i++)
            CidrRange.internalBinaryWrite(message.sourcePrefixRanges[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 source_ports = 7; */
        if (message.sourcePorts.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sourcePorts.length; i++)
                writer.uint32(message.sourcePorts[i]);
            writer.join();
        }
        /* repeated string server_names = 11; */
        for (let i = 0; i < message.serverNames.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.serverNames[i]);
        /* string transport_protocol = 9; */
        if (message.transportProtocol !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.transportProtocol);
        /* repeated string application_protocols = 10; */
        for (let i = 0; i < message.applicationProtocols.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.applicationProtocols[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.FilterChainMatch
 */
export const FilterChainMatch = new FilterChainMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterChain$Type extends MessageType<FilterChain> {
    constructor() {
        super("envoy.config.listener.v3.FilterChain", [
            { no: 1, name: "filter_chain_match", kind: "message", T: () => FilterChainMatch },
            { no: 3, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Filter },
            { no: 4, name: "use_proxy_proto", kind: "message", T: () => BoolValue, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 5, name: "metadata", kind: "message", T: () => Metadata },
            { no: 6, name: "transport_socket", kind: "message", T: () => TransportSocket },
            { no: 9, name: "transport_socket_connect_timeout", kind: "message", T: () => Duration },
            { no: 7, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "on_demand_configuration", kind: "message", T: () => FilterChain_OnDemandConfiguration }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.FilterChain" } });
    }
    create(value?: PartialMessage<FilterChain>): FilterChain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<FilterChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterChain): FilterChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.listener.v3.FilterChainMatch filter_chain_match */ 1:
                    message.filterChainMatch = FilterChainMatch.internalBinaryRead(reader, reader.uint32(), options, message.filterChainMatch);
                    break;
                case /* repeated envoy.config.listener.v3.Filter filters */ 3:
                    message.filters.push(Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue use_proxy_proto = 4 [deprecated = true];*/ 4:
                    message.useProxyProto = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.useProxyProto);
                    break;
                case /* envoy.config.core.v3.Metadata metadata */ 5:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.config.core.v3.TransportSocket transport_socket */ 6:
                    message.transportSocket = TransportSocket.internalBinaryRead(reader, reader.uint32(), options, message.transportSocket);
                    break;
                case /* google.protobuf.Duration transport_socket_connect_timeout */ 9:
                    message.transportSocketConnectTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.transportSocketConnectTimeout);
                    break;
                case /* string name */ 7:
                    message.name = reader.string();
                    break;
                case /* envoy.config.listener.v3.FilterChain.OnDemandConfiguration on_demand_configuration */ 8:
                    message.onDemandConfiguration = FilterChain_OnDemandConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.onDemandConfiguration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.listener.v3.FilterChainMatch filter_chain_match = 1; */
        if (message.filterChainMatch)
            FilterChainMatch.internalBinaryWrite(message.filterChainMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.listener.v3.Filter filters = 3; */
        for (let i = 0; i < message.filters.length; i++)
            Filter.internalBinaryWrite(message.filters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue use_proxy_proto = 4 [deprecated = true]; */
        if (message.useProxyProto)
            BoolValue.internalBinaryWrite(message.useProxyProto, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Metadata metadata = 5; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TransportSocket transport_socket = 6; */
        if (message.transportSocket)
            TransportSocket.internalBinaryWrite(message.transportSocket, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration transport_socket_connect_timeout = 9; */
        if (message.transportSocketConnectTimeout)
            Duration.internalBinaryWrite(message.transportSocketConnectTimeout, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string name = 7; */
        if (message.name !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.name);
        /* envoy.config.listener.v3.FilterChain.OnDemandConfiguration on_demand_configuration = 8; */
        if (message.onDemandConfiguration)
            FilterChain_OnDemandConfiguration.internalBinaryWrite(message.onDemandConfiguration, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.FilterChain
 */
export const FilterChain = new FilterChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterChain_OnDemandConfiguration$Type extends MessageType<FilterChain_OnDemandConfiguration> {
    constructor() {
        super("envoy.config.listener.v3.FilterChain.OnDemandConfiguration", [
            { no: 1, name: "rebuild_timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<FilterChain_OnDemandConfiguration>): FilterChain_OnDemandConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FilterChain_OnDemandConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterChain_OnDemandConfiguration): FilterChain_OnDemandConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration rebuild_timeout */ 1:
                    message.rebuildTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.rebuildTimeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterChain_OnDemandConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration rebuild_timeout = 1; */
        if (message.rebuildTimeout)
            Duration.internalBinaryWrite(message.rebuildTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.FilterChain.OnDemandConfiguration
 */
export const FilterChain_OnDemandConfiguration = new FilterChain_OnDemandConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilterChainMatchPredicate$Type extends MessageType<ListenerFilterChainMatchPredicate> {
    constructor() {
        super("envoy.config.listener.v3.ListenerFilterChainMatchPredicate", [
            { no: 1, name: "or_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate_MatchSet },
            { no: 2, name: "and_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate_MatchSet },
            { no: 3, name: "not_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate },
            { no: 4, name: "any_match", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 5, name: "destination_port_range", kind: "message", oneof: "rule", T: () => Int32Range }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.ListenerFilterChainMatchPredicate" } });
    }
    create(value?: PartialMessage<ListenerFilterChainMatchPredicate>): ListenerFilterChainMatchPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ListenerFilterChainMatchPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilterChainMatchPredicate): ListenerFilterChainMatchPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet or_match */ 1:
                    message.rule = {
                        oneofKind: "orMatch",
                        orMatch: ListenerFilterChainMatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orMatch)
                    };
                    break;
                case /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet and_match */ 2:
                    message.rule = {
                        oneofKind: "andMatch",
                        andMatch: ListenerFilterChainMatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andMatch)
                    };
                    break;
                case /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate not_match */ 3:
                    message.rule = {
                        oneofKind: "notMatch",
                        notMatch: ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notMatch)
                    };
                    break;
                case /* bool any_match */ 4:
                    message.rule = {
                        oneofKind: "anyMatch",
                        anyMatch: reader.bool()
                    };
                    break;
                case /* envoy.type.v3.Int32Range destination_port_range */ 5:
                    message.rule = {
                        oneofKind: "destinationPortRange",
                        destinationPortRange: Int32Range.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).destinationPortRange)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilterChainMatchPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet or_match = 1; */
        if (message.rule.oneofKind === "orMatch")
            ListenerFilterChainMatchPredicate_MatchSet.internalBinaryWrite(message.rule.orMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet and_match = 2; */
        if (message.rule.oneofKind === "andMatch")
            ListenerFilterChainMatchPredicate_MatchSet.internalBinaryWrite(message.rule.andMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate not_match = 3; */
        if (message.rule.oneofKind === "notMatch")
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.rule.notMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool any_match = 4; */
        if (message.rule.oneofKind === "anyMatch")
            writer.tag(4, WireType.Varint).bool(message.rule.anyMatch);
        /* envoy.type.v3.Int32Range destination_port_range = 5; */
        if (message.rule.oneofKind === "destinationPortRange")
            Int32Range.internalBinaryWrite(message.rule.destinationPortRange, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.ListenerFilterChainMatchPredicate
 */
export const ListenerFilterChainMatchPredicate = new ListenerFilterChainMatchPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilterChainMatchPredicate_MatchSet$Type extends MessageType<ListenerFilterChainMatchPredicate_MatchSet> {
    constructor() {
        super("envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenerFilterChainMatchPredicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet" } });
    }
    create(value?: PartialMessage<ListenerFilterChainMatchPredicate_MatchSet>): ListenerFilterChainMatchPredicate_MatchSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<ListenerFilterChainMatchPredicate_MatchSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilterChainMatchPredicate_MatchSet): ListenerFilterChainMatchPredicate_MatchSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.listener.v3.ListenerFilterChainMatchPredicate rules */ 1:
                    message.rules.push(ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilterChainMatchPredicate_MatchSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.listener.v3.ListenerFilterChainMatchPredicate rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet
 */
export const ListenerFilterChainMatchPredicate_MatchSet = new ListenerFilterChainMatchPredicate_MatchSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilter$Type extends MessageType<ListenerFilter> {
    constructor() {
        super("envoy.config.listener.v3.ListenerFilter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any },
            { no: 5, name: "config_discovery", kind: "message", oneof: "configType", T: () => ExtensionConfigSource },
            { no: 4, name: "filter_disabled", kind: "message", T: () => ListenerFilterChainMatchPredicate }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.ListenerFilter" } });
    }
    create(value?: PartialMessage<ListenerFilter>): ListenerFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ListenerFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilter): ListenerFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                case /* envoy.config.core.v3.ExtensionConfigSource config_discovery */ 5:
                    message.configType = {
                        oneofKind: "configDiscovery",
                        configDiscovery: ExtensionConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).configDiscovery)
                    };
                    break;
                case /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate filter_disabled */ 4:
                    message.filterDisabled = ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options, message.filterDisabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.ExtensionConfigSource config_discovery = 5; */
        if (message.configType.oneofKind === "configDiscovery")
            ExtensionConfigSource.internalBinaryWrite(message.configType.configDiscovery, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.listener.v3.ListenerFilterChainMatchPredicate filter_disabled = 4; */
        if (message.filterDisabled)
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.filterDisabled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.ListenerFilter
 */
export const ListenerFilter = new ListenerFilter$Type();
