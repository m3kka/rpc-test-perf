// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/listener/v3/listener_components.proto (package envoy.config.listener.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, Duration, proto3, UInt32Value } from "@bufbuild/protobuf";
import { ExtensionConfigSource } from "../../core/v3/config_source_pb.js";
import { CidrRange } from "../../core/v3/address_pb.js";
import { Metadata, TransportSocket } from "../../core/v3/base_pb.js";
import { Int32Range } from "../../../type/v3/range_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.Filter
 */
export const Filter = proto3.makeMessageType(
  "envoy.config.listener.v3.Filter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
    { no: 5, name: "config_discovery", kind: "message", T: ExtensionConfigSource, oneof: "config_type" },
  ],
);

/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Directly connected source IP address (this will only be different from the source IP address
 *    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
 *    listener filter <config_listener_filters_proxy_protocol>`).
 * 7. Source type (e.g. any, local or external network).
 * 8. Source IP address.
 * 9. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * A different way to reason about the filter chain matches:
 * Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
 * In each step, filter chains which most specifically matches the attributes continue to the next step.
 * The listener guarantees at most 1 filter chain is left after all of the steps.
 *
 * Example:
 *
 * For destination port, filter chains specifying the destination port of incoming traffic are the
 * most specific match. If none of the filter chains specifies the exact destination port, the filter
 * chains which do not specify ports are the most specific match. Filter chains specifying the
 * wrong port can never be the most specific match.
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 14]
 *
 * @generated from message envoy.config.listener.v3.FilterChainMatch
 */
export const FilterChainMatch = proto3.makeMessageType(
  "envoy.config.listener.v3.FilterChainMatch",
  () => [
    { no: 8, name: "destination_port", kind: "message", T: UInt32Value },
    { no: 3, name: "prefix_ranges", kind: "message", T: CidrRange, repeated: true },
    { no: 4, name: "address_suffix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "suffix_len", kind: "message", T: UInt32Value },
    { no: 13, name: "direct_source_prefix_ranges", kind: "message", T: CidrRange, repeated: true },
    { no: 12, name: "source_type", kind: "enum", T: proto3.getEnumType(FilterChainMatch_ConnectionSourceType) },
    { no: 6, name: "source_prefix_ranges", kind: "message", T: CidrRange, repeated: true },
    { no: 7, name: "source_ports", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 11, name: "server_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "transport_protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "application_protocols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
);

/**
 * @generated from enum envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType
 */
export const FilterChainMatch_ConnectionSourceType = proto3.makeEnum(
  "envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType",
  [
    {no: 0, name: "ANY"},
    {no: 1, name: "SAME_IP_OR_LOOPBACK"},
    {no: 2, name: "EXTERNAL"},
  ],
);

/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 10]
 *
 * @generated from message envoy.config.listener.v3.FilterChain
 */
export const FilterChain = proto3.makeMessageType(
  "envoy.config.listener.v3.FilterChain",
  () => [
    { no: 1, name: "filter_chain_match", kind: "message", T: FilterChainMatch },
    { no: 3, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 4, name: "use_proxy_proto", kind: "message", T: BoolValue },
    { no: 5, name: "metadata", kind: "message", T: Metadata },
    { no: 6, name: "transport_socket", kind: "message", T: TransportSocket },
    { no: 9, name: "transport_socket_connect_timeout", kind: "message", T: Duration },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "on_demand_configuration", kind: "message", T: FilterChain_OnDemandConfiguration },
  ],
);

/**
 * The configuration for on-demand filter chain. If this field is not empty in FilterChain message,
 * a filter chain will be built on-demand.
 * On-demand filter chains help speedup the warming up of listeners since the building and initialization of
 * an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain.
 * Filter chains that are not often used can be set as on-demand.
 *
 * @generated from message envoy.config.listener.v3.FilterChain.OnDemandConfiguration
 */
export const FilterChain_OnDemandConfiguration = proto3.makeMessageType(
  "envoy.config.listener.v3.FilterChain.OnDemandConfiguration",
  () => [
    { no: 1, name: "rebuild_timeout", kind: "message", T: Duration },
  ],
  {localName: "FilterChain_OnDemandConfiguration"},
);

/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.ListenerFilterChainMatchPredicate
 */
export const ListenerFilterChainMatchPredicate = proto3.makeMessageType(
  "envoy.config.listener.v3.ListenerFilterChainMatchPredicate",
  () => [
    { no: 1, name: "or_match", kind: "message", T: ListenerFilterChainMatchPredicate_MatchSet, oneof: "rule" },
    { no: 2, name: "and_match", kind: "message", T: ListenerFilterChainMatchPredicate_MatchSet, oneof: "rule" },
    { no: 3, name: "not_match", kind: "message", T: ListenerFilterChainMatchPredicate, oneof: "rule" },
    { no: 4, name: "any_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 5, name: "destination_port_range", kind: "message", T: Int32Range, oneof: "rule" },
  ],
);

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet
 */
export const ListenerFilterChainMatchPredicate_MatchSet = proto3.makeMessageType(
  "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet",
  () => [
    { no: 1, name: "rules", kind: "message", T: ListenerFilterChainMatchPredicate, repeated: true },
  ],
  {localName: "ListenerFilterChainMatchPredicate_MatchSet"},
);

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.ListenerFilter
 */
export const ListenerFilter = proto3.makeMessageType(
  "envoy.config.listener.v3.ListenerFilter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
    { no: 5, name: "config_discovery", kind: "message", T: ExtensionConfigSource, oneof: "config_type" },
    { no: 4, name: "filter_disabled", kind: "message", T: ListenerFilterChainMatchPredicate },
  ],
);

