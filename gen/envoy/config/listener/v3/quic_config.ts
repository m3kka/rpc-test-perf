// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/listener/v3/quic_config.proto" (package "envoy.config.listener.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TypedExtensionConfig } from "../../core/v3/extension";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { RuntimeFeatureFlag } from "../../core/v3/base";
import { Duration } from "../../../../google/protobuf/duration";
import { QuicProtocolOptions as QuicProtocolOptions$ } from "../../core/v3/protocol";
// [#protodoc-title: QUIC listener config]

/**
 * Configuration specific to the UDP QUIC listener.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.config.listener.v3.QuicProtocolOptions
 */
export interface QuicProtocolOptions {
    /**
     * @generated from protobuf field: envoy.config.core.v3.QuicProtocolOptions quic_protocol_options = 1;
     */
    quicProtocolOptions?: QuicProtocolOptions$;
    /**
     * Maximum number of milliseconds that connection will be alive when there is
     * no network activity.
     *
     * If it is less than 1ms, Envoy will use 1ms. 300000ms if not specified.
     *
     * @generated from protobuf field: google.protobuf.Duration idle_timeout = 2;
     */
    idleTimeout?: Duration;
    /**
     * Connection timeout in milliseconds before the crypto handshake is finished.
     *
     * If it is less than 5000ms, Envoy will use 5000ms. 20000ms if not specified.
     *
     * @generated from protobuf field: google.protobuf.Duration crypto_handshake_timeout = 3;
     */
    cryptoHandshakeTimeout?: Duration;
    /**
     * Runtime flag that controls whether the listener is enabled or not. If not specified, defaults
     * to enabled.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFeatureFlag enabled = 4;
     */
    enabled?: RuntimeFeatureFlag;
    /**
     * A multiplier to number of connections which is used to determine how many packets to read per
     * event loop. A reasonable number should allow the listener to process enough payload but not
     * starve TCP and other UDP sockets and also prevent long event loop duration.
     * The default value is 32. This means if there are N QUIC connections, the total number of
     * packets to read in each read event will be 32 * N.
     * The actual number of packets to read in total by the UDP listener is also
     * bound by 6000, regardless of this field or how many connections there are.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value packets_to_read_to_connection_count_ratio = 5;
     */
    packetsToReadToConnectionCountRatio?: UInt32Value;
    /**
     * Configure which implementation of ``quic::QuicCryptoClientStreamBase`` to be used for this listener.
     * If not specified the :ref:`QUICHE default one configured by <envoy_v3_api_msg_extensions.quic.crypto_stream.v3.CryptoServerStreamConfig>` will be used.
     * [#extension-category: envoy.quic.server.crypto_stream]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig crypto_stream_config = 6;
     */
    cryptoStreamConfig?: TypedExtensionConfig;
    /**
     * Configure which implementation of ``quic::ProofSource`` to be used for this listener.
     * If not specified the :ref:`default one configured by <envoy_v3_api_msg_extensions.quic.proof_source.v3.ProofSourceConfig>` will be used.
     * [#extension-category: envoy.quic.proof_source]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig proof_source_config = 7;
     */
    proofSourceConfig?: TypedExtensionConfig;
    /**
     * Config which implementation of ``quic::ConnectionIdGeneratorInterface`` to be used for this listener.
     * If not specified the :ref:`default one configured by <envoy_v3_api_msg_extensions.quic.connection_id_generator.v3.DeterministicConnectionIdGeneratorConfig>` will be used.
     * [#extension-category: envoy.quic.connection_id_generator]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig connection_id_generator_config = 8;
     */
    connectionIdGeneratorConfig?: TypedExtensionConfig;
    /**
     * Configure the server's preferred address to advertise so that client can migrate to it. See :ref:`example <envoy_v3_api_msg_extensions.quic.server_preferred_address.v3.FixedServerPreferredAddressConfig>` which configures a pair of v4 and v6 preferred addresses.
     * The current QUICHE implementation will advertise only one of the preferred IPv4 and IPv6 addresses based on the address family the client initially connects with, and only if the client is also QUICHE-based.
     * If not specified, Envoy will not advertise any server's preferred address.
     * [#extension-category: envoy.quic.server_preferred_address]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig server_preferred_address_config = 9;
     */
    serverPreferredAddressConfig?: TypedExtensionConfig;
}
// @generated message type with reflection information, may provide speed optimized methods
class QuicProtocolOptions$Type extends MessageType<QuicProtocolOptions> {
    constructor() {
        super("envoy.config.listener.v3.QuicProtocolOptions", [
            { no: 1, name: "quic_protocol_options", kind: "message", T: () => QuicProtocolOptions$ },
            { no: 2, name: "idle_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "crypto_handshake_timeout", kind: "message", T: () => Duration },
            { no: 4, name: "enabled", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 5, name: "packets_to_read_to_connection_count_ratio", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 6, name: "crypto_stream_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 7, name: "proof_source_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 8, name: "connection_id_generator_config", kind: "message", T: () => TypedExtensionConfig },
            { no: 9, name: "server_preferred_address_config", kind: "message", T: () => TypedExtensionConfig, options: { "xds.annotations.v3.field_status": { workInProgress: true } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.listener.QuicProtocolOptions" } });
    }
    create(value?: PartialMessage<QuicProtocolOptions>): QuicProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuicProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuicProtocolOptions): QuicProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.QuicProtocolOptions quic_protocol_options */ 1:
                    message.quicProtocolOptions = QuicProtocolOptions$.internalBinaryRead(reader, reader.uint32(), options, message.quicProtocolOptions);
                    break;
                case /* google.protobuf.Duration idle_timeout */ 2:
                    message.idleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.idleTimeout);
                    break;
                case /* google.protobuf.Duration crypto_handshake_timeout */ 3:
                    message.cryptoHandshakeTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.cryptoHandshakeTimeout);
                    break;
                case /* envoy.config.core.v3.RuntimeFeatureFlag enabled */ 4:
                    message.enabled = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                case /* google.protobuf.UInt32Value packets_to_read_to_connection_count_ratio */ 5:
                    message.packetsToReadToConnectionCountRatio = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.packetsToReadToConnectionCountRatio);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig crypto_stream_config */ 6:
                    message.cryptoStreamConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.cryptoStreamConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig proof_source_config */ 7:
                    message.proofSourceConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.proofSourceConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig connection_id_generator_config */ 8:
                    message.connectionIdGeneratorConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.connectionIdGeneratorConfig);
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig server_preferred_address_config */ 9:
                    message.serverPreferredAddressConfig = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.serverPreferredAddressConfig);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuicProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.QuicProtocolOptions quic_protocol_options = 1; */
        if (message.quicProtocolOptions)
            QuicProtocolOptions$.internalBinaryWrite(message.quicProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration idle_timeout = 2; */
        if (message.idleTimeout)
            Duration.internalBinaryWrite(message.idleTimeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration crypto_handshake_timeout = 3; */
        if (message.cryptoHandshakeTimeout)
            Duration.internalBinaryWrite(message.cryptoHandshakeTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFeatureFlag enabled = 4; */
        if (message.enabled)
            RuntimeFeatureFlag.internalBinaryWrite(message.enabled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value packets_to_read_to_connection_count_ratio = 5; */
        if (message.packetsToReadToConnectionCountRatio)
            UInt32Value.internalBinaryWrite(message.packetsToReadToConnectionCountRatio, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig crypto_stream_config = 6; */
        if (message.cryptoStreamConfig)
            TypedExtensionConfig.internalBinaryWrite(message.cryptoStreamConfig, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig proof_source_config = 7; */
        if (message.proofSourceConfig)
            TypedExtensionConfig.internalBinaryWrite(message.proofSourceConfig, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig connection_id_generator_config = 8; */
        if (message.connectionIdGeneratorConfig)
            TypedExtensionConfig.internalBinaryWrite(message.connectionIdGeneratorConfig, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig server_preferred_address_config = 9; */
        if (message.serverPreferredAddressConfig)
            TypedExtensionConfig.internalBinaryWrite(message.serverPreferredAddressConfig, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.listener.v3.QuicProtocolOptions
 */
export const QuicProtocolOptions = new QuicProtocolOptions$Type();
