// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/listener/v3/listener_components.proto (package envoy.config.listener.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { ExtensionConfigSource } from "../../core/v3/config_source_pb.js";
import type { CidrRange } from "../../core/v3/address_pb.js";
import type { Metadata, TransportSocket } from "../../core/v3/base_pb.js";
import type { Int32Range } from "../../../type/v3/range_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.Filter
 */
export declare class Filter extends Message<Filter> {
  /**
   * The name of the filter configuration.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.config.listener.v3.Filter.config_type
   */
  configType: {
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     * [#extension-category: envoy.filters.network]
     *
     * @generated from field: google.protobuf.Any typed_config = 4;
     */
    value: Any;
    case: "typedConfig";
  } | {
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * listener closes the connections.
     * [#not-implemented-hide:]
     *
     * @generated from field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 5;
     */
    value: ExtensionConfigSource;
    case: "configDiscovery";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Filter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.Filter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter;

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean;
}

/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Directly connected source IP address (this will only be different from the source IP address
 *    when using a listener filter that overrides the source address, such as the :ref:`Proxy Protocol
 *    listener filter <config_listener_filters_proxy_protocol>`).
 * 7. Source type (e.g. any, local or external network).
 * 8. Source IP address.
 * 9. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * A different way to reason about the filter chain matches:
 * Suppose there exists N filter chains. Prune the filter chain set using the above 8 steps.
 * In each step, filter chains which most specifically matches the attributes continue to the next step.
 * The listener guarantees at most 1 filter chain is left after all of the steps.
 *
 * Example:
 *
 * For destination port, filter chains specifying the destination port of incoming traffic are the
 * most specific match. If none of the filter chains specifies the exact destination port, the filter
 * chains which do not specify ports are the most specific match. Filter chains specifying the
 * wrong port can never be the most specific match.
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 14]
 *
 * @generated from message envoy.config.listener.v3.FilterChainMatch
 */
export declare class FilterChainMatch extends Message<FilterChainMatch> {
  /**
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   *
   * @generated from field: google.protobuf.UInt32Value destination_port = 8;
   */
  destinationPort?: number;

  /**
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange prefix_ranges = 3;
   */
  prefixRanges: CidrRange[];

  /**
   * If non-empty, an IP address and suffix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * [#not-implemented-hide:]
   *
   * @generated from field: string address_suffix = 4;
   */
  addressSuffix: string;

  /**
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.UInt32Value suffix_len = 5;
   */
  suffixLen?: number;

  /**
   * The criteria is satisfied if the directly connected source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the parameter is not
   * specified or the list is empty, the directly connected source IP address is ignored.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange direct_source_prefix_ranges = 13;
   */
  directSourcePrefixRanges: CidrRange[];

  /**
   * Specifies the connection source IP match type. Can be any, local or external network.
   *
   * @generated from field: envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType source_type = 12;
   */
  sourceType: FilterChainMatch_ConnectionSourceType;

  /**
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   *
   * @generated from field: repeated envoy.config.core.v3.CidrRange source_prefix_ranges = 6;
   */
  sourcePrefixRanges: CidrRange[];

  /**
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   *
   * @generated from field: repeated uint32 source_ports = 7;
   */
  sourcePorts: number[];

  /**
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   *
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   *
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   * The value ``*`` is also not supported, and ``server_names`` should be omitted instead.
   *
   * .. attention::
   *
   *   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
   *   information.
   *
   * @generated from field: repeated string server_names = 11;
   */
  serverNames: string[];

  /**
   * If non-empty, a transport protocol to consider when determining a filter chain match.
   * This value will be compared against the transport protocol of a new connection, when
   * it's detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``raw_buffer`` - default, used when no transport protocol is detected,
   * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *   when TLS protocol is detected.
   *
   * @generated from field: string transport_protocol = 9;
   */
  transportProtocol: string;

  /**
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   <config_listener_filters_tls_inspector>`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *
   * .. attention::
   *
   *   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
   *   application protocol detection based on the requested
   *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
   *
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   *
   * @generated from field: repeated string application_protocols = 10;
   */
  applicationProtocols: string[];

  constructor(data?: PartialMessage<FilterChainMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.FilterChainMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterChainMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterChainMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterChainMatch;

  static equals(a: FilterChainMatch | PlainMessage<FilterChainMatch> | undefined, b: FilterChainMatch | PlainMessage<FilterChainMatch> | undefined): boolean;
}

/**
 * @generated from enum envoy.config.listener.v3.FilterChainMatch.ConnectionSourceType
 */
export declare enum FilterChainMatch_ConnectionSourceType {
  /**
   * Any connection source matches.
   *
   * @generated from enum value: ANY = 0;
   */
  ANY = 0,

  /**
   * Match a connection originating from the same host.
   *
   * @generated from enum value: SAME_IP_OR_LOOPBACK = 1;
   */
  SAME_IP_OR_LOOPBACK = 1,

  /**
   * Match a connection originating from a different host.
   *
   * @generated from enum value: EXTERNAL = 2;
   */
  EXTERNAL = 2,
}

/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 10]
 *
 * @generated from message envoy.config.listener.v3.FilterChain
 */
export declare class FilterChain extends Message<FilterChain> {
  /**
   * The criteria to use when matching a connection to this filter chain.
   *
   * @generated from field: envoy.config.listener.v3.FilterChainMatch filter_chain_match = 1;
   */
  filterChainMatch?: FilterChainMatch;

  /**
   * A list of individual network filters that make up the filter chain for
   * connections established with the listener. Order matters as the filters are
   * processed sequentially as connection events happen. Note: If the filter
   * list is empty, the connection will close by default.
   *
   * For QUIC listeners, network filters other than HTTP Connection Manager (HCM)
   * can be created, but due to differences in the connection implementation compared
   * to TCP, the onData() method will never be called. Therefore, network filters
   * for QUIC listeners should only expect to do work at the start of a new connection
   * (i.e. in onNewConnection()). HCM must be the last (or only) filter in the chain.
   *
   * @generated from field: repeated envoy.config.listener.v3.Filter filters = 3;
   */
  filters: Filter[];

  /**
   * Whether the listener should expect a PROXY protocol V1 header on new
   * connections. If this option is enabled, the listener will assume that that
   * remote address of the connection is the one specified in the header. Some
   * load balancers including the AWS ELB support this option. If the option is
   * absent or set to false, Envoy will use the physical peer address of the
   * connection as the remote address.
   *
   * This field is deprecated. Add a
   * :ref:`PROXY protocol listener filter <config_listener_filters_proxy_protocol>`
   * explicitly instead.
   *
   * @generated from field: google.protobuf.BoolValue use_proxy_proto = 4 [deprecated = true];
   * @deprecated
   */
  useProxyProto?: boolean;

  /**
   * [#not-implemented-hide:] filter chain metadata.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata = 5;
   */
  metadata?: Metadata;

  /**
   * Optional custom transport socket implementation to use for downstream connections.
   * To setup TLS, set a transport socket with name ``envoy.transport_sockets.tls`` and
   * :ref:`DownstreamTlsContext <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.DownstreamTlsContext>` in the ``typed_config``.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   * [#extension-category: envoy.transport_sockets.downstream]
   *
   * @generated from field: envoy.config.core.v3.TransportSocket transport_socket = 6;
   */
  transportSocket?: TransportSocket;

  /**
   * If present and nonzero, the amount of time to allow incoming connections to complete any
   * transport socket negotiations. If this expires before the transport reports connection
   * establishment, the connection is summarily closed.
   *
   * @generated from field: google.protobuf.Duration transport_socket_connect_timeout = 9;
   */
  transportSocketConnectTimeout?: Duration;

  /**
   * The unique name (or empty) by which this filter chain is known.
   * Note: :ref:`filter_chain_matcher
   * <envoy_v3_api_field_config.listener.v3.Listener.filter_chain_matcher>`
   * requires that filter chains are uniquely named within a listener.
   *
   * @generated from field: string name = 7;
   */
  name: string;

  /**
   * [#not-implemented-hide:] The configuration to specify whether the filter chain will be built on-demand.
   * If this field is not empty, the filter chain will be built on-demand.
   * Otherwise, the filter chain will be built normally and block listener warming.
   *
   * @generated from field: envoy.config.listener.v3.FilterChain.OnDemandConfiguration on_demand_configuration = 8;
   */
  onDemandConfiguration?: FilterChain_OnDemandConfiguration;

  constructor(data?: PartialMessage<FilterChain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.FilterChain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterChain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterChain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterChain;

  static equals(a: FilterChain | PlainMessage<FilterChain> | undefined, b: FilterChain | PlainMessage<FilterChain> | undefined): boolean;
}

/**
 * The configuration for on-demand filter chain. If this field is not empty in FilterChain message,
 * a filter chain will be built on-demand.
 * On-demand filter chains help speedup the warming up of listeners since the building and initialization of
 * an on-demand filter chain will be postponed to the arrival of new connection requests that require this filter chain.
 * Filter chains that are not often used can be set as on-demand.
 *
 * @generated from message envoy.config.listener.v3.FilterChain.OnDemandConfiguration
 */
export declare class FilterChain_OnDemandConfiguration extends Message<FilterChain_OnDemandConfiguration> {
  /**
   * The timeout to wait for filter chain placeholders to complete rebuilding.
   * 1. If this field is set to 0, timeout is disabled.
   * 2. If not specified, a default timeout of 15s is used.
   * Rebuilding will wait until dependencies are ready, have failed, or this timeout is reached.
   * Upon failure or timeout, all connections related to this filter chain will be closed.
   * Rebuilding will start again on the next new connection.
   *
   * @generated from field: google.protobuf.Duration rebuild_timeout = 1;
   */
  rebuildTimeout?: Duration;

  constructor(data?: PartialMessage<FilterChain_OnDemandConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.FilterChain.OnDemandConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterChain_OnDemandConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterChain_OnDemandConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterChain_OnDemandConfiguration;

  static equals(a: FilterChain_OnDemandConfiguration | PlainMessage<FilterChain_OnDemandConfiguration> | undefined, b: FilterChain_OnDemandConfiguration | PlainMessage<FilterChain_OnDemandConfiguration> | undefined): boolean;
}

/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.ListenerFilterChainMatchPredicate
 */
export declare class ListenerFilterChainMatchPredicate extends Message<ListenerFilterChainMatchPredicate> {
  /**
   * @generated from oneof envoy.config.listener.v3.ListenerFilterChainMatchPredicate.rule
   */
  rule: {
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet or_match = 1;
     */
    value: ListenerFilterChainMatchPredicate_MatchSet;
    case: "orMatch";
  } | {
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet and_match = 2;
     */
    value: ListenerFilterChainMatchPredicate_MatchSet;
    case: "andMatch";
  } | {
    /**
     * A negation match. The match configuration will match if the negated match condition matches.
     *
     * @generated from field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate not_match = 3;
     */
    value: ListenerFilterChainMatchPredicate;
    case: "notMatch";
  } | {
    /**
     * The match configuration will always match.
     *
     * @generated from field: bool any_match = 4;
     */
    value: boolean;
    case: "anyMatch";
  } | {
    /**
     * Match destination port. Particularly, the match evaluation must use the recovered local port if
     * the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
     *
     * @generated from field: envoy.type.v3.Int32Range destination_port_range = 5;
     */
    value: Int32Range;
    case: "destinationPortRange";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ListenerFilterChainMatchPredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.ListenerFilterChainMatchPredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilterChainMatchPredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate;

  static equals(a: ListenerFilterChainMatchPredicate | PlainMessage<ListenerFilterChainMatchPredicate> | undefined, b: ListenerFilterChainMatchPredicate | PlainMessage<ListenerFilterChainMatchPredicate> | undefined): boolean;
}

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet
 */
export declare class ListenerFilterChainMatchPredicate_MatchSet extends Message<ListenerFilterChainMatchPredicate_MatchSet> {
  /**
   * The list of rules that make up the set.
   *
   * @generated from field: repeated envoy.config.listener.v3.ListenerFilterChainMatchPredicate rules = 1;
   */
  rules: ListenerFilterChainMatchPredicate[];

  constructor(data?: PartialMessage<ListenerFilterChainMatchPredicate_MatchSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.ListenerFilterChainMatchPredicate.MatchSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static equals(a: ListenerFilterChainMatchPredicate_MatchSet | PlainMessage<ListenerFilterChainMatchPredicate_MatchSet> | undefined, b: ListenerFilterChainMatchPredicate_MatchSet | PlainMessage<ListenerFilterChainMatchPredicate_MatchSet> | undefined): boolean;
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.listener.v3.ListenerFilter
 */
export declare class ListenerFilter extends Message<ListenerFilter> {
  /**
   * The name of the filter configuration.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.config.listener.v3.ListenerFilter.config_type
   */
  configType: {
    /**
     * Filter specific configuration which depends on the filter being
     * instantiated. See the supported filters for further documentation.
     * [#extension-category: envoy.filters.listener,envoy.filters.udp_listener]
     *
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | {
    /**
     * Configuration source specifier for an extension configuration discovery
     * service. In case of a failure and without the default configuration, the
     * listener closes the connections.
     *
     * @generated from field: envoy.config.core.v3.ExtensionConfigSource config_discovery = 5;
     */
    value: ExtensionConfigSource;
    case: "configDiscovery";
  } | { case: undefined; value?: undefined };

  /**
   * Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
   * See :ref:`ListenerFilterChainMatchPredicate <envoy_v3_api_msg_config.listener.v3.ListenerFilterChainMatchPredicate>`
   * for further examples.
   *
   * @generated from field: envoy.config.listener.v3.ListenerFilterChainMatchPredicate filter_disabled = 4;
   */
  filterDisabled?: ListenerFilterChainMatchPredicate;

  constructor(data?: PartialMessage<ListenerFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.listener.v3.ListenerFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilter;

  static equals(a: ListenerFilter | PlainMessage<ListenerFilter> | undefined, b: ListenerFilter | PlainMessage<ListenerFilter> | undefined): boolean;
}

