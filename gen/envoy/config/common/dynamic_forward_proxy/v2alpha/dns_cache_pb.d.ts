// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/common/dynamic_forward_proxy/v2alpha/dns_cache.proto (package envoy.config.common.dynamic_forward_proxy.v2alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Cluster_DnsLookupFamily, Cluster_RefreshRate } from "../../../../api/v2/cluster_pb.js";

/**
 * Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
 * <arch_overview_http_dynamic_forward_proxy>` for more information.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.common.dynamic_forward_proxy.v2alpha.DnsCacheConfig
 */
export declare class DnsCacheConfig extends Message<DnsCacheConfig> {
  /**
   * The name of the cache. Multiple named caches allow independent dynamic forward proxy
   * configurations to operate within a single Envoy process using different configurations. All
   * configurations with the same name *must* otherwise have the same settings when referenced
   * from different configuration components. Configuration will fail to load if this is not
   * the case.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The DNS lookup family to use during resolution.
   *
   * [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
   * way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
   * then configures a host to have a primary and fall back address. With this, we could very
   * likely build a "happy eyeballs" connection pool which would race the primary / fall back
   * address and return the one that wins. This same method could potentially also be used for
   * QUIC to TCP fall back.]
   *
   * @generated from field: envoy.api.v2.Cluster.DnsLookupFamily dns_lookup_family = 2;
   */
  dnsLookupFamily: Cluster_DnsLookupFamily;

  /**
   * The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
   *
   * .. note:
   *
   *  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
   *  added in a future change.
   *
   * .. note:
   *
   * The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
   *
   * @generated from field: google.protobuf.Duration dns_refresh_rate = 3;
   */
  dnsRefreshRate?: Duration;

  /**
   * The TTL for hosts that are unused. Hosts that have not been used in the configured time
   * interval will be purged. If not specified defaults to 5m.
   *
   * .. note:
   *
   *   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
   *   means that if the configured TTL is shorter than the refresh rate the host may not be removed
   *   immediately.
   *
   *  .. note:
   *
   *   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
   *
   * @generated from field: google.protobuf.Duration host_ttl = 4;
   */
  hostTtl?: Duration;

  /**
   * The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
   *
   * .. note:
   *
   *   The implementation is approximate and enforced independently on each worker thread, thus
   *   it is possible for the maximum hosts in the cache to go slightly above the configured
   *   value depending on timing. This is similar to how other circuit breakers work.
   *
   * @generated from field: google.protobuf.UInt32Value max_hosts = 5;
   */
  maxHosts?: number;

  /**
   * If the DNS failure refresh rate is specified,
   * this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
   * not specified, the failure refresh rate defaults to the dns_refresh_rate.
   *
   * @generated from field: envoy.api.v2.Cluster.RefreshRate dns_failure_refresh_rate = 6;
   */
  dnsFailureRefreshRate?: Cluster_RefreshRate;

  constructor(data?: PartialMessage<DnsCacheConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.dynamic_forward_proxy.v2alpha.DnsCacheConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DnsCacheConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DnsCacheConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DnsCacheConfig;

  static equals(a: DnsCacheConfig | PlainMessage<DnsCacheConfig> | undefined, b: DnsCacheConfig | PlainMessage<DnsCacheConfig> | undefined): boolean;
}

