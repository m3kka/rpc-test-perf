// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/common/mutation_rules/v3/mutation_rules.proto" (package "envoy.config.common.mutation_rules.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderValueOption } from "../../../core/v3/base";
import { RegexMatcher } from "../../../../type/matcher/v3/regex";
import { BoolValue } from "../../../../../google/protobuf/wrappers";
// [#protodoc-title: Header mutation rules]

/**
 * The HeaderMutationRules structure specifies what headers may be
 * manipulated by a processing filter. This set of rules makes it
 * possible to control which modifications a filter may make.
 *
 * By default, an external processing server may add, modify, or remove
 * any header except for an "Envoy internal" header (which is typically
 * denoted by an x-envoy prefix) or specific headers that may affect
 * further filter processing:
 *
 * * ``host``
 * * ``:authority``
 * * ``:scheme``
 * * ``:method``
 *
 * Every attempt to add, change, append, or remove a header will be
 * tested against the rules here. Disallowed header mutations will be
 * ignored unless ``disallow_is_error`` is set to true.
 *
 * Attempts to remove headers are further constrained -- regardless of the
 * settings, system-defined headers (that start with ``:``) and the ``host``
 * header may never be removed.
 *
 * In addition, a counter will be incremented whenever a mutation is
 * rejected. In the ext_proc filter, that counter is named
 * ``rejected_header_mutations``.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.config.common.mutation_rules.v3.HeaderMutationRules
 */
export interface HeaderMutationRules {
    /**
     * By default, certain headers that could affect processing of subsequent
     * filters or request routing cannot be modified. These headers are
     * ``host``, ``:authority``, ``:scheme``, and ``:method``. Setting this parameter
     * to true allows these headers to be modified as well.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_all_routing = 1;
     */
    allowAllRouting?: BoolValue;
    /**
     * If true, allow modification of envoy internal headers. By default, these
     * start with ``x-envoy`` but this may be overridden in the ``Bootstrap``
     * configuration using the
     * :ref:`header_prefix <envoy_v3_api_field_config.bootstrap.v3.Bootstrap.header_prefix>`
     * field. Default is false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_envoy = 2;
     */
    allowEnvoy?: BoolValue;
    /**
     * If true, prevent modification of any system header, defined as a header
     * that starts with a ``:`` character, regardless of any other settings.
     * A processing server may still override the ``:status`` of an HTTP response
     * using an ``ImmediateResponse`` message. Default is false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue disallow_system = 3;
     */
    disallowSystem?: BoolValue;
    /**
     * If true, prevent modifications of all header values, regardless of any
     * other settings. A processing server may still override the ``:status``
     * of an HTTP response using an ``ImmediateResponse`` message. Default is false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue disallow_all = 4;
     */
    disallowAll?: BoolValue;
    /**
     * If set, specifically allow any header that matches this regular
     * expression. This overrides all other settings except for
     * ``disallow_expression``.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.RegexMatcher allow_expression = 5;
     */
    allowExpression?: RegexMatcher;
    /**
     * If set, specifically disallow any header that matches this regular
     * expression regardless of any other settings.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.RegexMatcher disallow_expression = 6;
     */
    disallowExpression?: RegexMatcher;
    /**
     * If true, and if the rules in this list cause a header mutation to be
     * disallowed, then the filter using this configuration will terminate the
     * request with a 500 error. In addition, regardless of the setting of this
     * parameter, any attempt to set, add, or modify a disallowed header will
     * cause the ``rejected_header_mutations`` counter to be incremented.
     * Default is false.
     *
     * @generated from protobuf field: google.protobuf.BoolValue disallow_is_error = 7;
     */
    disallowIsError?: BoolValue;
}
/**
 * The HeaderMutation structure specifies an action that may be taken on HTTP
 * headers.
 *
 * @generated from protobuf message envoy.config.common.mutation_rules.v3.HeaderMutation
 */
export interface HeaderMutation {
    /**
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "remove";
        /**
         * Remove the specified header if it exists.
         *
         * @generated from protobuf field: string remove = 1;
         */
        remove: string;
    } | {
        oneofKind: "append";
        /**
         * Append new header by the specified HeaderValueOption.
         *
         * @generated from protobuf field: envoy.config.core.v3.HeaderValueOption append = 2;
         */
        append: HeaderValueOption;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMutationRules$Type extends MessageType<HeaderMutationRules> {
    constructor() {
        super("envoy.config.common.mutation_rules.v3.HeaderMutationRules", [
            { no: 1, name: "allow_all_routing", kind: "message", T: () => BoolValue },
            { no: 2, name: "allow_envoy", kind: "message", T: () => BoolValue },
            { no: 3, name: "disallow_system", kind: "message", T: () => BoolValue },
            { no: 4, name: "disallow_all", kind: "message", T: () => BoolValue },
            { no: 5, name: "allow_expression", kind: "message", T: () => RegexMatcher },
            { no: 6, name: "disallow_expression", kind: "message", T: () => RegexMatcher },
            { no: 7, name: "disallow_is_error", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<HeaderMutationRules>): HeaderMutationRules {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeaderMutationRules>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMutationRules): HeaderMutationRules {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue allow_all_routing */ 1:
                    message.allowAllRouting = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowAllRouting);
                    break;
                case /* google.protobuf.BoolValue allow_envoy */ 2:
                    message.allowEnvoy = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowEnvoy);
                    break;
                case /* google.protobuf.BoolValue disallow_system */ 3:
                    message.disallowSystem = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.disallowSystem);
                    break;
                case /* google.protobuf.BoolValue disallow_all */ 4:
                    message.disallowAll = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.disallowAll);
                    break;
                case /* envoy.type.matcher.v3.RegexMatcher allow_expression */ 5:
                    message.allowExpression = RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowExpression);
                    break;
                case /* envoy.type.matcher.v3.RegexMatcher disallow_expression */ 6:
                    message.disallowExpression = RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, message.disallowExpression);
                    break;
                case /* google.protobuf.BoolValue disallow_is_error */ 7:
                    message.disallowIsError = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.disallowIsError);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMutationRules, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue allow_all_routing = 1; */
        if (message.allowAllRouting)
            BoolValue.internalBinaryWrite(message.allowAllRouting, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue allow_envoy = 2; */
        if (message.allowEnvoy)
            BoolValue.internalBinaryWrite(message.allowEnvoy, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue disallow_system = 3; */
        if (message.disallowSystem)
            BoolValue.internalBinaryWrite(message.disallowSystem, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue disallow_all = 4; */
        if (message.disallowAll)
            BoolValue.internalBinaryWrite(message.disallowAll, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.RegexMatcher allow_expression = 5; */
        if (message.allowExpression)
            RegexMatcher.internalBinaryWrite(message.allowExpression, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.RegexMatcher disallow_expression = 6; */
        if (message.disallowExpression)
            RegexMatcher.internalBinaryWrite(message.disallowExpression, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue disallow_is_error = 7; */
        if (message.disallowIsError)
            BoolValue.internalBinaryWrite(message.disallowIsError, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.mutation_rules.v3.HeaderMutationRules
 */
export const HeaderMutationRules = new HeaderMutationRules$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMutation$Type extends MessageType<HeaderMutation> {
    constructor() {
        super("envoy.config.common.mutation_rules.v3.HeaderMutation", [
            { no: 1, name: "remove", kind: "scalar", oneof: "action", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 2, name: "append", kind: "message", oneof: "action", T: () => HeaderValueOption }
        ]);
    }
    create(value?: PartialMessage<HeaderMutation>): HeaderMutation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HeaderMutation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMutation): HeaderMutation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string remove */ 1:
                    message.action = {
                        oneofKind: "remove",
                        remove: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.HeaderValueOption append */ 2:
                    message.action = {
                        oneofKind: "append",
                        append: HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).append)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMutation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string remove = 1; */
        if (message.action.oneofKind === "remove")
            writer.tag(1, WireType.LengthDelimited).string(message.action.remove);
        /* envoy.config.core.v3.HeaderValueOption append = 2; */
        if (message.action.oneofKind === "append")
            HeaderValueOption.internalBinaryWrite(message.action.append, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.mutation_rules.v3.HeaderMutation
 */
export const HeaderMutation = new HeaderMutation$Type();
