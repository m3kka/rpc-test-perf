// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/common/matcher/v3/matcher.proto (package envoy.config.common.matcher.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { TypedExtensionConfig } from "../../../core/v3/extension_pb.js";
import { StringMatcher } from "../../../../type/matcher/v3/string_pb.js";
import { HeaderMatcher } from "../../../route/v3/route_components_pb.js";

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher
 */
export const Matcher = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher",
  () => [
    { no: 1, name: "matcher_list", kind: "message", T: Matcher_MatcherList, oneof: "matcher_type" },
    { no: 2, name: "matcher_tree", kind: "message", T: Matcher_MatcherTree, oneof: "matcher_type" },
    { no: 3, name: "on_no_match", kind: "message", T: Matcher_OnMatch },
  ],
);

/**
 * What to do if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.OnMatch
 */
export const Matcher_OnMatch = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.OnMatch",
  () => [
    { no: 1, name: "matcher", kind: "message", T: Matcher, oneof: "on_match" },
    { no: 2, name: "action", kind: "message", T: TypedExtensionConfig, oneof: "on_match" },
  ],
  {localName: "Matcher_OnMatch"},
);

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList
 */
export const Matcher_MatcherList = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherList",
  () => [
    { no: 1, name: "matchers", kind: "message", T: Matcher_MatcherList_FieldMatcher, repeated: true },
  ],
  {localName: "Matcher_MatcherList"},
);

/**
 * Predicate to determine if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate
 */
export const Matcher_MatcherList_Predicate = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate",
  () => [
    { no: 1, name: "single_predicate", kind: "message", T: Matcher_MatcherList_Predicate_SinglePredicate, oneof: "match_type" },
    { no: 2, name: "or_matcher", kind: "message", T: Matcher_MatcherList_Predicate_PredicateList, oneof: "match_type" },
    { no: 3, name: "and_matcher", kind: "message", T: Matcher_MatcherList_Predicate_PredicateList, oneof: "match_type" },
    { no: 4, name: "not_matcher", kind: "message", T: Matcher_MatcherList_Predicate, oneof: "match_type" },
  ],
  {localName: "Matcher_MatcherList_Predicate"},
);

/**
 * Predicate for a single input field.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate
 */
export const Matcher_MatcherList_Predicate_SinglePredicate = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate",
  () => [
    { no: 1, name: "input", kind: "message", T: TypedExtensionConfig },
    { no: 2, name: "value_match", kind: "message", T: StringMatcher, oneof: "matcher" },
    { no: 3, name: "custom_match", kind: "message", T: TypedExtensionConfig, oneof: "matcher" },
  ],
  {localName: "Matcher_MatcherList_Predicate_SinglePredicate"},
);

/**
 * A list of two or more matchers. Used to allow using a list within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList
 */
export const Matcher_MatcherList_Predicate_PredicateList = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList",
  () => [
    { no: 1, name: "predicate", kind: "message", T: Matcher_MatcherList_Predicate, repeated: true },
  ],
  {localName: "Matcher_MatcherList_Predicate_PredicateList"},
);

/**
 * An individual matcher.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher
 */
export const Matcher_MatcherList_FieldMatcher = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher",
  () => [
    { no: 1, name: "predicate", kind: "message", T: Matcher_MatcherList_Predicate },
    { no: 2, name: "on_match", kind: "message", T: Matcher_OnMatch },
  ],
  {localName: "Matcher_MatcherList_FieldMatcher"},
);

/**
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree
 */
export const Matcher_MatcherTree = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherTree",
  () => [
    { no: 1, name: "input", kind: "message", T: TypedExtensionConfig },
    { no: 2, name: "exact_match_map", kind: "message", T: Matcher_MatcherTree_MatchMap, oneof: "tree_type" },
    { no: 3, name: "prefix_match_map", kind: "message", T: Matcher_MatcherTree_MatchMap, oneof: "tree_type" },
    { no: 4, name: "custom_match", kind: "message", T: TypedExtensionConfig, oneof: "tree_type" },
  ],
  {localName: "Matcher_MatcherTree"},
);

/**
 * A map of configured matchers. Used to allow using a map within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap
 */
export const Matcher_MatcherTree_MatchMap = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap",
  () => [
    { no: 1, name: "map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Matcher_OnMatch} },
  ],
  {localName: "Matcher_MatcherTree_MatchMap"},
);

/**
 * Match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate
 */
export const MatchPredicate = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.MatchPredicate",
  () => [
    { no: 1, name: "or_match", kind: "message", T: MatchPredicate_MatchSet, oneof: "rule" },
    { no: 2, name: "and_match", kind: "message", T: MatchPredicate_MatchSet, oneof: "rule" },
    { no: 3, name: "not_match", kind: "message", T: MatchPredicate, oneof: "rule" },
    { no: 4, name: "any_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 5, name: "http_request_headers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 6, name: "http_request_trailers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 7, name: "http_response_headers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 8, name: "http_response_trailers_match", kind: "message", T: HttpHeadersMatch, oneof: "rule" },
    { no: 9, name: "http_request_generic_body_match", kind: "message", T: HttpGenericBodyMatch, oneof: "rule" },
    { no: 10, name: "http_response_generic_body_match", kind: "message", T: HttpGenericBodyMatch, oneof: "rule" },
  ],
);

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate.MatchSet
 */
export const MatchPredicate_MatchSet = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.MatchPredicate.MatchSet",
  () => [
    { no: 1, name: "rules", kind: "message", T: MatchPredicate, repeated: true },
  ],
  {localName: "MatchPredicate_MatchSet"},
);

/**
 * HTTP headers match configuration.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpHeadersMatch
 */
export const HttpHeadersMatch = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.HttpHeadersMatch",
  () => [
    { no: 1, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
);

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch
 */
export const HttpGenericBodyMatch = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.HttpGenericBodyMatch",
  () => [
    { no: 1, name: "bytes_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "patterns", kind: "message", T: HttpGenericBodyMatch_GenericTextMatch, repeated: true },
  ],
);

/**
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export const HttpGenericBodyMatch_GenericTextMatch = proto3.makeMessageType(
  "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch",
  () => [
    { no: 1, name: "string_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "rule" },
    { no: 2, name: "binary_match", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "rule" },
  ],
  {localName: "HttpGenericBodyMatch_GenericTextMatch"},
);

