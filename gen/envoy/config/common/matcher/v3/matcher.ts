// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/common/matcher/v3/matcher.proto" (package "envoy.config.common.matcher.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderMatcher } from "../../../route/v3/route_components";
import { StringMatcher } from "../../../../type/matcher/v3/string";
import { TypedExtensionConfig } from "../../../core/v3/extension";
// [#protodoc-title: Unified Matcher API]

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher
 */
export interface Matcher {
    /**
     * @generated from protobuf oneof: matcher_type
     */
    matcherType: {
        oneofKind: "matcherList";
        /**
         * A linear list of matchers to evaluate.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList matcher_list = 1;
         */
        matcherList: Matcher_MatcherList;
    } | {
        oneofKind: "matcherTree";
        /**
         * A match tree to evaluate.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherTree matcher_tree = 2;
         */
        matcherTree: Matcher_MatcherTree;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional OnMatch to use if the matcher failed.
     * If specified, the OnMatch is used, and the matcher is considered
     * to have matched.
     * If not specified, the matcher is considered not to have matched.
     *
     * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.OnMatch on_no_match = 3;
     */
    onNoMatch?: Matcher_OnMatch;
}
/**
 * What to do if a match is successful.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.OnMatch
 */
export interface Matcher_OnMatch {
    /**
     * @generated from protobuf oneof: on_match
     */
    onMatch: {
        oneofKind: "matcher";
        /**
         * Nested matcher to evaluate.
         * If the nested matcher does not match and does not specify
         * on_no_match, then this matcher is considered not to have
         * matched, even if a predicate at this level or above returned
         * true.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher matcher = 1;
         */
        matcher: Matcher;
    } | {
        oneofKind: "action";
        /**
         * Protocol-specific action to take.
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig action = 2;
         */
        action: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList
 */
export interface Matcher_MatcherList {
    /**
     * A list of matchers. First match wins.
     *
     * @generated from protobuf field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher matchers = 1;
     */
    matchers: Matcher_MatcherList_FieldMatcher[];
}
/**
 * Predicate to determine if a match is successful.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate
 */
export interface Matcher_MatcherList_Predicate {
    /**
     * @generated from protobuf oneof: match_type
     */
    matchType: {
        oneofKind: "singlePredicate";
        /**
         * A single predicate to evaluate.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate single_predicate = 1;
         */
        singlePredicate: Matcher_MatcherList_Predicate_SinglePredicate;
    } | {
        oneofKind: "orMatcher";
        /**
         * A list of predicates to be OR-ed together.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList or_matcher = 2;
         */
        orMatcher: Matcher_MatcherList_Predicate_PredicateList;
    } | {
        oneofKind: "andMatcher";
        /**
         * A list of predicates to be AND-ed together.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList and_matcher = 3;
         */
        andMatcher: Matcher_MatcherList_Predicate_PredicateList;
    } | {
        oneofKind: "notMatcher";
        /**
         * The invert of a predicate
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate not_matcher = 4;
         */
        notMatcher: Matcher_MatcherList_Predicate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Predicate for a single input field.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate
 */
export interface Matcher_MatcherList_Predicate_SinglePredicate {
    /**
     * Protocol-specific specification of input field to match on.
     * [#extension-category: envoy.matching.common_inputs]
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig input = 1;
     */
    input?: TypedExtensionConfig;
    /**
     * @generated from protobuf oneof: matcher
     */
    matcher: {
        oneofKind: "valueMatch";
        /**
         * Built-in string matcher.
         *
         * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher value_match = 2;
         */
        valueMatch: StringMatcher;
    } | {
        oneofKind: "customMatch";
        /**
         * Extension for custom matching logic.
         * [#extension-category: envoy.matching.input_matchers]
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig custom_match = 3;
         */
        customMatch: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A list of two or more matchers. Used to allow using a list within a oneof.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList
 */
export interface Matcher_MatcherList_Predicate_PredicateList {
    /**
     * @generated from protobuf field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
     */
    predicate: Matcher_MatcherList_Predicate[];
}
/**
 * An individual matcher.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher
 */
export interface Matcher_MatcherList_FieldMatcher {
    /**
     * Determines if the match succeeds.
     *
     * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
     */
    predicate?: Matcher_MatcherList_Predicate;
    /**
     * What to do if the match succeeds.
     *
     * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.OnMatch on_match = 2;
     */
    onMatch?: Matcher_OnMatch;
}
/**
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherTree
 */
export interface Matcher_MatcherTree {
    /**
     * Protocol-specific specification of input field to match on.
     *
     * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig input = 1;
     */
    input?: TypedExtensionConfig;
    /**
     * @generated from protobuf oneof: tree_type
     */
    treeType: {
        oneofKind: "exactMatchMap";
        /**
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap exact_match_map = 2;
         */
        exactMatchMap: Matcher_MatcherTree_MatchMap;
    } | {
        oneofKind: "prefixMatchMap";
        /**
         * Longest matching prefix wins.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap prefix_match_map = 3;
         */
        prefixMatchMap: Matcher_MatcherTree_MatchMap;
    } | {
        oneofKind: "customMatch";
        /**
         * Extension for custom matching logic.
         *
         * @generated from protobuf field: envoy.config.core.v3.TypedExtensionConfig custom_match = 4;
         */
        customMatch: TypedExtensionConfig;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A map of configured matchers. Used to allow using a map within a oneof.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap
 */
export interface Matcher_MatcherTree_MatchMap {
    /**
     * @generated from protobuf field: map<string, envoy.config.common.matcher.v3.Matcher.OnMatch> map = 1;
     */
    map: {
        [key: string]: Matcher_OnMatch;
    };
}
/**
 * Match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.MatchPredicate
 */
export interface MatchPredicate {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "orMatch";
        /**
         * A set that describes a logical OR. If any member of the set matches, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet or_match = 1;
         */
        orMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "andMatch";
        /**
         * A set that describes a logical AND. If all members of the set match, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet and_match = 2;
         */
        andMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "notMatch";
        /**
         * A negation match. The match configuration will match if the negated match condition matches.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.MatchPredicate not_match = 3;
         */
        notMatch: MatchPredicate;
    } | {
        oneofKind: "anyMatch";
        /**
         * The match configuration will always match.
         *
         * @generated from protobuf field: bool any_match = 4;
         */
        anyMatch: boolean;
    } | {
        oneofKind: "httpRequestHeadersMatch";
        /**
         * HTTP request headers match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_headers_match = 5;
         */
        httpRequestHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpRequestTrailersMatch";
        /**
         * HTTP request trailers match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_trailers_match = 6;
         */
        httpRequestTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseHeadersMatch";
        /**
         * HTTP response headers match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_headers_match = 7;
         */
        httpResponseHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseTrailersMatch";
        /**
         * HTTP response trailers match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_trailers_match = 8;
         */
        httpResponseTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpRequestGenericBodyMatch";
        /**
         * HTTP request generic body match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_request_generic_body_match = 9;
         */
        httpRequestGenericBodyMatch: HttpGenericBodyMatch;
    } | {
        oneofKind: "httpResponseGenericBodyMatch";
        /**
         * HTTP response generic body match configuration.
         *
         * @generated from protobuf field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_response_generic_body_match = 10;
         */
        httpResponseGenericBodyMatch: HttpGenericBodyMatch;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of match configurations used for logical operations.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.MatchPredicate.MatchSet
 */
export interface MatchPredicate_MatchSet {
    /**
     * The list of rules that make up the set.
     *
     * @generated from protobuf field: repeated envoy.config.common.matcher.v3.MatchPredicate rules = 1;
     */
    rules: MatchPredicate[];
}
/**
 * HTTP headers match configuration.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.HttpHeadersMatch
 */
export interface HttpHeadersMatch {
    /**
     * HTTP headers to match.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 1;
     */
    headers: HeaderMatcher[];
}
/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 *
 * @generated from protobuf message envoy.config.common.matcher.v3.HttpGenericBodyMatch
 */
export interface HttpGenericBodyMatch {
    /**
     * Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
     *
     * @generated from protobuf field: uint32 bytes_limit = 1;
     */
    bytesLimit: number;
    /**
     * List of patterns to match.
     *
     * @generated from protobuf field: repeated envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2;
     */
    patterns: HttpGenericBodyMatch_GenericTextMatch[];
}
/**
 * @generated from protobuf message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export interface HttpGenericBodyMatch_GenericTextMatch {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "stringMatch";
        /**
         * Text string to be located in HTTP body.
         *
         * @generated from protobuf field: string string_match = 1;
         */
        stringMatch: string;
    } | {
        oneofKind: "binaryMatch";
        /**
         * Sequence of bytes to be located in HTTP body.
         *
         * @generated from protobuf field: bytes binary_match = 2;
         */
        binaryMatch: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class Matcher$Type extends MessageType<Matcher> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher", [
            { no: 1, name: "matcher_list", kind: "message", oneof: "matcherType", T: () => Matcher_MatcherList },
            { no: 2, name: "matcher_tree", kind: "message", oneof: "matcherType", T: () => Matcher_MatcherTree },
            { no: 3, name: "on_no_match", kind: "message", T: () => Matcher_OnMatch }
        ], { "xds.annotations.v3.message_status": { workInProgress: true } });
    }
    create(value?: PartialMessage<Matcher>): Matcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matcherType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Matcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher): Matcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList matcher_list */ 1:
                    message.matcherType = {
                        oneofKind: "matcherList",
                        matcherList: Matcher_MatcherList.internalBinaryRead(reader, reader.uint32(), options, (message.matcherType as any).matcherList)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherTree matcher_tree */ 2:
                    message.matcherType = {
                        oneofKind: "matcherTree",
                        matcherTree: Matcher_MatcherTree.internalBinaryRead(reader, reader.uint32(), options, (message.matcherType as any).matcherTree)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.OnMatch on_no_match */ 3:
                    message.onNoMatch = Matcher_OnMatch.internalBinaryRead(reader, reader.uint32(), options, message.onNoMatch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.common.matcher.v3.Matcher.MatcherList matcher_list = 1; */
        if (message.matcherType.oneofKind === "matcherList")
            Matcher_MatcherList.internalBinaryWrite(message.matcherType.matcherList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherTree matcher_tree = 2; */
        if (message.matcherType.oneofKind === "matcherTree")
            Matcher_MatcherTree.internalBinaryWrite(message.matcherType.matcherTree, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.OnMatch on_no_match = 3; */
        if (message.onNoMatch)
            Matcher_OnMatch.internalBinaryWrite(message.onNoMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher
 */
export const Matcher = new Matcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_OnMatch$Type extends MessageType<Matcher_OnMatch> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.OnMatch", [
            { no: 1, name: "matcher", kind: "message", oneof: "onMatch", T: () => Matcher },
            { no: 2, name: "action", kind: "message", oneof: "onMatch", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<Matcher_OnMatch>): Matcher_OnMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.onMatch = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Matcher_OnMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_OnMatch): Matcher_OnMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.common.matcher.v3.Matcher matcher */ 1:
                    message.onMatch = {
                        oneofKind: "matcher",
                        matcher: Matcher.internalBinaryRead(reader, reader.uint32(), options, (message.onMatch as any).matcher)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig action */ 2:
                    message.onMatch = {
                        oneofKind: "action",
                        action: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.onMatch as any).action)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_OnMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.common.matcher.v3.Matcher matcher = 1; */
        if (message.onMatch.oneofKind === "matcher")
            Matcher.internalBinaryWrite(message.onMatch.matcher, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig action = 2; */
        if (message.onMatch.oneofKind === "action")
            TypedExtensionConfig.internalBinaryWrite(message.onMatch.action, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.OnMatch
 */
export const Matcher_OnMatch = new Matcher_OnMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherList$Type extends MessageType<Matcher_MatcherList> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherList", [
            { no: 1, name: "matchers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Matcher_MatcherList_FieldMatcher, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherList>): Matcher_MatcherList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matchers = [];
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherList): Matcher_MatcherList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher matchers */ 1:
                    message.matchers.push(Matcher_MatcherList_FieldMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher matchers = 1; */
        for (let i = 0; i < message.matchers.length; i++)
            Matcher_MatcherList_FieldMatcher.internalBinaryWrite(message.matchers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList
 */
export const Matcher_MatcherList = new Matcher_MatcherList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherList_Predicate$Type extends MessageType<Matcher_MatcherList_Predicate> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate", [
            { no: 1, name: "single_predicate", kind: "message", oneof: "matchType", T: () => Matcher_MatcherList_Predicate_SinglePredicate },
            { no: 2, name: "or_matcher", kind: "message", oneof: "matchType", T: () => Matcher_MatcherList_Predicate_PredicateList },
            { no: 3, name: "and_matcher", kind: "message", oneof: "matchType", T: () => Matcher_MatcherList_Predicate_PredicateList },
            { no: 4, name: "not_matcher", kind: "message", oneof: "matchType", T: () => Matcher_MatcherList_Predicate }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherList_Predicate>): Matcher_MatcherList_Predicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matchType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherList_Predicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherList_Predicate): Matcher_MatcherList_Predicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate single_predicate */ 1:
                    message.matchType = {
                        oneofKind: "singlePredicate",
                        singlePredicate: Matcher_MatcherList_Predicate_SinglePredicate.internalBinaryRead(reader, reader.uint32(), options, (message.matchType as any).singlePredicate)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList or_matcher */ 2:
                    message.matchType = {
                        oneofKind: "orMatcher",
                        orMatcher: Matcher_MatcherList_Predicate_PredicateList.internalBinaryRead(reader, reader.uint32(), options, (message.matchType as any).orMatcher)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList and_matcher */ 3:
                    message.matchType = {
                        oneofKind: "andMatcher",
                        andMatcher: Matcher_MatcherList_Predicate_PredicateList.internalBinaryRead(reader, reader.uint32(), options, (message.matchType as any).andMatcher)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate not_matcher */ 4:
                    message.matchType = {
                        oneofKind: "notMatcher",
                        notMatcher: Matcher_MatcherList_Predicate.internalBinaryRead(reader, reader.uint32(), options, (message.matchType as any).notMatcher)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherList_Predicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate single_predicate = 1; */
        if (message.matchType.oneofKind === "singlePredicate")
            Matcher_MatcherList_Predicate_SinglePredicate.internalBinaryWrite(message.matchType.singlePredicate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList or_matcher = 2; */
        if (message.matchType.oneofKind === "orMatcher")
            Matcher_MatcherList_Predicate_PredicateList.internalBinaryWrite(message.matchType.orMatcher, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList and_matcher = 3; */
        if (message.matchType.oneofKind === "andMatcher")
            Matcher_MatcherList_Predicate_PredicateList.internalBinaryWrite(message.matchType.andMatcher, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate not_matcher = 4; */
        if (message.matchType.oneofKind === "notMatcher")
            Matcher_MatcherList_Predicate.internalBinaryWrite(message.matchType.notMatcher, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate
 */
export const Matcher_MatcherList_Predicate = new Matcher_MatcherList_Predicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherList_Predicate_SinglePredicate$Type extends MessageType<Matcher_MatcherList_Predicate_SinglePredicate> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate", [
            { no: 1, name: "input", kind: "message", T: () => TypedExtensionConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "value_match", kind: "message", oneof: "matcher", T: () => StringMatcher },
            { no: 3, name: "custom_match", kind: "message", oneof: "matcher", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherList_Predicate_SinglePredicate>): Matcher_MatcherList_Predicate_SinglePredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.matcher = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherList_Predicate_SinglePredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherList_Predicate_SinglePredicate): Matcher_MatcherList_Predicate_SinglePredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig input */ 1:
                    message.input = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* envoy.type.matcher.v3.StringMatcher value_match */ 2:
                    message.matcher = {
                        oneofKind: "valueMatch",
                        valueMatch: StringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.matcher as any).valueMatch)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig custom_match */ 3:
                    message.matcher = {
                        oneofKind: "customMatch",
                        customMatch: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.matcher as any).customMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherList_Predicate_SinglePredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig input = 1; */
        if (message.input)
            TypedExtensionConfig.internalBinaryWrite(message.input, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.v3.StringMatcher value_match = 2; */
        if (message.matcher.oneofKind === "valueMatch")
            StringMatcher.internalBinaryWrite(message.matcher.valueMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig custom_match = 3; */
        if (message.matcher.oneofKind === "customMatch")
            TypedExtensionConfig.internalBinaryWrite(message.matcher.customMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate
 */
export const Matcher_MatcherList_Predicate_SinglePredicate = new Matcher_MatcherList_Predicate_SinglePredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherList_Predicate_PredicateList$Type extends MessageType<Matcher_MatcherList_Predicate_PredicateList> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList", [
            { no: 1, name: "predicate", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Matcher_MatcherList_Predicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherList_Predicate_PredicateList>): Matcher_MatcherList_Predicate_PredicateList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.predicate = [];
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherList_Predicate_PredicateList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherList_Predicate_PredicateList): Matcher_MatcherList_Predicate_PredicateList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate */ 1:
                    message.predicate.push(Matcher_MatcherList_Predicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherList_Predicate_PredicateList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1; */
        for (let i = 0; i < message.predicate.length; i++)
            Matcher_MatcherList_Predicate.internalBinaryWrite(message.predicate[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList
 */
export const Matcher_MatcherList_Predicate_PredicateList = new Matcher_MatcherList_Predicate_PredicateList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherList_FieldMatcher$Type extends MessageType<Matcher_MatcherList_FieldMatcher> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher", [
            { no: 1, name: "predicate", kind: "message", T: () => Matcher_MatcherList_Predicate, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "on_match", kind: "message", T: () => Matcher_OnMatch, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherList_FieldMatcher>): Matcher_MatcherList_FieldMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherList_FieldMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherList_FieldMatcher): Matcher_MatcherList_FieldMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate */ 1:
                    message.predicate = Matcher_MatcherList_Predicate.internalBinaryRead(reader, reader.uint32(), options, message.predicate);
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.OnMatch on_match */ 2:
                    message.onMatch = Matcher_OnMatch.internalBinaryRead(reader, reader.uint32(), options, message.onMatch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherList_FieldMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1; */
        if (message.predicate)
            Matcher_MatcherList_Predicate.internalBinaryWrite(message.predicate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.OnMatch on_match = 2; */
        if (message.onMatch)
            Matcher_OnMatch.internalBinaryWrite(message.onMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher
 */
export const Matcher_MatcherList_FieldMatcher = new Matcher_MatcherList_FieldMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherTree$Type extends MessageType<Matcher_MatcherTree> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherTree", [
            { no: 1, name: "input", kind: "message", T: () => TypedExtensionConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "exact_match_map", kind: "message", oneof: "treeType", T: () => Matcher_MatcherTree_MatchMap },
            { no: 3, name: "prefix_match_map", kind: "message", oneof: "treeType", T: () => Matcher_MatcherTree_MatchMap },
            { no: 4, name: "custom_match", kind: "message", oneof: "treeType", T: () => TypedExtensionConfig }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherTree>): Matcher_MatcherTree {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.treeType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherTree>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherTree): Matcher_MatcherTree {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.TypedExtensionConfig input */ 1:
                    message.input = TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap exact_match_map */ 2:
                    message.treeType = {
                        oneofKind: "exactMatchMap",
                        exactMatchMap: Matcher_MatcherTree_MatchMap.internalBinaryRead(reader, reader.uint32(), options, (message.treeType as any).exactMatchMap)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap prefix_match_map */ 3:
                    message.treeType = {
                        oneofKind: "prefixMatchMap",
                        prefixMatchMap: Matcher_MatcherTree_MatchMap.internalBinaryRead(reader, reader.uint32(), options, (message.treeType as any).prefixMatchMap)
                    };
                    break;
                case /* envoy.config.core.v3.TypedExtensionConfig custom_match */ 4:
                    message.treeType = {
                        oneofKind: "customMatch",
                        customMatch: TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options, (message.treeType as any).customMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Matcher_MatcherTree, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.TypedExtensionConfig input = 1; */
        if (message.input)
            TypedExtensionConfig.internalBinaryWrite(message.input, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap exact_match_map = 2; */
        if (message.treeType.oneofKind === "exactMatchMap")
            Matcher_MatcherTree_MatchMap.internalBinaryWrite(message.treeType.exactMatchMap, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap prefix_match_map = 3; */
        if (message.treeType.oneofKind === "prefixMatchMap")
            Matcher_MatcherTree_MatchMap.internalBinaryWrite(message.treeType.prefixMatchMap, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.TypedExtensionConfig custom_match = 4; */
        if (message.treeType.oneofKind === "customMatch")
            TypedExtensionConfig.internalBinaryWrite(message.treeType.customMatch, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherTree
 */
export const Matcher_MatcherTree = new Matcher_MatcherTree$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Matcher_MatcherTree_MatchMap$Type extends MessageType<Matcher_MatcherTree_MatchMap> {
    constructor() {
        super("envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap", [
            { no: 1, name: "map", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Matcher_OnMatch }, options: { "validate.rules": { map: { minPairs: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<Matcher_MatcherTree_MatchMap>): Matcher_MatcherTree_MatchMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.map = {};
        if (value !== undefined)
            reflectionMergePartial<Matcher_MatcherTree_MatchMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Matcher_MatcherTree_MatchMap): Matcher_MatcherTree_MatchMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, envoy.config.common.matcher.v3.Matcher.OnMatch> map */ 1:
                    this.binaryReadMap1(message.map, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Matcher_MatcherTree_MatchMap["map"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Matcher_MatcherTree_MatchMap["map"] | undefined, val: Matcher_MatcherTree_MatchMap["map"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Matcher_OnMatch.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap.map");
            }
        }
        map[key ?? ""] = val ?? Matcher_OnMatch.create();
    }
    internalBinaryWrite(message: Matcher_MatcherTree_MatchMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, envoy.config.common.matcher.v3.Matcher.OnMatch> map = 1; */
        for (let k of globalThis.Object.keys(message.map)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Matcher_OnMatch.internalBinaryWrite(message.map[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap
 */
export const Matcher_MatcherTree_MatchMap = new Matcher_MatcherTree_MatchMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate$Type extends MessageType<MatchPredicate> {
    constructor() {
        super("envoy.config.common.matcher.v3.MatchPredicate", [
            { no: 1, name: "or_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 2, name: "and_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 3, name: "not_match", kind: "message", oneof: "rule", T: () => MatchPredicate },
            { no: 4, name: "any_match", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 5, name: "http_request_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 6, name: "http_request_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 7, name: "http_response_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 8, name: "http_response_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 9, name: "http_request_generic_body_match", kind: "message", oneof: "rule", T: () => HttpGenericBodyMatch },
            { no: 10, name: "http_response_generic_body_match", kind: "message", oneof: "rule", T: () => HttpGenericBodyMatch }
        ]);
    }
    create(value?: PartialMessage<MatchPredicate>): MatchPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate): MatchPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.common.matcher.v3.MatchPredicate.MatchSet or_match */ 1:
                    message.rule = {
                        oneofKind: "orMatch",
                        orMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.MatchPredicate.MatchSet and_match */ 2:
                    message.rule = {
                        oneofKind: "andMatch",
                        andMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.MatchPredicate not_match */ 3:
                    message.rule = {
                        oneofKind: "notMatch",
                        notMatch: MatchPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notMatch)
                    };
                    break;
                case /* bool any_match */ 4:
                    message.rule = {
                        oneofKind: "anyMatch",
                        anyMatch: reader.bool()
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpHeadersMatch http_request_headers_match */ 5:
                    message.rule = {
                        oneofKind: "httpRequestHeadersMatch",
                        httpRequestHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestHeadersMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpHeadersMatch http_request_trailers_match */ 6:
                    message.rule = {
                        oneofKind: "httpRequestTrailersMatch",
                        httpRequestTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestTrailersMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpHeadersMatch http_response_headers_match */ 7:
                    message.rule = {
                        oneofKind: "httpResponseHeadersMatch",
                        httpResponseHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseHeadersMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpHeadersMatch http_response_trailers_match */ 8:
                    message.rule = {
                        oneofKind: "httpResponseTrailersMatch",
                        httpResponseTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseTrailersMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpGenericBodyMatch http_request_generic_body_match */ 9:
                    message.rule = {
                        oneofKind: "httpRequestGenericBodyMatch",
                        httpRequestGenericBodyMatch: HttpGenericBodyMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestGenericBodyMatch)
                    };
                    break;
                case /* envoy.config.common.matcher.v3.HttpGenericBodyMatch http_response_generic_body_match */ 10:
                    message.rule = {
                        oneofKind: "httpResponseGenericBodyMatch",
                        httpResponseGenericBodyMatch: HttpGenericBodyMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseGenericBodyMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.common.matcher.v3.MatchPredicate.MatchSet or_match = 1; */
        if (message.rule.oneofKind === "orMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.orMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.MatchPredicate.MatchSet and_match = 2; */
        if (message.rule.oneofKind === "andMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.andMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.MatchPredicate not_match = 3; */
        if (message.rule.oneofKind === "notMatch")
            MatchPredicate.internalBinaryWrite(message.rule.notMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool any_match = 4; */
        if (message.rule.oneofKind === "anyMatch")
            writer.tag(4, WireType.Varint).bool(message.rule.anyMatch);
        /* envoy.config.common.matcher.v3.HttpHeadersMatch http_request_headers_match = 5; */
        if (message.rule.oneofKind === "httpRequestHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestHeadersMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.HttpHeadersMatch http_request_trailers_match = 6; */
        if (message.rule.oneofKind === "httpRequestTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestTrailersMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.HttpHeadersMatch http_response_headers_match = 7; */
        if (message.rule.oneofKind === "httpResponseHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseHeadersMatch, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.HttpHeadersMatch http_response_trailers_match = 8; */
        if (message.rule.oneofKind === "httpResponseTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseTrailersMatch, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.HttpGenericBodyMatch http_request_generic_body_match = 9; */
        if (message.rule.oneofKind === "httpRequestGenericBodyMatch")
            HttpGenericBodyMatch.internalBinaryWrite(message.rule.httpRequestGenericBodyMatch, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.HttpGenericBodyMatch http_response_generic_body_match = 10; */
        if (message.rule.oneofKind === "httpResponseGenericBodyMatch")
            HttpGenericBodyMatch.internalBinaryWrite(message.rule.httpResponseGenericBodyMatch, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.MatchPredicate
 */
export const MatchPredicate = new MatchPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate_MatchSet$Type extends MessageType<MatchPredicate_MatchSet> {
    constructor() {
        super("envoy.config.common.matcher.v3.MatchPredicate.MatchSet", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MatchPredicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<MatchPredicate_MatchSet>): MatchPredicate_MatchSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate_MatchSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate_MatchSet): MatchPredicate_MatchSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.common.matcher.v3.MatchPredicate rules */ 1:
                    message.rules.push(MatchPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate_MatchSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.common.matcher.v3.MatchPredicate rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            MatchPredicate.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.MatchPredicate.MatchSet
 */
export const MatchPredicate_MatchSet = new MatchPredicate_MatchSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpHeadersMatch$Type extends MessageType<HttpHeadersMatch> {
    constructor() {
        super("envoy.config.common.matcher.v3.HttpHeadersMatch", [
            { no: 1, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher }
        ]);
    }
    create(value?: PartialMessage<HttpHeadersMatch>): HttpHeadersMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<HttpHeadersMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpHeadersMatch): HttpHeadersMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 1:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpHeadersMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 1; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.HttpHeadersMatch
 */
export const HttpHeadersMatch = new HttpHeadersMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpGenericBodyMatch$Type extends MessageType<HttpGenericBodyMatch> {
    constructor() {
        super("envoy.config.common.matcher.v3.HttpGenericBodyMatch", [
            { no: 1, name: "bytes_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "patterns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpGenericBodyMatch_GenericTextMatch, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<HttpGenericBodyMatch>): HttpGenericBodyMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bytesLimit = 0;
        message.patterns = [];
        if (value !== undefined)
            reflectionMergePartial<HttpGenericBodyMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpGenericBodyMatch): HttpGenericBodyMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bytes_limit */ 1:
                    message.bytesLimit = reader.uint32();
                    break;
                case /* repeated envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch patterns */ 2:
                    message.patterns.push(HttpGenericBodyMatch_GenericTextMatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpGenericBodyMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 bytes_limit = 1; */
        if (message.bytesLimit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.bytesLimit);
        /* repeated envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2; */
        for (let i = 0; i < message.patterns.length; i++)
            HttpGenericBodyMatch_GenericTextMatch.internalBinaryWrite(message.patterns[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.HttpGenericBodyMatch
 */
export const HttpGenericBodyMatch = new HttpGenericBodyMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpGenericBodyMatch_GenericTextMatch$Type extends MessageType<HttpGenericBodyMatch_GenericTextMatch> {
    constructor() {
        super("envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch", [
            { no: 1, name: "string_match", kind: "scalar", oneof: "rule", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "binary_match", kind: "scalar", oneof: "rule", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<HttpGenericBodyMatch_GenericTextMatch>): HttpGenericBodyMatch_GenericTextMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HttpGenericBodyMatch_GenericTextMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpGenericBodyMatch_GenericTextMatch): HttpGenericBodyMatch_GenericTextMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string string_match */ 1:
                    message.rule = {
                        oneofKind: "stringMatch",
                        stringMatch: reader.string()
                    };
                    break;
                case /* bytes binary_match */ 2:
                    message.rule = {
                        oneofKind: "binaryMatch",
                        binaryMatch: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpGenericBodyMatch_GenericTextMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string string_match = 1; */
        if (message.rule.oneofKind === "stringMatch")
            writer.tag(1, WireType.LengthDelimited).string(message.rule.stringMatch);
        /* bytes binary_match = 2; */
        if (message.rule.oneofKind === "binaryMatch")
            writer.tag(2, WireType.LengthDelimited).bytes(message.rule.binaryMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export const HttpGenericBodyMatch_GenericTextMatch = new HttpGenericBodyMatch_GenericTextMatch$Type();
