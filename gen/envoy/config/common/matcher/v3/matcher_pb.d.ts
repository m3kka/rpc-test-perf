// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/common/matcher/v3/matcher.proto (package envoy.config.common.matcher.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { TypedExtensionConfig } from "../../../core/v3/extension_pb.js";
import type { StringMatcher } from "../../../../type/matcher/v3/string_pb.js";
import type { HeaderMatcher } from "../../../route/v3/route_components_pb.js";

/**
 * A matcher, which may traverse a matching tree in order to result in a match action.
 * During matching, the tree will be traversed until a match is found, or if no match
 * is found the action specified by the most specific on_no_match will be evaluated.
 * As an on_no_match might result in another matching tree being evaluated, this process
 * might repeat several times until the final OnMatch (or no match) is decided.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher
 */
export declare class Matcher extends Message<Matcher> {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.matcher_type
   */
  matcherType: {
    /**
     * A linear list of matchers to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList matcher_list = 1;
     */
    value: Matcher_MatcherList;
    case: "matcherList";
  } | {
    /**
     * A match tree to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree matcher_tree = 2;
     */
    value: Matcher_MatcherTree;
    case: "matcherTree";
  } | { case: undefined; value?: undefined };

  /**
   * Optional OnMatch to use if the matcher failed.
   * If specified, the OnMatch is used, and the matcher is considered
   * to have matched.
   * If not specified, the matcher is considered not to have matched.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.OnMatch on_no_match = 3;
   */
  onNoMatch?: Matcher_OnMatch;

  constructor(data?: PartialMessage<Matcher>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher;

  static equals(a: Matcher | PlainMessage<Matcher> | undefined, b: Matcher | PlainMessage<Matcher> | undefined): boolean;
}

/**
 * What to do if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.OnMatch
 */
export declare class Matcher_OnMatch extends Message<Matcher_OnMatch> {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.OnMatch.on_match
   */
  onMatch: {
    /**
     * Nested matcher to evaluate.
     * If the nested matcher does not match and does not specify
     * on_no_match, then this matcher is considered not to have
     * matched, even if a predicate at this level or above returned
     * true.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher matcher = 1;
     */
    value: Matcher;
    case: "matcher";
  } | {
    /**
     * Protocol-specific action to take.
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig action = 2;
     */
    value: TypedExtensionConfig;
    case: "action";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Matcher_OnMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.OnMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_OnMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_OnMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_OnMatch;

  static equals(a: Matcher_OnMatch | PlainMessage<Matcher_OnMatch> | undefined, b: Matcher_OnMatch | PlainMessage<Matcher_OnMatch> | undefined): boolean;
}

/**
 * A linear list of field matchers.
 * The field matchers are evaluated in order, and the first match
 * wins.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList
 */
export declare class Matcher_MatcherList extends Message<Matcher_MatcherList> {
  /**
   * A list of matchers. First match wins.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher matchers = 1;
   */
  matchers: Matcher_MatcherList_FieldMatcher[];

  constructor(data?: PartialMessage<Matcher_MatcherList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherList;

  static equals(a: Matcher_MatcherList | PlainMessage<Matcher_MatcherList> | undefined, b: Matcher_MatcherList | PlainMessage<Matcher_MatcherList> | undefined): boolean;
}

/**
 * Predicate to determine if a match is successful.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate
 */
export declare class Matcher_MatcherList_Predicate extends Message<Matcher_MatcherList_Predicate> {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.match_type
   */
  matchType: {
    /**
     * A single predicate to evaluate.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate single_predicate = 1;
     */
    value: Matcher_MatcherList_Predicate_SinglePredicate;
    case: "singlePredicate";
  } | {
    /**
     * A list of predicates to be OR-ed together.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList or_matcher = 2;
     */
    value: Matcher_MatcherList_Predicate_PredicateList;
    case: "orMatcher";
  } | {
    /**
     * A list of predicates to be AND-ed together.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList and_matcher = 3;
     */
    value: Matcher_MatcherList_Predicate_PredicateList;
    case: "andMatcher";
  } | {
    /**
     * The invert of a predicate
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate not_matcher = 4;
     */
    value: Matcher_MatcherList_Predicate;
    case: "notMatcher";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Matcher_MatcherList_Predicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherList_Predicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate;

  static equals(a: Matcher_MatcherList_Predicate | PlainMessage<Matcher_MatcherList_Predicate> | undefined, b: Matcher_MatcherList_Predicate | PlainMessage<Matcher_MatcherList_Predicate> | undefined): boolean;
}

/**
 * Predicate for a single input field.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate
 */
export declare class Matcher_MatcherList_Predicate_SinglePredicate extends Message<Matcher_MatcherList_Predicate_SinglePredicate> {
  /**
   * Protocol-specific specification of input field to match on.
   * [#extension-category: envoy.matching.common_inputs]
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig input = 1;
   */
  input?: TypedExtensionConfig;

  /**
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate.matcher
   */
  matcher: {
    /**
     * Built-in string matcher.
     *
     * @generated from field: envoy.type.matcher.v3.StringMatcher value_match = 2;
     */
    value: StringMatcher;
    case: "valueMatch";
  } | {
    /**
     * Extension for custom matching logic.
     * [#extension-category: envoy.matching.input_matchers]
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_match = 3;
     */
    value: TypedExtensionConfig;
    case: "customMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Matcher_MatcherList_Predicate_SinglePredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.SinglePredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherList_Predicate_SinglePredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate_SinglePredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate_SinglePredicate;

  static equals(a: Matcher_MatcherList_Predicate_SinglePredicate | PlainMessage<Matcher_MatcherList_Predicate_SinglePredicate> | undefined, b: Matcher_MatcherList_Predicate_SinglePredicate | PlainMessage<Matcher_MatcherList_Predicate_SinglePredicate> | undefined): boolean;
}

/**
 * A list of two or more matchers. Used to allow using a list within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList
 */
export declare class Matcher_MatcherList_Predicate_PredicateList extends Message<Matcher_MatcherList_Predicate_PredicateList> {
  /**
   * @generated from field: repeated envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
   */
  predicate: Matcher_MatcherList_Predicate[];

  constructor(data?: PartialMessage<Matcher_MatcherList_Predicate_PredicateList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate.PredicateList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherList_Predicate_PredicateList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate_PredicateList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherList_Predicate_PredicateList;

  static equals(a: Matcher_MatcherList_Predicate_PredicateList | PlainMessage<Matcher_MatcherList_Predicate_PredicateList> | undefined, b: Matcher_MatcherList_Predicate_PredicateList | PlainMessage<Matcher_MatcherList_Predicate_PredicateList> | undefined): boolean;
}

/**
 * An individual matcher.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher
 */
export declare class Matcher_MatcherList_FieldMatcher extends Message<Matcher_MatcherList_FieldMatcher> {
  /**
   * Determines if the match succeeds.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherList.Predicate predicate = 1;
   */
  predicate?: Matcher_MatcherList_Predicate;

  /**
   * What to do if the match succeeds.
   *
   * @generated from field: envoy.config.common.matcher.v3.Matcher.OnMatch on_match = 2;
   */
  onMatch?: Matcher_OnMatch;

  constructor(data?: PartialMessage<Matcher_MatcherList_FieldMatcher>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherList.FieldMatcher";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherList_FieldMatcher;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherList_FieldMatcher;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherList_FieldMatcher;

  static equals(a: Matcher_MatcherList_FieldMatcher | PlainMessage<Matcher_MatcherList_FieldMatcher> | undefined, b: Matcher_MatcherList_FieldMatcher | PlainMessage<Matcher_MatcherList_FieldMatcher> | undefined): boolean;
}

/**
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree
 */
export declare class Matcher_MatcherTree extends Message<Matcher_MatcherTree> {
  /**
   * Protocol-specific specification of input field to match on.
   *
   * @generated from field: envoy.config.core.v3.TypedExtensionConfig input = 1;
   */
  input?: TypedExtensionConfig;

  /**
   * Exact or prefix match maps in which to look up the input value.
   * If the lookup succeeds, the match is considered successful, and
   * the corresponding OnMatch is used.
   *
   * @generated from oneof envoy.config.common.matcher.v3.Matcher.MatcherTree.tree_type
   */
  treeType: {
    /**
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap exact_match_map = 2;
     */
    value: Matcher_MatcherTree_MatchMap;
    case: "exactMatchMap";
  } | {
    /**
     * Longest matching prefix wins.
     *
     * @generated from field: envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap prefix_match_map = 3;
     */
    value: Matcher_MatcherTree_MatchMap;
    case: "prefixMatchMap";
  } | {
    /**
     * Extension for custom matching logic.
     *
     * @generated from field: envoy.config.core.v3.TypedExtensionConfig custom_match = 4;
     */
    value: TypedExtensionConfig;
    case: "customMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Matcher_MatcherTree>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherTree";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherTree;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherTree;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherTree;

  static equals(a: Matcher_MatcherTree | PlainMessage<Matcher_MatcherTree> | undefined, b: Matcher_MatcherTree | PlainMessage<Matcher_MatcherTree> | undefined): boolean;
}

/**
 * A map of configured matchers. Used to allow using a map within a oneof.
 *
 * @generated from message envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap
 */
export declare class Matcher_MatcherTree_MatchMap extends Message<Matcher_MatcherTree_MatchMap> {
  /**
   * @generated from field: map<string, envoy.config.common.matcher.v3.Matcher.OnMatch> map = 1;
   */
  map: { [key: string]: Matcher_OnMatch };

  constructor(data?: PartialMessage<Matcher_MatcherTree_MatchMap>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.Matcher.MatcherTree.MatchMap";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Matcher_MatcherTree_MatchMap;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Matcher_MatcherTree_MatchMap;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Matcher_MatcherTree_MatchMap;

  static equals(a: Matcher_MatcherTree_MatchMap | PlainMessage<Matcher_MatcherTree_MatchMap> | undefined, b: Matcher_MatcherTree_MatchMap | PlainMessage<Matcher_MatcherTree_MatchMap> | undefined): boolean;
}

/**
 * Match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate
 */
export declare class MatchPredicate extends Message<MatchPredicate> {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.MatchPredicate.rule
   */
  rule: {
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet or_match = 1;
     */
    value: MatchPredicate_MatchSet;
    case: "orMatch";
  } | {
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate.MatchSet and_match = 2;
     */
    value: MatchPredicate_MatchSet;
    case: "andMatch";
  } | {
    /**
     * A negation match. The match configuration will match if the negated match condition matches.
     *
     * @generated from field: envoy.config.common.matcher.v3.MatchPredicate not_match = 3;
     */
    value: MatchPredicate;
    case: "notMatch";
  } | {
    /**
     * The match configuration will always match.
     *
     * @generated from field: bool any_match = 4;
     */
    value: boolean;
    case: "anyMatch";
  } | {
    /**
     * HTTP request headers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_headers_match = 5;
     */
    value: HttpHeadersMatch;
    case: "httpRequestHeadersMatch";
  } | {
    /**
     * HTTP request trailers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_request_trailers_match = 6;
     */
    value: HttpHeadersMatch;
    case: "httpRequestTrailersMatch";
  } | {
    /**
     * HTTP response headers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_headers_match = 7;
     */
    value: HttpHeadersMatch;
    case: "httpResponseHeadersMatch";
  } | {
    /**
     * HTTP response trailers match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpHeadersMatch http_response_trailers_match = 8;
     */
    value: HttpHeadersMatch;
    case: "httpResponseTrailersMatch";
  } | {
    /**
     * HTTP request generic body match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_request_generic_body_match = 9;
     */
    value: HttpGenericBodyMatch;
    case: "httpRequestGenericBodyMatch";
  } | {
    /**
     * HTTP response generic body match configuration.
     *
     * @generated from field: envoy.config.common.matcher.v3.HttpGenericBodyMatch http_response_generic_body_match = 10;
     */
    value: HttpGenericBodyMatch;
    case: "httpResponseGenericBodyMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<MatchPredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.MatchPredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchPredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchPredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchPredicate;

  static equals(a: MatchPredicate | PlainMessage<MatchPredicate> | undefined, b: MatchPredicate | PlainMessage<MatchPredicate> | undefined): boolean;
}

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.common.matcher.v3.MatchPredicate.MatchSet
 */
export declare class MatchPredicate_MatchSet extends Message<MatchPredicate_MatchSet> {
  /**
   * The list of rules that make up the set.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.MatchPredicate rules = 1;
   */
  rules: MatchPredicate[];

  constructor(data?: PartialMessage<MatchPredicate_MatchSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.MatchPredicate.MatchSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchPredicate_MatchSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchPredicate_MatchSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchPredicate_MatchSet;

  static equals(a: MatchPredicate_MatchSet | PlainMessage<MatchPredicate_MatchSet> | undefined, b: MatchPredicate_MatchSet | PlainMessage<MatchPredicate_MatchSet> | undefined): boolean;
}

/**
 * HTTP headers match configuration.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpHeadersMatch
 */
export declare class HttpHeadersMatch extends Message<HttpHeadersMatch> {
  /**
   * HTTP headers to match.
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 1;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<HttpHeadersMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.HttpHeadersMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpHeadersMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpHeadersMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpHeadersMatch;

  static equals(a: HttpHeadersMatch | PlainMessage<HttpHeadersMatch> | undefined, b: HttpHeadersMatch | PlainMessage<HttpHeadersMatch> | undefined): boolean;
}

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 *
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch
 */
export declare class HttpGenericBodyMatch extends Message<HttpGenericBodyMatch> {
  /**
   * Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
   *
   * @generated from field: uint32 bytes_limit = 1;
   */
  bytesLimit: number;

  /**
   * List of patterns to match.
   *
   * @generated from field: repeated envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2;
   */
  patterns: HttpGenericBodyMatch_GenericTextMatch[];

  constructor(data?: PartialMessage<HttpGenericBodyMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.HttpGenericBodyMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpGenericBodyMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch;

  static equals(a: HttpGenericBodyMatch | PlainMessage<HttpGenericBodyMatch> | undefined, b: HttpGenericBodyMatch | PlainMessage<HttpGenericBodyMatch> | undefined): boolean;
}

/**
 * @generated from message envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export declare class HttpGenericBodyMatch_GenericTextMatch extends Message<HttpGenericBodyMatch_GenericTextMatch> {
  /**
   * @generated from oneof envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch.rule
   */
  rule: {
    /**
     * Text string to be located in HTTP body.
     *
     * @generated from field: string string_match = 1;
     */
    value: string;
    case: "stringMatch";
  } | {
    /**
     * Sequence of bytes to be located in HTTP body.
     *
     * @generated from field: bytes binary_match = 2;
     */
    value: Uint8Array;
    case: "binaryMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<HttpGenericBodyMatch_GenericTextMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.common.matcher.v3.HttpGenericBodyMatch.GenericTextMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static equals(a: HttpGenericBodyMatch_GenericTextMatch | PlainMessage<HttpGenericBodyMatch_GenericTextMatch> | undefined, b: HttpGenericBodyMatch_GenericTextMatch | PlainMessage<HttpGenericBodyMatch_GenericTextMatch> | undefined): boolean;
}

