// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/accesslog/v3/accesslog.proto (package envoy.config.accesslog.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { RuntimeUInt32 } from "../../core/v3/base_pb.js";
import type { FractionalPercent } from "../../../type/v3/percent_pb.js";
import type { HeaderMatcher } from "../../route/v3/route_components_pb.js";
import type { MetadataMatcher } from "../../../type/matcher/v3/metadata_pb.js";
import type { AccessLogType } from "../../../data/accesslog/v3/accesslog_pb.js";

/**
 * @generated from message envoy.config.accesslog.v3.AccessLog
 */
export declare class AccessLog extends Message<AccessLog> {
  /**
   * The name of the access log extension configuration.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Filter which is used to determine if the access log needs to be written.
   *
   * @generated from field: envoy.config.accesslog.v3.AccessLogFilter filter = 2;
   */
  filter?: AccessLogFilter;

  /**
   * Custom configuration that must be set according to the access logger extension being instantiated.
   * [#extension-category: envoy.access_loggers]
   *
   * @generated from oneof envoy.config.accesslog.v3.AccessLog.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Any typed_config = 4;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<AccessLog>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.AccessLog";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessLog;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessLog;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessLog;

  static equals(a: AccessLog | PlainMessage<AccessLog> | undefined, b: AccessLog | PlainMessage<AccessLog> | undefined): boolean;
}

/**
 * [#next-free-field: 14]
 *
 * @generated from message envoy.config.accesslog.v3.AccessLogFilter
 */
export declare class AccessLogFilter extends Message<AccessLogFilter> {
  /**
   * @generated from oneof envoy.config.accesslog.v3.AccessLogFilter.filter_specifier
   */
  filterSpecifier: {
    /**
     * Status code filter.
     *
     * @generated from field: envoy.config.accesslog.v3.StatusCodeFilter status_code_filter = 1;
     */
    value: StatusCodeFilter;
    case: "statusCodeFilter";
  } | {
    /**
     * Duration filter.
     *
     * @generated from field: envoy.config.accesslog.v3.DurationFilter duration_filter = 2;
     */
    value: DurationFilter;
    case: "durationFilter";
  } | {
    /**
     * Not health check filter.
     *
     * @generated from field: envoy.config.accesslog.v3.NotHealthCheckFilter not_health_check_filter = 3;
     */
    value: NotHealthCheckFilter;
    case: "notHealthCheckFilter";
  } | {
    /**
     * Traceable filter.
     *
     * @generated from field: envoy.config.accesslog.v3.TraceableFilter traceable_filter = 4;
     */
    value: TraceableFilter;
    case: "traceableFilter";
  } | {
    /**
     * Runtime filter.
     *
     * @generated from field: envoy.config.accesslog.v3.RuntimeFilter runtime_filter = 5;
     */
    value: RuntimeFilter;
    case: "runtimeFilter";
  } | {
    /**
     * And filter.
     *
     * @generated from field: envoy.config.accesslog.v3.AndFilter and_filter = 6;
     */
    value: AndFilter;
    case: "andFilter";
  } | {
    /**
     * Or filter.
     *
     * @generated from field: envoy.config.accesslog.v3.OrFilter or_filter = 7;
     */
    value: OrFilter;
    case: "orFilter";
  } | {
    /**
     * Header filter.
     *
     * @generated from field: envoy.config.accesslog.v3.HeaderFilter header_filter = 8;
     */
    value: HeaderFilter;
    case: "headerFilter";
  } | {
    /**
     * Response flag filter.
     *
     * @generated from field: envoy.config.accesslog.v3.ResponseFlagFilter response_flag_filter = 9;
     */
    value: ResponseFlagFilter;
    case: "responseFlagFilter";
  } | {
    /**
     * gRPC status filter.
     *
     * @generated from field: envoy.config.accesslog.v3.GrpcStatusFilter grpc_status_filter = 10;
     */
    value: GrpcStatusFilter;
    case: "grpcStatusFilter";
  } | {
    /**
     * Extension filter.
     * [#extension-category: envoy.access_loggers.extension_filters]
     *
     * @generated from field: envoy.config.accesslog.v3.ExtensionFilter extension_filter = 11;
     */
    value: ExtensionFilter;
    case: "extensionFilter";
  } | {
    /**
     * Metadata Filter
     *
     * @generated from field: envoy.config.accesslog.v3.MetadataFilter metadata_filter = 12;
     */
    value: MetadataFilter;
    case: "metadataFilter";
  } | {
    /**
     * Log Type Filter
     *
     * @generated from field: envoy.config.accesslog.v3.LogTypeFilter log_type_filter = 13;
     */
    value: LogTypeFilter;
    case: "logTypeFilter";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<AccessLogFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.AccessLogFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessLogFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessLogFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessLogFilter;

  static equals(a: AccessLogFilter | PlainMessage<AccessLogFilter> | undefined, b: AccessLogFilter | PlainMessage<AccessLogFilter> | undefined): boolean;
}

/**
 * Filter on an integer comparison.
 *
 * @generated from message envoy.config.accesslog.v3.ComparisonFilter
 */
export declare class ComparisonFilter extends Message<ComparisonFilter> {
  /**
   * Comparison operator.
   *
   * @generated from field: envoy.config.accesslog.v3.ComparisonFilter.Op op = 1;
   */
  op: ComparisonFilter_Op;

  /**
   * Value to compare against.
   *
   * @generated from field: envoy.config.core.v3.RuntimeUInt32 value = 2;
   */
  value?: RuntimeUInt32;

  constructor(data?: PartialMessage<ComparisonFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.ComparisonFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComparisonFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComparisonFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComparisonFilter;

  static equals(a: ComparisonFilter | PlainMessage<ComparisonFilter> | undefined, b: ComparisonFilter | PlainMessage<ComparisonFilter> | undefined): boolean;
}

/**
 * @generated from enum envoy.config.accesslog.v3.ComparisonFilter.Op
 */
export declare enum ComparisonFilter_Op {
  /**
   * =
   *
   * @generated from enum value: EQ = 0;
   */
  EQ = 0,

  /**
   * >=
   *
   * @generated from enum value: GE = 1;
   */
  GE = 1,

  /**
   * <=
   *
   * @generated from enum value: LE = 2;
   */
  LE = 2,
}

/**
 * Filters on HTTP response/status code.
 *
 * @generated from message envoy.config.accesslog.v3.StatusCodeFilter
 */
export declare class StatusCodeFilter extends Message<StatusCodeFilter> {
  /**
   * Comparison.
   *
   * @generated from field: envoy.config.accesslog.v3.ComparisonFilter comparison = 1;
   */
  comparison?: ComparisonFilter;

  constructor(data?: PartialMessage<StatusCodeFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.StatusCodeFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusCodeFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusCodeFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusCodeFilter;

  static equals(a: StatusCodeFilter | PlainMessage<StatusCodeFilter> | undefined, b: StatusCodeFilter | PlainMessage<StatusCodeFilter> | undefined): boolean;
}

/**
 * Filters based on the duration of the request or stream, in milliseconds.
 * For end of stream access logs, the total duration of the stream will be used.
 * For :ref:`periodic access logs<arch_overview_access_log_periodic>`,
 * the duration of the stream at the time of log recording will be used.
 *
 * @generated from message envoy.config.accesslog.v3.DurationFilter
 */
export declare class DurationFilter extends Message<DurationFilter> {
  /**
   * Comparison.
   *
   * @generated from field: envoy.config.accesslog.v3.ComparisonFilter comparison = 1;
   */
  comparison?: ComparisonFilter;

  constructor(data?: PartialMessage<DurationFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.DurationFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DurationFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DurationFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DurationFilter;

  static equals(a: DurationFilter | PlainMessage<DurationFilter> | undefined, b: DurationFilter | PlainMessage<DurationFilter> | undefined): boolean;
}

/**
 * Filters for requests that are not health check requests. A health check
 * request is marked by the health check filter.
 *
 * @generated from message envoy.config.accesslog.v3.NotHealthCheckFilter
 */
export declare class NotHealthCheckFilter extends Message<NotHealthCheckFilter> {
  constructor(data?: PartialMessage<NotHealthCheckFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.NotHealthCheckFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NotHealthCheckFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NotHealthCheckFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NotHealthCheckFilter;

  static equals(a: NotHealthCheckFilter | PlainMessage<NotHealthCheckFilter> | undefined, b: NotHealthCheckFilter | PlainMessage<NotHealthCheckFilter> | undefined): boolean;
}

/**
 * Filters for requests that are traceable. See the tracing overview for more
 * information on how a request becomes traceable.
 *
 * @generated from message envoy.config.accesslog.v3.TraceableFilter
 */
export declare class TraceableFilter extends Message<TraceableFilter> {
  constructor(data?: PartialMessage<TraceableFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.TraceableFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TraceableFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TraceableFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TraceableFilter;

  static equals(a: TraceableFilter | PlainMessage<TraceableFilter> | undefined, b: TraceableFilter | PlainMessage<TraceableFilter> | undefined): boolean;
}

/**
 * Filters for random sampling of requests.
 *
 * @generated from message envoy.config.accesslog.v3.RuntimeFilter
 */
export declare class RuntimeFilter extends Message<RuntimeFilter> {
  /**
   * Runtime key to get an optional overridden numerator for use in the
   * ``percent_sampled`` field. If found in runtime, this value will replace the
   * default numerator.
   *
   * @generated from field: string runtime_key = 1;
   */
  runtimeKey: string;

  /**
   * The default sampling percentage. If not specified, defaults to 0% with
   * denominator of 100.
   *
   * @generated from field: envoy.type.v3.FractionalPercent percent_sampled = 2;
   */
  percentSampled?: FractionalPercent;

  /**
   * By default, sampling pivots on the header
   * :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being
   * present. If :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`
   * is present, the filter will consistently sample across multiple hosts based
   * on the runtime key value and the value extracted from
   * :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
   * missing, or ``use_independent_randomness`` is set to true, the filter will
   * randomly sample based on the runtime key value alone.
   * ``use_independent_randomness`` can be used for logging kill switches within
   * complex nested :ref:`AndFilter
   * <envoy_v3_api_msg_config.accesslog.v3.AndFilter>` and :ref:`OrFilter
   * <envoy_v3_api_msg_config.accesslog.v3.OrFilter>` blocks that are easier to
   * reason about from a probability perspective (i.e., setting to true will
   * cause the filter to behave like an independent random variable when
   * composed within logical operator filters).
   *
   * @generated from field: bool use_independent_randomness = 3;
   */
  useIndependentRandomness: boolean;

  constructor(data?: PartialMessage<RuntimeFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.RuntimeFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuntimeFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuntimeFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuntimeFilter;

  static equals(a: RuntimeFilter | PlainMessage<RuntimeFilter> | undefined, b: RuntimeFilter | PlainMessage<RuntimeFilter> | undefined): boolean;
}

/**
 * Performs a logical “and” operation on the result of each filter in filters.
 * Filters are evaluated sequentially and if one of them returns false, the
 * filter returns false immediately.
 *
 * @generated from message envoy.config.accesslog.v3.AndFilter
 */
export declare class AndFilter extends Message<AndFilter> {
  /**
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLogFilter filters = 1;
   */
  filters: AccessLogFilter[];

  constructor(data?: PartialMessage<AndFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.AndFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AndFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AndFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AndFilter;

  static equals(a: AndFilter | PlainMessage<AndFilter> | undefined, b: AndFilter | PlainMessage<AndFilter> | undefined): boolean;
}

/**
 * Performs a logical “or” operation on the result of each individual filter.
 * Filters are evaluated sequentially and if one of them returns true, the
 * filter returns true immediately.
 *
 * @generated from message envoy.config.accesslog.v3.OrFilter
 */
export declare class OrFilter extends Message<OrFilter> {
  /**
   * @generated from field: repeated envoy.config.accesslog.v3.AccessLogFilter filters = 2;
   */
  filters: AccessLogFilter[];

  constructor(data?: PartialMessage<OrFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.OrFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrFilter;

  static equals(a: OrFilter | PlainMessage<OrFilter> | undefined, b: OrFilter | PlainMessage<OrFilter> | undefined): boolean;
}

/**
 * Filters requests based on the presence or value of a request header.
 *
 * @generated from message envoy.config.accesslog.v3.HeaderFilter
 */
export declare class HeaderFilter extends Message<HeaderFilter> {
  /**
   * Only requests with a header which matches the specified HeaderMatcher will
   * pass the filter check.
   *
   * @generated from field: envoy.config.route.v3.HeaderMatcher header = 1;
   */
  header?: HeaderMatcher;

  constructor(data?: PartialMessage<HeaderFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.HeaderFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderFilter;

  static equals(a: HeaderFilter | PlainMessage<HeaderFilter> | undefined, b: HeaderFilter | PlainMessage<HeaderFilter> | undefined): boolean;
}

/**
 * Filters requests that received responses with an Envoy response flag set.
 * A list of the response flags can be found
 * in the access log formatter
 * :ref:`documentation<config_access_log_format_response_flags>`.
 *
 * @generated from message envoy.config.accesslog.v3.ResponseFlagFilter
 */
export declare class ResponseFlagFilter extends Message<ResponseFlagFilter> {
  /**
   * Only responses with the any of the flags listed in this field will be
   * logged. This field is optional. If it is not specified, then any response
   * flag will pass the filter check.
   *
   * @generated from field: repeated string flags = 1;
   */
  flags: string[];

  constructor(data?: PartialMessage<ResponseFlagFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.ResponseFlagFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseFlagFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseFlagFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseFlagFilter;

  static equals(a: ResponseFlagFilter | PlainMessage<ResponseFlagFilter> | undefined, b: ResponseFlagFilter | PlainMessage<ResponseFlagFilter> | undefined): boolean;
}

/**
 * Filters gRPC requests based on their response status. If a gRPC status is not
 * provided, the filter will infer the status from the HTTP status code.
 *
 * @generated from message envoy.config.accesslog.v3.GrpcStatusFilter
 */
export declare class GrpcStatusFilter extends Message<GrpcStatusFilter> {
  /**
   * Logs only responses that have any one of the gRPC statuses in this field.
   *
   * @generated from field: repeated envoy.config.accesslog.v3.GrpcStatusFilter.Status statuses = 1;
   */
  statuses: GrpcStatusFilter_Status[];

  /**
   * If included and set to true, the filter will instead block all responses
   * with a gRPC status or inferred gRPC status enumerated in statuses, and
   * allow all other responses.
   *
   * @generated from field: bool exclude = 2;
   */
  exclude: boolean;

  constructor(data?: PartialMessage<GrpcStatusFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.GrpcStatusFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcStatusFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcStatusFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcStatusFilter;

  static equals(a: GrpcStatusFilter | PlainMessage<GrpcStatusFilter> | undefined, b: GrpcStatusFilter | PlainMessage<GrpcStatusFilter> | undefined): boolean;
}

/**
 * @generated from enum envoy.config.accesslog.v3.GrpcStatusFilter.Status
 */
export declare enum GrpcStatusFilter_Status {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: CANCELED = 1;
   */
  CANCELED = 1,

  /**
   * @generated from enum value: UNKNOWN = 2;
   */
  UNKNOWN = 2,

  /**
   * @generated from enum value: INVALID_ARGUMENT = 3;
   */
  INVALID_ARGUMENT = 3,

  /**
   * @generated from enum value: DEADLINE_EXCEEDED = 4;
   */
  DEADLINE_EXCEEDED = 4,

  /**
   * @generated from enum value: NOT_FOUND = 5;
   */
  NOT_FOUND = 5,

  /**
   * @generated from enum value: ALREADY_EXISTS = 6;
   */
  ALREADY_EXISTS = 6,

  /**
   * @generated from enum value: PERMISSION_DENIED = 7;
   */
  PERMISSION_DENIED = 7,

  /**
   * @generated from enum value: RESOURCE_EXHAUSTED = 8;
   */
  RESOURCE_EXHAUSTED = 8,

  /**
   * @generated from enum value: FAILED_PRECONDITION = 9;
   */
  FAILED_PRECONDITION = 9,

  /**
   * @generated from enum value: ABORTED = 10;
   */
  ABORTED = 10,

  /**
   * @generated from enum value: OUT_OF_RANGE = 11;
   */
  OUT_OF_RANGE = 11,

  /**
   * @generated from enum value: UNIMPLEMENTED = 12;
   */
  UNIMPLEMENTED = 12,

  /**
   * @generated from enum value: INTERNAL = 13;
   */
  INTERNAL = 13,

  /**
   * @generated from enum value: UNAVAILABLE = 14;
   */
  UNAVAILABLE = 14,

  /**
   * @generated from enum value: DATA_LOSS = 15;
   */
  DATA_LOSS = 15,

  /**
   * @generated from enum value: UNAUTHENTICATED = 16;
   */
  UNAUTHENTICATED = 16,
}

/**
 * Filters based on matching dynamic metadata.
 * If the matcher path and key correspond to an existing key in dynamic
 * metadata, the request is logged only if the matcher value is equal to the
 * metadata value. If the matcher path and key *do not* correspond to an
 * existing key in dynamic metadata, the request is logged only if
 * match_if_key_not_found is "true" or unset.
 *
 * @generated from message envoy.config.accesslog.v3.MetadataFilter
 */
export declare class MetadataFilter extends Message<MetadataFilter> {
  /**
   * Matcher to check metadata for specified value. For example, to match on the
   * access_log_hint metadata, set the filter to "envoy.common" and the path to
   * "access_log_hint", and the value to "true".
   *
   * @generated from field: envoy.type.matcher.v3.MetadataMatcher matcher = 1;
   */
  matcher?: MetadataMatcher;

  /**
   * Default result if the key does not exist in dynamic metadata: if unset or
   * true, then log; if false, then don't log.
   *
   * @generated from field: google.protobuf.BoolValue match_if_key_not_found = 2;
   */
  matchIfKeyNotFound?: boolean;

  constructor(data?: PartialMessage<MetadataFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.MetadataFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetadataFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetadataFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetadataFilter;

  static equals(a: MetadataFilter | PlainMessage<MetadataFilter> | undefined, b: MetadataFilter | PlainMessage<MetadataFilter> | undefined): boolean;
}

/**
 * Filters based on access log type.
 *
 * @generated from message envoy.config.accesslog.v3.LogTypeFilter
 */
export declare class LogTypeFilter extends Message<LogTypeFilter> {
  /**
   * Logs only records which their type is one of the types defined in this field.
   *
   * @generated from field: repeated envoy.data.accesslog.v3.AccessLogType types = 1;
   */
  types: AccessLogType[];

  /**
   * If this field is set to true, the filter will instead block all records
   * with a access log type in types field, and allow all other records.
   *
   * @generated from field: bool exclude = 2;
   */
  exclude: boolean;

  constructor(data?: PartialMessage<LogTypeFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.LogTypeFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogTypeFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogTypeFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogTypeFilter;

  static equals(a: LogTypeFilter | PlainMessage<LogTypeFilter> | undefined, b: LogTypeFilter | PlainMessage<LogTypeFilter> | undefined): boolean;
}

/**
 * Extension filter is statically registered at runtime.
 *
 * @generated from message envoy.config.accesslog.v3.ExtensionFilter
 */
export declare class ExtensionFilter extends Message<ExtensionFilter> {
  /**
   * The name of the filter implementation to instantiate. The name must
   * match a statically registered filter.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Custom configuration that depends on the filter being instantiated.
   *
   * @generated from oneof envoy.config.accesslog.v3.ExtensionFilter.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ExtensionFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.accesslog.v3.ExtensionFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensionFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensionFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensionFilter;

  static equals(a: ExtensionFilter | PlainMessage<ExtensionFilter> | undefined, b: ExtensionFilter | PlainMessage<ExtensionFilter> | undefined): boolean;
}

