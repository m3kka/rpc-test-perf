// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/tap/v3/common.proto" (package "envoy.config.tap.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GrpcService } from "../../core/v3/grpc_service";
import { Duration } from "../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { HeaderMatcher } from "../../route/v3/route_components";
import { RuntimeFractionalPercent } from "../../core/v3/base";
import { MatchPredicate as MatchPredicate$ } from "../../common/matcher/v3/matcher";
// [#protodoc-title: Tap common configuration]

/**
 * Tap configuration.
 *
 * [#comment:TODO(mattklein123): Rate limiting]
 *
 * @generated from protobuf message envoy.config.tap.v3.TapConfig
 */
export interface TapConfig {
    /**
     * The match configuration. If the configuration matches the data source being tapped, a tap will
     * occur, with the result written to the configured output.
     * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
     * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
     * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
     *
     * @deprecated
     * @generated from protobuf field: envoy.config.tap.v3.MatchPredicate match_config = 1 [deprecated = true];
     */
    matchConfig?: MatchPredicate;
    /**
     * The match configuration. If the configuration matches the data source being tapped, a tap will
     * occur, with the result written to the configured output.
     * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
     * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
     * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
     *
     * @generated from protobuf field: envoy.config.common.matcher.v3.MatchPredicate match = 4;
     */
    match?: MatchPredicate$;
    /**
     * The tap output configuration. If a match configuration matches a data source being tapped,
     * a tap will occur and the data will be written to the configured output.
     *
     * @generated from protobuf field: envoy.config.tap.v3.OutputConfig output_config = 2;
     */
    outputConfig?: OutputConfig;
    /**
     * [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
     * which the tap matching is enabled. When not enabled, the request\connection will not be
     * recorded.
     *
     * .. note::
     *
     *   This field defaults to 100/:ref:`HUNDRED
     *   <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
     *
     * @generated from protobuf field: envoy.config.core.v3.RuntimeFractionalPercent tap_enabled = 3;
     */
    tapEnabled?: RuntimeFractionalPercent;
}
/**
 * Tap match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.config.tap.v3.MatchPredicate
 */
export interface MatchPredicate {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "orMatch";
        /**
         * A set that describes a logical OR. If any member of the set matches, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.tap.v3.MatchPredicate.MatchSet or_match = 1;
         */
        orMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "andMatch";
        /**
         * A set that describes a logical AND. If all members of the set match, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.config.tap.v3.MatchPredicate.MatchSet and_match = 2;
         */
        andMatch: MatchPredicate_MatchSet;
    } | {
        oneofKind: "notMatch";
        /**
         * A negation match. The match configuration will match if the negated match condition matches.
         *
         * @generated from protobuf field: envoy.config.tap.v3.MatchPredicate not_match = 3;
         */
        notMatch: MatchPredicate;
    } | {
        oneofKind: "anyMatch";
        /**
         * The match configuration will always match.
         *
         * @generated from protobuf field: bool any_match = 4;
         */
        anyMatch: boolean;
    } | {
        oneofKind: "httpRequestHeadersMatch";
        /**
         * HTTP request headers match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpHeadersMatch http_request_headers_match = 5;
         */
        httpRequestHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpRequestTrailersMatch";
        /**
         * HTTP request trailers match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpHeadersMatch http_request_trailers_match = 6;
         */
        httpRequestTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseHeadersMatch";
        /**
         * HTTP response headers match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpHeadersMatch http_response_headers_match = 7;
         */
        httpResponseHeadersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpResponseTrailersMatch";
        /**
         * HTTP response trailers match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpHeadersMatch http_response_trailers_match = 8;
         */
        httpResponseTrailersMatch: HttpHeadersMatch;
    } | {
        oneofKind: "httpRequestGenericBodyMatch";
        /**
         * HTTP request generic body match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpGenericBodyMatch http_request_generic_body_match = 9;
         */
        httpRequestGenericBodyMatch: HttpGenericBodyMatch;
    } | {
        oneofKind: "httpResponseGenericBodyMatch";
        /**
         * HTTP response generic body match configuration.
         *
         * @generated from protobuf field: envoy.config.tap.v3.HttpGenericBodyMatch http_response_generic_body_match = 10;
         */
        httpResponseGenericBodyMatch: HttpGenericBodyMatch;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of match configurations used for logical operations.
 *
 * @generated from protobuf message envoy.config.tap.v3.MatchPredicate.MatchSet
 */
export interface MatchPredicate_MatchSet {
    /**
     * The list of rules that make up the set.
     *
     * @generated from protobuf field: repeated envoy.config.tap.v3.MatchPredicate rules = 1;
     */
    rules: MatchPredicate[];
}
/**
 * HTTP headers match configuration.
 *
 * @generated from protobuf message envoy.config.tap.v3.HttpHeadersMatch
 */
export interface HttpHeadersMatch {
    /**
     * HTTP headers to match.
     *
     * @generated from protobuf field: repeated envoy.config.route.v3.HeaderMatcher headers = 1;
     */
    headers: HeaderMatcher[];
}
/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 *
 * @generated from protobuf message envoy.config.tap.v3.HttpGenericBodyMatch
 */
export interface HttpGenericBodyMatch {
    /**
     * Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
     *
     * @generated from protobuf field: uint32 bytes_limit = 1;
     */
    bytesLimit: number;
    /**
     * List of patterns to match.
     *
     * @generated from protobuf field: repeated envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2;
     */
    patterns: HttpGenericBodyMatch_GenericTextMatch[];
}
/**
 * @generated from protobuf message envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export interface HttpGenericBodyMatch_GenericTextMatch {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "stringMatch";
        /**
         * Text string to be located in HTTP body.
         *
         * @generated from protobuf field: string string_match = 1;
         */
        stringMatch: string;
    } | {
        oneofKind: "binaryMatch";
        /**
         * Sequence of bytes to be located in HTTP body.
         *
         * @generated from protobuf field: bytes binary_match = 2;
         */
        binaryMatch: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Tap output configuration.
 *
 * @generated from protobuf message envoy.config.tap.v3.OutputConfig
 */
export interface OutputConfig {
    /**
     * Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
     * sink types are supported this constraint will be relaxed.
     *
     * @generated from protobuf field: repeated envoy.config.tap.v3.OutputSink sinks = 1;
     */
    sinks: OutputSink[];
    /**
     * For buffered tapping, the maximum amount of received body that will be buffered prior to
     * truncation. If truncation occurs, the :ref:`truncated
     * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
     * default is 1KiB.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_buffered_rx_bytes = 2;
     */
    maxBufferedRxBytes?: UInt32Value;
    /**
     * For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
     * truncation. If truncation occurs, the :ref:`truncated
     * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
     * default is 1KiB.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_buffered_tx_bytes = 3;
     */
    maxBufferedTxBytes?: UInt32Value;
    /**
     * Indicates whether taps produce a single buffered message per tap, or multiple streamed
     * messages per tap in the emitted :ref:`TraceWrapper
     * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. Note that streamed tapping does not
     * mean that no buffering takes place. Buffering may be required if data is processed before a
     * match can be determined. See the HTTP tap filter :ref:`streaming
     * <config_http_filters_tap_streaming>` documentation for more information.
     *
     * @generated from protobuf field: bool streaming = 4;
     */
    streaming: boolean;
}
/**
 * Tap output sink configuration.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.config.tap.v3.OutputSink
 */
export interface OutputSink {
    /**
     * Sink output format.
     *
     * @generated from protobuf field: envoy.config.tap.v3.OutputSink.Format format = 1;
     */
    format: OutputSink_Format;
    /**
     * @generated from protobuf oneof: output_sink_type
     */
    outputSinkType: {
        oneofKind: "streamingAdmin";
        /**
         * Tap output will be streamed out the :http:post:`/tap` admin endpoint.
         *
         * .. attention::
         *
         *   It is only allowed to specify the streaming admin output sink if the tap is being
         *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
         *   been configured to receive tap configuration from some other source (e.g., static
         *   file, XDS, etc.) configuring the streaming admin output type will fail.
         *
         * @generated from protobuf field: envoy.config.tap.v3.StreamingAdminSink streaming_admin = 2;
         */
        streamingAdmin: StreamingAdminSink;
    } | {
        oneofKind: "filePerTap";
        /**
         * Tap output will be written to a file per tap sink.
         *
         * @generated from protobuf field: envoy.config.tap.v3.FilePerTapSink file_per_tap = 3;
         */
        filePerTap: FilePerTapSink;
    } | {
        oneofKind: "streamingGrpc";
        /**
         * [#not-implemented-hide:]
         * GrpcService to stream data to. The format argument must be PROTO_BINARY.
         * [#comment: TODO(samflattery): remove cleanup in uber_per_filter.cc once implemented]
         *
         * @generated from protobuf field: envoy.config.tap.v3.StreamingGrpcSink streaming_grpc = 4;
         */
        streamingGrpc: StreamingGrpcSink;
    } | {
        oneofKind: "bufferedAdmin";
        /**
         * Tap output will be buffered in a single block before flushing to the :http:post:`/tap` admin endpoint
         *
         * .. attention::
         *
         *   It is only allowed to specify the buffered admin output sink if the tap is being
         *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
         *   been configured to receive tap configuration from some other source (e.g., static
         *   file, XDS, etc.) configuring the buffered admin output type will fail.
         *
         * @generated from protobuf field: envoy.config.tap.v3.BufferedAdminSink buffered_admin = 5;
         */
        bufferedAdmin: BufferedAdminSink;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Output format. All output is in the form of one or more :ref:`TraceWrapper
 * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. This enumeration indicates
 * how those messages are written. Note that not all sinks support all output formats. See
 * individual sink documentation for more information.
 *
 * @generated from protobuf enum envoy.config.tap.v3.OutputSink.Format
 */
export enum OutputSink_Format {
    /**
     * Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
     * data will be present in the :ref:`as_bytes
     * <envoy_v3_api_field_data.tap.v3.Body.as_bytes>` field. This means that body data will be
     * base64 encoded as per the `proto3 JSON mappings
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
     *
     * @generated from protobuf enum value: JSON_BODY_AS_BYTES = 0;
     */
    JSON_BODY_AS_BYTES = 0,
    /**
     * Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
     * data will be present in the :ref:`as_string
     * <envoy_v3_api_field_data.tap.v3.Body.as_string>` field. This means that body data will be
     * string encoded as per the `proto3 JSON mappings
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
     * useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
     * user wishes to view it directly without being forced to base64 decode the body.
     *
     * @generated from protobuf enum value: JSON_BODY_AS_STRING = 1;
     */
    JSON_BODY_AS_STRING = 1,
    /**
     * Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
     * multiple binary messages without any length information the data stream will not be
     * useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
     * this output format makes consumption simpler.
     *
     * @generated from protobuf enum value: PROTO_BINARY = 2;
     */
    PROTO_BINARY = 2,
    /**
     * Messages are written as a sequence tuples, where each tuple is the message length encoded
     * as a `protobuf 32-bit varint
     * <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
     * followed by the binary message. The messages can be read back using the language specific
     * protobuf coded stream implementation to obtain the message length and the message.
     *
     * @generated from protobuf enum value: PROTO_BINARY_LENGTH_DELIMITED = 3;
     */
    PROTO_BINARY_LENGTH_DELIMITED = 3,
    /**
     * Text proto format.
     *
     * @generated from protobuf enum value: PROTO_TEXT = 4;
     */
    PROTO_TEXT = 4
}
/**
 * Streaming admin sink configuration.
 *
 * @generated from protobuf message envoy.config.tap.v3.StreamingAdminSink
 */
export interface StreamingAdminSink {
}
/**
 * BufferedAdminSink configures a tap output to collect traces without returning them until
 * one of multiple criteria are satisfied.
 * Similar to StreamingAdminSink, it is only allowed to specify the buffered admin output
 * sink if the tap is being configured from the ``/tap`` admin endpoint.
 *
 * @generated from protobuf message envoy.config.tap.v3.BufferedAdminSink
 */
export interface BufferedAdminSink {
    /**
     * Stop collecting traces when the specified number are collected.
     * If other criteria for ending collection are reached first, this value will not be used.
     *
     * @generated from protobuf field: uint64 max_traces = 1;
     */
    maxTraces: bigint;
    /**
     * Acts as a fallback to prevent the client from waiting for long periods of time.
     * After timeout has occurred, a buffer flush will be triggered, returning the traces buffered so far.
     * This may result in returning fewer traces than were requested, and in the case that no traces are
     * buffered during this time, no traces will be returned.
     * Specifying 0 for the timeout value (or not specifying a value at all) indicates an infinite timeout.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 2;
     */
    timeout?: Duration;
}
/**
 * The file per tap sink outputs a discrete file for every tapped stream.
 *
 * @generated from protobuf message envoy.config.tap.v3.FilePerTapSink
 */
export interface FilePerTapSink {
    /**
     * Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
     * identifier distinguishing the recorded trace for stream instances (the Envoy
     * connection ID, HTTP stream ID, etc.).
     *
     * @generated from protobuf field: string path_prefix = 1;
     */
    pathPrefix: string;
}
/**
 * [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
 * server.
 *
 * @generated from protobuf message envoy.config.tap.v3.StreamingGrpcSink
 */
export interface StreamingGrpcSink {
    /**
     * Opaque identifier, that will be sent back to the streaming grpc server.
     *
     * @generated from protobuf field: string tap_id = 1;
     */
    tapId: string;
    /**
     * The gRPC server that hosts the Tap Sink Service.
     *
     * @generated from protobuf field: envoy.config.core.v3.GrpcService grpc_service = 2;
     */
    grpcService?: GrpcService;
}
// @generated message type with reflection information, may provide speed optimized methods
class TapConfig$Type extends MessageType<TapConfig> {
    constructor() {
        super("envoy.config.tap.v3.TapConfig", [
            { no: 1, name: "match_config", kind: "message", T: () => MatchPredicate, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "match", kind: "message", T: () => MatchPredicate$ },
            { no: 2, name: "output_config", kind: "message", T: () => OutputConfig, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "tap_enabled", kind: "message", T: () => RuntimeFractionalPercent }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.TapConfig" } });
    }
    create(value?: PartialMessage<TapConfig>): TapConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TapConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TapConfig): TapConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.tap.v3.MatchPredicate match_config = 1 [deprecated = true];*/ 1:
                    message.matchConfig = MatchPredicate.internalBinaryRead(reader, reader.uint32(), options, message.matchConfig);
                    break;
                case /* envoy.config.common.matcher.v3.MatchPredicate match */ 4:
                    message.match = MatchPredicate$.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* envoy.config.tap.v3.OutputConfig output_config */ 2:
                    message.outputConfig = OutputConfig.internalBinaryRead(reader, reader.uint32(), options, message.outputConfig);
                    break;
                case /* envoy.config.core.v3.RuntimeFractionalPercent tap_enabled */ 3:
                    message.tapEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.tapEnabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TapConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.tap.v3.MatchPredicate match_config = 1 [deprecated = true]; */
        if (message.matchConfig)
            MatchPredicate.internalBinaryWrite(message.matchConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.common.matcher.v3.MatchPredicate match = 4; */
        if (message.match)
            MatchPredicate$.internalBinaryWrite(message.match, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.OutputConfig output_config = 2; */
        if (message.outputConfig)
            OutputConfig.internalBinaryWrite(message.outputConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RuntimeFractionalPercent tap_enabled = 3; */
        if (message.tapEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.tapEnabled, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.TapConfig
 */
export const TapConfig = new TapConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate$Type extends MessageType<MatchPredicate> {
    constructor() {
        super("envoy.config.tap.v3.MatchPredicate", [
            { no: 1, name: "or_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 2, name: "and_match", kind: "message", oneof: "rule", T: () => MatchPredicate_MatchSet },
            { no: 3, name: "not_match", kind: "message", oneof: "rule", T: () => MatchPredicate },
            { no: 4, name: "any_match", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 5, name: "http_request_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 6, name: "http_request_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 7, name: "http_response_headers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 8, name: "http_response_trailers_match", kind: "message", oneof: "rule", T: () => HttpHeadersMatch },
            { no: 9, name: "http_request_generic_body_match", kind: "message", oneof: "rule", T: () => HttpGenericBodyMatch },
            { no: 10, name: "http_response_generic_body_match", kind: "message", oneof: "rule", T: () => HttpGenericBodyMatch }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.MatchPredicate" } });
    }
    create(value?: PartialMessage<MatchPredicate>): MatchPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate): MatchPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.tap.v3.MatchPredicate.MatchSet or_match */ 1:
                    message.rule = {
                        oneofKind: "orMatch",
                        orMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.MatchPredicate.MatchSet and_match */ 2:
                    message.rule = {
                        oneofKind: "andMatch",
                        andMatch: MatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.MatchPredicate not_match */ 3:
                    message.rule = {
                        oneofKind: "notMatch",
                        notMatch: MatchPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notMatch)
                    };
                    break;
                case /* bool any_match */ 4:
                    message.rule = {
                        oneofKind: "anyMatch",
                        anyMatch: reader.bool()
                    };
                    break;
                case /* envoy.config.tap.v3.HttpHeadersMatch http_request_headers_match */ 5:
                    message.rule = {
                        oneofKind: "httpRequestHeadersMatch",
                        httpRequestHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestHeadersMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.HttpHeadersMatch http_request_trailers_match */ 6:
                    message.rule = {
                        oneofKind: "httpRequestTrailersMatch",
                        httpRequestTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestTrailersMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.HttpHeadersMatch http_response_headers_match */ 7:
                    message.rule = {
                        oneofKind: "httpResponseHeadersMatch",
                        httpResponseHeadersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseHeadersMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.HttpHeadersMatch http_response_trailers_match */ 8:
                    message.rule = {
                        oneofKind: "httpResponseTrailersMatch",
                        httpResponseTrailersMatch: HttpHeadersMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseTrailersMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.HttpGenericBodyMatch http_request_generic_body_match */ 9:
                    message.rule = {
                        oneofKind: "httpRequestGenericBodyMatch",
                        httpRequestGenericBodyMatch: HttpGenericBodyMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpRequestGenericBodyMatch)
                    };
                    break;
                case /* envoy.config.tap.v3.HttpGenericBodyMatch http_response_generic_body_match */ 10:
                    message.rule = {
                        oneofKind: "httpResponseGenericBodyMatch",
                        httpResponseGenericBodyMatch: HttpGenericBodyMatch.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).httpResponseGenericBodyMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.tap.v3.MatchPredicate.MatchSet or_match = 1; */
        if (message.rule.oneofKind === "orMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.orMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.MatchPredicate.MatchSet and_match = 2; */
        if (message.rule.oneofKind === "andMatch")
            MatchPredicate_MatchSet.internalBinaryWrite(message.rule.andMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.MatchPredicate not_match = 3; */
        if (message.rule.oneofKind === "notMatch")
            MatchPredicate.internalBinaryWrite(message.rule.notMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool any_match = 4; */
        if (message.rule.oneofKind === "anyMatch")
            writer.tag(4, WireType.Varint).bool(message.rule.anyMatch);
        /* envoy.config.tap.v3.HttpHeadersMatch http_request_headers_match = 5; */
        if (message.rule.oneofKind === "httpRequestHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestHeadersMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.HttpHeadersMatch http_request_trailers_match = 6; */
        if (message.rule.oneofKind === "httpRequestTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpRequestTrailersMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.HttpHeadersMatch http_response_headers_match = 7; */
        if (message.rule.oneofKind === "httpResponseHeadersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseHeadersMatch, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.HttpHeadersMatch http_response_trailers_match = 8; */
        if (message.rule.oneofKind === "httpResponseTrailersMatch")
            HttpHeadersMatch.internalBinaryWrite(message.rule.httpResponseTrailersMatch, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.HttpGenericBodyMatch http_request_generic_body_match = 9; */
        if (message.rule.oneofKind === "httpRequestGenericBodyMatch")
            HttpGenericBodyMatch.internalBinaryWrite(message.rule.httpRequestGenericBodyMatch, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.HttpGenericBodyMatch http_response_generic_body_match = 10; */
        if (message.rule.oneofKind === "httpResponseGenericBodyMatch")
            HttpGenericBodyMatch.internalBinaryWrite(message.rule.httpResponseGenericBodyMatch, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.MatchPredicate
 */
export const MatchPredicate = new MatchPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MatchPredicate_MatchSet$Type extends MessageType<MatchPredicate_MatchSet> {
    constructor() {
        super("envoy.config.tap.v3.MatchPredicate.MatchSet", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MatchPredicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.MatchPredicate.MatchSet" } });
    }
    create(value?: PartialMessage<MatchPredicate_MatchSet>): MatchPredicate_MatchSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<MatchPredicate_MatchSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MatchPredicate_MatchSet): MatchPredicate_MatchSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.tap.v3.MatchPredicate rules */ 1:
                    message.rules.push(MatchPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MatchPredicate_MatchSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.tap.v3.MatchPredicate rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            MatchPredicate.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.MatchPredicate.MatchSet
 */
export const MatchPredicate_MatchSet = new MatchPredicate_MatchSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpHeadersMatch$Type extends MessageType<HttpHeadersMatch> {
    constructor() {
        super("envoy.config.tap.v3.HttpHeadersMatch", [
            { no: 1, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.HttpHeadersMatch" } });
    }
    create(value?: PartialMessage<HttpHeadersMatch>): HttpHeadersMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<HttpHeadersMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpHeadersMatch): HttpHeadersMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.route.v3.HeaderMatcher headers */ 1:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpHeadersMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.route.v3.HeaderMatcher headers = 1; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.HttpHeadersMatch
 */
export const HttpHeadersMatch = new HttpHeadersMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpGenericBodyMatch$Type extends MessageType<HttpGenericBodyMatch> {
    constructor() {
        super("envoy.config.tap.v3.HttpGenericBodyMatch", [
            { no: 1, name: "bytes_limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "patterns", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HttpGenericBodyMatch_GenericTextMatch, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<HttpGenericBodyMatch>): HttpGenericBodyMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bytesLimit = 0;
        message.patterns = [];
        if (value !== undefined)
            reflectionMergePartial<HttpGenericBodyMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpGenericBodyMatch): HttpGenericBodyMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bytes_limit */ 1:
                    message.bytesLimit = reader.uint32();
                    break;
                case /* repeated envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch patterns */ 2:
                    message.patterns.push(HttpGenericBodyMatch_GenericTextMatch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpGenericBodyMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 bytes_limit = 1; */
        if (message.bytesLimit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.bytesLimit);
        /* repeated envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2; */
        for (let i = 0; i < message.patterns.length; i++)
            HttpGenericBodyMatch_GenericTextMatch.internalBinaryWrite(message.patterns[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.HttpGenericBodyMatch
 */
export const HttpGenericBodyMatch = new HttpGenericBodyMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpGenericBodyMatch_GenericTextMatch$Type extends MessageType<HttpGenericBodyMatch_GenericTextMatch> {
    constructor() {
        super("envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch", [
            { no: 1, name: "string_match", kind: "scalar", oneof: "rule", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "binary_match", kind: "scalar", oneof: "rule", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<HttpGenericBodyMatch_GenericTextMatch>): HttpGenericBodyMatch_GenericTextMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HttpGenericBodyMatch_GenericTextMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpGenericBodyMatch_GenericTextMatch): HttpGenericBodyMatch_GenericTextMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string string_match */ 1:
                    message.rule = {
                        oneofKind: "stringMatch",
                        stringMatch: reader.string()
                    };
                    break;
                case /* bytes binary_match */ 2:
                    message.rule = {
                        oneofKind: "binaryMatch",
                        binaryMatch: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpGenericBodyMatch_GenericTextMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string string_match = 1; */
        if (message.rule.oneofKind === "stringMatch")
            writer.tag(1, WireType.LengthDelimited).string(message.rule.stringMatch);
        /* bytes binary_match = 2; */
        if (message.rule.oneofKind === "binaryMatch")
            writer.tag(2, WireType.LengthDelimited).bytes(message.rule.binaryMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export const HttpGenericBodyMatch_GenericTextMatch = new HttpGenericBodyMatch_GenericTextMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutputConfig$Type extends MessageType<OutputConfig> {
    constructor() {
        super("envoy.config.tap.v3.OutputConfig", [
            { no: 1, name: "sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => OutputSink, options: { "validate.rules": { repeated: { minItems: "1", maxItems: "1" } } } },
            { no: 2, name: "max_buffered_rx_bytes", kind: "message", T: () => UInt32Value },
            { no: 3, name: "max_buffered_tx_bytes", kind: "message", T: () => UInt32Value },
            { no: 4, name: "streaming", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.OutputConfig" } });
    }
    create(value?: PartialMessage<OutputConfig>): OutputConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sinks = [];
        message.streaming = false;
        if (value !== undefined)
            reflectionMergePartial<OutputConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputConfig): OutputConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.tap.v3.OutputSink sinks */ 1:
                    message.sinks.push(OutputSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value max_buffered_rx_bytes */ 2:
                    message.maxBufferedRxBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxBufferedRxBytes);
                    break;
                case /* google.protobuf.UInt32Value max_buffered_tx_bytes */ 3:
                    message.maxBufferedTxBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxBufferedTxBytes);
                    break;
                case /* bool streaming */ 4:
                    message.streaming = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutputConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.tap.v3.OutputSink sinks = 1; */
        for (let i = 0; i < message.sinks.length; i++)
            OutputSink.internalBinaryWrite(message.sinks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_buffered_rx_bytes = 2; */
        if (message.maxBufferedRxBytes)
            UInt32Value.internalBinaryWrite(message.maxBufferedRxBytes, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_buffered_tx_bytes = 3; */
        if (message.maxBufferedTxBytes)
            UInt32Value.internalBinaryWrite(message.maxBufferedTxBytes, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool streaming = 4; */
        if (message.streaming !== false)
            writer.tag(4, WireType.Varint).bool(message.streaming);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.OutputConfig
 */
export const OutputConfig = new OutputConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OutputSink$Type extends MessageType<OutputSink> {
    constructor() {
        super("envoy.config.tap.v3.OutputSink", [
            { no: 1, name: "format", kind: "enum", T: () => ["envoy.config.tap.v3.OutputSink.Format", OutputSink_Format], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "streaming_admin", kind: "message", oneof: "outputSinkType", T: () => StreamingAdminSink },
            { no: 3, name: "file_per_tap", kind: "message", oneof: "outputSinkType", T: () => FilePerTapSink },
            { no: 4, name: "streaming_grpc", kind: "message", oneof: "outputSinkType", T: () => StreamingGrpcSink },
            { no: 5, name: "buffered_admin", kind: "message", oneof: "outputSinkType", T: () => BufferedAdminSink }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.OutputSink" } });
    }
    create(value?: PartialMessage<OutputSink>): OutputSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.format = 0;
        message.outputSinkType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<OutputSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutputSink): OutputSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.tap.v3.OutputSink.Format format */ 1:
                    message.format = reader.int32();
                    break;
                case /* envoy.config.tap.v3.StreamingAdminSink streaming_admin */ 2:
                    message.outputSinkType = {
                        oneofKind: "streamingAdmin",
                        streamingAdmin: StreamingAdminSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).streamingAdmin)
                    };
                    break;
                case /* envoy.config.tap.v3.FilePerTapSink file_per_tap */ 3:
                    message.outputSinkType = {
                        oneofKind: "filePerTap",
                        filePerTap: FilePerTapSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).filePerTap)
                    };
                    break;
                case /* envoy.config.tap.v3.StreamingGrpcSink streaming_grpc */ 4:
                    message.outputSinkType = {
                        oneofKind: "streamingGrpc",
                        streamingGrpc: StreamingGrpcSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).streamingGrpc)
                    };
                    break;
                case /* envoy.config.tap.v3.BufferedAdminSink buffered_admin */ 5:
                    message.outputSinkType = {
                        oneofKind: "bufferedAdmin",
                        bufferedAdmin: BufferedAdminSink.internalBinaryRead(reader, reader.uint32(), options, (message.outputSinkType as any).bufferedAdmin)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutputSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.tap.v3.OutputSink.Format format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format);
        /* envoy.config.tap.v3.StreamingAdminSink streaming_admin = 2; */
        if (message.outputSinkType.oneofKind === "streamingAdmin")
            StreamingAdminSink.internalBinaryWrite(message.outputSinkType.streamingAdmin, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.FilePerTapSink file_per_tap = 3; */
        if (message.outputSinkType.oneofKind === "filePerTap")
            FilePerTapSink.internalBinaryWrite(message.outputSinkType.filePerTap, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.StreamingGrpcSink streaming_grpc = 4; */
        if (message.outputSinkType.oneofKind === "streamingGrpc")
            StreamingGrpcSink.internalBinaryWrite(message.outputSinkType.streamingGrpc, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.tap.v3.BufferedAdminSink buffered_admin = 5; */
        if (message.outputSinkType.oneofKind === "bufferedAdmin")
            BufferedAdminSink.internalBinaryWrite(message.outputSinkType.bufferedAdmin, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.OutputSink
 */
export const OutputSink = new OutputSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamingAdminSink$Type extends MessageType<StreamingAdminSink> {
    constructor() {
        super("envoy.config.tap.v3.StreamingAdminSink", [], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.StreamingAdminSink" } });
    }
    create(value?: PartialMessage<StreamingAdminSink>): StreamingAdminSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamingAdminSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamingAdminSink): StreamingAdminSink {
        return target ?? this.create();
    }
    internalBinaryWrite(message: StreamingAdminSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.StreamingAdminSink
 */
export const StreamingAdminSink = new StreamingAdminSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BufferedAdminSink$Type extends MessageType<BufferedAdminSink> {
    constructor() {
        super("envoy.config.tap.v3.BufferedAdminSink", [
            { no: 1, name: "max_traces", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/, options: { "validate.rules": { uint64: { gt: "0" } } } },
            { no: 2, name: "timeout", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<BufferedAdminSink>): BufferedAdminSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxTraces = 0n;
        if (value !== undefined)
            reflectionMergePartial<BufferedAdminSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BufferedAdminSink): BufferedAdminSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 max_traces */ 1:
                    message.maxTraces = reader.uint64().toBigInt();
                    break;
                case /* google.protobuf.Duration timeout */ 2:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BufferedAdminSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 max_traces = 1; */
        if (message.maxTraces !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.maxTraces);
        /* google.protobuf.Duration timeout = 2; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.BufferedAdminSink
 */
export const BufferedAdminSink = new BufferedAdminSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilePerTapSink$Type extends MessageType<FilePerTapSink> {
    constructor() {
        super("envoy.config.tap.v3.FilePerTapSink", [
            { no: 1, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.FilePerTapSink" } });
    }
    create(value?: PartialMessage<FilePerTapSink>): FilePerTapSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<FilePerTapSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilePerTapSink): FilePerTapSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path_prefix */ 1:
                    message.pathPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilePerTapSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path_prefix = 1; */
        if (message.pathPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pathPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.FilePerTapSink
 */
export const FilePerTapSink = new FilePerTapSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamingGrpcSink$Type extends MessageType<StreamingGrpcSink> {
    constructor() {
        super("envoy.config.tap.v3.StreamingGrpcSink", [
            { no: 1, name: "tap_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "grpc_service", kind: "message", T: () => GrpcService, options: { "validate.rules": { message: { required: true } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.service.tap.v2alpha.StreamingGrpcSink" } });
    }
    create(value?: PartialMessage<StreamingGrpcSink>): StreamingGrpcSink {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tapId = "";
        if (value !== undefined)
            reflectionMergePartial<StreamingGrpcSink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamingGrpcSink): StreamingGrpcSink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tap_id */ 1:
                    message.tapId = reader.string();
                    break;
                case /* envoy.config.core.v3.GrpcService grpc_service */ 2:
                    message.grpcService = GrpcService.internalBinaryRead(reader, reader.uint32(), options, message.grpcService);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamingGrpcSink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tap_id = 1; */
        if (message.tapId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tapId);
        /* envoy.config.core.v3.GrpcService grpc_service = 2; */
        if (message.grpcService)
            GrpcService.internalBinaryWrite(message.grpcService, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.tap.v3.StreamingGrpcSink
 */
export const StreamingGrpcSink = new StreamingGrpcSink$Type();
