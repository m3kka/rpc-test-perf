// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/tap/v3/common.proto (package envoy.config.tap.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { MatchPredicate as MatchPredicate$1 } from "../../common/matcher/v3/matcher_pb.js";
import type { RuntimeFractionalPercent } from "../../core/v3/base_pb.js";
import type { HeaderMatcher } from "../../route/v3/route_components_pb.js";
import type { GrpcService } from "../../core/v3/grpc_service_pb.js";

/**
 * Tap configuration.
 *
 * [#comment:TODO(mattklein123): Rate limiting]
 *
 * @generated from message envoy.config.tap.v3.TapConfig
 */
export declare class TapConfig extends Message<TapConfig> {
  /**
   * The match configuration. If the configuration matches the data source being tapped, a tap will
   * occur, with the result written to the configured output.
   * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
   * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
   * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
   *
   * @generated from field: envoy.config.tap.v3.MatchPredicate match_config = 1 [deprecated = true];
   * @deprecated
   */
  matchConfig?: MatchPredicate;

  /**
   * The match configuration. If the configuration matches the data source being tapped, a tap will
   * occur, with the result written to the configured output.
   * Exactly one of :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` and
   * :ref:`match_config <envoy_v3_api_field_config.tap.v3.TapConfig.match_config>` must be set. If both
   * are set, the :ref:`match <envoy_v3_api_field_config.tap.v3.TapConfig.match>` will be used.
   *
   * @generated from field: envoy.config.common.matcher.v3.MatchPredicate match = 4;
   */
  match?: MatchPredicate$1;

  /**
   * The tap output configuration. If a match configuration matches a data source being tapped,
   * a tap will occur and the data will be written to the configured output.
   *
   * @generated from field: envoy.config.tap.v3.OutputConfig output_config = 2;
   */
  outputConfig?: OutputConfig;

  /**
   * [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
   * which the tap matching is enabled. When not enabled, the request\connection will not be
   * recorded.
   *
   * .. note::
   *
   *   This field defaults to 100/:ref:`HUNDRED
   *   <envoy_v3_api_enum_type.v3.FractionalPercent.DenominatorType>`.
   *
   * @generated from field: envoy.config.core.v3.RuntimeFractionalPercent tap_enabled = 3;
   */
  tapEnabled?: RuntimeFractionalPercent;

  constructor(data?: PartialMessage<TapConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.TapConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TapConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TapConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TapConfig;

  static equals(a: TapConfig | PlainMessage<TapConfig> | undefined, b: TapConfig | PlainMessage<TapConfig> | undefined): boolean;
}

/**
 * Tap match configuration. This is a recursive structure which allows complex nested match
 * configurations to be built using various logical operators.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.config.tap.v3.MatchPredicate
 */
export declare class MatchPredicate extends Message<MatchPredicate> {
  /**
   * @generated from oneof envoy.config.tap.v3.MatchPredicate.rule
   */
  rule: {
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.tap.v3.MatchPredicate.MatchSet or_match = 1;
     */
    value: MatchPredicate_MatchSet;
    case: "orMatch";
  } | {
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     *
     * @generated from field: envoy.config.tap.v3.MatchPredicate.MatchSet and_match = 2;
     */
    value: MatchPredicate_MatchSet;
    case: "andMatch";
  } | {
    /**
     * A negation match. The match configuration will match if the negated match condition matches.
     *
     * @generated from field: envoy.config.tap.v3.MatchPredicate not_match = 3;
     */
    value: MatchPredicate;
    case: "notMatch";
  } | {
    /**
     * The match configuration will always match.
     *
     * @generated from field: bool any_match = 4;
     */
    value: boolean;
    case: "anyMatch";
  } | {
    /**
     * HTTP request headers match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpHeadersMatch http_request_headers_match = 5;
     */
    value: HttpHeadersMatch;
    case: "httpRequestHeadersMatch";
  } | {
    /**
     * HTTP request trailers match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpHeadersMatch http_request_trailers_match = 6;
     */
    value: HttpHeadersMatch;
    case: "httpRequestTrailersMatch";
  } | {
    /**
     * HTTP response headers match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpHeadersMatch http_response_headers_match = 7;
     */
    value: HttpHeadersMatch;
    case: "httpResponseHeadersMatch";
  } | {
    /**
     * HTTP response trailers match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpHeadersMatch http_response_trailers_match = 8;
     */
    value: HttpHeadersMatch;
    case: "httpResponseTrailersMatch";
  } | {
    /**
     * HTTP request generic body match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpGenericBodyMatch http_request_generic_body_match = 9;
     */
    value: HttpGenericBodyMatch;
    case: "httpRequestGenericBodyMatch";
  } | {
    /**
     * HTTP response generic body match configuration.
     *
     * @generated from field: envoy.config.tap.v3.HttpGenericBodyMatch http_response_generic_body_match = 10;
     */
    value: HttpGenericBodyMatch;
    case: "httpResponseGenericBodyMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<MatchPredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.MatchPredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchPredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchPredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchPredicate;

  static equals(a: MatchPredicate | PlainMessage<MatchPredicate> | undefined, b: MatchPredicate | PlainMessage<MatchPredicate> | undefined): boolean;
}

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.config.tap.v3.MatchPredicate.MatchSet
 */
export declare class MatchPredicate_MatchSet extends Message<MatchPredicate_MatchSet> {
  /**
   * The list of rules that make up the set.
   *
   * @generated from field: repeated envoy.config.tap.v3.MatchPredicate rules = 1;
   */
  rules: MatchPredicate[];

  constructor(data?: PartialMessage<MatchPredicate_MatchSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.MatchPredicate.MatchSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MatchPredicate_MatchSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MatchPredicate_MatchSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MatchPredicate_MatchSet;

  static equals(a: MatchPredicate_MatchSet | PlainMessage<MatchPredicate_MatchSet> | undefined, b: MatchPredicate_MatchSet | PlainMessage<MatchPredicate_MatchSet> | undefined): boolean;
}

/**
 * HTTP headers match configuration.
 *
 * @generated from message envoy.config.tap.v3.HttpHeadersMatch
 */
export declare class HttpHeadersMatch extends Message<HttpHeadersMatch> {
  /**
   * HTTP headers to match.
   *
   * @generated from field: repeated envoy.config.route.v3.HeaderMatcher headers = 1;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<HttpHeadersMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.HttpHeadersMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpHeadersMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpHeadersMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpHeadersMatch;

  static equals(a: HttpHeadersMatch | PlainMessage<HttpHeadersMatch> | undefined, b: HttpHeadersMatch | PlainMessage<HttpHeadersMatch> | undefined): boolean;
}

/**
 * HTTP generic body match configuration.
 * List of text strings and hex strings to be located in HTTP body.
 * All specified strings must be found in the HTTP body for positive match.
 * The search may be limited to specified number of bytes from the body start.
 *
 * .. attention::
 *
 *   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
 *   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
 *   to scan only part of the http body.
 *
 * @generated from message envoy.config.tap.v3.HttpGenericBodyMatch
 */
export declare class HttpGenericBodyMatch extends Message<HttpGenericBodyMatch> {
  /**
   * Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
   *
   * @generated from field: uint32 bytes_limit = 1;
   */
  bytesLimit: number;

  /**
   * List of patterns to match.
   *
   * @generated from field: repeated envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch patterns = 2;
   */
  patterns: HttpGenericBodyMatch_GenericTextMatch[];

  constructor(data?: PartialMessage<HttpGenericBodyMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.HttpGenericBodyMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpGenericBodyMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch;

  static equals(a: HttpGenericBodyMatch | PlainMessage<HttpGenericBodyMatch> | undefined, b: HttpGenericBodyMatch | PlainMessage<HttpGenericBodyMatch> | undefined): boolean;
}

/**
 * @generated from message envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch
 */
export declare class HttpGenericBodyMatch_GenericTextMatch extends Message<HttpGenericBodyMatch_GenericTextMatch> {
  /**
   * @generated from oneof envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch.rule
   */
  rule: {
    /**
     * Text string to be located in HTTP body.
     *
     * @generated from field: string string_match = 1;
     */
    value: string;
    case: "stringMatch";
  } | {
    /**
     * Sequence of bytes to be located in HTTP body.
     *
     * @generated from field: bytes binary_match = 2;
     */
    value: Uint8Array;
    case: "binaryMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<HttpGenericBodyMatch_GenericTextMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.HttpGenericBodyMatch.GenericTextMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpGenericBodyMatch_GenericTextMatch;

  static equals(a: HttpGenericBodyMatch_GenericTextMatch | PlainMessage<HttpGenericBodyMatch_GenericTextMatch> | undefined, b: HttpGenericBodyMatch_GenericTextMatch | PlainMessage<HttpGenericBodyMatch_GenericTextMatch> | undefined): boolean;
}

/**
 * Tap output configuration.
 *
 * @generated from message envoy.config.tap.v3.OutputConfig
 */
export declare class OutputConfig extends Message<OutputConfig> {
  /**
   * Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
   * sink types are supported this constraint will be relaxed.
   *
   * @generated from field: repeated envoy.config.tap.v3.OutputSink sinks = 1;
   */
  sinks: OutputSink[];

  /**
   * For buffered tapping, the maximum amount of received body that will be buffered prior to
   * truncation. If truncation occurs, the :ref:`truncated
   * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
   * default is 1KiB.
   *
   * @generated from field: google.protobuf.UInt32Value max_buffered_rx_bytes = 2;
   */
  maxBufferedRxBytes?: number;

  /**
   * For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
   * truncation. If truncation occurs, the :ref:`truncated
   * <envoy_v3_api_field_data.tap.v3.Body.truncated>` field will be set. If not specified, the
   * default is 1KiB.
   *
   * @generated from field: google.protobuf.UInt32Value max_buffered_tx_bytes = 3;
   */
  maxBufferedTxBytes?: number;

  /**
   * Indicates whether taps produce a single buffered message per tap, or multiple streamed
   * messages per tap in the emitted :ref:`TraceWrapper
   * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. Note that streamed tapping does not
   * mean that no buffering takes place. Buffering may be required if data is processed before a
   * match can be determined. See the HTTP tap filter :ref:`streaming
   * <config_http_filters_tap_streaming>` documentation for more information.
   *
   * @generated from field: bool streaming = 4;
   */
  streaming: boolean;

  constructor(data?: PartialMessage<OutputConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.OutputConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputConfig;

  static equals(a: OutputConfig | PlainMessage<OutputConfig> | undefined, b: OutputConfig | PlainMessage<OutputConfig> | undefined): boolean;
}

/**
 * Tap output sink configuration.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.tap.v3.OutputSink
 */
export declare class OutputSink extends Message<OutputSink> {
  /**
   * Sink output format.
   *
   * @generated from field: envoy.config.tap.v3.OutputSink.Format format = 1;
   */
  format: OutputSink_Format;

  /**
   * @generated from oneof envoy.config.tap.v3.OutputSink.output_sink_type
   */
  outputSinkType: {
    /**
     * Tap output will be streamed out the :http:post:`/tap` admin endpoint.
     *
     * .. attention::
     *
     *   It is only allowed to specify the streaming admin output sink if the tap is being
     *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
     *   been configured to receive tap configuration from some other source (e.g., static
     *   file, XDS, etc.) configuring the streaming admin output type will fail.
     *
     * @generated from field: envoy.config.tap.v3.StreamingAdminSink streaming_admin = 2;
     */
    value: StreamingAdminSink;
    case: "streamingAdmin";
  } | {
    /**
     * Tap output will be written to a file per tap sink.
     *
     * @generated from field: envoy.config.tap.v3.FilePerTapSink file_per_tap = 3;
     */
    value: FilePerTapSink;
    case: "filePerTap";
  } | {
    /**
     * [#not-implemented-hide:]
     * GrpcService to stream data to. The format argument must be PROTO_BINARY.
     * [#comment: TODO(samflattery): remove cleanup in uber_per_filter.cc once implemented]
     *
     * @generated from field: envoy.config.tap.v3.StreamingGrpcSink streaming_grpc = 4;
     */
    value: StreamingGrpcSink;
    case: "streamingGrpc";
  } | {
    /**
     * Tap output will be buffered in a single block before flushing to the :http:post:`/tap` admin endpoint
     *
     * .. attention::
     *
     *   It is only allowed to specify the buffered admin output sink if the tap is being
     *   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
     *   been configured to receive tap configuration from some other source (e.g., static
     *   file, XDS, etc.) configuring the buffered admin output type will fail.
     *
     * @generated from field: envoy.config.tap.v3.BufferedAdminSink buffered_admin = 5;
     */
    value: BufferedAdminSink;
    case: "bufferedAdmin";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<OutputSink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.OutputSink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputSink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputSink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputSink;

  static equals(a: OutputSink | PlainMessage<OutputSink> | undefined, b: OutputSink | PlainMessage<OutputSink> | undefined): boolean;
}

/**
 * Output format. All output is in the form of one or more :ref:`TraceWrapper
 * <envoy_v3_api_msg_data.tap.v3.TraceWrapper>` messages. This enumeration indicates
 * how those messages are written. Note that not all sinks support all output formats. See
 * individual sink documentation for more information.
 *
 * @generated from enum envoy.config.tap.v3.OutputSink.Format
 */
export declare enum OutputSink_Format {
  /**
   * Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
   * data will be present in the :ref:`as_bytes
   * <envoy_v3_api_field_data.tap.v3.Body.as_bytes>` field. This means that body data will be
   * base64 encoded as per the `proto3 JSON mappings
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
   *
   * @generated from enum value: JSON_BODY_AS_BYTES = 0;
   */
  JSON_BODY_AS_BYTES = 0,

  /**
   * Each message will be written as JSON. Any :ref:`body <envoy_v3_api_msg_data.tap.v3.Body>`
   * data will be present in the :ref:`as_string
   * <envoy_v3_api_field_data.tap.v3.Body.as_string>` field. This means that body data will be
   * string encoded as per the `proto3 JSON mappings
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
   * useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
   * user wishes to view it directly without being forced to base64 decode the body.
   *
   * @generated from enum value: JSON_BODY_AS_STRING = 1;
   */
  JSON_BODY_AS_STRING = 1,

  /**
   * Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
   * multiple binary messages without any length information the data stream will not be
   * useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
   * this output format makes consumption simpler.
   *
   * @generated from enum value: PROTO_BINARY = 2;
   */
  PROTO_BINARY = 2,

  /**
   * Messages are written as a sequence tuples, where each tuple is the message length encoded
   * as a `protobuf 32-bit varint
   * <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
   * followed by the binary message. The messages can be read back using the language specific
   * protobuf coded stream implementation to obtain the message length and the message.
   *
   * @generated from enum value: PROTO_BINARY_LENGTH_DELIMITED = 3;
   */
  PROTO_BINARY_LENGTH_DELIMITED = 3,

  /**
   * Text proto format.
   *
   * @generated from enum value: PROTO_TEXT = 4;
   */
  PROTO_TEXT = 4,
}

/**
 * Streaming admin sink configuration.
 *
 * @generated from message envoy.config.tap.v3.StreamingAdminSink
 */
export declare class StreamingAdminSink extends Message<StreamingAdminSink> {
  constructor(data?: PartialMessage<StreamingAdminSink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.StreamingAdminSink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingAdminSink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingAdminSink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingAdminSink;

  static equals(a: StreamingAdminSink | PlainMessage<StreamingAdminSink> | undefined, b: StreamingAdminSink | PlainMessage<StreamingAdminSink> | undefined): boolean;
}

/**
 * BufferedAdminSink configures a tap output to collect traces without returning them until
 * one of multiple criteria are satisfied.
 * Similar to StreamingAdminSink, it is only allowed to specify the buffered admin output
 * sink if the tap is being configured from the ``/tap`` admin endpoint.
 *
 * @generated from message envoy.config.tap.v3.BufferedAdminSink
 */
export declare class BufferedAdminSink extends Message<BufferedAdminSink> {
  /**
   * Stop collecting traces when the specified number are collected.
   * If other criteria for ending collection are reached first, this value will not be used.
   *
   * @generated from field: uint64 max_traces = 1;
   */
  maxTraces: bigint;

  /**
   * Acts as a fallback to prevent the client from waiting for long periods of time.
   * After timeout has occurred, a buffer flush will be triggered, returning the traces buffered so far.
   * This may result in returning fewer traces than were requested, and in the case that no traces are
   * buffered during this time, no traces will be returned.
   * Specifying 0 for the timeout value (or not specifying a value at all) indicates an infinite timeout.
   *
   * @generated from field: google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;

  constructor(data?: PartialMessage<BufferedAdminSink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.BufferedAdminSink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BufferedAdminSink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BufferedAdminSink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BufferedAdminSink;

  static equals(a: BufferedAdminSink | PlainMessage<BufferedAdminSink> | undefined, b: BufferedAdminSink | PlainMessage<BufferedAdminSink> | undefined): boolean;
}

/**
 * The file per tap sink outputs a discrete file for every tapped stream.
 *
 * @generated from message envoy.config.tap.v3.FilePerTapSink
 */
export declare class FilePerTapSink extends Message<FilePerTapSink> {
  /**
   * Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
   * identifier distinguishing the recorded trace for stream instances (the Envoy
   * connection ID, HTTP stream ID, etc.).
   *
   * @generated from field: string path_prefix = 1;
   */
  pathPrefix: string;

  constructor(data?: PartialMessage<FilePerTapSink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.FilePerTapSink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilePerTapSink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilePerTapSink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilePerTapSink;

  static equals(a: FilePerTapSink | PlainMessage<FilePerTapSink> | undefined, b: FilePerTapSink | PlainMessage<FilePerTapSink> | undefined): boolean;
}

/**
 * [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
 * server.
 *
 * @generated from message envoy.config.tap.v3.StreamingGrpcSink
 */
export declare class StreamingGrpcSink extends Message<StreamingGrpcSink> {
  /**
   * Opaque identifier, that will be sent back to the streaming grpc server.
   *
   * @generated from field: string tap_id = 1;
   */
  tapId: string;

  /**
   * The gRPC server that hosts the Tap Sink Service.
   *
   * @generated from field: envoy.config.core.v3.GrpcService grpc_service = 2;
   */
  grpcService?: GrpcService;

  constructor(data?: PartialMessage<StreamingGrpcSink>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.tap.v3.StreamingGrpcSink";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingGrpcSink;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingGrpcSink;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingGrpcSink;

  static equals(a: StreamingGrpcSink | PlainMessage<StreamingGrpcSink> | undefined, b: StreamingGrpcSink | PlainMessage<StreamingGrpcSink> | undefined): boolean;
}

