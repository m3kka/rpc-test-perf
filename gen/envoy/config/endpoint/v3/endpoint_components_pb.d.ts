// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/endpoint/v3/endpoint_components.proto (package envoy.config.endpoint.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { Address } from "../../core/v3/address_pb.js";
import type { HealthStatus } from "../../core/v3/health_check_pb.js";
import type { Locality, Metadata } from "../../core/v3/base_pb.js";
import type { ConfigSource } from "../../core/v3/config_source_pb.js";

/**
 * Upstream host identifier.
 *
 * @generated from message envoy.config.endpoint.v3.Endpoint
 */
export declare class Endpoint extends Message<Endpoint> {
  /**
   * The upstream host address.
   *
   * .. attention::
   *
   *   The form of host address depends on the given cluster type. For STATIC or EDS,
   *   it is expected to be a direct IP address (or something resolvable by the
   *   specified :ref:`resolver <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`
   *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
   *   and will be resolved via DNS.
   *
   * @generated from field: envoy.config.core.v3.Address address = 1;
   */
  address?: Address;

  /**
   * The optional health check configuration is used as configuration for the
   * health checker to contact the health checked host.
   *
   * .. attention::
   *
   *   This takes into effect only for upstream clusters with
   *   :ref:`active health checking <arch_overview_health_checking>` enabled.
   *
   * @generated from field: envoy.config.endpoint.v3.Endpoint.HealthCheckConfig health_check_config = 2;
   */
  healthCheckConfig?: Endpoint_HealthCheckConfig;

  /**
   * The hostname associated with this endpoint. This hostname is not used for routing or address
   * resolution. If provided, it will be associated with the endpoint, and can be used for features
   * that require a hostname, like
   * :ref:`auto_host_rewrite <envoy_v3_api_field_config.route.v3.RouteAction.auto_host_rewrite>`.
   *
   * @generated from field: string hostname = 3;
   */
  hostname: string;

  /**
   * An ordered list of addresses that together with `address` comprise the
   * list of addresses for an endpoint. The address given in the `address` is
   * prepended to this list. It is assumed that the list must already be
   * sorted by preference order of the addresses. This will only be supported
   * for STATIC and EDS clusters.
   *
   * @generated from field: repeated envoy.config.endpoint.v3.Endpoint.AdditionalAddress additional_addresses = 4;
   */
  additionalAddresses: Endpoint_AdditionalAddress[];

  constructor(data?: PartialMessage<Endpoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.Endpoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Endpoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Endpoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Endpoint;

  static equals(a: Endpoint | PlainMessage<Endpoint> | undefined, b: Endpoint | PlainMessage<Endpoint> | undefined): boolean;
}

/**
 * The optional health check configuration.
 *
 * @generated from message envoy.config.endpoint.v3.Endpoint.HealthCheckConfig
 */
export declare class Endpoint_HealthCheckConfig extends Message<Endpoint_HealthCheckConfig> {
  /**
   * Optional alternative health check port value.
   *
   * By default the health check address port of an upstream host is the same
   * as the host's serving address port. This provides an alternative health
   * check port. Setting this with a non-zero value allows an upstream host
   * to have different health check address port.
   *
   * @generated from field: uint32 port_value = 1;
   */
  portValue: number;

  /**
   * By default, the host header for L7 health checks is controlled by cluster level configuration
   * (see: :ref:`host <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host>` and
   * :ref:`authority <envoy_v3_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority>`). Setting this
   * to a non-empty value allows overriding the cluster level configuration for a specific
   * endpoint.
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;

  /**
   * Optional alternative health check host address.
   *
   * .. attention::
   *
   *   The form of the health check host address is expected to be a direct IP address.
   *
   * @generated from field: envoy.config.core.v3.Address address = 3;
   */
  address?: Address;

  /**
   * Optional flag to control if perform active health check for this endpoint.
   * Active health check is enabled by default if there is a health checker.
   *
   * @generated from field: bool disable_active_health_check = 4;
   */
  disableActiveHealthCheck: boolean;

  constructor(data?: PartialMessage<Endpoint_HealthCheckConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.Endpoint.HealthCheckConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Endpoint_HealthCheckConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Endpoint_HealthCheckConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Endpoint_HealthCheckConfig;

  static equals(a: Endpoint_HealthCheckConfig | PlainMessage<Endpoint_HealthCheckConfig> | undefined, b: Endpoint_HealthCheckConfig | PlainMessage<Endpoint_HealthCheckConfig> | undefined): boolean;
}

/**
 * @generated from message envoy.config.endpoint.v3.Endpoint.AdditionalAddress
 */
export declare class Endpoint_AdditionalAddress extends Message<Endpoint_AdditionalAddress> {
  /**
   * Additional address that is associated with the endpoint.
   *
   * @generated from field: envoy.config.core.v3.Address address = 1;
   */
  address?: Address;

  constructor(data?: PartialMessage<Endpoint_AdditionalAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.Endpoint.AdditionalAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Endpoint_AdditionalAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Endpoint_AdditionalAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Endpoint_AdditionalAddress;

  static equals(a: Endpoint_AdditionalAddress | PlainMessage<Endpoint_AdditionalAddress> | undefined, b: Endpoint_AdditionalAddress | PlainMessage<Endpoint_AdditionalAddress> | undefined): boolean;
}

/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.endpoint.v3.LbEndpoint
 */
export declare class LbEndpoint extends Message<LbEndpoint> {
  /**
   * Upstream host identifier or a named reference.
   *
   * @generated from oneof envoy.config.endpoint.v3.LbEndpoint.host_identifier
   */
  hostIdentifier: {
    /**
     * @generated from field: envoy.config.endpoint.v3.Endpoint endpoint = 1;
     */
    value: Endpoint;
    case: "endpoint";
  } | {
    /**
     * [#not-implemented-hide:]
     *
     * @generated from field: string endpoint_name = 5;
     */
    value: string;
    case: "endpointName";
  } | { case: undefined; value?: undefined };

  /**
   * Optional health status when known and supplied by EDS server.
   *
   * @generated from field: envoy.config.core.v3.HealthStatus health_status = 2;
   */
  healthStatus: HealthStatus;

  /**
   * The endpoint metadata specifies values that may be used by the load
   * balancer to select endpoints in a cluster for a given request. The filter
   * name should be specified as ``envoy.lb``. An example boolean key-value pair
   * is ``canary``, providing the optional canary status of the upstream host.
   * This may be matched against in a route's
   * :ref:`RouteAction <envoy_v3_api_msg_config.route.v3.RouteAction>` metadata_match field
   * to subset the endpoints considered in cluster load balancing.
   *
   * @generated from field: envoy.config.core.v3.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * The optional load balancing weight of the upstream host; at least 1.
   * Envoy uses the load balancing weight in some of the built in load
   * balancers. The load balancing weight for an endpoint is divided by the sum
   * of the weights of all endpoints in the endpoint's locality to produce a
   * percentage of traffic for the endpoint. This percentage is then further
   * weighted by the endpoint's locality's load balancing weight from
   * LocalityLbEndpoints. If unspecified, will be treated as 1. The sum
   * of the weights of all endpoints in the endpoint's locality must not
   * exceed uint32_t maximal value (4294967295).
   *
   * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 4;
   */
  loadBalancingWeight?: number;

  constructor(data?: PartialMessage<LbEndpoint>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.LbEndpoint";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LbEndpoint;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LbEndpoint;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LbEndpoint;

  static equals(a: LbEndpoint | PlainMessage<LbEndpoint> | undefined, b: LbEndpoint | PlainMessage<LbEndpoint> | undefined): boolean;
}

/**
 * [#not-implemented-hide:]
 * A configuration for a LEDS collection.
 *
 * @generated from message envoy.config.endpoint.v3.LedsClusterLocalityConfig
 */
export declare class LedsClusterLocalityConfig extends Message<LedsClusterLocalityConfig> {
  /**
   * Configuration for the source of LEDS updates for a Locality.
   *
   * @generated from field: envoy.config.core.v3.ConfigSource leds_config = 1;
   */
  ledsConfig?: ConfigSource;

  /**
   * The xDS transport protocol glob collection resource name.
   * The service is only supported in delta xDS (incremental) mode.
   *
   * @generated from field: string leds_collection_name = 2;
   */
  ledsCollectionName: string;

  constructor(data?: PartialMessage<LedsClusterLocalityConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.LedsClusterLocalityConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LedsClusterLocalityConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LedsClusterLocalityConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LedsClusterLocalityConfig;

  static equals(a: LedsClusterLocalityConfig | PlainMessage<LedsClusterLocalityConfig> | undefined, b: LedsClusterLocalityConfig | PlainMessage<LedsClusterLocalityConfig> | undefined): boolean;
}

/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but only if
 * they have different priorities.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.endpoint.v3.LocalityLbEndpoints
 */
export declare class LocalityLbEndpoints extends Message<LocalityLbEndpoints> {
  /**
   * Identifies location of where the upstream hosts run.
   *
   * @generated from field: envoy.config.core.v3.Locality locality = 1;
   */
  locality?: Locality;

  /**
   * The group of endpoints belonging to the locality specified.
   * [#comment:TODO(adisuissa): Once LEDS is implemented this field needs to be
   * deprecated and replaced by ``load_balancer_endpoints``.]
   *
   * @generated from field: repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 2;
   */
  lbEndpoints: LbEndpoint[];

  /**
   * [#not-implemented-hide:]
   *
   * @generated from oneof envoy.config.endpoint.v3.LocalityLbEndpoints.lb_config
   */
  lbConfig: {
    /**
     * The group of endpoints belonging to the locality.
     * [#comment:TODO(adisuissa): Once LEDS is implemented the ``lb_endpoints`` field
     * needs to be deprecated.]
     *
     * @generated from field: envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList load_balancer_endpoints = 7;
     */
    value: LocalityLbEndpoints_LbEndpointList;
    case: "loadBalancerEndpoints";
  } | {
    /**
     * LEDS Configuration for the current locality.
     *
     * @generated from field: envoy.config.endpoint.v3.LedsClusterLocalityConfig leds_cluster_locality_config = 8;
     */
    value: LedsClusterLocalityConfig;
    case: "ledsClusterLocalityConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
   * balancing weight for a locality is divided by the sum of the weights of all
   * localities  at the same priority level to produce the effective percentage
   * of traffic for the locality. The sum of the weights of all localities at
   * the same priority level must not exceed uint32_t maximal value (4294967295).
   *
   * Locality weights are only considered when :ref:`locality weighted load
   * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
   * configured. These weights are ignored otherwise. If no weights are
   * specified when locality weighted load balancing is enabled, the locality is
   * assigned no load.
   *
   * @generated from field: google.protobuf.UInt32Value load_balancing_weight = 3;
   */
  loadBalancingWeight?: number;

  /**
   * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
   * default to the highest priority (0).
   *
   * Under usual circumstances, Envoy will only select endpoints for the highest
   * priority (0). In the event that enough endpoints for a particular priority are
   * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
   * next highest priority group. Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>`.
   *
   * Priorities should range from 0 (highest) to N (lowest) without skipping.
   *
   * @generated from field: uint32 priority = 5;
   */
  priority: number;

  /**
   * Optional: Per locality proximity value which indicates how close this
   * locality is from the source locality. This value only provides ordering
   * information (lower the value, closer it is to the source locality).
   * This will be consumed by load balancing schemes that need proximity order
   * to determine where to route the requests.
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.UInt32Value proximity = 6;
   */
  proximity?: number;

  constructor(data?: PartialMessage<LocalityLbEndpoints>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.LocalityLbEndpoints";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbEndpoints;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbEndpoints;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbEndpoints;

  static equals(a: LocalityLbEndpoints | PlainMessage<LocalityLbEndpoints> | undefined, b: LocalityLbEndpoints | PlainMessage<LocalityLbEndpoints> | undefined): boolean;
}

/**
 * [#not-implemented-hide:]
 * A list of endpoints of a specific locality.
 *
 * @generated from message envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList
 */
export declare class LocalityLbEndpoints_LbEndpointList extends Message<LocalityLbEndpoints_LbEndpointList> {
  /**
   * @generated from field: repeated envoy.config.endpoint.v3.LbEndpoint lb_endpoints = 1;
   */
  lbEndpoints: LbEndpoint[];

  constructor(data?: PartialMessage<LocalityLbEndpoints_LbEndpointList>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.endpoint.v3.LocalityLbEndpoints.LbEndpointList";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalityLbEndpoints_LbEndpointList;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalityLbEndpoints_LbEndpointList;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalityLbEndpoints_LbEndpointList;

  static equals(a: LocalityLbEndpoints_LbEndpointList | PlainMessage<LocalityLbEndpoints_LbEndpointList> | undefined, b: LocalityLbEndpoints_LbEndpointList | PlainMessage<LocalityLbEndpoints_LbEndpointList> | undefined): boolean;
}

