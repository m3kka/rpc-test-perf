// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/filter/network/redis_proxy/v2/redis_proxy.proto" (package "envoy.config.filter.network.redis_proxy.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RuntimeFractionalPercent } from "../../../../../api/v2/core/base";
import { UInt32Value } from "../../../../../../google/protobuf/wrappers";
import { Duration } from "../../../../../../google/protobuf/duration";
import { DataSource } from "../../../../../api/v2/core/base";
// [#protodoc-title: Redis Proxy]
// Redis Proxy :ref:`configuration overview <config_network_filters_redis_proxy>`.
// [#extension: envoy.filters.network.redis_proxy]

/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy
 */
export interface RedisProxy {
    /**
     * The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * Name of cluster from cluster manager. See the :ref:`configuration section
     * <arch_overview_redis_configuration>` of the architecture overview for recommendations on
     * configuring the backing cluster.
     *
     * .. attention::
     *
     *   This field is deprecated. Use a :ref:`catch_all
     *   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
     *   instead.
     *
     * @deprecated
     * @generated from protobuf field: string cluster = 2 [deprecated = true];
     */
    cluster: string;
    /**
     * Network settings for the connection pool to the upstream clusters.
     *
     * @generated from protobuf field: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings = 3;
     */
    settings?: RedisProxy_ConnPoolSettings;
    /**
     * Indicates that latency stat should be computed in microseconds. By default it is computed in
     * milliseconds.
     *
     * @generated from protobuf field: bool latency_in_micros = 4;
     */
    latencyInMicros: boolean;
    /**
     * List of **unique** prefixes used to separate keys from different workloads to different
     * clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
     * cluster can be used to forward commands when there is no match. Time complexity of the
     * lookups are in O(min(longest key prefix, key length)).
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *    prefix_routes:
     *      routes:
     *        - prefix: "ab"
     *          cluster: "cluster_a"
     *        - prefix: "abc"
     *          cluster: "cluster_b"
     *
     * When using the above routes, the following prefixes would be sent to:
     *
     * * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
     * * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
     * * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
     *   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
     *   would have retrieved the key from that cluster instead.
     *
     * See the :ref:`configuration section
     * <arch_overview_redis_configuration>` of the architecture overview for recommendations on
     * configuring the backing clusters.
     *
     * @generated from protobuf field: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes = 5;
     */
    prefixRoutes?: RedisProxy_PrefixRoutes;
    /**
     * Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
     * AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
     * command. If an AUTH command's password matches this password, an "OK" response will be returned
     * to the client. If the AUTH command password does not match this password, then an "ERR invalid
     * password" error will be returned. If any other command is received before AUTH when this
     * password is set, then a "NOAUTH Authentication required." error response will be sent to the
     * client. If an AUTH command is received when the password is not set, then an "ERR Client sent
     * AUTH, but no password is set" error will be returned.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource downstream_auth_password = 6;
     */
    downstreamAuthPassword?: DataSource;
}
/**
 * Redis connection pool settings.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings
 */
export interface RedisProxy_ConnPoolSettings {
    /**
     * Per-operation timeout in milliseconds. The timer starts when the first
     * command of a pipeline is written to the backend connection. Each response received from Redis
     * resets the timer since it signifies that the next command is being processed by the backend.
     * The only exception to this behavior is when a connection to a backend is not yet established.
     * In that case, the connect timeout on the cluster will govern the timeout until the connection
     * is ready.
     *
     * @generated from protobuf field: google.protobuf.Duration op_timeout = 1;
     */
    opTimeout?: Duration;
    /**
     * Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
     * forwarded to the same upstream. The hash key used for determining the upstream in a
     * consistent hash ring configuration will be computed from the hash tagged key instead of the
     * whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
     * implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
     *
     * Examples:
     *
     * * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
     * * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
     *
     * @generated from protobuf field: bool enable_hashtagging = 2;
     */
    enableHashtagging: boolean;
    /**
     * Accept `moved and ask redirection
     * <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
     * redis servers, and retry commands to the specified target server. The target server does not
     * need to be known to the cluster manager. If the command cannot be redirected, then the
     * original error is passed downstream unchanged. By default, this support is not enabled.
     *
     * @generated from protobuf field: bool enable_redirection = 3;
     */
    enableRedirection: boolean;
    /**
     * Maximum size of encoded request buffer before flush is triggered and encoded requests
     * are sent upstream. If this is unset, the buffer flushes whenever it receives data
     * and performs no batching.
     * This feature makes it possible for multiple clients to send requests to Envoy and have
     * them batched- for example if one is running several worker processes, each with its own
     * Redis connection. There is no benefit to using this with a single downstream process.
     * Recommended size (if enabled) is 1024 bytes.
     *
     * @generated from protobuf field: uint32 max_buffer_size_before_flush = 4;
     */
    maxBufferSizeBeforeFlush: number;
    /**
     * The encoded request buffer is flushed N milliseconds after the first request has been
     * encoded, unless the buffer size has already exceeded `max_buffer_size_before_flush`.
     * If `max_buffer_size_before_flush` is not set, this flush timer is not used. Otherwise,
     * the timer should be set according to the number of clients, overall request rate and
     * desired maximum latency for a single command. For example, if there are many requests
     * being batched together at a high rate, the buffer will likely be filled before the timer
     * fires. Alternatively, if the request rate is lower the buffer will not be filled as often
     * before the timer fires.
     * If `max_buffer_size_before_flush` is set, but `buffer_flush_timeout` is not, the latter
     * defaults to 3ms.
     *
     * @generated from protobuf field: google.protobuf.Duration buffer_flush_timeout = 5;
     */
    bufferFlushTimeout?: Duration;
    /**
     * `max_upstream_unknown_connections` controls how many upstream connections to unknown hosts
     * can be created at any given time by any given worker thread (see `enable_redirection` for
     * more details). If the host is unknown and a connection cannot be created due to enforcing
     * this limit, then redirection will fail and the original redirection error will be passed
     * downstream unchanged. This limit defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_upstream_unknown_connections = 6;
     */
    maxUpstreamUnknownConnections?: UInt32Value;
    /**
     * Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
     * count.
     *
     * @generated from protobuf field: bool enable_command_stats = 8;
     */
    enableCommandStats: boolean;
    /**
     * Read policy. The default is to read from the primary.
     *
     * @generated from protobuf field: envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy read_policy = 7;
     */
    readPolicy: RedisProxy_ConnPoolSettings_ReadPolicy;
}
/**
 * ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
 * supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
 * because replication is asynchronous and requires some delay. You need to ensure that your
 * application can tolerate stale data.
 *
 * @generated from protobuf enum envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy
 */
export enum RedisProxy_ConnPoolSettings_ReadPolicy {
    /**
     * Default mode. Read from the current primary node.
     *
     * @generated from protobuf enum value: MASTER = 0;
     */
    MASTER = 0,
    /**
     * Read from the primary, but if it is unavailable, read from replica nodes.
     *
     * @generated from protobuf enum value: PREFER_MASTER = 1;
     */
    PREFER_MASTER = 1,
    /**
     * Read from replica nodes. If multiple replica nodes are present within a shard, a random
     * node is selected. Healthy nodes have precedent over unhealthy nodes.
     *
     * @generated from protobuf enum value: REPLICA = 2;
     */
    REPLICA = 2,
    /**
     * Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
     * present or unhealthy), read from the primary.
     *
     * @generated from protobuf enum value: PREFER_REPLICA = 3;
     */
    PREFER_REPLICA = 3,
    /**
     * Read from any node of the cluster. A random node is selected among the primary and
     * replicas, healthy nodes have precedent over unhealthy nodes.
     *
     * @generated from protobuf enum value: ANY = 4;
     */
    ANY = 4
}
/**
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes
 */
export interface RedisProxy_PrefixRoutes {
    /**
     * List of prefix routes.
     *
     * @generated from protobuf field: repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route routes = 1;
     */
    routes: RedisProxy_PrefixRoutes_Route[];
    /**
     * Indicates that prefix matching should be case insensitive.
     *
     * @generated from protobuf field: bool case_insensitive = 2;
     */
    caseInsensitive: boolean;
    /**
     * Optional catch-all route to forward commands that doesn't match any of the routes. The
     * catch-all route becomes required when no routes are specified.
     * .. attention::
     *
     *   This field is deprecated. Use a :ref:`catch_all
     *   route<envoy_api_field_config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.catch_all_route>`
     *   instead.
     *
     * @deprecated
     * @generated from protobuf field: string catch_all_cluster = 3 [deprecated = true];
     */
    catchAllCluster: string;
    /**
     * Optional catch-all route to forward commands that doesn't match any of the routes. The
     * catch-all route becomes required when no routes are specified.
     *
     * @generated from protobuf field: envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route catch_all_route = 4;
     */
    catchAllRoute?: RedisProxy_PrefixRoutes_Route;
}
/**
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route
 */
export interface RedisProxy_PrefixRoutes_Route {
    /**
     * String prefix that must match the beginning of the keys. Envoy will always favor the
     * longest match.
     *
     * @generated from protobuf field: string prefix = 1;
     */
    prefix: string;
    /**
     * Indicates if the prefix needs to be removed from the key when forwarded.
     *
     * @generated from protobuf field: bool remove_prefix = 2;
     */
    removePrefix: boolean;
    /**
     * Upstream cluster to forward the command to.
     *
     * @generated from protobuf field: string cluster = 3;
     */
    cluster: string;
    /**
     * Indicates that the route has a request mirroring policy.
     *
     * @generated from protobuf field: repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy = 4;
     */
    requestMirrorPolicy: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy[];
}
/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
 */
export interface RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
    /**
     * Specifies the cluster that requests will be mirrored to. The cluster must
     * exist in the cluster manager configuration.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * If not specified or the runtime key is not present, all requests to the target cluster
     * will be mirrored.
     *
     * If specified, Envoy will lookup the runtime key to get the percentage of requests to the
     * mirror.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 2;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Set this to TRUE to only mirror write commands, this is effectively replicating the
     * writes in a "fire and forget" manner.
     *
     * @generated from protobuf field: bool exclude_read_commands = 3;
     */
    excludeReadCommands: boolean;
}
/**
 * RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
 * :ref:`typed_extension_protocol_options<envoy_api_field_Cluster.typed_extension_protocol_options>`,
 * keyed by the name `envoy.filters.network.redis_proxy`.
 *
 * @generated from protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions
 */
export interface RedisProtocolOptions {
    /**
     * Upstream server password as defined by the `requirepass` directive
     * <https://redis.io/topics/config>`_ in the server's configuration file.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource auth_password = 1;
     */
    authPassword?: DataSource;
}
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy$Type extends MessageType<RedisProxy> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProxy", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 3, name: "settings", kind: "message", T: () => RedisProxy_ConnPoolSettings, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "latency_in_micros", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "prefix_routes", kind: "message", T: () => RedisProxy_PrefixRoutes },
            { no: 6, name: "downstream_auth_password", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } }
        ]);
    }
    create(value?: PartialMessage<RedisProxy>): RedisProxy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        message.cluster = "";
        message.latencyInMicros = false;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy): RedisProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* string cluster = 2 [deprecated = true];*/ 2:
                    message.cluster = reader.string();
                    break;
                case /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings */ 3:
                    message.settings = RedisProxy_ConnPoolSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* bool latency_in_micros */ 4:
                    message.latencyInMicros = reader.bool();
                    break;
                case /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes */ 5:
                    message.prefixRoutes = RedisProxy_PrefixRoutes.internalBinaryRead(reader, reader.uint32(), options, message.prefixRoutes);
                    break;
                case /* envoy.api.v2.core.DataSource downstream_auth_password */ 6:
                    message.downstreamAuthPassword = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.downstreamAuthPassword);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* string cluster = 2 [deprecated = true]; */
        if (message.cluster !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cluster);
        /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings settings = 3; */
        if (message.settings)
            RedisProxy_ConnPoolSettings.internalBinaryWrite(message.settings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool latency_in_micros = 4; */
        if (message.latencyInMicros !== false)
            writer.tag(4, WireType.Varint).bool(message.latencyInMicros);
        /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes prefix_routes = 5; */
        if (message.prefixRoutes)
            RedisProxy_PrefixRoutes.internalBinaryWrite(message.prefixRoutes, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource downstream_auth_password = 6; */
        if (message.downstreamAuthPassword)
            DataSource.internalBinaryWrite(message.downstreamAuthPassword, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy
 */
export const RedisProxy = new RedisProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_ConnPoolSettings$Type extends MessageType<RedisProxy_ConnPoolSettings> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings", [
            { no: 1, name: "op_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true } } } },
            { no: 2, name: "enable_hashtagging", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "enable_redirection", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "max_buffer_size_before_flush", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "buffer_flush_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "max_upstream_unknown_connections", kind: "message", T: () => UInt32Value },
            { no: 8, name: "enable_command_stats", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "read_policy", kind: "enum", T: () => ["envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy", RedisProxy_ConnPoolSettings_ReadPolicy], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_ConnPoolSettings>): RedisProxy_ConnPoolSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableHashtagging = false;
        message.enableRedirection = false;
        message.maxBufferSizeBeforeFlush = 0;
        message.enableCommandStats = false;
        message.readPolicy = 0;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_ConnPoolSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_ConnPoolSettings): RedisProxy_ConnPoolSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration op_timeout */ 1:
                    message.opTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.opTimeout);
                    break;
                case /* bool enable_hashtagging */ 2:
                    message.enableHashtagging = reader.bool();
                    break;
                case /* bool enable_redirection */ 3:
                    message.enableRedirection = reader.bool();
                    break;
                case /* uint32 max_buffer_size_before_flush */ 4:
                    message.maxBufferSizeBeforeFlush = reader.uint32();
                    break;
                case /* google.protobuf.Duration buffer_flush_timeout */ 5:
                    message.bufferFlushTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.bufferFlushTimeout);
                    break;
                case /* google.protobuf.UInt32Value max_upstream_unknown_connections */ 6:
                    message.maxUpstreamUnknownConnections = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxUpstreamUnknownConnections);
                    break;
                case /* bool enable_command_stats */ 8:
                    message.enableCommandStats = reader.bool();
                    break;
                case /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy read_policy */ 7:
                    message.readPolicy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_ConnPoolSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration op_timeout = 1; */
        if (message.opTimeout)
            Duration.internalBinaryWrite(message.opTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_hashtagging = 2; */
        if (message.enableHashtagging !== false)
            writer.tag(2, WireType.Varint).bool(message.enableHashtagging);
        /* bool enable_redirection = 3; */
        if (message.enableRedirection !== false)
            writer.tag(3, WireType.Varint).bool(message.enableRedirection);
        /* uint32 max_buffer_size_before_flush = 4; */
        if (message.maxBufferSizeBeforeFlush !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxBufferSizeBeforeFlush);
        /* google.protobuf.Duration buffer_flush_timeout = 5; */
        if (message.bufferFlushTimeout)
            Duration.internalBinaryWrite(message.bufferFlushTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_upstream_unknown_connections = 6; */
        if (message.maxUpstreamUnknownConnections)
            UInt32Value.internalBinaryWrite(message.maxUpstreamUnknownConnections, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_command_stats = 8; */
        if (message.enableCommandStats !== false)
            writer.tag(8, WireType.Varint).bool(message.enableCommandStats);
        /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings.ReadPolicy read_policy = 7; */
        if (message.readPolicy !== 0)
            writer.tag(7, WireType.Varint).int32(message.readPolicy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings
 */
export const RedisProxy_ConnPoolSettings = new RedisProxy_ConnPoolSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes$Type extends MessageType<RedisProxy_PrefixRoutes> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes", [
            { no: 1, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RedisProxy_PrefixRoutes_Route },
            { no: 2, name: "case_insensitive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "catch_all_cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 4, name: "catch_all_route", kind: "message", T: () => RedisProxy_PrefixRoutes_Route }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes>): RedisProxy_PrefixRoutes {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.routes = [];
        message.caseInsensitive = false;
        message.catchAllCluster = "";
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes): RedisProxy_PrefixRoutes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route routes */ 1:
                    message.routes.push(RedisProxy_PrefixRoutes_Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool case_insensitive */ 2:
                    message.caseInsensitive = reader.bool();
                    break;
                case /* string catch_all_cluster = 3 [deprecated = true];*/ 3:
                    message.catchAllCluster = reader.string();
                    break;
                case /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route catch_all_route */ 4:
                    message.catchAllRoute = RedisProxy_PrefixRoutes_Route.internalBinaryRead(reader, reader.uint32(), options, message.catchAllRoute);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route routes = 1; */
        for (let i = 0; i < message.routes.length; i++)
            RedisProxy_PrefixRoutes_Route.internalBinaryWrite(message.routes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool case_insensitive = 2; */
        if (message.caseInsensitive !== false)
            writer.tag(2, WireType.Varint).bool(message.caseInsensitive);
        /* string catch_all_cluster = 3 [deprecated = true]; */
        if (message.catchAllCluster !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.catchAllCluster);
        /* envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route catch_all_route = 4; */
        if (message.catchAllRoute)
            RedisProxy_PrefixRoutes_Route.internalBinaryWrite(message.catchAllRoute, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes
 */
export const RedisProxy_PrefixRoutes = new RedisProxy_PrefixRoutes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes_Route$Type extends MessageType<RedisProxy_PrefixRoutes_Route> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route", [
            { no: 1, name: "prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "remove_prefix", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 4, name: "request_mirror_policy", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes_Route>): RedisProxy_PrefixRoutes_Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefix = "";
        message.removePrefix = false;
        message.cluster = "";
        message.requestMirrorPolicy = [];
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes_Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes_Route): RedisProxy_PrefixRoutes_Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prefix */ 1:
                    message.prefix = reader.string();
                    break;
                case /* bool remove_prefix */ 2:
                    message.removePrefix = reader.bool();
                    break;
                case /* string cluster */ 3:
                    message.cluster = reader.string();
                    break;
                case /* repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy */ 4:
                    message.requestMirrorPolicy.push(RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes_Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prefix = 1; */
        if (message.prefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.prefix);
        /* bool remove_prefix = 2; */
        if (message.removePrefix !== false)
            writer.tag(2, WireType.Varint).bool(message.removePrefix);
        /* string cluster = 3; */
        if (message.cluster !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cluster);
        /* repeated envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy request_mirror_policy = 4; */
        for (let i = 0; i < message.requestMirrorPolicy.length; i++)
            RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicy[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route
 */
export const RedisProxy_PrefixRoutes_Route = new RedisProxy_PrefixRoutes_Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy$Type extends MessageType<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 3, name: "exclude_read_commands", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.excludeReadCommands = false;
        if (value !== undefined)
            reflectionMergePartial<RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy): RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction */ 2:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* bool exclude_read_commands */ 3:
                    message.excludeReadCommands = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 2; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool exclude_read_commands = 3; */
        if (message.excludeReadCommands !== false)
            writer.tag(3, WireType.Varint).bool(message.excludeReadCommands);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy
 */
export const RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy = new RedisProxy_PrefixRoutes_Route_RequestMirrorPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedisProtocolOptions$Type extends MessageType<RedisProtocolOptions> {
    constructor() {
        super("envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions", [
            { no: 1, name: "auth_password", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } }
        ]);
    }
    create(value?: PartialMessage<RedisProtocolOptions>): RedisProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RedisProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedisProtocolOptions): RedisProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.DataSource auth_password */ 1:
                    message.authPassword = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.authPassword);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedisProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.DataSource auth_password = 1; */
        if (message.authPassword)
            DataSource.internalBinaryWrite(message.authPassword, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.network.redis_proxy.v2.RedisProtocolOptions
 */
export const RedisProtocolOptions = new RedisProtocolOptions$Type();
