// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/filter/network/dubbo_proxy/v2alpha1/route.proto (package envoy.config.filter.network.dubbo_proxy.v2alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { HeaderMatcher, WeightedCluster } from "../../../../../api/v2/route/route_components_pb.js";
import type { StringMatcher } from "../../../../../type/matcher/string_pb.js";
import type { Int64Range } from "../../../../../type/range_pb.js";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration
 */
export declare class RouteConfiguration extends Message<RouteConfiguration> {
  /**
   * The name of the route configuration. Reserved for future use in asynchronous route discovery.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The interface name of the service.
   *
   * @generated from field: string interface = 2;
   */
  interface: string;

  /**
   * Which group does the interface belong to.
   *
   * @generated from field: string group = 3;
   */
  group: string;

  /**
   * The version number of the interface.
   *
   * @generated from field: string version = 4;
   */
  version: string;

  /**
   * The list of routes that will be matched, in order, against incoming requests. The first route
   * that matches will be used.
   *
   * @generated from field: repeated envoy.config.filter.network.dubbo_proxy.v2alpha1.Route routes = 5;
   */
  routes: Route[];

  constructor(data?: PartialMessage<RouteConfiguration>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteConfiguration";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteConfiguration;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteConfiguration;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteConfiguration;

  static equals(a: RouteConfiguration | PlainMessage<RouteConfiguration> | undefined, b: RouteConfiguration | PlainMessage<RouteConfiguration> | undefined): boolean;
}

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.Route
 */
export declare class Route extends Message<Route> {
  /**
   * Route matching parameters.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * Route request to some upstream cluster.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction route = 2;
   */
  route?: RouteAction;

  constructor(data?: PartialMessage<Route>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.Route";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Route;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Route;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Route;

  static equals(a: Route | PlainMessage<Route> | undefined, b: Route | PlainMessage<Route> | undefined): boolean;
}

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch
 */
export declare class RouteMatch extends Message<RouteMatch> {
  /**
   * Method level routing matching.
   *
   * @generated from field: envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch method = 1;
   */
  method?: MethodMatch;

  /**
   * Specifies a set of headers that the route should match on. The router will check the requestâ€™s
   * headers against all the specified headers in the route config. A match will happen if all the
   * headers in the route are present in the request with the same values (or based on presence if
   * the value field is not in the config).
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher headers = 2;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<RouteMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatch;

  static equals(a: RouteMatch | PlainMessage<RouteMatch> | undefined, b: RouteMatch | PlainMessage<RouteMatch> | undefined): boolean;
}

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction
 */
export declare class RouteAction extends Message<RouteAction> {
  /**
   * @generated from oneof envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * Indicates the upstream cluster to which the request should be routed.
     *
     * @generated from field: string cluster = 1;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster.
     * Currently ClusterWeight only supports the name and weight fields.
     *
     * @generated from field: envoy.api.v2.route.WeightedCluster weighted_clusters = 2;
     */
    value: WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RouteAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.RouteAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction;

  static equals(a: RouteAction | PlainMessage<RouteAction> | undefined, b: RouteAction | PlainMessage<RouteAction> | undefined): boolean;
}

/**
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch
 */
export declare class MethodMatch extends Message<MethodMatch> {
  /**
   * The name of the method.
   *
   * @generated from field: envoy.type.matcher.StringMatcher name = 1;
   */
  name?: StringMatcher;

  /**
   * Method parameter definition.
   * The key is the parameter index, starting from 0.
   * The value is the parameter matching type.
   *
   * @generated from field: map<uint32, envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier> params_match = 2;
   */
  paramsMatch: { [key: number]: MethodMatch_ParameterMatchSpecifier };

  constructor(data?: PartialMessage<MethodMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodMatch;

  static equals(a: MethodMatch | PlainMessage<MethodMatch> | undefined, b: MethodMatch | PlainMessage<MethodMatch> | undefined): boolean;
}

/**
 * The parameter matching type.
 *
 * @generated from message envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier
 */
export declare class MethodMatch_ParameterMatchSpecifier extends Message<MethodMatch_ParameterMatchSpecifier> {
  /**
   * @generated from oneof envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier.parameter_match_specifier
   */
  parameterMatchSpecifier: {
    /**
     * If specified, header match will be performed based on the value of the header.
     *
     * @generated from field: string exact_match = 3;
     */
    value: string;
    case: "exactMatch";
  } | {
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting
     * of an optional plus or minus sign followed by a sequence of digits. The rule will not match
     * if the header value does not represent an integer. Match will fail for empty values,
     * floating point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0,
     *   "somestring", 10.9, "-1somestring"
     *
     * @generated from field: envoy.type.Int64Range range_match = 4;
     */
    value: Int64Range;
    case: "rangeMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<MethodMatch_ParameterMatchSpecifier>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.filter.network.dubbo_proxy.v2alpha1.MethodMatch.ParameterMatchSpecifier";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MethodMatch_ParameterMatchSpecifier;

  static equals(a: MethodMatch_ParameterMatchSpecifier | PlainMessage<MethodMatch_ParameterMatchSpecifier> | undefined, b: MethodMatch_ParameterMatchSpecifier | PlainMessage<MethodMatch_ParameterMatchSpecifier> | undefined): boolean;
}

