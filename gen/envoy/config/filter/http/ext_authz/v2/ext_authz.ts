// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/filter/http/ext_authz/v2/ext_authz.proto" (package "envoy.config.filter.http.ext_authz.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderValue } from "../../../../../api/v2/core/base";
import { ListStringMatcher } from "../../../../../type/matcher/string";
import { HttpUri } from "../../../../../api/v2/core/http_uri";
import { RuntimeFeatureFlag } from "../../../../../api/v2/core/base";
import { RuntimeFractionalPercent } from "../../../../../api/v2/core/base";
import { HttpStatus } from "../../../../../type/http_status";
import { GrpcService } from "../../../../../api/v2/core/grpc_service";
// [#protodoc-title: External Authorization]
// External Authorization :ref:`configuration overview <config_http_filters_ext_authz>`.
// [#extension: envoy.filters.http.ext_authz]

/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.ExtAuthz
 */
export interface ExtAuthz {
    /**
     * @generated from protobuf oneof: services
     */
    services: {
        oneofKind: "grpcService";
        /**
         * gRPC service configuration (default timeout: 200ms).
         *
         * @generated from protobuf field: envoy.api.v2.core.GrpcService grpc_service = 1;
         */
        grpcService: GrpcService;
    } | {
        oneofKind: "httpService";
        /**
         * HTTP service configuration (default timeout: 200ms).
         *
         * @generated from protobuf field: envoy.config.filter.http.ext_authz.v2.HttpService http_service = 3;
         */
        httpService: HttpService;
    } | {
        oneofKind: undefined;
    };
    /**
     *  Changes filter's behaviour on errors:
     *
     *  1. When set to true, the filter will *accept* client request even if the communication with
     *  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
     *  error.
     *
     *  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
     *  response if the communication with the authorization service has failed, or if the
     *  authorization service has returned a HTTP 5xx error.
     *
     * Note that errors can be *always* tracked in the :ref:`stats
     * <config_http_filters_ext_authz_stats>`.
     *
     * @generated from protobuf field: bool failure_mode_allow = 2;
     */
    failureModeAllow: boolean;
    /**
     * [#not-implemented-hide: Support for this field has been removed.]
     *
     * @deprecated
     * @generated from protobuf field: bool use_alpha = 4 [deprecated = true];
     */
    useAlpha: boolean;
    /**
     * Enables filter to buffer the client request body and send it within the authorization request.
     * A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
     * request message indicating if the body data is partial.
     *
     * @generated from protobuf field: envoy.config.filter.http.ext_authz.v2.BufferSettings with_request_body = 5;
     */
    withRequestBody?: BufferSettings;
    /**
     * Clears route cache in order to allow the external authorization service to correctly affect
     * routing decisions. Filter clears all cached routes when:
     *
     * 1. The field is set to *true*.
     *
     * 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
     *
     * 3. At least one *authorization response header* is added to the client request, or is used for
     * altering another client request header.
     *
     *
     * @generated from protobuf field: bool clear_route_cache = 6;
     */
    clearRouteCache: boolean;
    /**
     * Sets the HTTP status that is returned to the client when there is a network error between the
     * filter and the authorization server. The default status is HTTP 403 Forbidden.
     *
     * @generated from protobuf field: envoy.type.HttpStatus status_on_error = 7;
     */
    statusOnError?: HttpStatus;
    /**
     * Specifies a list of metadata namespaces whose values, if present, will be passed to the
     * ext_authz service as an opaque *protobuf::Struct*.
     *
     * For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
     * <envoy_api_field_config.filter.http.jwt_authn.v2alpha.JwtProvider.payload_in_metadata>` is set,
     * then the following will pass the jwt payload to the authorization server.
     *
     * .. code-block:: yaml
     *
     *    metadata_context_namespaces:
     *    - envoy.filters.http.jwt_authn
     *
     *
     * @generated from protobuf field: repeated string metadata_context_namespaces = 8;
     */
    metadataContextNamespaces: string[];
    /**
     * Specifies if the filter is enabled.
     *
     * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
     * Envoy will lookup the runtime key to get the percentage of requests to filter.
     *
     * If this field is not specified, the filter will be enabled for all requests.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9;
     */
    filterEnabled?: RuntimeFractionalPercent;
    /**
     * Specifies whether to deny the requests, when the filter is disabled.
     * If :ref:`runtime_key <envoy_api_field_core.RuntimeFeatureFlag.runtime_key>` is specified,
     * Envoy will lookup the runtime key to determine whether to deny request for
     * filter protected path at filter disabling. If filter is disabled in
     * typed_per_filter_config for the path, requests will not be denied.
     *
     * If this field is not specified, all requests will be allowed when disabled.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFeatureFlag deny_at_disable = 11;
     */
    denyAtDisable?: RuntimeFeatureFlag;
    /**
     * Specifies if the peer certificate is sent to the external service.
     *
     * When this field is true, Envoy will include the peer X.509 certificate, if available, in the
     * :ref:`certificate<envoy_api_field_service.auth.v2.AttributeContext.Peer.certificate>`.
     *
     * @generated from protobuf field: bool include_peer_certificate = 10;
     */
    includePeerCertificate: boolean;
}
/**
 * Configuration for buffering the request data.
 *
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.BufferSettings
 */
export interface BufferSettings {
    /**
     * Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
     * *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
     * set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
     * <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.failure_mode_allow>`.
     *
     * @generated from protobuf field: uint32 max_request_bytes = 1;
     */
    maxRequestBytes: number;
    /**
     * When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
     * The authorization request will be dispatched and no 413 HTTP error will be returned by the
     * filter.
     *
     * @generated from protobuf field: bool allow_partial_message = 2;
     */
    allowPartialMessage: boolean;
}
/**
 * HttpService is used for raw HTTP communication between the filter and the authorization service.
 * When configured, the filter will parse the client request and use these attributes to call the
 * authorization server. Depending on the response, the filter may reject or accept the client
 * request. Note that in any of these events, metadata can be added, removed or overridden by the
 * filter:
 *
 * *On authorization request*, a list of allowed request headers may be supplied. See
 * :ref:`allowed_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.allowed_headers>`
 * for details. Additional headers metadata may be added to the authorization request. See
 * :ref:`headers_to_add
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationRequest.headers_to_add>` for
 * details.
 *
 * On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
 * additional headers metadata may be added to the original client request. See
 * :ref:`allowed_upstream_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_upstream_headers>`
 * for details.
 *
 * On other authorization response statuses, the filter will not allow traffic. Additional headers
 * metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
 * <envoy_api_field_config.filter.http.ext_authz.v2.AuthorizationResponse.allowed_client_headers>`
 * for details.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.HttpService
 */
export interface HttpService {
    /**
     * Sets the HTTP server URI which the authorization requests must be sent to.
     *
     * @generated from protobuf field: envoy.api.v2.core.HttpUri server_uri = 1;
     */
    serverUri?: HttpUri;
    /**
     * Sets a prefix to the value of authorization request header *Path*.
     *
     * @generated from protobuf field: string path_prefix = 2;
     */
    pathPrefix: string;
    /**
     * Settings used for controlling authorization request metadata.
     *
     * @generated from protobuf field: envoy.config.filter.http.ext_authz.v2.AuthorizationRequest authorization_request = 7;
     */
    authorizationRequest?: AuthorizationRequest;
    /**
     * Settings used for controlling authorization response metadata.
     *
     * @generated from protobuf field: envoy.config.filter.http.ext_authz.v2.AuthorizationResponse authorization_response = 8;
     */
    authorizationResponse?: AuthorizationResponse;
}
/**
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.AuthorizationRequest
 */
export interface AuthorizationRequest {
    /**
     * Authorization request will include the client request headers that have a correspondent match
     * in the :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>`. Note that in addition to the
     * user's supplied matchers:
     *
     * 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
     *
     * 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
     * a message body. However, the authorization request can include the buffered client request body
     * (controlled by :ref:`with_request_body
     * <envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.with_request_body>` setting),
     * consequently the value of *Content-Length* of the authorization request reflects the size of
     * its payload size.
     *
     *
     * @generated from protobuf field: envoy.type.matcher.ListStringMatcher allowed_headers = 1;
     */
    allowedHeaders?: ListStringMatcher;
    /**
     * Sets a list of headers that will be included to the request to authorization service. Note that
     * client request of the same key will be overridden.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValue headers_to_add = 2;
     */
    headersToAdd: HeaderValue[];
}
/**
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.AuthorizationResponse
 */
export interface AuthorizationResponse {
    /**
     * When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the original client request.
     * Note that coexistent headers will be overridden.
     *
     * @generated from protobuf field: envoy.type.matcher.ListStringMatcher allowed_upstream_headers = 1;
     */
    allowedUpstreamHeaders?: ListStringMatcher;
    /**
     * When this :ref:`list <envoy_api_msg_type.matcher.ListStringMatcher>` is set, authorization
     * response headers that have a correspondent match will be added to the client's response. Note
     * that when this list is *not* set, all the authorization response headers, except *Authority
     * (Host)* will be in the response to the client. When a header is included in this list, *Path*,
     * *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
     *
     * @generated from protobuf field: envoy.type.matcher.ListStringMatcher allowed_client_headers = 2;
     */
    allowedClientHeaders?: ListStringMatcher;
}
/**
 * Extra settings on a per virtualhost/route/weighted-cluster level.
 *
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute
 */
export interface ExtAuthzPerRoute {
    /**
     * @generated from protobuf oneof: override
     */
    override: {
        oneofKind: "disabled";
        /**
         * Disable the ext auth filter for this particular vhost or route.
         * If disabled is specified in multiple per-filter-configs, the most specific one will be used.
         *
         * @generated from protobuf field: bool disabled = 1;
         */
        disabled: boolean;
    } | {
        oneofKind: "checkSettings";
        /**
         * Check request settings for this route.
         *
         * @generated from protobuf field: envoy.config.filter.http.ext_authz.v2.CheckSettings check_settings = 2;
         */
        checkSettings: CheckSettings;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Extra settings for the check request. You can use this to provide extra context for the
 * external authorization server on specific virtual hosts \ routes. For example, adding a context
 * extension on the virtual host level can give the ext-authz server information on what virtual
 * host is used without needing to parse the host header. If CheckSettings is specified in multiple
 * per-filter-configs, they will be merged in order, and the result will be used.
 *
 * @generated from protobuf message envoy.config.filter.http.ext_authz.v2.CheckSettings
 */
export interface CheckSettings {
    /**
     * Context extensions to set on the CheckRequest's
     * :ref:`AttributeContext.context_extensions<envoy_api_field_service.auth.v2.AttributeContext.context_extensions>`
     *
     * Merge semantics for this field are such that keys from more specific configs override.
     *
     * .. note::
     *
     *   These settings are only applied to a filter configured with a
     *   :ref:`grpc_service<envoy_api_field_config.filter.http.ext_authz.v2.ExtAuthz.grpc_service>`.
     *
     * @generated from protobuf field: map<string, string> context_extensions = 1;
     */
    contextExtensions: {
        [key: string]: string;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class ExtAuthz$Type extends MessageType<ExtAuthz> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.ExtAuthz", [
            { no: 1, name: "grpc_service", kind: "message", oneof: "services", T: () => GrpcService },
            { no: 3, name: "http_service", kind: "message", oneof: "services", T: () => HttpService },
            { no: 2, name: "failure_mode_allow", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "use_alpha", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 5, name: "with_request_body", kind: "message", T: () => BufferSettings },
            { no: 6, name: "clear_route_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "status_on_error", kind: "message", T: () => HttpStatus },
            { no: 8, name: "metadata_context_namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "filter_enabled", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 11, name: "deny_at_disable", kind: "message", T: () => RuntimeFeatureFlag },
            { no: 10, name: "include_peer_certificate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExtAuthz>): ExtAuthz {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.services = { oneofKind: undefined };
        message.failureModeAllow = false;
        message.useAlpha = false;
        message.clearRouteCache = false;
        message.metadataContextNamespaces = [];
        message.includePeerCertificate = false;
        if (value !== undefined)
            reflectionMergePartial<ExtAuthz>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtAuthz): ExtAuthz {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.GrpcService grpc_service */ 1:
                    message.services = {
                        oneofKind: "grpcService",
                        grpcService: GrpcService.internalBinaryRead(reader, reader.uint32(), options, (message.services as any).grpcService)
                    };
                    break;
                case /* envoy.config.filter.http.ext_authz.v2.HttpService http_service */ 3:
                    message.services = {
                        oneofKind: "httpService",
                        httpService: HttpService.internalBinaryRead(reader, reader.uint32(), options, (message.services as any).httpService)
                    };
                    break;
                case /* bool failure_mode_allow */ 2:
                    message.failureModeAllow = reader.bool();
                    break;
                case /* bool use_alpha = 4 [deprecated = true];*/ 4:
                    message.useAlpha = reader.bool();
                    break;
                case /* envoy.config.filter.http.ext_authz.v2.BufferSettings with_request_body */ 5:
                    message.withRequestBody = BufferSettings.internalBinaryRead(reader, reader.uint32(), options, message.withRequestBody);
                    break;
                case /* bool clear_route_cache */ 6:
                    message.clearRouteCache = reader.bool();
                    break;
                case /* envoy.type.HttpStatus status_on_error */ 7:
                    message.statusOnError = HttpStatus.internalBinaryRead(reader, reader.uint32(), options, message.statusOnError);
                    break;
                case /* repeated string metadata_context_namespaces */ 8:
                    message.metadataContextNamespaces.push(reader.string());
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent filter_enabled */ 9:
                    message.filterEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.filterEnabled);
                    break;
                case /* envoy.api.v2.core.RuntimeFeatureFlag deny_at_disable */ 11:
                    message.denyAtDisable = RuntimeFeatureFlag.internalBinaryRead(reader, reader.uint32(), options, message.denyAtDisable);
                    break;
                case /* bool include_peer_certificate */ 10:
                    message.includePeerCertificate = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtAuthz, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.GrpcService grpc_service = 1; */
        if (message.services.oneofKind === "grpcService")
            GrpcService.internalBinaryWrite(message.services.grpcService, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.ext_authz.v2.HttpService http_service = 3; */
        if (message.services.oneofKind === "httpService")
            HttpService.internalBinaryWrite(message.services.httpService, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool failure_mode_allow = 2; */
        if (message.failureModeAllow !== false)
            writer.tag(2, WireType.Varint).bool(message.failureModeAllow);
        /* bool use_alpha = 4 [deprecated = true]; */
        if (message.useAlpha !== false)
            writer.tag(4, WireType.Varint).bool(message.useAlpha);
        /* envoy.config.filter.http.ext_authz.v2.BufferSettings with_request_body = 5; */
        if (message.withRequestBody)
            BufferSettings.internalBinaryWrite(message.withRequestBody, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool clear_route_cache = 6; */
        if (message.clearRouteCache !== false)
            writer.tag(6, WireType.Varint).bool(message.clearRouteCache);
        /* envoy.type.HttpStatus status_on_error = 7; */
        if (message.statusOnError)
            HttpStatus.internalBinaryWrite(message.statusOnError, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string metadata_context_namespaces = 8; */
        for (let i = 0; i < message.metadataContextNamespaces.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.metadataContextNamespaces[i]);
        /* envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9; */
        if (message.filterEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.filterEnabled, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RuntimeFeatureFlag deny_at_disable = 11; */
        if (message.denyAtDisable)
            RuntimeFeatureFlag.internalBinaryWrite(message.denyAtDisable, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool include_peer_certificate = 10; */
        if (message.includePeerCertificate !== false)
            writer.tag(10, WireType.Varint).bool(message.includePeerCertificate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.ExtAuthz
 */
export const ExtAuthz = new ExtAuthz$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BufferSettings$Type extends MessageType<BufferSettings> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.BufferSettings", [
            { no: 1, name: "max_request_bytes", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gt: 0 } } } },
            { no: 2, name: "allow_partial_message", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BufferSettings>): BufferSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxRequestBytes = 0;
        message.allowPartialMessage = false;
        if (value !== undefined)
            reflectionMergePartial<BufferSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BufferSettings): BufferSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_request_bytes */ 1:
                    message.maxRequestBytes = reader.uint32();
                    break;
                case /* bool allow_partial_message */ 2:
                    message.allowPartialMessage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BufferSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_request_bytes = 1; */
        if (message.maxRequestBytes !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxRequestBytes);
        /* bool allow_partial_message = 2; */
        if (message.allowPartialMessage !== false)
            writer.tag(2, WireType.Varint).bool(message.allowPartialMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.BufferSettings
 */
export const BufferSettings = new BufferSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpService$Type extends MessageType<HttpService> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.HttpService", [
            { no: 1, name: "server_uri", kind: "message", T: () => HttpUri },
            { no: 2, name: "path_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "authorization_request", kind: "message", T: () => AuthorizationRequest },
            { no: 8, name: "authorization_response", kind: "message", T: () => AuthorizationResponse }
        ]);
    }
    create(value?: PartialMessage<HttpService>): HttpService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<HttpService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpService): HttpService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.HttpUri server_uri */ 1:
                    message.serverUri = HttpUri.internalBinaryRead(reader, reader.uint32(), options, message.serverUri);
                    break;
                case /* string path_prefix */ 2:
                    message.pathPrefix = reader.string();
                    break;
                case /* envoy.config.filter.http.ext_authz.v2.AuthorizationRequest authorization_request */ 7:
                    message.authorizationRequest = AuthorizationRequest.internalBinaryRead(reader, reader.uint32(), options, message.authorizationRequest);
                    break;
                case /* envoy.config.filter.http.ext_authz.v2.AuthorizationResponse authorization_response */ 8:
                    message.authorizationResponse = AuthorizationResponse.internalBinaryRead(reader, reader.uint32(), options, message.authorizationResponse);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.HttpUri server_uri = 1; */
        if (message.serverUri)
            HttpUri.internalBinaryWrite(message.serverUri, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string path_prefix = 2; */
        if (message.pathPrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pathPrefix);
        /* envoy.config.filter.http.ext_authz.v2.AuthorizationRequest authorization_request = 7; */
        if (message.authorizationRequest)
            AuthorizationRequest.internalBinaryWrite(message.authorizationRequest, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.ext_authz.v2.AuthorizationResponse authorization_response = 8; */
        if (message.authorizationResponse)
            AuthorizationResponse.internalBinaryWrite(message.authorizationResponse, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.HttpService
 */
export const HttpService = new HttpService$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationRequest$Type extends MessageType<AuthorizationRequest> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.AuthorizationRequest", [
            { no: 1, name: "allowed_headers", kind: "message", T: () => ListStringMatcher },
            { no: 2, name: "headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue }
        ]);
    }
    create(value?: PartialMessage<AuthorizationRequest>): AuthorizationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headersToAdd = [];
        if (value !== undefined)
            reflectionMergePartial<AuthorizationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationRequest): AuthorizationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.ListStringMatcher allowed_headers */ 1:
                    message.allowedHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedHeaders);
                    break;
                case /* repeated envoy.api.v2.core.HeaderValue headers_to_add */ 2:
                    message.headersToAdd.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.ListStringMatcher allowed_headers = 1; */
        if (message.allowedHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HeaderValue headers_to_add = 2; */
        for (let i = 0; i < message.headersToAdd.length; i++)
            HeaderValue.internalBinaryWrite(message.headersToAdd[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.AuthorizationRequest
 */
export const AuthorizationRequest = new AuthorizationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizationResponse$Type extends MessageType<AuthorizationResponse> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.AuthorizationResponse", [
            { no: 1, name: "allowed_upstream_headers", kind: "message", T: () => ListStringMatcher },
            { no: 2, name: "allowed_client_headers", kind: "message", T: () => ListStringMatcher }
        ]);
    }
    create(value?: PartialMessage<AuthorizationResponse>): AuthorizationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AuthorizationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AuthorizationResponse): AuthorizationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.matcher.ListStringMatcher allowed_upstream_headers */ 1:
                    message.allowedUpstreamHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedUpstreamHeaders);
                    break;
                case /* envoy.type.matcher.ListStringMatcher allowed_client_headers */ 2:
                    message.allowedClientHeaders = ListStringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.allowedClientHeaders);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AuthorizationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.matcher.ListStringMatcher allowed_upstream_headers = 1; */
        if (message.allowedUpstreamHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedUpstreamHeaders, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.ListStringMatcher allowed_client_headers = 2; */
        if (message.allowedClientHeaders)
            ListStringMatcher.internalBinaryWrite(message.allowedClientHeaders, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.AuthorizationResponse
 */
export const AuthorizationResponse = new AuthorizationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtAuthzPerRoute$Type extends MessageType<ExtAuthzPerRoute> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute", [
            { no: 1, name: "disabled", kind: "scalar", oneof: "override", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "check_settings", kind: "message", oneof: "override", T: () => CheckSettings, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ExtAuthzPerRoute>): ExtAuthzPerRoute {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.override = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExtAuthzPerRoute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtAuthzPerRoute): ExtAuthzPerRoute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool disabled */ 1:
                    message.override = {
                        oneofKind: "disabled",
                        disabled: reader.bool()
                    };
                    break;
                case /* envoy.config.filter.http.ext_authz.v2.CheckSettings check_settings */ 2:
                    message.override = {
                        oneofKind: "checkSettings",
                        checkSettings: CheckSettings.internalBinaryRead(reader, reader.uint32(), options, (message.override as any).checkSettings)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtAuthzPerRoute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool disabled = 1; */
        if (message.override.oneofKind === "disabled")
            writer.tag(1, WireType.Varint).bool(message.override.disabled);
        /* envoy.config.filter.http.ext_authz.v2.CheckSettings check_settings = 2; */
        if (message.override.oneofKind === "checkSettings")
            CheckSettings.internalBinaryWrite(message.override.checkSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.ExtAuthzPerRoute
 */
export const ExtAuthzPerRoute = new ExtAuthzPerRoute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckSettings$Type extends MessageType<CheckSettings> {
    constructor() {
        super("envoy.config.filter.http.ext_authz.v2.CheckSettings", [
            { no: 1, name: "context_extensions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<CheckSettings>): CheckSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contextExtensions = {};
        if (value !== undefined)
            reflectionMergePartial<CheckSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckSettings): CheckSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> context_extensions */ 1:
                    this.binaryReadMap1(message.contextExtensions, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CheckSettings["contextExtensions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CheckSettings["contextExtensions"] | undefined, val: CheckSettings["contextExtensions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.filter.http.ext_authz.v2.CheckSettings.context_extensions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: CheckSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> context_extensions = 1; */
        for (let k of globalThis.Object.keys(message.contextExtensions))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.contextExtensions[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.ext_authz.v2.CheckSettings
 */
export const CheckSettings = new CheckSettings$Type();
