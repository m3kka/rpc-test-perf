// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/filter/http/jwt_authn/v2alpha/config.proto" (package "envoy.config.filter.http.jwt_authn.v2alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RouteMatch } from "../../../../../api/v2/route/route_components";
import { Empty } from "../../../../../../google/protobuf/empty";
import { Duration } from "../../../../../../google/protobuf/duration";
import { HttpUri } from "../../../../../api/v2/core/http_uri";
import { DataSource } from "../../../../../api/v2/core/base";
// [#protodoc-title: JWT Authentication]
// JWT Authentication :ref:`configuration overview <config_http_filters_jwt_authn>`.
// [#extension: envoy.filters.http.jwt_authn]

/**
 * Please see following for JWT authentication flow:
 *
 * * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
 * * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
 * * `OpenID Connect <http://openid.net/connect>`_
 *
 * A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
 *
 * * issuer: the principal that issues the JWT. It has to match the one from the token.
 * * allowed audiences: the ones in the token have to be listed here.
 * * how to fetch public key JWKS to verify the token signature.
 * * how to extract JWT token in the request.
 * * how to pass successfully verified token payload.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *     issuer: https://example.com
 *     audiences:
 *     - bookstore_android.apps.googleusercontent.com
 *     - bookstore_web.apps.googleusercontent.com
 *     remote_jwks:
 *       http_uri:
 *         uri: https://example.com/.well-known/jwks.json
 *         cluster: example_jwks_cluster
 *       cache_duration:
 *         seconds: 300
 *
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider
 */
export interface JwtProvider {
    /**
     * Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
     * the JWT, usually a URL or an email address.
     *
     * Example: https://securetoken.google.com
     * Example: 1234567-compute@developer.gserviceaccount.com
     *
     *
     * @generated from protobuf field: string issuer = 1;
     */
    issuer: string;
    /**
     * The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
     * allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
     * will not check audiences in the token.
     *
     * Example:
     *
     * .. code-block:: yaml
     *
     *     audiences:
     *     - bookstore_android.apps.googleusercontent.com
     *     - bookstore_web.apps.googleusercontent.com
     *
     *
     * @generated from protobuf field: repeated string audiences = 2;
     */
    audiences: string[];
    /**
     * @generated from protobuf oneof: jwks_source_specifier
     */
    jwksSourceSpecifier: {
        oneofKind: "remoteJwks";
        /**
         * JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
         * URI and how the fetched JWKS should be cached.
         *
         * Example:
         *
         * .. code-block:: yaml
         *
         *    remote_jwks:
         *      http_uri:
         *        uri: https://www.googleapis.com/oauth2/v1/certs
         *        cluster: jwt.www.googleapis.com|443
         *      cache_duration:
         *        seconds: 300
         *
         *
         * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks remote_jwks = 3;
         */
        remoteJwks: RemoteJwks;
    } | {
        oneofKind: "localJwks";
        /**
         * JWKS is in local data source. It could be either in a local file or embedded in the
         * inline_string.
         *
         * Example: local file
         *
         * .. code-block:: yaml
         *
         *    local_jwks:
         *      filename: /etc/envoy/jwks/jwks1.txt
         *
         * Example: inline_string
         *
         * .. code-block:: yaml
         *
         *    local_jwks:
         *      inline_string: ACADADADADA
         *
         *
         * @generated from protobuf field: envoy.api.v2.core.DataSource local_jwks = 4;
         */
        localJwks: DataSource;
    } | {
        oneofKind: undefined;
    };
    /**
     * If false, the JWT is removed in the request after a success verification. If true, the JWT is
     * not removed in the request. Default value is false.
     *
     * @generated from protobuf field: bool forward = 5;
     */
    forward: boolean;
    /**
     * Two fields below define where to extract the JWT from an HTTP request.
     *
     * If no explicit location is specified, the following default locations are tried in order:
     *
     * 1. The Authorization header using the `Bearer schema
     * <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
     *
     *    Authorization: Bearer <token>.
     *
     * 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
     *
     * Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
     * its provider specified or from the default locations.
     *
     * Specify the HTTP headers to extract JWT token. For examples, following config:
     *
     * .. code-block:: yaml
     *
     *   from_headers:
     *   - name: x-goog-iap-jwt-assertion
     *
     * can be used to extract token from header::
     *
     *   ``x-goog-iap-jwt-assertion: <JWT>``.
     *
     *
     * @generated from protobuf field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader from_headers = 6;
     */
    fromHeaders: JwtHeader[];
    /**
     * JWT is sent in a query parameter. `jwt_params` represents the query parameter names.
     *
     * For example, if config is:
     *
     * .. code-block:: yaml
     *
     *   from_params:
     *   - jwt_token
     *
     * The JWT format in query parameter is::
     *
     *    /path?jwt_token=<JWT>
     *
     *
     * @generated from protobuf field: repeated string from_params = 7;
     */
    fromParams: string[];
    /**
     * This field specifies the header name to forward a successfully verified JWT payload to the
     * backend. The forwarded data is::
     *
     *    base64url_encoded(jwt_payload_in_JSON)
     *
     * If it is not specified, the payload will not be forwarded.
     *
     * @generated from protobuf field: string forward_payload_header = 8;
     */
    forwardPayloadHeader: string;
    /**
     * If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
     * in the format as: *namespace* is the jwt_authn filter name as **envoy.filters.http.jwt_authn**
     * The value is the *protobuf::Struct*. The value of this field will be the key for its *fields*
     * and the value is the *protobuf::Struct* converted from JWT JSON payload.
     *
     * For example, if payload_in_metadata is *my_payload*:
     *
     * .. code-block:: yaml
     *
     *   envoy.filters.http.jwt_authn:
     *     my_payload:
     *       iss: https://example.com
     *       sub: test@example.com
     *       aud: https://example.com
     *       exp: 1501281058
     *
     *
     * @generated from protobuf field: string payload_in_metadata = 9;
     */
    payloadInMetadata: string;
}
/**
 * This message specifies how to fetch JWKS from remote and how to cache it.
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks
 */
export interface RemoteJwks {
    /**
     * The HTTP URI to fetch the JWKS. For example:
     *
     * .. code-block:: yaml
     *
     *    http_uri:
     *      uri: https://www.googleapis.com/oauth2/v1/certs
     *      cluster: jwt.www.googleapis.com|443
     *
     *
     * @generated from protobuf field: envoy.api.v2.core.HttpUri http_uri = 1;
     */
    httpUri?: HttpUri;
    /**
     * Duration after which the cached JWKS should be expired. If not specified, default cache
     * duration is 5 minutes.
     *
     * @generated from protobuf field: google.protobuf.Duration cache_duration = 2;
     */
    cacheDuration?: Duration;
}
/**
 * This message specifies a header location to extract JWT token.
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader
 */
export interface JwtHeader {
    /**
     * The HTTP header name.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The value prefix. The value format is "value_prefix<token>"
     * For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
     * end.
     *
     * @generated from protobuf field: string value_prefix = 2;
     */
    valuePrefix: string;
}
/**
 * Specify a required provider with audiences.
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences
 */
export interface ProviderWithAudiences {
    /**
     * Specify a required provider name.
     *
     * @generated from protobuf field: string provider_name = 1;
     */
    providerName: string;
    /**
     * This field overrides the one specified in the JwtProvider.
     *
     * @generated from protobuf field: repeated string audiences = 2;
     */
    audiences: string[];
}
/**
 * This message specifies a Jwt requirement. An empty message means JWT verification is not
 * required. Here are some config examples:
 *
 * .. code-block:: yaml
 *
 *  # Example 1: not required with an empty message
 *
 *  # Example 2: require A
 *  provider_name: provider-A
 *
 *  # Example 3: require A or B
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 4: require A and B
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - provider_name: provider-B
 *
 *  # Example 5: require A and (B or C)
 *  requires_all:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_any:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 6: require A or (B and C)
 *  requires_any:
 *    requirements:
 *      - provider_name: provider-A
 *      - requires_all:
 *        requirements:
 *          - provider_name: provider-B
 *          - provider_name: provider-C
 *
 *  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
 *  missing token.)
 *  requires_any:
 *    requirements:
 *    - provider_name: provider-A
 *    - allow_missing: {}
 *
 *  # Example 8: A is optional and B is required.
 *  requires_all:
 *    requirements:
 *    - requires_any:
 *        requirements:
 *        - provider_name: provider-A
 *        - allow_missing: {}
 *    - provider_name: provider-B
 *
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement
 */
export interface JwtRequirement {
    /**
     * @generated from protobuf oneof: requires_type
     */
    requiresType: {
        oneofKind: "providerName";
        /**
         * Specify a required provider name.
         *
         * @generated from protobuf field: string provider_name = 1;
         */
        providerName: string;
    } | {
        oneofKind: "providerAndAudiences";
        /**
         * Specify a required provider with audiences.
         *
         * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences provider_and_audiences = 2;
         */
        providerAndAudiences: ProviderWithAudiences;
    } | {
        oneofKind: "requiresAny";
        /**
         * Specify list of JwtRequirement. Their results are OR-ed.
         * If any one of them passes, the result is passed.
         *
         * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList requires_any = 3;
         */
        requiresAny: JwtRequirementOrList;
    } | {
        oneofKind: "requiresAll";
        /**
         * Specify list of JwtRequirement. Their results are AND-ed.
         * All of them must pass, if one of them fails or missing, it fails.
         *
         * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList requires_all = 4;
         */
        requiresAll: JwtRequirementAndList;
    } | {
        oneofKind: "allowMissingOrFailed";
        /**
         * The requirement is always satisfied even if JWT is missing or the JWT
         * verification fails. A typical usage is: this filter is used to only verify
         * JWTs and pass the verified JWT payloads to another filter, the other filter
         * will make decision. In this mode, all JWT tokens will be verified.
         *
         * @generated from protobuf field: google.protobuf.Empty allow_missing_or_failed = 5;
         */
        allowMissingOrFailed: Empty;
    } | {
        oneofKind: "allowMissing";
        /**
         * The requirement is satisfied if JWT is missing, but failed if JWT is
         * presented but invalid. Similar to allow_missing_or_failed, this is used
         * to only verify JWTs and pass the verified payload to another filter. The
         * different is this mode will reject requests with invalid tokens.
         *
         * @generated from protobuf field: google.protobuf.Empty allow_missing = 6;
         */
        allowMissing: Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * This message specifies a list of RequiredProvider.
 * Their results are OR-ed; if any one of them passes, the result is passed
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList
 */
export interface JwtRequirementOrList {
    /**
     * Specify a list of JwtRequirement.
     *
     * @generated from protobuf field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;
     */
    requirements: JwtRequirement[];
}
/**
 * This message specifies a list of RequiredProvider.
 * Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList
 */
export interface JwtRequirementAndList {
    /**
     * Specify a list of JwtRequirement.
     *
     * @generated from protobuf field: repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;
     */
    requirements: JwtRequirement[];
}
/**
 * This message specifies a Jwt requirement for a specific Route condition.
 * Example 1:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /healthz
 *
 * In above example, "requires" field is empty for /healthz prefix match,
 * it means that requests matching the path prefix don't require JWT authentication.
 *
 * Example 2:
 *
 * .. code-block:: yaml
 *
 *    - match:
 *        prefix: /
 *      requires: { provider_name: provider-A }
 *
 * In above example, all requests matched the path prefix require jwt authentication
 * from "provider-A".
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule
 */
export interface RequirementRule {
    /**
     * The route matching parameter. Only when the match is satisfied, the "requires" field will
     * apply.
     *
     * For example: following match will match all requests.
     *
     * .. code-block:: yaml
     *
     *    match:
     *      prefix: /
     *
     *
     * @generated from protobuf field: envoy.api.v2.route.RouteMatch match = 1;
     */
    match?: RouteMatch;
    /**
     * Specify a Jwt Requirement. Please detail comment in message JwtRequirement.
     *
     * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requires = 2;
     */
    requires?: JwtRequirement;
}
/**
 * This message specifies Jwt requirements based on stream_info.filterState.
 * This FilterState should use `Router::StringAccessor` object to set a string value.
 * Other HTTP filters can use it to specify Jwt requirements dynamically.
 *
 * Example:
 *
 * .. code-block:: yaml
 *
 *    name: jwt_selector
 *    requires:
 *      issuer_1:
 *        provider_name: issuer1
 *      issuer_2:
 *        provider_name: issuer2
 *
 * If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
 * jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule
 */
export interface FilterStateRule {
    /**
     * The filter state name to retrieve the `Router::StringAccessor` object.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A map of string keys to requirements. The string key is the string value
     * in the FilterState with the name specified in the *name* field above.
     *
     * @generated from protobuf field: map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement> requires = 3;
     */
    requires: {
        [key: string]: JwtRequirement;
    };
}
/**
 * This is the Envoy HTTP filter config for JWT authentication.
 *
 * For example:
 *
 * .. code-block:: yaml
 *
 *   providers:
 *      provider1:
 *        issuer: issuer1
 *        audiences:
 *        - audience1
 *        - audience2
 *        remote_jwks:
 *          http_uri:
 *            uri: https://example.com/.well-known/jwks.json
 *            cluster: example_jwks_cluster
 *      provider2:
 *        issuer: issuer2
 *        local_jwks:
 *          inline_string: jwks_string
 *
 *   rules:
 *      # Not jwt verification is required for /health path
 *      - match:
 *          prefix: /health
 *
 *      # Jwt verification for provider1 is required for path prefixed with "prefix"
 *      - match:
 *          prefix: /prefix
 *        requires:
 *          provider_name: provider1
 *
 *      # Jwt verification for either provider1 or provider2 is required for all other requests.
 *      - match:
 *          prefix: /
 *        requires:
 *          requires_any:
 *            requirements:
 *              - provider_name: provider1
 *              - provider_name: provider2
 *
 *
 * @generated from protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication
 */
export interface JwtAuthentication {
    /**
     * Map of provider names to JwtProviders.
     *
     * .. code-block:: yaml
     *
     *   providers:
     *     provider1:
     *        issuer: issuer1
     *        audiences:
     *        - audience1
     *        - audience2
     *        remote_jwks:
     *          http_uri:
     *            uri: https://example.com/.well-known/jwks.json
     *            cluster: example_jwks_cluster
     *      provider2:
     *        issuer: provider2
     *        local_jwks:
     *          inline_string: jwks_string
     *
     *
     * @generated from protobuf field: map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider> providers = 1;
     */
    providers: {
        [key: string]: JwtProvider;
    };
    /**
     * Specifies requirements based on the route matches. The first matched requirement will be
     * applied. If there are overlapped match conditions, please put the most specific match first.
     *
     * Examples
     *
     * .. code-block:: yaml
     *
     *   rules:
     *     - match:
     *         prefix: /healthz
     *     - match:
     *         prefix: /baz
     *       requires:
     *         provider_name: provider1
     *     - match:
     *         prefix: /foo
     *       requires:
     *         requires_any:
     *           requirements:
     *             - provider_name: provider1
     *             - provider_name: provider2
     *     - match:
     *         prefix: /bar
     *       requires:
     *         requires_all:
     *           requirements:
     *             - provider_name: provider1
     *             - provider_name: provider2
     *
     *
     * @generated from protobuf field: repeated envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule rules = 2;
     */
    rules: RequirementRule[];
    /**
     * This message specifies Jwt requirements based on stream_info.filterState.
     * Other HTTP filters can use it to specify Jwt requirements dynamically.
     * The *rules* field above is checked first, if it could not find any matches,
     * check this one.
     *
     * @generated from protobuf field: envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule filter_state_rules = 3;
     */
    filterStateRules?: FilterStateRule;
    /**
     * When set to true, bypass the `CORS preflight request
     * <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
     * requirements specified in the rules.
     *
     * @generated from protobuf field: bool bypass_cors_preflight = 4;
     */
    bypassCorsPreflight: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class JwtProvider$Type extends MessageType<JwtProvider> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider", [
            { no: 1, name: "issuer", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "audiences", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "remote_jwks", kind: "message", oneof: "jwksSourceSpecifier", T: () => RemoteJwks },
            { no: 4, name: "local_jwks", kind: "message", oneof: "jwksSourceSpecifier", T: () => DataSource },
            { no: 5, name: "forward", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "from_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JwtHeader },
            { no: 7, name: "from_params", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "forward_payload_header", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "payload_in_metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JwtProvider>): JwtProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.issuer = "";
        message.audiences = [];
        message.jwksSourceSpecifier = { oneofKind: undefined };
        message.forward = false;
        message.fromHeaders = [];
        message.fromParams = [];
        message.forwardPayloadHeader = "";
        message.payloadInMetadata = "";
        if (value !== undefined)
            reflectionMergePartial<JwtProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtProvider): JwtProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string issuer */ 1:
                    message.issuer = reader.string();
                    break;
                case /* repeated string audiences */ 2:
                    message.audiences.push(reader.string());
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks remote_jwks */ 3:
                    message.jwksSourceSpecifier = {
                        oneofKind: "remoteJwks",
                        remoteJwks: RemoteJwks.internalBinaryRead(reader, reader.uint32(), options, (message.jwksSourceSpecifier as any).remoteJwks)
                    };
                    break;
                case /* envoy.api.v2.core.DataSource local_jwks */ 4:
                    message.jwksSourceSpecifier = {
                        oneofKind: "localJwks",
                        localJwks: DataSource.internalBinaryRead(reader, reader.uint32(), options, (message.jwksSourceSpecifier as any).localJwks)
                    };
                    break;
                case /* bool forward */ 5:
                    message.forward = reader.bool();
                    break;
                case /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader from_headers */ 6:
                    message.fromHeaders.push(JwtHeader.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string from_params */ 7:
                    message.fromParams.push(reader.string());
                    break;
                case /* string forward_payload_header */ 8:
                    message.forwardPayloadHeader = reader.string();
                    break;
                case /* string payload_in_metadata */ 9:
                    message.payloadInMetadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JwtProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string issuer = 1; */
        if (message.issuer !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.issuer);
        /* repeated string audiences = 2; */
        for (let i = 0; i < message.audiences.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.audiences[i]);
        /* envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks remote_jwks = 3; */
        if (message.jwksSourceSpecifier.oneofKind === "remoteJwks")
            RemoteJwks.internalBinaryWrite(message.jwksSourceSpecifier.remoteJwks, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource local_jwks = 4; */
        if (message.jwksSourceSpecifier.oneofKind === "localJwks")
            DataSource.internalBinaryWrite(message.jwksSourceSpecifier.localJwks, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool forward = 5; */
        if (message.forward !== false)
            writer.tag(5, WireType.Varint).bool(message.forward);
        /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader from_headers = 6; */
        for (let i = 0; i < message.fromHeaders.length; i++)
            JwtHeader.internalBinaryWrite(message.fromHeaders[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string from_params = 7; */
        for (let i = 0; i < message.fromParams.length; i++)
            writer.tag(7, WireType.LengthDelimited).string(message.fromParams[i]);
        /* string forward_payload_header = 8; */
        if (message.forwardPayloadHeader !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.forwardPayloadHeader);
        /* string payload_in_metadata = 9; */
        if (message.payloadInMetadata !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.payloadInMetadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider
 */
export const JwtProvider = new JwtProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteJwks$Type extends MessageType<RemoteJwks> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks", [
            { no: 1, name: "http_uri", kind: "message", T: () => HttpUri },
            { no: 2, name: "cache_duration", kind: "message", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<RemoteJwks>): RemoteJwks {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RemoteJwks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteJwks): RemoteJwks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.HttpUri http_uri */ 1:
                    message.httpUri = HttpUri.internalBinaryRead(reader, reader.uint32(), options, message.httpUri);
                    break;
                case /* google.protobuf.Duration cache_duration */ 2:
                    message.cacheDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.cacheDuration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteJwks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.HttpUri http_uri = 1; */
        if (message.httpUri)
            HttpUri.internalBinaryWrite(message.httpUri, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration cache_duration = 2; */
        if (message.cacheDuration)
            Duration.internalBinaryWrite(message.cacheDuration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks
 */
export const RemoteJwks = new RemoteJwks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JwtHeader$Type extends MessageType<JwtHeader> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "value_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<JwtHeader>): JwtHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.valuePrefix = "";
        if (value !== undefined)
            reflectionMergePartial<JwtHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtHeader): JwtHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value_prefix */ 2:
                    message.valuePrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JwtHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value_prefix = 2; */
        if (message.valuePrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.valuePrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader
 */
export const JwtHeader = new JwtHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProviderWithAudiences$Type extends MessageType<ProviderWithAudiences> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences", [
            { no: 1, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "audiences", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProviderWithAudiences>): ProviderWithAudiences {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerName = "";
        message.audiences = [];
        if (value !== undefined)
            reflectionMergePartial<ProviderWithAudiences>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProviderWithAudiences): ProviderWithAudiences {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_name */ 1:
                    message.providerName = reader.string();
                    break;
                case /* repeated string audiences */ 2:
                    message.audiences.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProviderWithAudiences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_name = 1; */
        if (message.providerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.providerName);
        /* repeated string audiences = 2; */
        for (let i = 0; i < message.audiences.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.audiences[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences
 */
export const ProviderWithAudiences = new ProviderWithAudiences$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JwtRequirement$Type extends MessageType<JwtRequirement> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement", [
            { no: 1, name: "provider_name", kind: "scalar", oneof: "requiresType", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider_and_audiences", kind: "message", oneof: "requiresType", T: () => ProviderWithAudiences },
            { no: 3, name: "requires_any", kind: "message", oneof: "requiresType", T: () => JwtRequirementOrList },
            { no: 4, name: "requires_all", kind: "message", oneof: "requiresType", T: () => JwtRequirementAndList },
            { no: 5, name: "allow_missing_or_failed", kind: "message", oneof: "requiresType", T: () => Empty },
            { no: 6, name: "allow_missing", kind: "message", oneof: "requiresType", T: () => Empty }
        ]);
    }
    create(value?: PartialMessage<JwtRequirement>): JwtRequirement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requiresType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<JwtRequirement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtRequirement): JwtRequirement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_name */ 1:
                    message.requiresType = {
                        oneofKind: "providerName",
                        providerName: reader.string()
                    };
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences provider_and_audiences */ 2:
                    message.requiresType = {
                        oneofKind: "providerAndAudiences",
                        providerAndAudiences: ProviderWithAudiences.internalBinaryRead(reader, reader.uint32(), options, (message.requiresType as any).providerAndAudiences)
                    };
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList requires_any */ 3:
                    message.requiresType = {
                        oneofKind: "requiresAny",
                        requiresAny: JwtRequirementOrList.internalBinaryRead(reader, reader.uint32(), options, (message.requiresType as any).requiresAny)
                    };
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList requires_all */ 4:
                    message.requiresType = {
                        oneofKind: "requiresAll",
                        requiresAll: JwtRequirementAndList.internalBinaryRead(reader, reader.uint32(), options, (message.requiresType as any).requiresAll)
                    };
                    break;
                case /* google.protobuf.Empty allow_missing_or_failed */ 5:
                    message.requiresType = {
                        oneofKind: "allowMissingOrFailed",
                        allowMissingOrFailed: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.requiresType as any).allowMissingOrFailed)
                    };
                    break;
                case /* google.protobuf.Empty allow_missing */ 6:
                    message.requiresType = {
                        oneofKind: "allowMissing",
                        allowMissing: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.requiresType as any).allowMissing)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JwtRequirement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_name = 1; */
        if (message.requiresType.oneofKind === "providerName")
            writer.tag(1, WireType.LengthDelimited).string(message.requiresType.providerName);
        /* envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences provider_and_audiences = 2; */
        if (message.requiresType.oneofKind === "providerAndAudiences")
            ProviderWithAudiences.internalBinaryWrite(message.requiresType.providerAndAudiences, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList requires_any = 3; */
        if (message.requiresType.oneofKind === "requiresAny")
            JwtRequirementOrList.internalBinaryWrite(message.requiresType.requiresAny, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList requires_all = 4; */
        if (message.requiresType.oneofKind === "requiresAll")
            JwtRequirementAndList.internalBinaryWrite(message.requiresType.requiresAll, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Empty allow_missing_or_failed = 5; */
        if (message.requiresType.oneofKind === "allowMissingOrFailed")
            Empty.internalBinaryWrite(message.requiresType.allowMissingOrFailed, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Empty allow_missing = 6; */
        if (message.requiresType.oneofKind === "allowMissing")
            Empty.internalBinaryWrite(message.requiresType.allowMissing, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement
 */
export const JwtRequirement = new JwtRequirement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JwtRequirementOrList$Type extends MessageType<JwtRequirementOrList> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList", [
            { no: 1, name: "requirements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JwtRequirement, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<JwtRequirementOrList>): JwtRequirementOrList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requirements = [];
        if (value !== undefined)
            reflectionMergePartial<JwtRequirementOrList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtRequirementOrList): JwtRequirementOrList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements */ 1:
                    message.requirements.push(JwtRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JwtRequirementOrList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1; */
        for (let i = 0; i < message.requirements.length; i++)
            JwtRequirement.internalBinaryWrite(message.requirements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList
 */
export const JwtRequirementOrList = new JwtRequirementOrList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JwtRequirementAndList$Type extends MessageType<JwtRequirementAndList> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList", [
            { no: 1, name: "requirements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => JwtRequirement, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<JwtRequirementAndList>): JwtRequirementAndList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requirements = [];
        if (value !== undefined)
            reflectionMergePartial<JwtRequirementAndList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtRequirementAndList): JwtRequirementAndList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements */ 1:
                    message.requirements.push(JwtRequirement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JwtRequirementAndList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1; */
        for (let i = 0; i < message.requirements.length; i++)
            JwtRequirement.internalBinaryWrite(message.requirements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList
 */
export const JwtRequirementAndList = new JwtRequirementAndList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequirementRule$Type extends MessageType<RequirementRule> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule", [
            { no: 1, name: "match", kind: "message", T: () => RouteMatch, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "requires", kind: "message", T: () => JwtRequirement }
        ]);
    }
    create(value?: PartialMessage<RequirementRule>): RequirementRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequirementRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequirementRule): RequirementRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.route.RouteMatch match */ 1:
                    message.match = RouteMatch.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requires */ 2:
                    message.requires = JwtRequirement.internalBinaryRead(reader, reader.uint32(), options, message.requires);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequirementRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.route.RouteMatch match = 1; */
        if (message.match)
            RouteMatch.internalBinaryWrite(message.match, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requires = 2; */
        if (message.requires)
            JwtRequirement.internalBinaryWrite(message.requires, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule
 */
export const RequirementRule = new RequirementRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterStateRule$Type extends MessageType<FilterStateRule> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 3, name: "requires", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => JwtRequirement } }
        ]);
    }
    create(value?: PartialMessage<FilterStateRule>): FilterStateRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.requires = {};
        if (value !== undefined)
            reflectionMergePartial<FilterStateRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterStateRule): FilterStateRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement> requires */ 3:
                    this.binaryReadMap3(message.requires, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: FilterStateRule["requires"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof FilterStateRule["requires"] | undefined, val: FilterStateRule["requires"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = JwtRequirement.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.requires");
            }
        }
        map[key ?? ""] = val ?? JwtRequirement.create();
    }
    internalBinaryWrite(message: FilterStateRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement> requires = 3; */
        for (let k of globalThis.Object.keys(message.requires)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            JwtRequirement.internalBinaryWrite(message.requires[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule
 */
export const FilterStateRule = new FilterStateRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JwtAuthentication$Type extends MessageType<JwtAuthentication> {
    constructor() {
        super("envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication", [
            { no: 1, name: "providers", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => JwtProvider } },
            { no: 2, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RequirementRule },
            { no: 3, name: "filter_state_rules", kind: "message", T: () => FilterStateRule },
            { no: 4, name: "bypass_cors_preflight", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<JwtAuthentication>): JwtAuthentication {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providers = {};
        message.rules = [];
        message.bypassCorsPreflight = false;
        if (value !== undefined)
            reflectionMergePartial<JwtAuthentication>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JwtAuthentication): JwtAuthentication {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider> providers */ 1:
                    this.binaryReadMap1(message.providers, reader, options);
                    break;
                case /* repeated envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule rules */ 2:
                    message.rules.push(RequirementRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule filter_state_rules */ 3:
                    message.filterStateRules = FilterStateRule.internalBinaryRead(reader, reader.uint32(), options, message.filterStateRules);
                    break;
                case /* bool bypass_cors_preflight */ 4:
                    message.bypassCorsPreflight = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: JwtAuthentication["providers"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof JwtAuthentication["providers"] | undefined, val: JwtAuthentication["providers"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = JwtProvider.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.providers");
            }
        }
        map[key ?? ""] = val ?? JwtProvider.create();
    }
    internalBinaryWrite(message: JwtAuthentication, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, envoy.config.filter.http.jwt_authn.v2alpha.JwtProvider> providers = 1; */
        for (let k of globalThis.Object.keys(message.providers)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            JwtProvider.internalBinaryWrite(message.providers[k], writer, options);
            writer.join().join();
        }
        /* repeated envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule rules = 2; */
        for (let i = 0; i < message.rules.length; i++)
            RequirementRule.internalBinaryWrite(message.rules[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule filter_state_rules = 3; */
        if (message.filterStateRules)
            FilterStateRule.internalBinaryWrite(message.filterStateRules, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool bypass_cors_preflight = 4; */
        if (message.bypassCorsPreflight !== false)
            writer.tag(4, WireType.Varint).bool(message.bypassCorsPreflight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication
 */
export const JwtAuthentication = new JwtAuthentication$Type();
