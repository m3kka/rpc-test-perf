// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/filter/http/router/v2/router.proto" (package "envoy.config.filter.http.router.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AccessLog } from "../../../accesslog/v2/accesslog";
import { BoolValue } from "../../../../../../google/protobuf/wrappers";
// [#protodoc-title: Router]
// Router :ref:`configuration overview <config_http_filters_router>`.
// [#extension: envoy.filters.http.router]

/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.filter.http.router.v2.Router
 */
export interface Router {
    /**
     * Whether the router generates dynamic cluster statistics. Defaults to
     * true. Can be disabled in high performance scenarios.
     *
     * @generated from protobuf field: google.protobuf.BoolValue dynamic_stats = 1;
     */
    dynamicStats?: BoolValue;
    /**
     * Whether to start a child span for egress routed calls. This can be
     * useful in scenarios where other filters (auth, ratelimit, etc.) make
     * outbound calls and have child spans rooted at the same ingress
     * parent. Defaults to false.
     *
     * @generated from protobuf field: bool start_child_span = 2;
     */
    startChildSpan: boolean;
    /**
     * Configuration for HTTP upstream logs emitted by the router. Upstream logs
     * are configured in the same way as access logs, but each log entry represents
     * an upstream request. Presuming retries are configured, multiple upstream
     * requests may be made for each downstream (inbound) request.
     *
     * @generated from protobuf field: repeated envoy.config.filter.accesslog.v2.AccessLog upstream_log = 3;
     */
    upstreamLog: AccessLog[];
    /**
     * Do not add any additional *x-envoy-* headers to requests or responses. This
     * only affects the :ref:`router filter generated *x-envoy-* headers
     * <config_http_filters_router_headers_set>`, other Envoy filters and the HTTP
     * connection manager may continue to set *x-envoy-* headers.
     *
     * @generated from protobuf field: bool suppress_envoy_headers = 4;
     */
    suppressEnvoyHeaders: boolean;
    /**
     * Specifies a list of HTTP headers to strictly validate. Envoy will reject a
     * request and respond with HTTP status 400 if the request contains an invalid
     * value for any of the headers listed in this field. Strict header checking
     * is only supported for the following headers:
     *
     * Value must be a ','-delimited list (i.e. no spaces) of supported retry
     * policy values:
     *
     * * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`
     * * :ref:`config_http_filters_router_x-envoy-retry-on`
     *
     * Value must be an integer:
     *
     * * :ref:`config_http_filters_router_x-envoy-max-retries`
     * * :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`
     * * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`
     *
     * @generated from protobuf field: repeated string strict_check_headers = 5;
     */
    strictCheckHeaders: string[];
    /**
     * If not set, ingress Envoy will ignore
     * :ref:`config_http_filters_router_x-envoy-expected-rq-timeout-ms` header, populated by egress
     * Envoy, when deriving timeout for upstream cluster.
     *
     * @generated from protobuf field: bool respect_expected_rq_timeout = 6;
     */
    respectExpectedRqTimeout: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class Router$Type extends MessageType<Router> {
    constructor() {
        super("envoy.config.filter.http.router.v2.Router", [
            { no: 1, name: "dynamic_stats", kind: "message", T: () => BoolValue },
            { no: 2, name: "start_child_span", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "upstream_log", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLog },
            { no: 4, name: "suppress_envoy_headers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "strict_check_headers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { in: ["x-envoy-upstream-rq-timeout-ms", "x-envoy-upstream-rq-per-try-timeout-ms", "x-envoy-max-retries", "x-envoy-retry-grpc-on", "x-envoy-retry-on"] } } } } } },
            { no: 6, name: "respect_expected_rq_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Router>): Router {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.startChildSpan = false;
        message.upstreamLog = [];
        message.suppressEnvoyHeaders = false;
        message.strictCheckHeaders = [];
        message.respectExpectedRqTimeout = false;
        if (value !== undefined)
            reflectionMergePartial<Router>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Router): Router {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue dynamic_stats */ 1:
                    message.dynamicStats = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.dynamicStats);
                    break;
                case /* bool start_child_span */ 2:
                    message.startChildSpan = reader.bool();
                    break;
                case /* repeated envoy.config.filter.accesslog.v2.AccessLog upstream_log */ 3:
                    message.upstreamLog.push(AccessLog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool suppress_envoy_headers */ 4:
                    message.suppressEnvoyHeaders = reader.bool();
                    break;
                case /* repeated string strict_check_headers */ 5:
                    message.strictCheckHeaders.push(reader.string());
                    break;
                case /* bool respect_expected_rq_timeout */ 6:
                    message.respectExpectedRqTimeout = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Router, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue dynamic_stats = 1; */
        if (message.dynamicStats)
            BoolValue.internalBinaryWrite(message.dynamicStats, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool start_child_span = 2; */
        if (message.startChildSpan !== false)
            writer.tag(2, WireType.Varint).bool(message.startChildSpan);
        /* repeated envoy.config.filter.accesslog.v2.AccessLog upstream_log = 3; */
        for (let i = 0; i < message.upstreamLog.length; i++)
            AccessLog.internalBinaryWrite(message.upstreamLog[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool suppress_envoy_headers = 4; */
        if (message.suppressEnvoyHeaders !== false)
            writer.tag(4, WireType.Varint).bool(message.suppressEnvoyHeaders);
        /* repeated string strict_check_headers = 5; */
        for (let i = 0; i < message.strictCheckHeaders.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.strictCheckHeaders[i]);
        /* bool respect_expected_rq_timeout = 6; */
        if (message.respectExpectedRqTimeout !== false)
            writer.tag(6, WireType.Varint).bool(message.respectExpectedRqTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.http.router.v2.Router
 */
export const Router = new Router$Type();
