// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/filter/accesslog/v2/accesslog.proto" (package "envoy.config.filter.accesslog.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeaderMatcher } from "../../../../api/v2/route/route_components";
import { FractionalPercent } from "../../../../type/percent";
import { RuntimeUInt32 } from "../../../../api/v2/core/base";
import { Any } from "../../../../../google/protobuf/any";
import { Struct } from "../../../../../google/protobuf/struct";
// [#protodoc-title: Common access log types]

/**
 * @generated from protobuf message envoy.config.filter.accesslog.v2.AccessLog
 */
export interface AccessLog {
    /**
     * The name of the access log implementation to instantiate. The name must
     * match a statically registered access log. Current built-in loggers include:
     *
     * #. "envoy.access_loggers.file"
     * #. "envoy.access_loggers.http_grpc"
     * #. "envoy.access_loggers.tcp_grpc"
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Filter which is used to determine if the access log needs to be written.
     *
     * @generated from protobuf field: envoy.config.filter.accesslog.v2.AccessLogFilter filter = 2;
     */
    filter?: AccessLogFilter;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 3 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 4;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.AccessLogFilter
 */
export interface AccessLogFilter {
    /**
     * @generated from protobuf oneof: filter_specifier
     */
    filterSpecifier: {
        oneofKind: "statusCodeFilter";
        /**
         * Status code filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.StatusCodeFilter status_code_filter = 1;
         */
        statusCodeFilter: StatusCodeFilter;
    } | {
        oneofKind: "durationFilter";
        /**
         * Duration filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.DurationFilter duration_filter = 2;
         */
        durationFilter: DurationFilter;
    } | {
        oneofKind: "notHealthCheckFilter";
        /**
         * Not health check filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.NotHealthCheckFilter not_health_check_filter = 3;
         */
        notHealthCheckFilter: NotHealthCheckFilter;
    } | {
        oneofKind: "traceableFilter";
        /**
         * Traceable filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.TraceableFilter traceable_filter = 4;
         */
        traceableFilter: TraceableFilter;
    } | {
        oneofKind: "runtimeFilter";
        /**
         * Runtime filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.RuntimeFilter runtime_filter = 5;
         */
        runtimeFilter: RuntimeFilter;
    } | {
        oneofKind: "andFilter";
        /**
         * And filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.AndFilter and_filter = 6;
         */
        andFilter: AndFilter;
    } | {
        oneofKind: "orFilter";
        /**
         * Or filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.OrFilter or_filter = 7;
         */
        orFilter: OrFilter;
    } | {
        oneofKind: "headerFilter";
        /**
         * Header filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.HeaderFilter header_filter = 8;
         */
        headerFilter: HeaderFilter;
    } | {
        oneofKind: "responseFlagFilter";
        /**
         * Response flag filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.ResponseFlagFilter response_flag_filter = 9;
         */
        responseFlagFilter: ResponseFlagFilter;
    } | {
        oneofKind: "grpcStatusFilter";
        /**
         * gRPC status filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.GrpcStatusFilter grpc_status_filter = 10;
         */
        grpcStatusFilter: GrpcStatusFilter;
    } | {
        oneofKind: "extensionFilter";
        /**
         * Extension filter.
         *
         * @generated from protobuf field: envoy.config.filter.accesslog.v2.ExtensionFilter extension_filter = 11;
         */
        extensionFilter: ExtensionFilter;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Filter on an integer comparison.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.ComparisonFilter
 */
export interface ComparisonFilter {
    /**
     * Comparison operator.
     *
     * @generated from protobuf field: envoy.config.filter.accesslog.v2.ComparisonFilter.Op op = 1;
     */
    op: ComparisonFilter_Op;
    /**
     * Value to compare against.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeUInt32 value = 2;
     */
    value?: RuntimeUInt32;
}
/**
 * @generated from protobuf enum envoy.config.filter.accesslog.v2.ComparisonFilter.Op
 */
export enum ComparisonFilter_Op {
    /**
     * =
     *
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * >=
     *
     * @generated from protobuf enum value: GE = 1;
     */
    GE = 1,
    /**
     * <=
     *
     * @generated from protobuf enum value: LE = 2;
     */
    LE = 2
}
/**
 * Filters on HTTP response/status code.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.StatusCodeFilter
 */
export interface StatusCodeFilter {
    /**
     * Comparison.
     *
     * @generated from protobuf field: envoy.config.filter.accesslog.v2.ComparisonFilter comparison = 1;
     */
    comparison?: ComparisonFilter;
}
/**
 * Filters on total request duration in milliseconds.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.DurationFilter
 */
export interface DurationFilter {
    /**
     * Comparison.
     *
     * @generated from protobuf field: envoy.config.filter.accesslog.v2.ComparisonFilter comparison = 1;
     */
    comparison?: ComparisonFilter;
}
/**
 * Filters for requests that are not health check requests. A health check
 * request is marked by the health check filter.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.NotHealthCheckFilter
 */
export interface NotHealthCheckFilter {
}
/**
 * Filters for requests that are traceable. See the tracing overview for more
 * information on how a request becomes traceable.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.TraceableFilter
 */
export interface TraceableFilter {
}
/**
 * Filters for random sampling of requests.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.RuntimeFilter
 */
export interface RuntimeFilter {
    /**
     * Runtime key to get an optional overridden numerator for use in the *percent_sampled* field.
     * If found in runtime, this value will replace the default numerator.
     *
     * @generated from protobuf field: string runtime_key = 1;
     */
    runtimeKey: string;
    /**
     * The default sampling percentage. If not specified, defaults to 0% with denominator of 100.
     *
     * @generated from protobuf field: envoy.type.FractionalPercent percent_sampled = 2;
     */
    percentSampled?: FractionalPercent;
    /**
     * By default, sampling pivots on the header
     * :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being present. If
     * :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` is present, the filter will
     * consistently sample across multiple hosts based on the runtime key value and the value
     * extracted from :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
     * missing, or *use_independent_randomness* is set to true, the filter will randomly sample based
     * on the runtime key value alone. *use_independent_randomness* can be used for logging kill
     * switches within complex nested :ref:`AndFilter
     * <envoy_api_msg_config.filter.accesslog.v2.AndFilter>` and :ref:`OrFilter
     * <envoy_api_msg_config.filter.accesslog.v2.OrFilter>` blocks that are easier to reason about
     * from a probability perspective (i.e., setting to true will cause the filter to behave like
     * an independent random variable when composed within logical operator filters).
     *
     * @generated from protobuf field: bool use_independent_randomness = 3;
     */
    useIndependentRandomness: boolean;
}
/**
 * Performs a logical “and” operation on the result of each filter in filters.
 * Filters are evaluated sequentially and if one of them returns false, the
 * filter returns false immediately.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.AndFilter
 */
export interface AndFilter {
    /**
     * @generated from protobuf field: repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters = 1;
     */
    filters: AccessLogFilter[];
}
/**
 * Performs a logical “or” operation on the result of each individual filter.
 * Filters are evaluated sequentially and if one of them returns true, the
 * filter returns true immediately.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.OrFilter
 */
export interface OrFilter {
    /**
     * @generated from protobuf field: repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters = 2;
     */
    filters: AccessLogFilter[];
}
/**
 * Filters requests based on the presence or value of a request header.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.HeaderFilter
 */
export interface HeaderFilter {
    /**
     * Only requests with a header which matches the specified HeaderMatcher will pass the filter
     * check.
     *
     * @generated from protobuf field: envoy.api.v2.route.HeaderMatcher header = 1;
     */
    header?: HeaderMatcher;
}
/**
 * Filters requests that received responses with an Envoy response flag set.
 * A list of the response flags can be found
 * in the access log formatter :ref:`documentation<config_access_log_format_response_flags>`.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.ResponseFlagFilter
 */
export interface ResponseFlagFilter {
    /**
     * Only responses with the any of the flags listed in this field will be logged.
     * This field is optional. If it is not specified, then any response flag will pass
     * the filter check.
     *
     * @generated from protobuf field: repeated string flags = 1;
     */
    flags: string[];
}
/**
 * Filters gRPC requests based on their response status. If a gRPC status is not provided, the
 * filter will infer the status from the HTTP status code.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.GrpcStatusFilter
 */
export interface GrpcStatusFilter {
    /**
     * Logs only responses that have any one of the gRPC statuses in this field.
     *
     * @generated from protobuf field: repeated envoy.config.filter.accesslog.v2.GrpcStatusFilter.Status statuses = 1;
     */
    statuses: GrpcStatusFilter_Status[];
    /**
     * If included and set to true, the filter will instead block all responses with a gRPC status or
     * inferred gRPC status enumerated in statuses, and allow all other responses.
     *
     * @generated from protobuf field: bool exclude = 2;
     */
    exclude: boolean;
}
/**
 * @generated from protobuf enum envoy.config.filter.accesslog.v2.GrpcStatusFilter.Status
 */
export enum GrpcStatusFilter_Status {
    /**
     * @generated from protobuf enum value: OK = 0;
     */
    OK = 0,
    /**
     * @generated from protobuf enum value: CANCELED = 1;
     */
    CANCELED = 1,
    /**
     * @generated from protobuf enum value: UNKNOWN = 2;
     */
    UNKNOWN = 2,
    /**
     * @generated from protobuf enum value: INVALID_ARGUMENT = 3;
     */
    INVALID_ARGUMENT = 3,
    /**
     * @generated from protobuf enum value: DEADLINE_EXCEEDED = 4;
     */
    DEADLINE_EXCEEDED = 4,
    /**
     * @generated from protobuf enum value: NOT_FOUND = 5;
     */
    NOT_FOUND = 5,
    /**
     * @generated from protobuf enum value: ALREADY_EXISTS = 6;
     */
    ALREADY_EXISTS = 6,
    /**
     * @generated from protobuf enum value: PERMISSION_DENIED = 7;
     */
    PERMISSION_DENIED = 7,
    /**
     * @generated from protobuf enum value: RESOURCE_EXHAUSTED = 8;
     */
    RESOURCE_EXHAUSTED = 8,
    /**
     * @generated from protobuf enum value: FAILED_PRECONDITION = 9;
     */
    FAILED_PRECONDITION = 9,
    /**
     * @generated from protobuf enum value: ABORTED = 10;
     */
    ABORTED = 10,
    /**
     * @generated from protobuf enum value: OUT_OF_RANGE = 11;
     */
    OUT_OF_RANGE = 11,
    /**
     * @generated from protobuf enum value: UNIMPLEMENTED = 12;
     */
    UNIMPLEMENTED = 12,
    /**
     * @generated from protobuf enum value: INTERNAL = 13;
     */
    INTERNAL = 13,
    /**
     * @generated from protobuf enum value: UNAVAILABLE = 14;
     */
    UNAVAILABLE = 14,
    /**
     * @generated from protobuf enum value: DATA_LOSS = 15;
     */
    DATA_LOSS = 15,
    /**
     * @generated from protobuf enum value: UNAUTHENTICATED = 16;
     */
    UNAUTHENTICATED = 16
}
/**
 * Extension filter is statically registered at runtime.
 *
 * @generated from protobuf message envoy.config.filter.accesslog.v2.ExtensionFilter
 */
export interface ExtensionFilter {
    /**
     * The name of the filter implementation to instantiate. The name must
     * match a statically registered filter.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class AccessLog$Type extends MessageType<AccessLog> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.AccessLog", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "filter", kind: "message", T: () => AccessLogFilter },
            { no: 3, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 4, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<AccessLog>): AccessLog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AccessLog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessLog): AccessLog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.config.filter.accesslog.v2.AccessLogFilter filter */ 2:
                    message.filter = AccessLogFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* google.protobuf.Struct config = 3 [deprecated = true];*/ 3:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 4:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessLog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.config.filter.accesslog.v2.AccessLogFilter filter = 2; */
        if (message.filter)
            AccessLogFilter.internalBinaryWrite(message.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct config = 3 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 4; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.AccessLog
 */
export const AccessLog = new AccessLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccessLogFilter$Type extends MessageType<AccessLogFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.AccessLogFilter", [
            { no: 1, name: "status_code_filter", kind: "message", oneof: "filterSpecifier", T: () => StatusCodeFilter },
            { no: 2, name: "duration_filter", kind: "message", oneof: "filterSpecifier", T: () => DurationFilter },
            { no: 3, name: "not_health_check_filter", kind: "message", oneof: "filterSpecifier", T: () => NotHealthCheckFilter },
            { no: 4, name: "traceable_filter", kind: "message", oneof: "filterSpecifier", T: () => TraceableFilter },
            { no: 5, name: "runtime_filter", kind: "message", oneof: "filterSpecifier", T: () => RuntimeFilter },
            { no: 6, name: "and_filter", kind: "message", oneof: "filterSpecifier", T: () => AndFilter },
            { no: 7, name: "or_filter", kind: "message", oneof: "filterSpecifier", T: () => OrFilter },
            { no: 8, name: "header_filter", kind: "message", oneof: "filterSpecifier", T: () => HeaderFilter },
            { no: 9, name: "response_flag_filter", kind: "message", oneof: "filterSpecifier", T: () => ResponseFlagFilter },
            { no: 10, name: "grpc_status_filter", kind: "message", oneof: "filterSpecifier", T: () => GrpcStatusFilter },
            { no: 11, name: "extension_filter", kind: "message", oneof: "filterSpecifier", T: () => ExtensionFilter }
        ]);
    }
    create(value?: PartialMessage<AccessLogFilter>): AccessLogFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filterSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AccessLogFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccessLogFilter): AccessLogFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.filter.accesslog.v2.StatusCodeFilter status_code_filter */ 1:
                    message.filterSpecifier = {
                        oneofKind: "statusCodeFilter",
                        statusCodeFilter: StatusCodeFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).statusCodeFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.DurationFilter duration_filter */ 2:
                    message.filterSpecifier = {
                        oneofKind: "durationFilter",
                        durationFilter: DurationFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).durationFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.NotHealthCheckFilter not_health_check_filter */ 3:
                    message.filterSpecifier = {
                        oneofKind: "notHealthCheckFilter",
                        notHealthCheckFilter: NotHealthCheckFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).notHealthCheckFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.TraceableFilter traceable_filter */ 4:
                    message.filterSpecifier = {
                        oneofKind: "traceableFilter",
                        traceableFilter: TraceableFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).traceableFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.RuntimeFilter runtime_filter */ 5:
                    message.filterSpecifier = {
                        oneofKind: "runtimeFilter",
                        runtimeFilter: RuntimeFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).runtimeFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.AndFilter and_filter */ 6:
                    message.filterSpecifier = {
                        oneofKind: "andFilter",
                        andFilter: AndFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).andFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.OrFilter or_filter */ 7:
                    message.filterSpecifier = {
                        oneofKind: "orFilter",
                        orFilter: OrFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).orFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.HeaderFilter header_filter */ 8:
                    message.filterSpecifier = {
                        oneofKind: "headerFilter",
                        headerFilter: HeaderFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).headerFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.ResponseFlagFilter response_flag_filter */ 9:
                    message.filterSpecifier = {
                        oneofKind: "responseFlagFilter",
                        responseFlagFilter: ResponseFlagFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).responseFlagFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.GrpcStatusFilter grpc_status_filter */ 10:
                    message.filterSpecifier = {
                        oneofKind: "grpcStatusFilter",
                        grpcStatusFilter: GrpcStatusFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).grpcStatusFilter)
                    };
                    break;
                case /* envoy.config.filter.accesslog.v2.ExtensionFilter extension_filter */ 11:
                    message.filterSpecifier = {
                        oneofKind: "extensionFilter",
                        extensionFilter: ExtensionFilter.internalBinaryRead(reader, reader.uint32(), options, (message.filterSpecifier as any).extensionFilter)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccessLogFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.filter.accesslog.v2.StatusCodeFilter status_code_filter = 1; */
        if (message.filterSpecifier.oneofKind === "statusCodeFilter")
            StatusCodeFilter.internalBinaryWrite(message.filterSpecifier.statusCodeFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.DurationFilter duration_filter = 2; */
        if (message.filterSpecifier.oneofKind === "durationFilter")
            DurationFilter.internalBinaryWrite(message.filterSpecifier.durationFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.NotHealthCheckFilter not_health_check_filter = 3; */
        if (message.filterSpecifier.oneofKind === "notHealthCheckFilter")
            NotHealthCheckFilter.internalBinaryWrite(message.filterSpecifier.notHealthCheckFilter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.TraceableFilter traceable_filter = 4; */
        if (message.filterSpecifier.oneofKind === "traceableFilter")
            TraceableFilter.internalBinaryWrite(message.filterSpecifier.traceableFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.RuntimeFilter runtime_filter = 5; */
        if (message.filterSpecifier.oneofKind === "runtimeFilter")
            RuntimeFilter.internalBinaryWrite(message.filterSpecifier.runtimeFilter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.AndFilter and_filter = 6; */
        if (message.filterSpecifier.oneofKind === "andFilter")
            AndFilter.internalBinaryWrite(message.filterSpecifier.andFilter, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.OrFilter or_filter = 7; */
        if (message.filterSpecifier.oneofKind === "orFilter")
            OrFilter.internalBinaryWrite(message.filterSpecifier.orFilter, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.HeaderFilter header_filter = 8; */
        if (message.filterSpecifier.oneofKind === "headerFilter")
            HeaderFilter.internalBinaryWrite(message.filterSpecifier.headerFilter, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.ResponseFlagFilter response_flag_filter = 9; */
        if (message.filterSpecifier.oneofKind === "responseFlagFilter")
            ResponseFlagFilter.internalBinaryWrite(message.filterSpecifier.responseFlagFilter, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.GrpcStatusFilter grpc_status_filter = 10; */
        if (message.filterSpecifier.oneofKind === "grpcStatusFilter")
            GrpcStatusFilter.internalBinaryWrite(message.filterSpecifier.grpcStatusFilter, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.filter.accesslog.v2.ExtensionFilter extension_filter = 11; */
        if (message.filterSpecifier.oneofKind === "extensionFilter")
            ExtensionFilter.internalBinaryWrite(message.filterSpecifier.extensionFilter, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.AccessLogFilter
 */
export const AccessLogFilter = new AccessLogFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComparisonFilter$Type extends MessageType<ComparisonFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.ComparisonFilter", [
            { no: 1, name: "op", kind: "enum", T: () => ["envoy.config.filter.accesslog.v2.ComparisonFilter.Op", ComparisonFilter_Op], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "value", kind: "message", T: () => RuntimeUInt32 }
        ]);
    }
    create(value?: PartialMessage<ComparisonFilter>): ComparisonFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.op = 0;
        if (value !== undefined)
            reflectionMergePartial<ComparisonFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComparisonFilter): ComparisonFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.filter.accesslog.v2.ComparisonFilter.Op op */ 1:
                    message.op = reader.int32();
                    break;
                case /* envoy.api.v2.core.RuntimeUInt32 value */ 2:
                    message.value = RuntimeUInt32.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComparisonFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.filter.accesslog.v2.ComparisonFilter.Op op = 1; */
        if (message.op !== 0)
            writer.tag(1, WireType.Varint).int32(message.op);
        /* envoy.api.v2.core.RuntimeUInt32 value = 2; */
        if (message.value)
            RuntimeUInt32.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.ComparisonFilter
 */
export const ComparisonFilter = new ComparisonFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusCodeFilter$Type extends MessageType<StatusCodeFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.StatusCodeFilter", [
            { no: 1, name: "comparison", kind: "message", T: () => ComparisonFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<StatusCodeFilter>): StatusCodeFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusCodeFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusCodeFilter): StatusCodeFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.filter.accesslog.v2.ComparisonFilter comparison */ 1:
                    message.comparison = ComparisonFilter.internalBinaryRead(reader, reader.uint32(), options, message.comparison);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusCodeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.filter.accesslog.v2.ComparisonFilter comparison = 1; */
        if (message.comparison)
            ComparisonFilter.internalBinaryWrite(message.comparison, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.StatusCodeFilter
 */
export const StatusCodeFilter = new StatusCodeFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DurationFilter$Type extends MessageType<DurationFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.DurationFilter", [
            { no: 1, name: "comparison", kind: "message", T: () => ComparisonFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<DurationFilter>): DurationFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DurationFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DurationFilter): DurationFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.filter.accesslog.v2.ComparisonFilter comparison */ 1:
                    message.comparison = ComparisonFilter.internalBinaryRead(reader, reader.uint32(), options, message.comparison);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DurationFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.filter.accesslog.v2.ComparisonFilter comparison = 1; */
        if (message.comparison)
            ComparisonFilter.internalBinaryWrite(message.comparison, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.DurationFilter
 */
export const DurationFilter = new DurationFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NotHealthCheckFilter$Type extends MessageType<NotHealthCheckFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.NotHealthCheckFilter", []);
    }
    create(value?: PartialMessage<NotHealthCheckFilter>): NotHealthCheckFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NotHealthCheckFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NotHealthCheckFilter): NotHealthCheckFilter {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NotHealthCheckFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.NotHealthCheckFilter
 */
export const NotHealthCheckFilter = new NotHealthCheckFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TraceableFilter$Type extends MessageType<TraceableFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.TraceableFilter", []);
    }
    create(value?: PartialMessage<TraceableFilter>): TraceableFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TraceableFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TraceableFilter): TraceableFilter {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TraceableFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.TraceableFilter
 */
export const TraceableFilter = new TraceableFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeFilter$Type extends MessageType<RuntimeFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.RuntimeFilter", [
            { no: 1, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "percent_sampled", kind: "message", T: () => FractionalPercent },
            { no: 3, name: "use_independent_randomness", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeFilter>): RuntimeFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        message.useIndependentRandomness = false;
        if (value !== undefined)
            reflectionMergePartial<RuntimeFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeFilter): RuntimeFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string runtime_key */ 1:
                    message.runtimeKey = reader.string();
                    break;
                case /* envoy.type.FractionalPercent percent_sampled */ 2:
                    message.percentSampled = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.percentSampled);
                    break;
                case /* bool use_independent_randomness */ 3:
                    message.useIndependentRandomness = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string runtime_key = 1; */
        if (message.runtimeKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.runtimeKey);
        /* envoy.type.FractionalPercent percent_sampled = 2; */
        if (message.percentSampled)
            FractionalPercent.internalBinaryWrite(message.percentSampled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool use_independent_randomness = 3; */
        if (message.useIndependentRandomness !== false)
            writer.tag(3, WireType.Varint).bool(message.useIndependentRandomness);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.RuntimeFilter
 */
export const RuntimeFilter = new RuntimeFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AndFilter$Type extends MessageType<AndFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.AndFilter", [
            { no: 1, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLogFilter, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<AndFilter>): AndFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<AndFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AndFilter): AndFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters */ 1:
                    message.filters.push(AccessLogFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AndFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters = 1; */
        for (let i = 0; i < message.filters.length; i++)
            AccessLogFilter.internalBinaryWrite(message.filters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.AndFilter
 */
export const AndFilter = new AndFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrFilter$Type extends MessageType<OrFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.OrFilter", [
            { no: 2, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccessLogFilter, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<OrFilter>): OrFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<OrFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrFilter): OrFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters */ 2:
                    message.filters.push(AccessLogFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.accesslog.v2.AccessLogFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            AccessLogFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.OrFilter
 */
export const OrFilter = new OrFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderFilter$Type extends MessageType<HeaderFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.HeaderFilter", [
            { no: 1, name: "header", kind: "message", T: () => HeaderMatcher, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<HeaderFilter>): HeaderFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeaderFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderFilter): HeaderFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.route.HeaderMatcher header */ 1:
                    message.header = HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.route.HeaderMatcher header = 1; */
        if (message.header)
            HeaderMatcher.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.HeaderFilter
 */
export const HeaderFilter = new HeaderFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlagFilter$Type extends MessageType<ResponseFlagFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.ResponseFlagFilter", [
            { no: 1, name: "flags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { in: ["LH", "UH", "UT", "LR", "UR", "UF", "UC", "UO", "NR", "DI", "FI", "RL", "UAEX", "RLSE", "DC", "URX", "SI", "IH", "DPE"] } } } } } }
        ]);
    }
    create(value?: PartialMessage<ResponseFlagFilter>): ResponseFlagFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.flags = [];
        if (value !== undefined)
            reflectionMergePartial<ResponseFlagFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFlagFilter): ResponseFlagFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string flags */ 1:
                    message.flags.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseFlagFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string flags = 1; */
        for (let i = 0; i < message.flags.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.flags[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.ResponseFlagFilter
 */
export const ResponseFlagFilter = new ResponseFlagFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrpcStatusFilter$Type extends MessageType<GrpcStatusFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.GrpcStatusFilter", [
            { no: 1, name: "statuses", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["envoy.config.filter.accesslog.v2.GrpcStatusFilter.Status", GrpcStatusFilter_Status], options: { "validate.rules": { repeated: { items: { enum: { definedOnly: true } } } } } },
            { no: 2, name: "exclude", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GrpcStatusFilter>): GrpcStatusFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        message.exclude = false;
        if (value !== undefined)
            reflectionMergePartial<GrpcStatusFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcStatusFilter): GrpcStatusFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.filter.accesslog.v2.GrpcStatusFilter.Status statuses */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.statuses.push(reader.int32());
                    else
                        message.statuses.push(reader.int32());
                    break;
                case /* bool exclude */ 2:
                    message.exclude = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrpcStatusFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.filter.accesslog.v2.GrpcStatusFilter.Status statuses = 1; */
        if (message.statuses.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.statuses.length; i++)
                writer.int32(message.statuses[i]);
            writer.join();
        }
        /* bool exclude = 2; */
        if (message.exclude !== false)
            writer.tag(2, WireType.Varint).bool(message.exclude);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.GrpcStatusFilter
 */
export const GrpcStatusFilter = new GrpcStatusFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionFilter$Type extends MessageType<ExtensionFilter> {
    constructor() {
        super("envoy.config.filter.accesslog.v2.ExtensionFilter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ExtensionFilter>): ExtensionFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ExtensionFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionFilter): ExtensionFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.filter.accesslog.v2.ExtensionFilter
 */
export const ExtensionFilter = new ExtensionFilter$Type();
