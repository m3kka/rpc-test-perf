// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/core/v3/base.proto" (package "envoy.config.core.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FractionalPercent } from "../../../type/v3/percent";
import { HttpUri } from "./http_uri";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { BackoffStrategy } from "./backoff";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { Percent } from "../../../type/v3/percent";
import { Any } from "../../../../google/protobuf/any";
import { Address } from "./address";
import { Struct } from "../../../../google/protobuf/struct";
import { SemanticVersion } from "../../../type/v3/semantic_version";
/**
 * Identifies location of where either Envoy runs or where upstream hosts run.
 *
 * @generated from protobuf message envoy.config.core.v3.Locality
 */
export interface Locality {
    /**
     * Region this :ref:`zone <envoy_v3_api_field_config.core.v3.Locality.zone>` belongs to.
     *
     * @generated from protobuf field: string region = 1;
     */
    region: string;
    /**
     * Defines the local service zone where Envoy is running. Though optional, it
     * should be set if discovery service routing is used and the discovery
     * service exposes :ref:`zone data <envoy_v3_api_field_config.endpoint.v3.LocalityLbEndpoints.locality>`,
     * either in this message or via :option:`--service-zone`. The meaning of zone
     * is context dependent, e.g. `Availability Zone (AZ)
     * <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
     * on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
     * GCP, etc.
     *
     * @generated from protobuf field: string zone = 2;
     */
    zone: string;
    /**
     * When used for locality of upstream hosts, this field further splits zone
     * into smaller chunks of sub-zones so they can be load balanced
     * independently.
     *
     * @generated from protobuf field: string sub_zone = 3;
     */
    subZone: string;
}
/**
 * BuildVersion combines SemVer version of extension with free-form build information
 * (i.e. 'alpha', 'private-build') as a set of strings.
 *
 * @generated from protobuf message envoy.config.core.v3.BuildVersion
 */
export interface BuildVersion {
    /**
     * SemVer version of extension.
     *
     * @generated from protobuf field: envoy.type.v3.SemanticVersion version = 1;
     */
    version?: SemanticVersion;
    /**
     * Free-form build information.
     * Envoy defines several well known keys in the source/common/version/version.h file
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 2;
     */
    metadata?: Struct;
}
/**
 * Version and identification for an Envoy extension.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.config.core.v3.Extension
 */
export interface Extension {
    /**
     * This is the name of the Envoy filter as specified in the Envoy
     * configuration, e.g. envoy.filters.http.router, com.acme.widget.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Category of the extension.
     * Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
     * for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
     * acme.com vendor.
     * [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
     *
     * @generated from protobuf field: string category = 2;
     */
    category: string;
    /**
     * [#not-implemented-hide:] Type descriptor of extension configuration proto.
     * [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
     * [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
     *
     * @deprecated
     * @generated from protobuf field: string type_descriptor = 3 [deprecated = true];
     */
    typeDescriptor: string;
    /**
     * The version is a property of the extension and maintained independently
     * of other extensions and the Envoy API.
     * This field is not set when extension did not provide version information.
     *
     * @generated from protobuf field: envoy.config.core.v3.BuildVersion version = 4;
     */
    version?: BuildVersion;
    /**
     * Indicates that the extension is present but was disabled via dynamic configuration.
     *
     * @generated from protobuf field: bool disabled = 5;
     */
    disabled: boolean;
    /**
     * Type URLs of extension configuration protos.
     *
     * @generated from protobuf field: repeated string type_urls = 6;
     */
    typeUrls: string[];
}
/**
 * Identifies a specific Envoy instance. The node identifier is presented to the
 * management server, which may use this identifier to distinguish per Envoy
 * configuration for serving.
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.config.core.v3.Node
 */
export interface Node {
    /**
     * An opaque node identifier for the Envoy node. This also provides the local
     * service node name. It should be set if any of the following features are
     * used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
     * <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-node`.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Defines the local service cluster name where Envoy is running. Though
     * optional, it should be set if any of the following features are used:
     * :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
     * verification
     * <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher>`,
     * :ref:`runtime override directory <envoy_v3_api_msg_config.bootstrap.v3.Runtime>`,
     * :ref:`user agent addition
     * <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent>`,
     * :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
     * :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-cluster`.
     *
     * @generated from protobuf field: string cluster = 2;
     */
    cluster: string;
    /**
     * Opaque metadata extending the node identifier. Envoy will pass this
     * directly to the management server.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 3;
     */
    metadata?: Struct;
    // Map from xDS resource type URL to dynamic context parameters. These may vary at runtime (unlike
    // other fields in this message). For example, the xDS client may have a shard identifier that
    // changes during the lifetime of the xDS client. In Envoy, this would be achieved by updating the
    // dynamic context on the Server::Instance's LocalInfo context provider. The shard ID dynamic
    // parameter then appears in this field during future discovery requests.
    // map<string, xds.core.v3.ContextParams> dynamic_parameters = 12;

    /**
     * Locality specifying where the Envoy instance is running.
     *
     * @generated from protobuf field: envoy.config.core.v3.Locality locality = 4;
     */
    locality?: Locality;
    /**
     * Free-form string that identifies the entity requesting config.
     * E.g. "envoy" or "grpc"
     *
     * @generated from protobuf field: string user_agent_name = 6;
     */
    userAgentName: string;
    /**
     * @generated from protobuf oneof: user_agent_version_type
     */
    userAgentVersionType: {
        oneofKind: "userAgentVersion";
        /**
         * Free-form string that identifies the version of the entity requesting config.
         * E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
         *
         * @generated from protobuf field: string user_agent_version = 7;
         */
        userAgentVersion: string;
    } | {
        oneofKind: "userAgentBuildVersion";
        /**
         * Structured version of the entity requesting config.
         *
         * @generated from protobuf field: envoy.config.core.v3.BuildVersion user_agent_build_version = 8;
         */
        userAgentBuildVersion: BuildVersion;
    } | {
        oneofKind: undefined;
    };
    /**
     * List of extensions and their versions supported by the node.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.Extension extensions = 9;
     */
    extensions: Extension[];
    /**
     * Client feature support list. These are well known features described
     * in the Envoy API repository for a given major version of an API. Client features
     * use reverse DNS naming scheme, for example ``com.acme.feature``.
     * See :ref:`the list of features <client_features>` that xDS client may
     * support.
     *
     * @generated from protobuf field: repeated string client_features = 10;
     */
    clientFeatures: string[];
    /**
     * Known listening ports on the node as a generic hint to the management server
     * for filtering :ref:`listeners <config_listeners>` to be returned. For example,
     * if there is a listener bound to port 80, the list can optionally contain the
     * SocketAddress ``(0.0.0.0,80)``. The field is optional and just a hint.
     *
     * @deprecated
     * @generated from protobuf field: repeated envoy.config.core.v3.Address listening_addresses = 11 [deprecated = true];
     */
    listeningAddresses: Address[];
}
/**
 * Metadata provides additional inputs to filters based on matched listeners,
 * filter chains, routes and endpoints. It is structured as a map, usually from
 * filter name (in reverse DNS format) to metadata specific to the filter. Metadata
 * key-values for a filter are merged as connection and request handling occurs,
 * with later values for the same key overriding earlier values.
 *
 * An example use of metadata is providing additional values to
 * http_connection_manager in the envoy.http_connection_manager.access_log
 * namespace.
 *
 * Another example use of metadata is to per service config info in cluster metadata, which may get
 * consumed by multiple filters.
 *
 * For load balancing, Metadata provides a means to subset cluster endpoints.
 * Endpoints have a Metadata object associated and routes contain a Metadata
 * object to match against. There are some well defined metadata used today for
 * this purpose:
 *
 * * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
 *   endpoint and is also used during header processing
 *   (x-envoy-upstream-canary) and for stats purposes.
 * [#next-major-version: move to type/metadata/v2]
 *
 * @generated from protobuf message envoy.config.core.v3.Metadata
 */
export interface Metadata {
    /**
     * Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
     * namespace is reserved for Envoy's built-in filters.
     * If both ``filter_metadata`` and
     * :ref:`typed_filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.typed_filter_metadata>`
     * fields are present in the metadata with same keys,
     * only ``typed_filter_metadata`` field will be parsed.
     *
     * @generated from protobuf field: map<string, google.protobuf.Struct> filter_metadata = 1;
     */
    filterMetadata: {
        [key: string]: Struct;
    };
    /**
     * Key is the reverse DNS filter name, e.g. com.acme.widget. The ``envoy.*``
     * namespace is reserved for Envoy's built-in filters.
     * The value is encoded as google.protobuf.Any.
     * If both :ref:`filter_metadata <envoy_v3_api_field_config.core.v3.Metadata.filter_metadata>`
     * and ``typed_filter_metadata`` fields are present in the metadata with same keys,
     * only ``typed_filter_metadata`` field will be parsed.
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_filter_metadata = 2;
     */
    typedFilterMetadata: {
        [key: string]: Any;
    };
}
/**
 * Runtime derived uint32 with a default when not specified.
 *
 * @generated from protobuf message envoy.config.core.v3.RuntimeUInt32
 */
export interface RuntimeUInt32 {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: uint32 default_value = 2;
     */
    defaultValue: number;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from protobuf field: string runtime_key = 3;
     */
    runtimeKey: string;
}
/**
 * Runtime derived percentage with a default when not specified.
 *
 * @generated from protobuf message envoy.config.core.v3.RuntimePercent
 */
export interface RuntimePercent {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: envoy.type.v3.Percent default_value = 1;
     */
    defaultValue?: Percent;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Runtime derived double with a default when not specified.
 *
 * @generated from protobuf message envoy.config.core.v3.RuntimeDouble
 */
export interface RuntimeDouble {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: double default_value = 1;
     */
    defaultValue: number;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Runtime derived bool with a default when not specified.
 *
 * @generated from protobuf message envoy.config.core.v3.RuntimeFeatureFlag
 */
export interface RuntimeFeatureFlag {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: google.protobuf.BoolValue default_value = 1;
     */
    defaultValue?: BoolValue;
    /**
     * Runtime key to get value for comparison. This value is used if defined. The boolean value must
     * be represented via its
     * `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Query parameter name/value pair.
 *
 * @generated from protobuf message envoy.config.core.v3.QueryParameter
 */
export interface QueryParameter {
    /**
     * The key of the query parameter. Case sensitive.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * The value of the query parameter.
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * Header name/value pair.
 *
 * @generated from protobuf message envoy.config.core.v3.HeaderValue
 */
export interface HeaderValue {
    /**
     * Header name.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * Header value.
     *
     * The same :ref:`format specifier <config_access_log_format>` as used for
     * :ref:`HTTP access logging <config_access_log>` applies here, however
     * unknown header values are replaced with the empty string instead of ``-``.
     * Header value is encoded as string. This does not work for non-utf8 characters.
     * Only one of ``value`` or ``raw_value`` can be set.
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
    /**
     * Header value is encoded as bytes which can support non-utf8 characters.
     * Only one of ``value`` or ``raw_value`` can be set.
     *
     * @generated from protobuf field: bytes raw_value = 3;
     */
    rawValue: Uint8Array;
}
/**
 * Header name/value pair plus option to control append behavior.
 *
 * @generated from protobuf message envoy.config.core.v3.HeaderValueOption
 */
export interface HeaderValueOption {
    /**
     * Header name/value pair that this option applies to.
     *
     * @generated from protobuf field: envoy.config.core.v3.HeaderValue header = 1;
     */
    header?: HeaderValue;
    /**
     * Should the value be appended? If true (default), the value is appended to
     * existing values. Otherwise it replaces any existing values.
     * This field is deprecated and please use
     * :ref:`append_action <envoy_v3_api_field_config.core.v3.HeaderValueOption.append_action>` as replacement.
     *
     * .. note::
     *   The :ref:`external authorization service <envoy_v3_api_msg_service.auth.v3.CheckResponse>` and
     *   :ref:`external processor service <envoy_v3_api_msg_service.ext_proc.v3.ProcessingResponse>` have
     *   default value (``false``) for this field.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.BoolValue append = 2 [deprecated = true];
     */
    append?: BoolValue;
    /**
     * Describes the action taken to append/overwrite the given value for an existing header
     * or to only add this header if it's absent.
     * Value defaults to :ref:`APPEND_IF_EXISTS_OR_ADD
     * <envoy_v3_api_enum_value_config.core.v3.HeaderValueOption.HeaderAppendAction.APPEND_IF_EXISTS_OR_ADD>`.
     *
     * @generated from protobuf field: envoy.config.core.v3.HeaderValueOption.HeaderAppendAction append_action = 3;
     */
    appendAction: HeaderValueOption_HeaderAppendAction;
    /**
     * Is the header value allowed to be empty? If false (default), custom headers with empty values are dropped,
     * otherwise they are added.
     *
     * @generated from protobuf field: bool keep_empty_value = 4;
     */
    keepEmptyValue: boolean;
}
/**
 * Describes the supported actions types for header append action.
 *
 * @generated from protobuf enum envoy.config.core.v3.HeaderValueOption.HeaderAppendAction
 */
export enum HeaderValueOption_HeaderAppendAction {
    /**
     * This action will append the specified value to the existing values if the header
     * already exists. If the header doesn't exist then this will add the header with
     * specified key and value.
     *
     * @generated from protobuf enum value: APPEND_IF_EXISTS_OR_ADD = 0;
     */
    APPEND_IF_EXISTS_OR_ADD = 0,
    /**
     * This action will add the header if it doesn't already exist. If the header
     * already exists then this will be a no-op.
     *
     * @generated from protobuf enum value: ADD_IF_ABSENT = 1;
     */
    ADD_IF_ABSENT = 1,
    /**
     * This action will overwrite the specified value by discarding any existing values if
     * the header already exists. If the header doesn't exist then this will add the header
     * with specified key and value.
     *
     * @generated from protobuf enum value: OVERWRITE_IF_EXISTS_OR_ADD = 2;
     */
    OVERWRITE_IF_EXISTS_OR_ADD = 2,
    /**
     * This action will overwrite the specified value by discarding any existing values if
     * the header already exists. If the header doesn't exist then this will be no-op.
     *
     * @generated from protobuf enum value: OVERWRITE_IF_EXISTS = 3;
     */
    OVERWRITE_IF_EXISTS = 3
}
/**
 * Wrapper for a set of headers.
 *
 * @generated from protobuf message envoy.config.core.v3.HeaderMap
 */
export interface HeaderMap {
    /**
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValue headers = 1;
     */
    headers: HeaderValue[];
}
/**
 * A directory that is watched for changes, e.g. by inotify on Linux. Move/rename
 * events inside this directory trigger the watch.
 *
 * @generated from protobuf message envoy.config.core.v3.WatchedDirectory
 */
export interface WatchedDirectory {
    /**
     * Directory path to watch.
     *
     * @generated from protobuf field: string path = 1;
     */
    path: string;
}
/**
 * Data source consisting of a file, an inline value, or an environment variable.
 *
 * @generated from protobuf message envoy.config.core.v3.DataSource
 */
export interface DataSource {
    /**
     * @generated from protobuf oneof: specifier
     */
    specifier: {
        oneofKind: "filename";
        /**
         * Local filesystem data source.
         *
         * @generated from protobuf field: string filename = 1;
         */
        filename: string;
    } | {
        oneofKind: "inlineBytes";
        /**
         * Bytes inlined in the configuration.
         *
         * @generated from protobuf field: bytes inline_bytes = 2;
         */
        inlineBytes: Uint8Array;
    } | {
        oneofKind: "inlineString";
        /**
         * String inlined in the configuration.
         *
         * @generated from protobuf field: string inline_string = 3;
         */
        inlineString: string;
    } | {
        oneofKind: "environmentVariable";
        /**
         * Environment variable data source.
         *
         * @generated from protobuf field: string environment_variable = 4;
         */
        environmentVariable: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The message specifies the retry policy of remote data source when fetching fails.
 *
 * @generated from protobuf message envoy.config.core.v3.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * Specifies parameters that control :ref:`retry backoff strategy <envoy_v3_api_msg_config.core.v3.BackoffStrategy>`.
     * This parameter is optional, in which case the default base interval is 1000 milliseconds. The
     * default maximum interval is 10 times the base interval.
     *
     * @generated from protobuf field: envoy.config.core.v3.BackoffStrategy retry_back_off = 1;
     */
    retryBackOff?: BackoffStrategy;
    /**
     * Specifies the allowed number of retries. This parameter is optional and
     * defaults to 1.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value num_retries = 2;
     */
    numRetries?: UInt32Value;
}
/**
 * The message specifies how to fetch data from remote and how to verify it.
 *
 * @generated from protobuf message envoy.config.core.v3.RemoteDataSource
 */
export interface RemoteDataSource {
    /**
     * The HTTP URI to fetch the remote data.
     *
     * @generated from protobuf field: envoy.config.core.v3.HttpUri http_uri = 1;
     */
    httpUri?: HttpUri;
    /**
     * SHA256 string for verifying data.
     *
     * @generated from protobuf field: string sha256 = 2;
     */
    sha256: string;
    /**
     * Retry policy for fetching remote data.
     *
     * @generated from protobuf field: envoy.config.core.v3.RetryPolicy retry_policy = 3;
     */
    retryPolicy?: RetryPolicy;
}
/**
 * Async data source which support async data fetch.
 *
 * @generated from protobuf message envoy.config.core.v3.AsyncDataSource
 */
export interface AsyncDataSource {
    /**
     * @generated from protobuf oneof: specifier
     */
    specifier: {
        oneofKind: "local";
        /**
         * Local async data source.
         *
         * @generated from protobuf field: envoy.config.core.v3.DataSource local = 1;
         */
        local: DataSource;
    } | {
        oneofKind: "remote";
        /**
         * Remote async data source.
         *
         * @generated from protobuf field: envoy.config.core.v3.RemoteDataSource remote = 2;
         */
        remote: RemoteDataSource;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Configuration for transport socket in :ref:`listeners <config_listeners>` and
 * :ref:`clusters <envoy_v3_api_msg_config.cluster.v3.Cluster>`. If the configuration is
 * empty, a default transport socket implementation and configuration will be
 * chosen based on the platform and existence of tls_context.
 *
 * @generated from protobuf message envoy.config.core.v3.TransportSocket
 */
export interface TransportSocket {
    /**
     * The name of the transport socket to instantiate. The name must match a supported transport
     * socket implementation.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
 * specified via a runtime key.
 *
 * .. note::
 *
 *   Parsing of the runtime key's data is implemented such that it may be represented as a
 *   :ref:`FractionalPercent <envoy_v3_api_msg_type.v3.FractionalPercent>` proto represented as JSON/YAML
 *   and may also be represented as an integer with the assumption that the value is an integral
 *   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
 *   as a ``FractionalPercent`` whose numerator is 42 and denominator is HUNDRED.
 *
 * @generated from protobuf message envoy.config.core.v3.RuntimeFractionalPercent
 */
export interface RuntimeFractionalPercent {
    /**
     * Default value if the runtime value's for the numerator/denominator keys are not available.
     *
     * @generated from protobuf field: envoy.type.v3.FractionalPercent default_value = 1;
     */
    defaultValue?: FractionalPercent;
    /**
     * Runtime key for a YAML representation of a FractionalPercent.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Identifies a specific ControlPlane instance that Envoy is connected to.
 *
 * @generated from protobuf message envoy.config.core.v3.ControlPlane
 */
export interface ControlPlane {
    /**
     * An opaque control plane identifier that uniquely identifies an instance
     * of control plane. This can be used to identify which control plane instance,
     * the Envoy is connected to.
     *
     * @generated from protobuf field: string identifier = 1;
     */
    identifier: string;
}
// [#protodoc-title: Common types]

/**
 * Envoy supports :ref:`upstream priority routing
 * <arch_overview_http_routing_priority>` both at the route and the virtual
 * cluster level. The current priority implementation uses different connection
 * pool and circuit breaking settings for each priority level. This means that
 * even for HTTP/2 requests, two physical connections will be used to an
 * upstream host. In the future Envoy will likely support true HTTP/2 priority
 * over a single upstream connection.
 *
 * @generated from protobuf enum envoy.config.core.v3.RoutingPriority
 */
export enum RoutingPriority {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * @generated from protobuf enum value: HIGH = 1;
     */
    HIGH = 1
}
/**
 * HTTP request method.
 *
 * @generated from protobuf enum envoy.config.core.v3.RequestMethod
 */
export enum RequestMethod {
    /**
     * @generated from protobuf enum value: METHOD_UNSPECIFIED = 0;
     */
    METHOD_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: GET = 1;
     */
    GET = 1,
    /**
     * @generated from protobuf enum value: HEAD = 2;
     */
    HEAD = 2,
    /**
     * @generated from protobuf enum value: POST = 3;
     */
    POST = 3,
    /**
     * @generated from protobuf enum value: PUT = 4;
     */
    PUT = 4,
    /**
     * @generated from protobuf enum value: DELETE = 5;
     */
    DELETE = 5,
    /**
     * @generated from protobuf enum value: CONNECT = 6;
     */
    CONNECT = 6,
    /**
     * @generated from protobuf enum value: OPTIONS = 7;
     */
    OPTIONS = 7,
    /**
     * @generated from protobuf enum value: TRACE = 8;
     */
    TRACE = 8,
    /**
     * @generated from protobuf enum value: PATCH = 9;
     */
    PATCH = 9
}
/**
 * Identifies the direction of the traffic relative to the local Envoy.
 *
 * @generated from protobuf enum envoy.config.core.v3.TrafficDirection
 */
export enum TrafficDirection {
    /**
     * Default option is unspecified.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * The transport is used for incoming traffic.
     *
     * @generated from protobuf enum value: INBOUND = 1;
     */
    INBOUND = 1,
    /**
     * The transport is used for outgoing traffic.
     *
     * @generated from protobuf enum value: OUTBOUND = 2;
     */
    OUTBOUND = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Locality$Type extends MessageType<Locality> {
    constructor() {
        super("envoy.config.core.v3.Locality", [
            { no: 1, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sub_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.Locality" } });
    }
    create(value?: PartialMessage<Locality>): Locality {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.zone = "";
        message.subZone = "";
        if (value !== undefined)
            reflectionMergePartial<Locality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Locality): Locality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string region */ 1:
                    message.region = reader.string();
                    break;
                case /* string zone */ 2:
                    message.zone = reader.string();
                    break;
                case /* string sub_zone */ 3:
                    message.subZone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Locality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string region = 1; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* string zone = 2; */
        if (message.zone !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.zone);
        /* string sub_zone = 3; */
        if (message.subZone !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subZone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.Locality
 */
export const Locality = new Locality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildVersion$Type extends MessageType<BuildVersion> {
    constructor() {
        super("envoy.config.core.v3.BuildVersion", [
            { no: 1, name: "version", kind: "message", T: () => SemanticVersion },
            { no: 2, name: "metadata", kind: "message", T: () => Struct }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.BuildVersion" } });
    }
    create(value?: PartialMessage<BuildVersion>): BuildVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BuildVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildVersion): BuildVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.SemanticVersion version */ 1:
                    message.version = SemanticVersion.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* google.protobuf.Struct metadata */ 2:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.SemanticVersion version = 1; */
        if (message.version)
            SemanticVersion.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 2; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.BuildVersion
 */
export const BuildVersion = new BuildVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Extension$Type extends MessageType<Extension> {
    constructor() {
        super("envoy.config.core.v3.Extension", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type_descriptor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 4, name: "version", kind: "message", T: () => BuildVersion },
            { no: 5, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "type_urls", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.Extension" } });
    }
    create(value?: PartialMessage<Extension>): Extension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.category = "";
        message.typeDescriptor = "";
        message.disabled = false;
        message.typeUrls = [];
        if (value !== undefined)
            reflectionMergePartial<Extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Extension): Extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string category */ 2:
                    message.category = reader.string();
                    break;
                case /* string type_descriptor = 3 [deprecated = true];*/ 3:
                    message.typeDescriptor = reader.string();
                    break;
                case /* envoy.config.core.v3.BuildVersion version */ 4:
                    message.version = BuildVersion.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool disabled */ 5:
                    message.disabled = reader.bool();
                    break;
                case /* repeated string type_urls */ 6:
                    message.typeUrls.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string category = 2; */
        if (message.category !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.category);
        /* string type_descriptor = 3 [deprecated = true]; */
        if (message.typeDescriptor !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.typeDescriptor);
        /* envoy.config.core.v3.BuildVersion version = 4; */
        if (message.version)
            BuildVersion.internalBinaryWrite(message.version, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool disabled = 5; */
        if (message.disabled !== false)
            writer.tag(5, WireType.Varint).bool(message.disabled);
        /* repeated string type_urls = 6; */
        for (let i = 0; i < message.typeUrls.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.typeUrls[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.Extension
 */
export const Extension = new Extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends MessageType<Node> {
    constructor() {
        super("envoy.config.core.v3.Node", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "message", T: () => Struct },
            { no: 4, name: "locality", kind: "message", T: () => Locality },
            { no: 6, name: "user_agent_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "user_agent_version", kind: "scalar", oneof: "userAgentVersionType", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "user_agent_build_version", kind: "message", oneof: "userAgentVersionType", T: () => BuildVersion },
            { no: 9, name: "extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Extension },
            { no: 10, name: "client_features", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "listening_addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Address, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.Node" } });
    }
    create(value?: PartialMessage<Node>): Node {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.cluster = "";
        message.userAgentName = "";
        message.userAgentVersionType = { oneofKind: undefined };
        message.extensions = [];
        message.clientFeatures = [];
        message.listeningAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string cluster */ 2:
                    message.cluster = reader.string();
                    break;
                case /* google.protobuf.Struct metadata */ 3:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.config.core.v3.Locality locality */ 4:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* string user_agent_name */ 6:
                    message.userAgentName = reader.string();
                    break;
                case /* string user_agent_version */ 7:
                    message.userAgentVersionType = {
                        oneofKind: "userAgentVersion",
                        userAgentVersion: reader.string()
                    };
                    break;
                case /* envoy.config.core.v3.BuildVersion user_agent_build_version */ 8:
                    message.userAgentVersionType = {
                        oneofKind: "userAgentBuildVersion",
                        userAgentBuildVersion: BuildVersion.internalBinaryRead(reader, reader.uint32(), options, (message.userAgentVersionType as any).userAgentBuildVersion)
                    };
                    break;
                case /* repeated envoy.config.core.v3.Extension extensions */ 9:
                    message.extensions.push(Extension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string client_features */ 10:
                    message.clientFeatures.push(reader.string());
                    break;
                case /* repeated envoy.config.core.v3.Address listening_addresses = 11 [deprecated = true];*/ 11:
                    message.listeningAddresses.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string cluster = 2; */
        if (message.cluster !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cluster);
        /* google.protobuf.Struct metadata = 3; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Locality locality = 4; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string user_agent_name = 6; */
        if (message.userAgentName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userAgentName);
        /* string user_agent_version = 7; */
        if (message.userAgentVersionType.oneofKind === "userAgentVersion")
            writer.tag(7, WireType.LengthDelimited).string(message.userAgentVersionType.userAgentVersion);
        /* envoy.config.core.v3.BuildVersion user_agent_build_version = 8; */
        if (message.userAgentVersionType.oneofKind === "userAgentBuildVersion")
            BuildVersion.internalBinaryWrite(message.userAgentVersionType.userAgentBuildVersion, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.Extension extensions = 9; */
        for (let i = 0; i < message.extensions.length; i++)
            Extension.internalBinaryWrite(message.extensions[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string client_features = 10; */
        for (let i = 0; i < message.clientFeatures.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.clientFeatures[i]);
        /* repeated envoy.config.core.v3.Address listening_addresses = 11 [deprecated = true]; */
        for (let i = 0; i < message.listeningAddresses.length; i++)
            Address.internalBinaryWrite(message.listeningAddresses[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.Node
 */
export const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("envoy.config.core.v3.Metadata", [
            { no: 1, name: "filter_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 2, name: "typed_filter_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.Metadata" } });
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filterMetadata = {};
        message.typedFilterMetadata = {};
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, google.protobuf.Struct> filter_metadata */ 1:
                    this.binaryReadMap1(message.filterMetadata, reader, options);
                    break;
                case /* map<string, google.protobuf.Any> typed_filter_metadata */ 2:
                    this.binaryReadMap2(message.typedFilterMetadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Metadata["filterMetadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["filterMetadata"] | undefined, val: Metadata["filterMetadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.core.v3.Metadata.filter_metadata");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    private binaryReadMap2(map: Metadata["typedFilterMetadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["typedFilterMetadata"] | undefined, val: Metadata["typedFilterMetadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.config.core.v3.Metadata.typed_filter_metadata");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, google.protobuf.Struct> filter_metadata = 1; */
        for (let k of globalThis.Object.keys(message.filterMetadata)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.filterMetadata[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.Any> typed_filter_metadata = 2; */
        for (let k of globalThis.Object.keys(message.typedFilterMetadata)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedFilterMetadata[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeUInt32$Type extends MessageType<RuntimeUInt32> {
    constructor() {
        super("envoy.config.core.v3.RuntimeUInt32", [
            { no: 2, name: "default_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RuntimeUInt32" } });
    }
    create(value?: PartialMessage<RuntimeUInt32>): RuntimeUInt32 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultValue = 0;
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeUInt32>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeUInt32): RuntimeUInt32 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 default_value */ 2:
                    message.defaultValue = reader.uint32();
                    break;
                case /* string runtime_key */ 3:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeUInt32, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 default_value = 2; */
        if (message.defaultValue !== 0)
            writer.tag(2, WireType.Varint).uint32(message.defaultValue);
        /* string runtime_key = 3; */
        if (message.runtimeKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RuntimeUInt32
 */
export const RuntimeUInt32 = new RuntimeUInt32$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimePercent$Type extends MessageType<RuntimePercent> {
    constructor() {
        super("envoy.config.core.v3.RuntimePercent", [
            { no: 1, name: "default_value", kind: "message", T: () => Percent },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RuntimePercent>): RuntimePercent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimePercent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimePercent): RuntimePercent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.Percent default_value */ 1:
                    message.defaultValue = Percent.internalBinaryRead(reader, reader.uint32(), options, message.defaultValue);
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimePercent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.Percent default_value = 1; */
        if (message.defaultValue)
            Percent.internalBinaryWrite(message.defaultValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RuntimePercent
 */
export const RuntimePercent = new RuntimePercent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeDouble$Type extends MessageType<RuntimeDouble> {
    constructor() {
        super("envoy.config.core.v3.RuntimeDouble", [
            { no: 1, name: "default_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RuntimeDouble" } });
    }
    create(value?: PartialMessage<RuntimeDouble>): RuntimeDouble {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultValue = 0;
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeDouble>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeDouble): RuntimeDouble {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double default_value */ 1:
                    message.defaultValue = reader.double();
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeDouble, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double default_value = 1; */
        if (message.defaultValue !== 0)
            writer.tag(1, WireType.Bit64).double(message.defaultValue);
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RuntimeDouble
 */
export const RuntimeDouble = new RuntimeDouble$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeFeatureFlag$Type extends MessageType<RuntimeFeatureFlag> {
    constructor() {
        super("envoy.config.core.v3.RuntimeFeatureFlag", [
            { no: 1, name: "default_value", kind: "message", T: () => BoolValue, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RuntimeFeatureFlag" } });
    }
    create(value?: PartialMessage<RuntimeFeatureFlag>): RuntimeFeatureFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeFeatureFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeFeatureFlag): RuntimeFeatureFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue default_value */ 1:
                    message.defaultValue = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.defaultValue);
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeFeatureFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue default_value = 1; */
        if (message.defaultValue)
            BoolValue.internalBinaryWrite(message.defaultValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RuntimeFeatureFlag
 */
export const RuntimeFeatureFlag = new RuntimeFeatureFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParameter$Type extends MessageType<QueryParameter> {
    constructor() {
        super("envoy.config.core.v3.QueryParameter", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QueryParameter>): QueryParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<QueryParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParameter): QueryParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.QueryParameter
 */
export const QueryParameter = new QueryParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderValue$Type extends MessageType<HeaderValue> {
    constructor() {
        super("envoy.config.core.v3.HeaderValue", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } }, "udpa.annotations.field_migrate": { oneofPromotion: "value_type" } } },
            { no: 3, name: "raw_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { minLen: "0", maxLen: "16384" } }, "udpa.annotations.field_migrate": { oneofPromotion: "value_type" } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HeaderValue" } });
    }
    create(value?: PartialMessage<HeaderValue>): HeaderValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        message.rawValue = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<HeaderValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderValue): HeaderValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* bytes raw_value */ 3:
                    message.rawValue = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* bytes raw_value = 3; */
        if (message.rawValue.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.rawValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HeaderValue
 */
export const HeaderValue = new HeaderValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderValueOption$Type extends MessageType<HeaderValueOption> {
    constructor() {
        super("envoy.config.core.v3.HeaderValueOption", [
            { no: 1, name: "header", kind: "message", T: () => HeaderValue, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "append", kind: "message", T: () => BoolValue, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 3, name: "append_action", kind: "enum", T: () => ["envoy.config.core.v3.HeaderValueOption.HeaderAppendAction", HeaderValueOption_HeaderAppendAction], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 4, name: "keep_empty_value", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HeaderValueOption" } });
    }
    create(value?: PartialMessage<HeaderValueOption>): HeaderValueOption {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appendAction = 0;
        message.keepEmptyValue = false;
        if (value !== undefined)
            reflectionMergePartial<HeaderValueOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderValueOption): HeaderValueOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HeaderValue header */ 1:
                    message.header = HeaderValue.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* google.protobuf.BoolValue append = 2 [deprecated = true];*/ 2:
                    message.append = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.append);
                    break;
                case /* envoy.config.core.v3.HeaderValueOption.HeaderAppendAction append_action */ 3:
                    message.appendAction = reader.int32();
                    break;
                case /* bool keep_empty_value */ 4:
                    message.keepEmptyValue = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderValueOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HeaderValue header = 1; */
        if (message.header)
            HeaderValue.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue append = 2 [deprecated = true]; */
        if (message.append)
            BoolValue.internalBinaryWrite(message.append, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HeaderValueOption.HeaderAppendAction append_action = 3; */
        if (message.appendAction !== 0)
            writer.tag(3, WireType.Varint).int32(message.appendAction);
        /* bool keep_empty_value = 4; */
        if (message.keepEmptyValue !== false)
            writer.tag(4, WireType.Varint).bool(message.keepEmptyValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HeaderValueOption
 */
export const HeaderValueOption = new HeaderValueOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMap$Type extends MessageType<HeaderMap> {
    constructor() {
        super("envoy.config.core.v3.HeaderMap", [
            { no: 1, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HeaderMap" } });
    }
    create(value?: PartialMessage<HeaderMap>): HeaderMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<HeaderMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMap): HeaderMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.core.v3.HeaderValue headers */ 1:
                    message.headers.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.core.v3.HeaderValue headers = 1; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderValue.internalBinaryWrite(message.headers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HeaderMap
 */
export const HeaderMap = new HeaderMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchedDirectory$Type extends MessageType<WatchedDirectory> {
    constructor() {
        super("envoy.config.core.v3.WatchedDirectory", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<WatchedDirectory>): WatchedDirectory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<WatchedDirectory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchedDirectory): WatchedDirectory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchedDirectory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.WatchedDirectory
 */
export const WatchedDirectory = new WatchedDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataSource$Type extends MessageType<DataSource> {
    constructor() {
        super("envoy.config.core.v3.DataSource", [
            { no: 1, name: "filename", kind: "scalar", oneof: "specifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "inline_bytes", kind: "scalar", oneof: "specifier", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "inline_string", kind: "scalar", oneof: "specifier", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "environment_variable", kind: "scalar", oneof: "specifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.DataSource" } });
    }
    create(value?: PartialMessage<DataSource>): DataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.specifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataSource): DataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string filename */ 1:
                    message.specifier = {
                        oneofKind: "filename",
                        filename: reader.string()
                    };
                    break;
                case /* bytes inline_bytes */ 2:
                    message.specifier = {
                        oneofKind: "inlineBytes",
                        inlineBytes: reader.bytes()
                    };
                    break;
                case /* string inline_string */ 3:
                    message.specifier = {
                        oneofKind: "inlineString",
                        inlineString: reader.string()
                    };
                    break;
                case /* string environment_variable */ 4:
                    message.specifier = {
                        oneofKind: "environmentVariable",
                        environmentVariable: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string filename = 1; */
        if (message.specifier.oneofKind === "filename")
            writer.tag(1, WireType.LengthDelimited).string(message.specifier.filename);
        /* bytes inline_bytes = 2; */
        if (message.specifier.oneofKind === "inlineBytes")
            writer.tag(2, WireType.LengthDelimited).bytes(message.specifier.inlineBytes);
        /* string inline_string = 3; */
        if (message.specifier.oneofKind === "inlineString")
            writer.tag(3, WireType.LengthDelimited).string(message.specifier.inlineString);
        /* string environment_variable = 4; */
        if (message.specifier.oneofKind === "environmentVariable")
            writer.tag(4, WireType.LengthDelimited).string(message.specifier.environmentVariable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.DataSource
 */
export const DataSource = new DataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("envoy.config.core.v3.RetryPolicy", [
            { no: 1, name: "retry_back_off", kind: "message", T: () => BackoffStrategy },
            { no: 2, name: "num_retries", kind: "message", T: () => UInt32Value, options: { "udpa.annotations.field_migrate": { rename: "max_retries" } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RetryPolicy" } });
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.BackoffStrategy retry_back_off */ 1:
                    message.retryBackOff = BackoffStrategy.internalBinaryRead(reader, reader.uint32(), options, message.retryBackOff);
                    break;
                case /* google.protobuf.UInt32Value num_retries */ 2:
                    message.numRetries = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.numRetries);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.BackoffStrategy retry_back_off = 1; */
        if (message.retryBackOff)
            BackoffStrategy.internalBinaryWrite(message.retryBackOff, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value num_retries = 2; */
        if (message.numRetries)
            UInt32Value.internalBinaryWrite(message.numRetries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataSource$Type extends MessageType<RemoteDataSource> {
    constructor() {
        super("envoy.config.core.v3.RemoteDataSource", [
            { no: 1, name: "http_uri", kind: "message", T: () => HttpUri, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "sha256", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "retry_policy", kind: "message", T: () => RetryPolicy }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RemoteDataSource" } });
    }
    create(value?: PartialMessage<RemoteDataSource>): RemoteDataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sha256 = "";
        if (value !== undefined)
            reflectionMergePartial<RemoteDataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteDataSource): RemoteDataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HttpUri http_uri */ 1:
                    message.httpUri = HttpUri.internalBinaryRead(reader, reader.uint32(), options, message.httpUri);
                    break;
                case /* string sha256 */ 2:
                    message.sha256 = reader.string();
                    break;
                case /* envoy.config.core.v3.RetryPolicy retry_policy */ 3:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteDataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HttpUri http_uri = 1; */
        if (message.httpUri)
            HttpUri.internalBinaryWrite(message.httpUri, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string sha256 = 2; */
        if (message.sha256 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sha256);
        /* envoy.config.core.v3.RetryPolicy retry_policy = 3; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RemoteDataSource
 */
export const RemoteDataSource = new RemoteDataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncDataSource$Type extends MessageType<AsyncDataSource> {
    constructor() {
        super("envoy.config.core.v3.AsyncDataSource", [
            { no: 1, name: "local", kind: "message", oneof: "specifier", T: () => DataSource },
            { no: 2, name: "remote", kind: "message", oneof: "specifier", T: () => RemoteDataSource }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.AsyncDataSource" } });
    }
    create(value?: PartialMessage<AsyncDataSource>): AsyncDataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.specifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AsyncDataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncDataSource): AsyncDataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.DataSource local */ 1:
                    message.specifier = {
                        oneofKind: "local",
                        local: DataSource.internalBinaryRead(reader, reader.uint32(), options, (message.specifier as any).local)
                    };
                    break;
                case /* envoy.config.core.v3.RemoteDataSource remote */ 2:
                    message.specifier = {
                        oneofKind: "remote",
                        remote: RemoteDataSource.internalBinaryRead(reader, reader.uint32(), options, (message.specifier as any).remote)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncDataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.DataSource local = 1; */
        if (message.specifier.oneofKind === "local")
            DataSource.internalBinaryWrite(message.specifier.local, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RemoteDataSource remote = 2; */
        if (message.specifier.oneofKind === "remote")
            RemoteDataSource.internalBinaryWrite(message.specifier.remote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.AsyncDataSource
 */
export const AsyncDataSource = new AsyncDataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransportSocket$Type extends MessageType<TransportSocket> {
    constructor() {
        super("envoy.config.core.v3.TransportSocket", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.TransportSocket" } });
    }
    create(value?: PartialMessage<TransportSocket>): TransportSocket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TransportSocket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransportSocket): TransportSocket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransportSocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.TransportSocket
 */
export const TransportSocket = new TransportSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeFractionalPercent$Type extends MessageType<RuntimeFractionalPercent> {
    constructor() {
        super("envoy.config.core.v3.RuntimeFractionalPercent", [
            { no: 1, name: "default_value", kind: "message", T: () => FractionalPercent, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.RuntimeFractionalPercent" } });
    }
    create(value?: PartialMessage<RuntimeFractionalPercent>): RuntimeFractionalPercent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeFractionalPercent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeFractionalPercent): RuntimeFractionalPercent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.v3.FractionalPercent default_value */ 1:
                    message.defaultValue = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.defaultValue);
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeFractionalPercent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.v3.FractionalPercent default_value = 1; */
        if (message.defaultValue)
            FractionalPercent.internalBinaryWrite(message.defaultValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.RuntimeFractionalPercent
 */
export const RuntimeFractionalPercent = new RuntimeFractionalPercent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlPlane$Type extends MessageType<ControlPlane> {
    constructor() {
        super("envoy.config.core.v3.ControlPlane", [
            { no: 1, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.ControlPlane" } });
    }
    create(value?: PartialMessage<ControlPlane>): ControlPlane {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.identifier = "";
        if (value !== undefined)
            reflectionMergePartial<ControlPlane>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControlPlane): ControlPlane {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string identifier */ 1:
                    message.identifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControlPlane, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string identifier = 1; */
        if (message.identifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.ControlPlane
 */
export const ControlPlane = new ControlPlane$Type();
