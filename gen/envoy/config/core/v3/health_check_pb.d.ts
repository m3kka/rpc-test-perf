// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/core/v3/health_check.proto (package envoy.config.core.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { TypedExtensionConfig } from "./extension_pb.js";
import type { EventServiceConfig } from "./event_service_config_pb.js";
import type { HeaderValueOption, RequestMethod } from "./base_pb.js";
import type { Int64Range } from "../../../type/v3/range_pb.js";
import type { CodecClientType } from "../../../type/v3/http_pb.js";
import type { StringMatcher } from "../../../type/matcher/v3/string_pb.js";

/**
 * Endpoint health status.
 *
 * @generated from enum envoy.config.core.v3.HealthStatus
 */
export declare enum HealthStatus {
  /**
   * The health status is not known. This is interpreted by Envoy as ``HEALTHY``.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Healthy.
   *
   * @generated from enum value: HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * Unhealthy.
   *
   * @generated from enum value: UNHEALTHY = 2;
   */
  UNHEALTHY = 2,

  /**
   * Connection draining in progress. E.g.,
   * `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
   * or
   * `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
   * This is interpreted by Envoy as ``UNHEALTHY``.
   *
   * @generated from enum value: DRAINING = 3;
   */
  DRAINING = 3,

  /**
   * Health check timed out. This is part of HDS and is interpreted by Envoy as
   * ``UNHEALTHY``.
   *
   * @generated from enum value: TIMEOUT = 4;
   */
  TIMEOUT = 4,

  /**
   * Degraded.
   *
   * @generated from enum value: DEGRADED = 5;
   */
  DEGRADED = 5,
}

/**
 * @generated from message envoy.config.core.v3.HealthStatusSet
 */
export declare class HealthStatusSet extends Message<HealthStatusSet> {
  /**
   * An order-independent set of health status.
   *
   * @generated from field: repeated envoy.config.core.v3.HealthStatus statuses = 1;
   */
  statuses: HealthStatus[];

  constructor(data?: PartialMessage<HealthStatusSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthStatusSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthStatusSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthStatusSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthStatusSet;

  static equals(a: HealthStatusSet | PlainMessage<HealthStatusSet> | undefined, b: HealthStatusSet | PlainMessage<HealthStatusSet> | undefined): boolean;
}

/**
 * [#next-free-field: 26]
 *
 * @generated from message envoy.config.core.v3.HealthCheck
 */
export declare class HealthCheck extends Message<HealthCheck> {
  /**
   * The time to wait for a health check response. If the timeout is reached the
   * health check attempt will be considered a failure.
   *
   * @generated from field: google.protobuf.Duration timeout = 1;
   */
  timeout?: Duration;

  /**
   * The interval between health checks.
   *
   * @generated from field: google.protobuf.Duration interval = 2;
   */
  interval?: Duration;

  /**
   * An optional jitter amount in milliseconds. If specified, Envoy will start health
   * checking after for a random time in ms between 0 and initial_jitter. This only
   * applies to the first health check.
   *
   * @generated from field: google.protobuf.Duration initial_jitter = 20;
   */
  initialJitter?: Duration;

  /**
   * An optional jitter amount in milliseconds. If specified, during every
   * interval Envoy will add interval_jitter to the wait time.
   *
   * @generated from field: google.protobuf.Duration interval_jitter = 3;
   */
  intervalJitter?: Duration;

  /**
   * An optional jitter amount as a percentage of interval_ms. If specified,
   * during every interval Envoy will add ``interval_ms`` *
   * ``interval_jitter_percent`` / 100 to the wait time.
   *
   * If interval_jitter_ms and interval_jitter_percent are both set, both of
   * them will be used to increase the wait time.
   *
   * @generated from field: uint32 interval_jitter_percent = 18;
   */
  intervalJitterPercent: number;

  /**
   * The number of unhealthy health checks required before a host is marked
   * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
   * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
   * or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
   * this threshold is ignored and the host is considered immediately unhealthy.
   *
   * @generated from field: google.protobuf.UInt32Value unhealthy_threshold = 4;
   */
  unhealthyThreshold?: number;

  /**
   * The number of healthy health checks required before a host is marked
   * healthy. Note that during startup, only a single successful health check is
   * required to mark a host healthy.
   *
   * @generated from field: google.protobuf.UInt32Value healthy_threshold = 5;
   */
  healthyThreshold?: number;

  /**
   * [#not-implemented-hide:] Non-serving port for health checking.
   *
   * @generated from field: google.protobuf.UInt32Value alt_port = 6;
   */
  altPort?: number;

  /**
   * Reuse health check connection between health checks. Default is true.
   *
   * @generated from field: google.protobuf.BoolValue reuse_connection = 7;
   */
  reuseConnection?: boolean;

  /**
   * @generated from oneof envoy.config.core.v3.HealthCheck.health_checker
   */
  healthChecker: {
    /**
     * HTTP health check.
     *
     * @generated from field: envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;
     */
    value: HealthCheck_HttpHealthCheck;
    case: "httpHealthCheck";
  } | {
    /**
     * TCP health check.
     *
     * @generated from field: envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;
     */
    value: HealthCheck_TcpHealthCheck;
    case: "tcpHealthCheck";
  } | {
    /**
     * gRPC health check.
     *
     * @generated from field: envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;
     */
    value: HealthCheck_GrpcHealthCheck;
    case: "grpcHealthCheck";
  } | {
    /**
     * Custom health check.
     *
     * @generated from field: envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;
     */
    value: HealthCheck_CustomHealthCheck;
    case: "customHealthCheck";
  } | { case: undefined; value?: undefined };

  /**
   * The "no traffic interval" is a special health check interval that is used when a cluster has
   * never had traffic routed to it. This lower interval allows cluster information to be kept up to
   * date, without sending a potentially large amount of active health checking traffic for no
   * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined. Note that this interval takes precedence over
   * any other.
   *
   * The default value for "no traffic interval" is 60 seconds.
   *
   * @generated from field: google.protobuf.Duration no_traffic_interval = 12;
   */
  noTrafficInterval?: Duration;

  /**
   * The "no traffic healthy interval" is a special health check interval that
   * is used for hosts that are currently passing active health checking
   * (including new hosts) when the cluster has received no traffic.
   *
   * This is useful for when we want to send frequent health checks with
   * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
   * a host in the cluster is marked as healthy.
   *
   * Once a cluster has been used for traffic routing, Envoy will shift back to using the
   * standard health check interval that is defined.
   *
   * If no_traffic_healthy_interval is not set, it will default to the
   * no traffic interval and send that interval regardless of health state.
   *
   * @generated from field: google.protobuf.Duration no_traffic_healthy_interval = 24;
   */
  noTrafficHealthyInterval?: Duration;

  /**
   * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
   * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
   * standard health check interval that is defined.
   *
   * The default value for "unhealthy interval" is the same as "interval".
   *
   * @generated from field: google.protobuf.Duration unhealthy_interval = 14;
   */
  unhealthyInterval?: Duration;

  /**
   * The "unhealthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as unhealthy. For subsequent health checks
   * Envoy will shift back to using either "unhealthy interval" if present or the standard health
   * check interval that is defined.
   *
   * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
   *
   * @generated from field: google.protobuf.Duration unhealthy_edge_interval = 15;
   */
  unhealthyEdgeInterval?: Duration;

  /**
   * The "healthy edge interval" is a special health check interval that is used for the first
   * health check right after a host is marked as healthy. For subsequent health checks
   * Envoy will shift back to using the standard health check interval that is defined.
   *
   * The default value for "healthy edge interval" is the same as the default interval.
   *
   * @generated from field: google.protobuf.Duration healthy_edge_interval = 16;
   */
  healthyEdgeInterval?: Duration;

  /**
   * .. attention::
   * This field is deprecated in favor of the extension
   * :ref:`event_logger <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>` and
   * :ref:`event_log_path <envoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path>`
   * in the file sink extension.
   *
   * Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
   *
   * @generated from field: string event_log_path = 17 [deprecated = true];
   * @deprecated
   */
  eventLogPath: string;

  /**
   * A list of event log sinks to process the health check event.
   * [#extension-category: envoy.health_check.event_sinks]
   *
   * @generated from field: repeated envoy.config.core.v3.TypedExtensionConfig event_logger = 25;
   */
  eventLogger: TypedExtensionConfig[];

  /**
   * [#not-implemented-hide:]
   * The gRPC service for the health check event service.
   * If empty, health check events won't be sent to a remote endpoint.
   *
   * @generated from field: envoy.config.core.v3.EventServiceConfig event_service = 22;
   */
  eventService?: EventServiceConfig;

  /**
   * If set to true, health check failure events will always be logged. If set to false, only the
   * initial health check failure event will be logged.
   * The default value is false.
   *
   * @generated from field: bool always_log_health_check_failures = 19;
   */
  alwaysLogHealthCheckFailures: boolean;

  /**
   * This allows overriding the cluster TLS settings, just for health check connections.
   *
   * @generated from field: envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;
   */
  tlsOptions?: HealthCheck_TlsOptions;

  /**
   * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
   * :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
   * For example, the following match criteria
   *
   * .. code-block:: yaml
   *
   *  transport_socket_match_criteria:
   *    useMTLS: true
   *
   * Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`
   *
   * .. code-block:: yaml
   *
   *  transport_socket_matches:
   *  - name: "useMTLS"
   *    match:
   *      useMTLS: true
   *    transport_socket:
   *      name: envoy.transport_sockets.tls
   *      config: { ... } # tls socket configuration
   *
   * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
   * :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
   * This allows using different transport socket capabilities for health checking versus proxying to the
   * endpoint.
   *
   * If the key/values pairs specified do not match any
   * :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
   * the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
   * will be used for health check socket configuration.
   *
   * @generated from field: google.protobuf.Struct transport_socket_match_criteria = 23;
   */
  transportSocketMatchCriteria?: Struct;

  constructor(data?: PartialMessage<HealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck;

  static equals(a: HealthCheck | PlainMessage<HealthCheck> | undefined, b: HealthCheck | PlainMessage<HealthCheck> | undefined): boolean;
}

/**
 * Describes the encoding of the payload bytes in the payload.
 *
 * @generated from message envoy.config.core.v3.HealthCheck.Payload
 */
export declare class HealthCheck_Payload extends Message<HealthCheck_Payload> {
  /**
   * @generated from oneof envoy.config.core.v3.HealthCheck.Payload.payload
   */
  payload: {
    /**
     * Hex encoded payload. E.g., "000000FF".
     *
     * @generated from field: string text = 1;
     */
    value: string;
    case: "text";
  } | {
    /**
     * Binary payload.
     *
     * @generated from field: bytes binary = 2;
     */
    value: Uint8Array;
    case: "binary";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<HealthCheck_Payload>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.Payload";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_Payload;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_Payload;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_Payload;

  static equals(a: HealthCheck_Payload | PlainMessage<HealthCheck_Payload> | undefined, b: HealthCheck_Payload | PlainMessage<HealthCheck_Payload> | undefined): boolean;
}

/**
 * [#next-free-field: 15]
 *
 * @generated from message envoy.config.core.v3.HealthCheck.HttpHealthCheck
 */
export declare class HealthCheck_HttpHealthCheck extends Message<HealthCheck_HttpHealthCheck> {
  /**
   * The value of the host header in the HTTP health check request. If
   * left empty (default value), the name of the cluster this health check is associated
   * with will be used. The host header can be customized for a specific endpoint by setting the
   * :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * Specifies the HTTP path that will be requested during health checking. For example
   * ``/healthcheck``.
   *
   * @generated from field: string path = 2;
   */
  path: string;

  /**
   * [#not-implemented-hide:] HTTP specific payload.
   *
   * @generated from field: envoy.config.core.v3.HealthCheck.Payload send = 3;
   */
  send?: HealthCheck_Payload;

  /**
   * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
   * If it is set, both the expected response check and status code determine the health check.
   * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
   * and in the order specified, but not necessarily contiguous.
   *
   * .. note::
   *
   *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
   *   The default buffer size is 1024 bytes when it is not set.
   *
   * @generated from field: repeated envoy.config.core.v3.HealthCheck.Payload receive = 4;
   */
  receive: HealthCheck_Payload[];

  /**
   * Specifies the size of response buffer in bytes that is used to Payload match.
   * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
   *
   * @generated from field: google.protobuf.UInt64Value response_buffer_size = 14;
   */
  responseBufferSize?: bigint;

  /**
   * Specifies a list of HTTP headers that should be added to each request that is sent to the
   * health checked cluster. For more information, including details on header value syntax, see
   * the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6;
   */
  requestHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each request that is sent to the
   * health checked cluster.
   *
   * @generated from field: repeated string request_headers_to_remove = 8;
   */
  requestHeadersToRemove: string[];

  /**
   * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
   * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
   * semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
   * range are required. Only statuses in the range [100, 600) are allowed.
   *
   * @generated from field: repeated envoy.type.v3.Int64Range expected_statuses = 9;
   */
  expectedStatuses: Int64Range[];

  /**
   * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
   * will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
   * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
   * :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
   * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
   * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
   * be considered a successful health check. By default all responses not in
   * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
   * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
   * non-200 response will result in the host being marked unhealthy.
   *
   * @generated from field: repeated envoy.type.v3.Int64Range retriable_statuses = 12;
   */
  retriableStatuses: Int64Range[];

  /**
   * Use specified application protocol for health checks.
   *
   * @generated from field: envoy.type.v3.CodecClientType codec_client_type = 10;
   */
  codecClientType: CodecClientType;

  /**
   * An optional service name parameter which is used to validate the identity of
   * the health checked cluster using a :ref:`StringMatcher
   * <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
   * <arch_overview_health_checking_identity>` for more information.
   *
   * @generated from field: envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;
   */
  serviceNameMatcher?: StringMatcher;

  /**
   * HTTP Method that will be used for health checking, default is "GET".
   * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
   * CONNECT method is disallowed because it is not appropriate for health check request.
   * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
   *
   * @generated from field: envoy.config.core.v3.RequestMethod method = 13;
   */
  method: RequestMethod;

  constructor(data?: PartialMessage<HealthCheck_HttpHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.HttpHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_HttpHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_HttpHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_HttpHealthCheck;

  static equals(a: HealthCheck_HttpHealthCheck | PlainMessage<HealthCheck_HttpHealthCheck> | undefined, b: HealthCheck_HttpHealthCheck | PlainMessage<HealthCheck_HttpHealthCheck> | undefined): boolean;
}

/**
 * @generated from message envoy.config.core.v3.HealthCheck.TcpHealthCheck
 */
export declare class HealthCheck_TcpHealthCheck extends Message<HealthCheck_TcpHealthCheck> {
  /**
   * Empty payloads imply a connect-only health check.
   *
   * @generated from field: envoy.config.core.v3.HealthCheck.Payload send = 1;
   */
  send?: HealthCheck_Payload;

  /**
   * When checking the response, “fuzzy” matching is performed such that each
   * payload block must be found, and in the order specified, but not
   * necessarily contiguous.
   *
   * @generated from field: repeated envoy.config.core.v3.HealthCheck.Payload receive = 2;
   */
  receive: HealthCheck_Payload[];

  constructor(data?: PartialMessage<HealthCheck_TcpHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.TcpHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_TcpHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_TcpHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_TcpHealthCheck;

  static equals(a: HealthCheck_TcpHealthCheck | PlainMessage<HealthCheck_TcpHealthCheck> | undefined, b: HealthCheck_TcpHealthCheck | PlainMessage<HealthCheck_TcpHealthCheck> | undefined): boolean;
}

/**
 * @generated from message envoy.config.core.v3.HealthCheck.RedisHealthCheck
 */
export declare class HealthCheck_RedisHealthCheck extends Message<HealthCheck_RedisHealthCheck> {
  /**
   * If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
   * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
   * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
   * by setting the specified key to any value and waiting for traffic to drain.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  constructor(data?: PartialMessage<HealthCheck_RedisHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.RedisHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_RedisHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_RedisHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_RedisHealthCheck;

  static equals(a: HealthCheck_RedisHealthCheck | PlainMessage<HealthCheck_RedisHealthCheck> | undefined, b: HealthCheck_RedisHealthCheck | PlainMessage<HealthCheck_RedisHealthCheck> | undefined): boolean;
}

/**
 * `grpc.health.v1.Health
 * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
 * healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
 * for details.
 *
 * @generated from message envoy.config.core.v3.HealthCheck.GrpcHealthCheck
 */
export declare class HealthCheck_GrpcHealthCheck extends Message<HealthCheck_GrpcHealthCheck> {
  /**
   * An optional service name parameter which will be sent to gRPC service in
   * `grpc.health.v1.HealthCheckRequest
   * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
   * message. See `gRPC health-checking overview
   * <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
   *
   * @generated from field: string service_name = 1;
   */
  serviceName: string;

  /**
   * The value of the :authority header in the gRPC health check request. If
   * left empty (default value), the name of the cluster this health check is associated
   * with will be used. The authority header can be customized for a specific endpoint by setting
   * the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
   *
   * @generated from field: string authority = 2;
   */
  authority: string;

  /**
   * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
   * that is sent to the health checked cluster. For more information, including details on header value syntax,
   * see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.config.core.v3.HeaderValueOption initial_metadata = 3;
   */
  initialMetadata: HeaderValueOption[];

  constructor(data?: PartialMessage<HealthCheck_GrpcHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.GrpcHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_GrpcHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_GrpcHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_GrpcHealthCheck;

  static equals(a: HealthCheck_GrpcHealthCheck | PlainMessage<HealthCheck_GrpcHealthCheck> | undefined, b: HealthCheck_GrpcHealthCheck | PlainMessage<HealthCheck_GrpcHealthCheck> | undefined): boolean;
}

/**
 * Custom health check.
 *
 * @generated from message envoy.config.core.v3.HealthCheck.CustomHealthCheck
 */
export declare class HealthCheck_CustomHealthCheck extends Message<HealthCheck_CustomHealthCheck> {
  /**
   * The registered name of the custom health checker.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A custom health checker specific configuration which depends on the custom health checker
   * being instantiated. See :api:`envoy/config/health_checker` for reference.
   * [#extension-category: envoy.health_checkers]
   *
   * @generated from oneof envoy.config.core.v3.HealthCheck.CustomHealthCheck.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<HealthCheck_CustomHealthCheck>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.CustomHealthCheck";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_CustomHealthCheck;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_CustomHealthCheck;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_CustomHealthCheck;

  static equals(a: HealthCheck_CustomHealthCheck | PlainMessage<HealthCheck_CustomHealthCheck> | undefined, b: HealthCheck_CustomHealthCheck | PlainMessage<HealthCheck_CustomHealthCheck> | undefined): boolean;
}

/**
 * Health checks occur over the transport socket specified for the cluster. This implies that if a
 * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
 *
 * This allows overriding the cluster TLS settings, just for health check connections.
 *
 * @generated from message envoy.config.core.v3.HealthCheck.TlsOptions
 */
export declare class HealthCheck_TlsOptions extends Message<HealthCheck_TlsOptions> {
  /**
   * Specifies the ALPN protocols for health check connections. This is useful if the
   * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
   * <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
   * versus data connections. If empty, no ALPN protocols will be set on health check connections.
   *
   * @generated from field: repeated string alpn_protocols = 1;
   */
  alpnProtocols: string[];

  constructor(data?: PartialMessage<HealthCheck_TlsOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.HealthCheck.TlsOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthCheck_TlsOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthCheck_TlsOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthCheck_TlsOptions;

  static equals(a: HealthCheck_TlsOptions | PlainMessage<HealthCheck_TlsOptions> | undefined, b: HealthCheck_TlsOptions | PlainMessage<HealthCheck_TlsOptions> | undefined): boolean;
}

