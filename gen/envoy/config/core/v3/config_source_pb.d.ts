// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/core/v3/config_source.proto (package envoy.config.core.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { GrpcService } from "./grpc_service_pb.js";
import type { TypedExtensionConfig } from "./extension_pb.js";
import type { WatchedDirectory } from "./base_pb.js";
import type { Authority } from "../../../../xds/core/v3/authority_pb.js";

/**
 * xDS API and non-xDS services version. This is used to describe both resource and transport
 * protocol versions (in distinct configuration fields).
 *
 * @generated from enum envoy.config.core.v3.ApiVersion
 */
export declare enum ApiVersion {
  /**
   * When not specified, we assume v2, to ease migration to Envoy's stable API
   * versioning. If a client does not support v2 (e.g. due to deprecation), this
   * is an invalid value.
   *
   * @generated from enum value: AUTO = 0 [deprecated = true];
   * @deprecated
   */
  AUTO = 0,

  /**
   * Use xDS v2 API.
   *
   * @generated from enum value: V2 = 1 [deprecated = true];
   * @deprecated
   */
  V2 = 1,

  /**
   * Use xDS v3 API.
   *
   * @generated from enum value: V3 = 2;
   */
  V3 = 2,
}

/**
 * API configuration source. This identifies the API type and cluster that Envoy
 * will use to fetch an xDS API.
 * [#next-free-field: 10]
 *
 * @generated from message envoy.config.core.v3.ApiConfigSource
 */
export declare class ApiConfigSource extends Message<ApiConfigSource> {
  /**
   * API type (gRPC, REST, delta gRPC)
   *
   * @generated from field: envoy.config.core.v3.ApiConfigSource.ApiType api_type = 1;
   */
  apiType: ApiConfigSource_ApiType;

  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   *
   * @generated from field: envoy.config.core.v3.ApiVersion transport_api_version = 8;
   */
  transportApiVersion: ApiVersion;

  /**
   * Cluster names should be used only with REST. If > 1
   * cluster is defined, clusters will be cycled through if any kind of failure
   * occurs.
   *
   * .. note::
   *
   *  The cluster with name ``cluster_name`` must be statically defined and its
   *  type must not be ``EDS``.
   *
   * @generated from field: repeated string cluster_names = 2;
   */
  clusterNames: string[];

  /**
   * Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
   * services will be cycled through if any kind of failure occurs.
   *
   * @generated from field: repeated envoy.config.core.v3.GrpcService grpc_services = 4;
   */
  grpcServices: GrpcService[];

  /**
   * For REST APIs, the delay between successive polls.
   *
   * @generated from field: google.protobuf.Duration refresh_delay = 3;
   */
  refreshDelay?: Duration;

  /**
   * For REST APIs, the request timeout. If not set, a default value of 1s will be used.
   *
   * @generated from field: google.protobuf.Duration request_timeout = 5;
   */
  requestTimeout?: Duration;

  /**
   * For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
   * rate limited.
   *
   * @generated from field: envoy.config.core.v3.RateLimitSettings rate_limit_settings = 6;
   */
  rateLimitSettings?: RateLimitSettings;

  /**
   * Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
   *
   * @generated from field: bool set_node_on_first_message_only = 7;
   */
  setNodeOnFirstMessageOnly: boolean;

  /**
   * A list of config validators that will be executed when a new update is
   * received from the ApiConfigSource. Note that each validator handles a
   * specific xDS service type, and only the validators corresponding to the
   * type url (in ``:ref: DiscoveryResponse`` or ``:ref: DeltaDiscoveryResponse``)
   * will be invoked.
   * If the validator returns false or throws an exception, the config will be rejected by
   * the client, and a NACK will be sent.
   * [#extension-category: envoy.config.validators]
   *
   * @generated from field: repeated envoy.config.core.v3.TypedExtensionConfig config_validators = 9;
   */
  configValidators: TypedExtensionConfig[];

  constructor(data?: PartialMessage<ApiConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.ApiConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApiConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApiConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApiConfigSource;

  static equals(a: ApiConfigSource | PlainMessage<ApiConfigSource> | undefined, b: ApiConfigSource | PlainMessage<ApiConfigSource> | undefined): boolean;
}

/**
 * APIs may be fetched via either REST or gRPC.
 *
 * @generated from enum envoy.config.core.v3.ApiConfigSource.ApiType
 */
export declare enum ApiConfigSource_ApiType {
  /**
   * Ideally this would be 'reserved 0' but one can't reserve the default
   * value. Instead we throw an exception if this is ever used.
   *
   * @generated from enum value: DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0 [deprecated = true];
   * @deprecated
   */
  DEPRECATED_AND_UNAVAILABLE_DO_NOT_USE = 0,

  /**
   * REST-JSON v2 API. The `canonical JSON encoding
   * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
   * the v2 protos is used.
   *
   * @generated from enum value: REST = 1;
   */
  REST = 1,

  /**
   * SotW gRPC service.
   *
   * @generated from enum value: GRPC = 2;
   */
  GRPC = 2,

  /**
   * Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
   * rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
   * with every update, the xDS server only sends what has changed since the last update.
   *
   * @generated from enum value: DELTA_GRPC = 3;
   */
  DELTA_GRPC = 3,

  /**
   * SotW xDS gRPC with ADS. All resources which resolve to this configuration source will be
   * multiplexed on a single connection to an ADS endpoint.
   * [#not-implemented-hide:]
   *
   * @generated from enum value: AGGREGATED_GRPC = 5;
   */
  AGGREGATED_GRPC = 5,

  /**
   * Delta xDS gRPC with ADS. All resources which resolve to this configuration source will be
   * multiplexed on a single connection to an ADS endpoint.
   * [#not-implemented-hide:]
   *
   * @generated from enum value: AGGREGATED_DELTA_GRPC = 6;
   */
  AGGREGATED_DELTA_GRPC = 6,
}

/**
 * Aggregated Discovery Service (ADS) options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that ADS is to be used.
 *
 * @generated from message envoy.config.core.v3.AggregatedConfigSource
 */
export declare class AggregatedConfigSource extends Message<AggregatedConfigSource> {
  constructor(data?: PartialMessage<AggregatedConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.AggregatedConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregatedConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregatedConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregatedConfigSource;

  static equals(a: AggregatedConfigSource | PlainMessage<AggregatedConfigSource> | undefined, b: AggregatedConfigSource | PlainMessage<AggregatedConfigSource> | undefined): boolean;
}

/**
 * [#not-implemented-hide:]
 * Self-referencing config source options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_v3_api_msg_config.core.v3.ConfigSource>` can be used to
 * specify that other data can be obtained from the same server.
 *
 * @generated from message envoy.config.core.v3.SelfConfigSource
 */
export declare class SelfConfigSource extends Message<SelfConfigSource> {
  /**
   * API version for xDS transport protocol. This describes the xDS gRPC/REST
   * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
   *
   * @generated from field: envoy.config.core.v3.ApiVersion transport_api_version = 1;
   */
  transportApiVersion: ApiVersion;

  constructor(data?: PartialMessage<SelfConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.SelfConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfConfigSource;

  static equals(a: SelfConfigSource | PlainMessage<SelfConfigSource> | undefined, b: SelfConfigSource | PlainMessage<SelfConfigSource> | undefined): boolean;
}

/**
 * Rate Limit settings to be applied for discovery requests made by Envoy.
 *
 * @generated from message envoy.config.core.v3.RateLimitSettings
 */
export declare class RateLimitSettings extends Message<RateLimitSettings> {
  /**
   * Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
   * default value of 100 will be used.
   *
   * @generated from field: google.protobuf.UInt32Value max_tokens = 1;
   */
  maxTokens?: number;

  /**
   * Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
   * per second will be used.
   *
   * @generated from field: google.protobuf.DoubleValue fill_rate = 2;
   */
  fillRate?: number;

  constructor(data?: PartialMessage<RateLimitSettings>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.RateLimitSettings";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitSettings;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitSettings;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitSettings;

  static equals(a: RateLimitSettings | PlainMessage<RateLimitSettings> | undefined, b: RateLimitSettings | PlainMessage<RateLimitSettings> | undefined): boolean;
}

/**
 * Local filesystem path configuration source.
 *
 * @generated from message envoy.config.core.v3.PathConfigSource
 */
export declare class PathConfigSource extends Message<PathConfigSource> {
  /**
   * Path on the filesystem to source and watch for configuration updates.
   * When sourcing configuration for a :ref:`secret <envoy_v3_api_msg_extensions.transport_sockets.tls.v3.Secret>`,
   * the certificate and key files are also watched for updates.
   *
   * .. note::
   *
   *  The path to the source must exist at config load time.
   *
   * .. note::
   *
   *   If ``watched_directory`` is *not* configured, Envoy will watch the file path for *moves*.
   *   This is because in general only moves are atomic. The same method of swapping files as is
   *   demonstrated in the :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be
   *   used here also. If ``watched_directory`` is configured, no watch will be placed directly on
   *   this path. Instead, the configured ``watched_directory`` will be used to trigger reloads of
   *   this path. This is required in certain deployment scenarios. See below for more information.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * If configured, this directory will be watched for *moves*. When an entry in this directory is
   * moved to, the ``path`` will be reloaded. This is required in certain deployment scenarios.
   *
   * Specifically, if trying to load an xDS resource using a
   * `Kubernetes ConfigMap <https://kubernetes.io/docs/concepts/configuration/configmap/>`_, the
   * following configuration might be used:
   * 1. Store xds.yaml inside a ConfigMap.
   * 2. Mount the ConfigMap to ``/config_map/xds``
   * 3. Configure path ``/config_map/xds/xds.yaml``
   * 4. Configure watched directory ``/config_map/xds``
   *
   * The above configuration will ensure that Envoy watches the owning directory for moves which is
   * required due to how Kubernetes manages ConfigMap symbolic links during atomic updates.
   *
   * @generated from field: envoy.config.core.v3.WatchedDirectory watched_directory = 2;
   */
  watchedDirectory?: WatchedDirectory;

  constructor(data?: PartialMessage<PathConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.PathConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PathConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PathConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PathConfigSource;

  static equals(a: PathConfigSource | PlainMessage<PathConfigSource> | undefined, b: PathConfigSource | PlainMessage<PathConfigSource> | undefined): boolean;
}

/**
 * Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
 * <config_cluster_manager>`, :ref:`routes
 * <envoy_v3_api_msg_config.route.v3.RouteConfiguration>`, :ref:`endpoints
 * <arch_overview_service_discovery>` etc. may either be sourced from the
 * filesystem or from an xDS API source. Filesystem configs are watched with
 * inotify for updates.
 * [#next-free-field: 9]
 *
 * @generated from message envoy.config.core.v3.ConfigSource
 */
export declare class ConfigSource extends Message<ConfigSource> {
  /**
   * Authorities that this config source may be used for. An authority specified in a xdstp:// URL
   * is resolved to a ``ConfigSource`` prior to configuration fetch. This field provides the
   * association between authority name and configuration source.
   * [#not-implemented-hide:]
   *
   * @generated from field: repeated xds.core.v3.Authority authorities = 7;
   */
  authorities: Authority[];

  /**
   * @generated from oneof envoy.config.core.v3.ConfigSource.config_source_specifier
   */
  configSourceSpecifier: {
    /**
     * Deprecated in favor of ``path_config_source``. Use that field instead.
     *
     * @generated from field: string path = 1 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "path";
  } | {
    /**
     * Local filesystem path configuration source.
     *
     * @generated from field: envoy.config.core.v3.PathConfigSource path_config_source = 8;
     */
    value: PathConfigSource;
    case: "pathConfigSource";
  } | {
    /**
     * API configuration source.
     *
     * @generated from field: envoy.config.core.v3.ApiConfigSource api_config_source = 2;
     */
    value: ApiConfigSource;
    case: "apiConfigSource";
  } | {
    /**
     * When set, ADS will be used to fetch resources. The ADS API configuration
     * source in the bootstrap configuration is used.
     *
     * @generated from field: envoy.config.core.v3.AggregatedConfigSource ads = 3;
     */
    value: AggregatedConfigSource;
    case: "ads";
  } | {
    /**
     * [#not-implemented-hide:]
     * When set, the client will access the resources from the same server it got the
     * ConfigSource from, although not necessarily from the same stream. This is similar to the
     * :ref:`ads<envoy_v3_api_field.ConfigSource.ads>` field, except that the client may use a
     * different stream to the same server. As a result, this field can be used for things
     * like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
     * LDS to RDS on the same server without requiring the management server to know its name
     * or required credentials.
     * [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
     * this field can implicitly mean to use the same stream in the case where the ConfigSource
     * is provided via ADS and the specified data can also be obtained via ADS.]
     *
     * @generated from field: envoy.config.core.v3.SelfConfigSource self = 5;
     */
    value: SelfConfigSource;
    case: "self";
  } | { case: undefined; value?: undefined };

  /**
   * When this timeout is specified, Envoy will wait no longer than the specified time for first
   * config response on this xDS subscription during the :ref:`initialization process
   * <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
   * initialization phase, even if the first config is not delivered yet. The timer is activated
   * when the xDS API subscription starts, and is disarmed on first config update or on error. 0
   * means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
   * timeout applies). The default is 15s.
   *
   * @generated from field: google.protobuf.Duration initial_fetch_timeout = 4;
   */
  initialFetchTimeout?: Duration;

  /**
   * API version for xDS resources. This implies the type URLs that the client
   * will request for resources and the resource type that the client will in
   * turn expect to be delivered.
   *
   * @generated from field: envoy.config.core.v3.ApiVersion resource_api_version = 6;
   */
  resourceApiVersion: ApiVersion;

  constructor(data?: PartialMessage<ConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.ConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigSource;

  static equals(a: ConfigSource | PlainMessage<ConfigSource> | undefined, b: ConfigSource | PlainMessage<ConfigSource> | undefined): boolean;
}

/**
 * Configuration source specifier for a late-bound extension configuration. The
 * parent resource is warmed until all the initial extension configurations are
 * received, unless the flag to apply the default configuration is set.
 * Subsequent extension updates are atomic on a per-worker basis. Once an
 * extension configuration is applied to a request or a connection, it remains
 * constant for the duration of processing. If the initial delivery of the
 * extension configuration fails, due to a timeout for example, the optional
 * default configuration is applied. Without a default configuration, the
 * extension is disabled, until an extension configuration is received. The
 * behavior of a disabled extension depends on the context. For example, a
 * filter chain with a disabled extension filter rejects all incoming streams.
 *
 * @generated from message envoy.config.core.v3.ExtensionConfigSource
 */
export declare class ExtensionConfigSource extends Message<ExtensionConfigSource> {
  /**
   * @generated from field: envoy.config.core.v3.ConfigSource config_source = 1;
   */
  configSource?: ConfigSource;

  /**
   * Optional default configuration to use as the initial configuration if
   * there is a failure to receive the initial extension configuration or if
   * ``apply_default_config_without_warming`` flag is set.
   *
   * @generated from field: google.protobuf.Any default_config = 2;
   */
  defaultConfig?: Any;

  /**
   * Use the default config as the initial configuration without warming and
   * waiting for the first discovery response. Requires the default configuration
   * to be supplied.
   *
   * @generated from field: bool apply_default_config_without_warming = 3;
   */
  applyDefaultConfigWithoutWarming: boolean;

  /**
   * A set of permitted extension type URLs. Extension configuration updates are rejected
   * if they do not match any type URL in the set.
   *
   * @generated from field: repeated string type_urls = 4;
   */
  typeUrls: string[];

  constructor(data?: PartialMessage<ExtensionConfigSource>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.ExtensionConfigSource";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensionConfigSource;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensionConfigSource;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensionConfigSource;

  static equals(a: ExtensionConfigSource | PlainMessage<ExtensionConfigSource> | undefined, b: ExtensionConfigSource | PlainMessage<ExtensionConfigSource> | undefined): boolean;
}

