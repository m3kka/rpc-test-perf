// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/config/core/v3/health_check.proto" (package "envoy.config.core.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../../google/protobuf/any";
import { RequestMethod } from "./base";
import { StringMatcher } from "../../../type/matcher/v3/string";
import { CodecClientType } from "../../../type/v3/http";
import { Int64Range } from "../../../type/v3/range";
import { HeaderValueOption } from "./base";
import { UInt64Value } from "../../../../google/protobuf/wrappers";
import { Struct } from "../../../../google/protobuf/struct";
import { EventServiceConfig } from "./event_service_config";
import { TypedExtensionConfig } from "./extension";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Duration } from "../../../../google/protobuf/duration";
/**
 * @generated from protobuf message envoy.config.core.v3.HealthStatusSet
 */
export interface HealthStatusSet {
    /**
     * An order-independent set of health status.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HealthStatus statuses = 1;
     */
    statuses: HealthStatus[];
}
/**
 * [#next-free-field: 26]
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck
 */
export interface HealthCheck {
    /**
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 1;
     */
    timeout?: Duration;
    /**
     * The interval between health checks.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 2;
     */
    interval?: Duration;
    /**
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     *
     * @generated from protobuf field: google.protobuf.Duration initial_jitter = 20;
     */
    initialJitter?: Duration;
    /**
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     *
     * @generated from protobuf field: google.protobuf.Duration interval_jitter = 3;
     */
    intervalJitter?: Duration;
    /**
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add ``interval_ms`` *
     * ``interval_jitter_percent`` / 100 to the wait time.
     *
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     *
     * @generated from protobuf field: uint32 interval_jitter_percent = 18;
     */
    intervalJitterPercent: number;
    /**
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for ``http`` health checking if a host responds with a code not in
     * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
     * or :ref:`retriable_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.retriable_statuses>`,
     * this threshold is ignored and the host is considered immediately unhealthy.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value unhealthy_threshold = 4;
     */
    unhealthyThreshold?: UInt32Value;
    /**
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value healthy_threshold = 5;
     */
    healthyThreshold?: UInt32Value;
    /**
     * [#not-implemented-hide:] Non-serving port for health checking.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value alt_port = 6;
     */
    altPort?: UInt32Value;
    /**
     * Reuse health check connection between health checks. Default is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue reuse_connection = 7;
     */
    reuseConnection?: BoolValue;
    /**
     * @generated from protobuf oneof: health_checker
     */
    healthChecker: {
        oneofKind: "httpHealthCheck";
        /**
         * HTTP health check.
         *
         * @generated from protobuf field: envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8;
         */
        httpHealthCheck: HealthCheck_HttpHealthCheck;
    } | {
        oneofKind: "tcpHealthCheck";
        /**
         * TCP health check.
         *
         * @generated from protobuf field: envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9;
         */
        tcpHealthCheck: HealthCheck_TcpHealthCheck;
    } | {
        oneofKind: "grpcHealthCheck";
        /**
         * gRPC health check.
         *
         * @generated from protobuf field: envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11;
         */
        grpcHealthCheck: HealthCheck_GrpcHealthCheck;
    } | {
        oneofKind: "customHealthCheck";
        /**
         * Custom health check.
         *
         * @generated from protobuf field: envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13;
         */
        customHealthCheck: HealthCheck_CustomHealthCheck;
    } | {
        oneofKind: undefined;
    };
    /**
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     *
     * The default value for "no traffic interval" is 60 seconds.
     *
     * @generated from protobuf field: google.protobuf.Duration no_traffic_interval = 12;
     */
    noTrafficInterval?: Duration;
    /**
     * The "no traffic healthy interval" is a special health check interval that
     * is used for hosts that are currently passing active health checking
     * (including new hosts) when the cluster has received no traffic.
     *
     * This is useful for when we want to send frequent health checks with
     * ``no_traffic_interval`` but then revert to lower frequency ``no_traffic_healthy_interval`` once
     * a host in the cluster is marked as healthy.
     *
     * Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined.
     *
     * If no_traffic_healthy_interval is not set, it will default to the
     * no traffic interval and send that interval regardless of health state.
     *
     * @generated from protobuf field: google.protobuf.Duration no_traffic_healthy_interval = 24;
     */
    noTrafficHealthyInterval?: Duration;
    /**
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     *
     * The default value for "unhealthy interval" is the same as "interval".
     *
     * @generated from protobuf field: google.protobuf.Duration unhealthy_interval = 14;
     */
    unhealthyInterval?: Duration;
    /**
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     *
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     *
     * @generated from protobuf field: google.protobuf.Duration unhealthy_edge_interval = 15;
     */
    unhealthyEdgeInterval?: Duration;
    /**
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     *
     * The default value for "healthy edge interval" is the same as the default interval.
     *
     * @generated from protobuf field: google.protobuf.Duration healthy_edge_interval = 16;
     */
    healthyEdgeInterval?: Duration;
    /**
     * .. attention::
     * This field is deprecated in favor of the extension
     * :ref:`event_logger <envoy_v3_api_field_config.core.v3.HealthCheck.event_logger>` and
     * :ref:`event_log_path <envoy_v3_api_field_extensions.health_check.event_sinks.file.v3.HealthCheckEventFileSink.event_log_path>`
     * in the file sink extension.
     *
     * Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
     *
     * @deprecated
     * @generated from protobuf field: string event_log_path = 17 [deprecated = true];
     */
    eventLogPath: string;
    /**
     * A list of event log sinks to process the health check event.
     * [#extension-category: envoy.health_check.event_sinks]
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.TypedExtensionConfig event_logger = 25;
     */
    eventLogger: TypedExtensionConfig[];
    /**
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     *
     * @generated from protobuf field: envoy.config.core.v3.EventServiceConfig event_service = 22;
     */
    eventService?: EventServiceConfig;
    /**
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     *
     * @generated from protobuf field: bool always_log_health_check_failures = 19;
     */
    alwaysLogHealthCheckFailures: boolean;
    /**
     * This allows overriding the cluster TLS settings, just for health check connections.
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21;
     */
    tlsOptions?: HealthCheck_TlsOptions;
    /**
     * Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's
     * :ref:`tranport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`.
     * For example, the following match criteria
     *
     * .. code-block:: yaml
     *
     *  transport_socket_match_criteria:
     *    useMTLS: true
     *
     * Will match the following :ref:`cluster socket match <envoy_v3_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>`
     *
     * .. code-block:: yaml
     *
     *  transport_socket_matches:
     *  - name: "useMTLS"
     *    match:
     *      useMTLS: true
     *    transport_socket:
     *      name: envoy.transport_sockets.tls
     *      config: { ... } # tls socket configuration
     *
     * If this field is set, then for health checks it will supersede an entry of ``envoy.transport_socket`` in the
     * :ref:`LbEndpoint.Metadata <envoy_v3_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
     * This allows using different transport socket capabilities for health checking versus proxying to the
     * endpoint.
     *
     * If the key/values pairs specified do not match any
     * :ref:`transport socket matches <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket_matches>`,
     * the cluster's :ref:`transport socket <envoy_v3_api_field_config.cluster.v3.Cluster.transport_socket>`
     * will be used for health check socket configuration.
     *
     * @generated from protobuf field: google.protobuf.Struct transport_socket_match_criteria = 23;
     */
    transportSocketMatchCriteria?: Struct;
}
/**
 * Describes the encoding of the payload bytes in the payload.
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.Payload
 */
export interface HealthCheck_Payload {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "text";
        /**
         * Hex encoded payload. E.g., "000000FF".
         *
         * @generated from protobuf field: string text = 1;
         */
        text: string;
    } | {
        oneofKind: "binary";
        /**
         * Binary payload.
         *
         * @generated from protobuf field: bytes binary = 2;
         */
        binary: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#next-free-field: 15]
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.HttpHealthCheck
 */
export interface HealthCheck_HttpHealthCheck {
    /**
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * Specifies the HTTP path that will be requested during health checking. For example
     * ``/healthcheck``.
     *
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * [#not-implemented-hide:] HTTP specific payload.
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthCheck.Payload send = 3;
     */
    send?: HealthCheck_Payload;
    /**
     * Specifies a list of HTTP expected responses to match in the first ``response_buffer_size`` bytes of the response body.
     * If it is set, both the expected response check and status code determine the health check.
     * When checking the response, “fuzzy” matching is performed such that each payload block must be found,
     * and in the order specified, but not necessarily contiguous.
     *
     * .. note::
     *
     *   It is recommended to set ``response_buffer_size`` based on the total Payload size for efficiency.
     *   The default buffer size is 1024 bytes when it is not set.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HealthCheck.Payload receive = 4;
     */
    receive: HealthCheck_Payload[];
    /**
     * Specifies the size of response buffer in bytes that is used to Payload match.
     * The default value is 1024. Setting to 0 implies that the Payload will be matched against the entire response.
     *
     * @generated from protobuf field: google.protobuf.UInt64Value response_buffer_size = 14;
     */
    responseBufferSize?: UInt64Value;
    /**
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 8;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     *
     * @generated from protobuf field: repeated envoy.type.v3.Int64Range expected_statuses = 9;
     */
    expectedStatuses: Int64Range[];
    /**
     * Specifies a list of HTTP response statuses considered retriable. If provided, responses in this range
     * will count towards the configured :ref:`unhealthy_threshold <envoy_v3_api_field_config.core.v3.HealthCheck.unhealthy_threshold>`,
     * but will not result in the host being considered immediately unhealthy. Ranges follow half-open semantics of
     * :ref:`Int64Range <envoy_v3_api_msg_type.v3.Int64Range>`. The start and end of each range are required.
     * Only statuses in the range [100, 600) are allowed. The :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`
     * field takes precedence for any range overlaps with this field i.e. if status code 200 is both retriable and expected, a 200 response will
     * be considered a successful health check. By default all responses not in
     * :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>` will result in
     * the host being considered immediately unhealthy i.e. if status code 200 is expected and there are no configured retriable statuses, any
     * non-200 response will result in the host being marked unhealthy.
     *
     * @generated from protobuf field: repeated envoy.type.v3.Int64Range retriable_statuses = 12;
     */
    retriableStatuses: Int64Range[];
    /**
     * Use specified application protocol for health checks.
     *
     * @generated from protobuf field: envoy.type.v3.CodecClientType codec_client_type = 10;
     */
    codecClientType: CodecClientType;
    /**
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * <envoy_v3_api_msg_type.matcher.v3.StringMatcher>`. See the :ref:`architecture overview
     * <arch_overview_health_checking_identity>` for more information.
     *
     * @generated from protobuf field: envoy.type.matcher.v3.StringMatcher service_name_matcher = 11;
     */
    serviceNameMatcher?: StringMatcher;
    /**
     * HTTP Method that will be used for health checking, default is "GET".
     * GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE, PATCH methods are supported, but making request body is not supported.
     * CONNECT method is disallowed because it is not appropriate for health check request.
     * If a non-200 response is expected by the method, it needs to be set in :ref:`expected_statuses <envoy_v3_api_field_config.core.v3.HealthCheck.HttpHealthCheck.expected_statuses>`.
     *
     * @generated from protobuf field: envoy.config.core.v3.RequestMethod method = 13;
     */
    method: RequestMethod;
}
/**
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.TcpHealthCheck
 */
export interface HealthCheck_TcpHealthCheck {
    /**
     * Empty payloads imply a connect-only health check.
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthCheck.Payload send = 1;
     */
    send?: HealthCheck_Payload;
    /**
     * When checking the response, “fuzzy” matching is performed such that each
     * payload block must be found, and in the order specified, but not
     * necessarily contiguous.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HealthCheck.Payload receive = 2;
     */
    receive: HealthCheck_Payload[];
}
/**
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.RedisHealthCheck
 */
export interface HealthCheck_RedisHealthCheck {
    /**
     * If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * `grpc.health.v1.Health
 * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
 * healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
 * for details.
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.GrpcHealthCheck
 */
export interface HealthCheck_GrpcHealthCheck {
    /**
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
     * message. See `gRPC health-checking overview
     * <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
     *
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname <envoy_v3_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from protobuf field: string authority = 2;
     */
    authority: string;
    /**
     * Specifies a list of key-value pairs that should be added to the metadata of each GRPC call
     * that is sent to the health checked cluster. For more information, including details on header value syntax,
     * see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.config.core.v3.HeaderValueOption initial_metadata = 3;
     */
    initialMetadata: HeaderValueOption[];
}
/**
 * Custom health check.
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.CustomHealthCheck
 */
export interface HealthCheck_CustomHealthCheck {
    /**
     * The registered name of the custom health checker.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Health checks occur over the transport socket specified for the cluster. This implies that if a
 * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
 *
 * This allows overriding the cluster TLS settings, just for health check connections.
 *
 * @generated from protobuf message envoy.config.core.v3.HealthCheck.TlsOptions
 */
export interface HealthCheck_TlsOptions {
    /**
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     *
     * @generated from protobuf field: repeated string alpn_protocols = 1;
     */
    alpnProtocols: string[];
}
// [#protodoc-title: Health check]
// * Health checking :ref:`architecture overview <arch_overview_health_checking>`.
// * If health checking is configured for a cluster, additional statistics are emitted. They are
//   documented :ref:`here <config_cluster_manager_cluster_stats>`.

/**
 * Endpoint health status.
 *
 * @generated from protobuf enum envoy.config.core.v3.HealthStatus
 */
export enum HealthStatus {
    /**
     * The health status is not known. This is interpreted by Envoy as ``HEALTHY``.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Healthy.
     *
     * @generated from protobuf enum value: HEALTHY = 1;
     */
    HEALTHY = 1,
    /**
     * Unhealthy.
     *
     * @generated from protobuf enum value: UNHEALTHY = 2;
     */
    UNHEALTHY = 2,
    /**
     * Connection draining in progress. E.g.,
     * `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
     * or
     * `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
     * This is interpreted by Envoy as ``UNHEALTHY``.
     *
     * @generated from protobuf enum value: DRAINING = 3;
     */
    DRAINING = 3,
    /**
     * Health check timed out. This is part of HDS and is interpreted by Envoy as
     * ``UNHEALTHY``.
     *
     * @generated from protobuf enum value: TIMEOUT = 4;
     */
    TIMEOUT = 4,
    /**
     * Degraded.
     *
     * @generated from protobuf enum value: DEGRADED = 5;
     */
    DEGRADED = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class HealthStatusSet$Type extends MessageType<HealthStatusSet> {
    constructor() {
        super("envoy.config.core.v3.HealthStatusSet", [
            { no: 1, name: "statuses", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["envoy.config.core.v3.HealthStatus", HealthStatus], options: { "validate.rules": { repeated: { items: { enum: { definedOnly: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<HealthStatusSet>): HealthStatusSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<HealthStatusSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthStatusSet): HealthStatusSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.config.core.v3.HealthStatus statuses */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.statuses.push(reader.int32());
                    else
                        message.statuses.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthStatusSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.config.core.v3.HealthStatus statuses = 1; */
        if (message.statuses.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.statuses.length; i++)
                writer.int32(message.statuses[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthStatusSet
 */
export const HealthStatusSet = new HealthStatusSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck$Type extends MessageType<HealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck", [
            { no: 1, name: "timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 2, name: "interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 20, name: "initial_jitter", kind: "message", T: () => Duration },
            { no: 3, name: "interval_jitter", kind: "message", T: () => Duration },
            { no: 18, name: "interval_jitter_percent", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "unhealthy_threshold", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true } } } },
            { no: 5, name: "healthy_threshold", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "alt_port", kind: "message", T: () => UInt32Value },
            { no: 7, name: "reuse_connection", kind: "message", T: () => BoolValue },
            { no: 8, name: "http_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_HttpHealthCheck },
            { no: 9, name: "tcp_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_TcpHealthCheck },
            { no: 11, name: "grpc_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_GrpcHealthCheck },
            { no: 13, name: "custom_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_CustomHealthCheck },
            { no: 12, name: "no_traffic_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 24, name: "no_traffic_healthy_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 14, name: "unhealthy_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 15, name: "unhealthy_edge_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 16, name: "healthy_edge_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 17, name: "event_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.deprecated_at_minor_version": "3.0" } },
            { no: 25, name: "event_logger", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TypedExtensionConfig },
            { no: 22, name: "event_service", kind: "message", T: () => EventServiceConfig },
            { no: 19, name: "always_log_health_check_failures", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "tls_options", kind: "message", T: () => HealthCheck_TlsOptions },
            { no: 23, name: "transport_socket_match_criteria", kind: "message", T: () => Struct }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck>): HealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.intervalJitterPercent = 0;
        message.healthChecker = { oneofKind: undefined };
        message.eventLogPath = "";
        message.eventLogger = [];
        message.alwaysLogHealthCheckFailures = false;
        if (value !== undefined)
            reflectionMergePartial<HealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck): HealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration timeout */ 1:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* google.protobuf.Duration interval */ 2:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                case /* google.protobuf.Duration initial_jitter */ 20:
                    message.initialJitter = Duration.internalBinaryRead(reader, reader.uint32(), options, message.initialJitter);
                    break;
                case /* google.protobuf.Duration interval_jitter */ 3:
                    message.intervalJitter = Duration.internalBinaryRead(reader, reader.uint32(), options, message.intervalJitter);
                    break;
                case /* uint32 interval_jitter_percent */ 18:
                    message.intervalJitterPercent = reader.uint32();
                    break;
                case /* google.protobuf.UInt32Value unhealthy_threshold */ 4:
                    message.unhealthyThreshold = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyThreshold);
                    break;
                case /* google.protobuf.UInt32Value healthy_threshold */ 5:
                    message.healthyThreshold = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.healthyThreshold);
                    break;
                case /* google.protobuf.UInt32Value alt_port */ 6:
                    message.altPort = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.altPort);
                    break;
                case /* google.protobuf.BoolValue reuse_connection */ 7:
                    message.reuseConnection = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.reuseConnection);
                    break;
                case /* envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check */ 8:
                    message.healthChecker = {
                        oneofKind: "httpHealthCheck",
                        httpHealthCheck: HealthCheck_HttpHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).httpHealthCheck)
                    };
                    break;
                case /* envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check */ 9:
                    message.healthChecker = {
                        oneofKind: "tcpHealthCheck",
                        tcpHealthCheck: HealthCheck_TcpHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).tcpHealthCheck)
                    };
                    break;
                case /* envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check */ 11:
                    message.healthChecker = {
                        oneofKind: "grpcHealthCheck",
                        grpcHealthCheck: HealthCheck_GrpcHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).grpcHealthCheck)
                    };
                    break;
                case /* envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check */ 13:
                    message.healthChecker = {
                        oneofKind: "customHealthCheck",
                        customHealthCheck: HealthCheck_CustomHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).customHealthCheck)
                    };
                    break;
                case /* google.protobuf.Duration no_traffic_interval */ 12:
                    message.noTrafficInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.noTrafficInterval);
                    break;
                case /* google.protobuf.Duration no_traffic_healthy_interval */ 24:
                    message.noTrafficHealthyInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.noTrafficHealthyInterval);
                    break;
                case /* google.protobuf.Duration unhealthy_interval */ 14:
                    message.unhealthyInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyInterval);
                    break;
                case /* google.protobuf.Duration unhealthy_edge_interval */ 15:
                    message.unhealthyEdgeInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyEdgeInterval);
                    break;
                case /* google.protobuf.Duration healthy_edge_interval */ 16:
                    message.healthyEdgeInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.healthyEdgeInterval);
                    break;
                case /* string event_log_path = 17 [deprecated = true];*/ 17:
                    message.eventLogPath = reader.string();
                    break;
                case /* repeated envoy.config.core.v3.TypedExtensionConfig event_logger */ 25:
                    message.eventLogger.push(TypedExtensionConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.config.core.v3.EventServiceConfig event_service */ 22:
                    message.eventService = EventServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.eventService);
                    break;
                case /* bool always_log_health_check_failures */ 19:
                    message.alwaysLogHealthCheckFailures = reader.bool();
                    break;
                case /* envoy.config.core.v3.HealthCheck.TlsOptions tls_options */ 21:
                    message.tlsOptions = HealthCheck_TlsOptions.internalBinaryRead(reader, reader.uint32(), options, message.tlsOptions);
                    break;
                case /* google.protobuf.Struct transport_socket_match_criteria */ 23:
                    message.transportSocketMatchCriteria = Struct.internalBinaryRead(reader, reader.uint32(), options, message.transportSocketMatchCriteria);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration timeout = 1; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval = 2; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration initial_jitter = 20; */
        if (message.initialJitter)
            Duration.internalBinaryWrite(message.initialJitter, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval_jitter = 3; */
        if (message.intervalJitter)
            Duration.internalBinaryWrite(message.intervalJitter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 interval_jitter_percent = 18; */
        if (message.intervalJitterPercent !== 0)
            writer.tag(18, WireType.Varint).uint32(message.intervalJitterPercent);
        /* google.protobuf.UInt32Value unhealthy_threshold = 4; */
        if (message.unhealthyThreshold)
            UInt32Value.internalBinaryWrite(message.unhealthyThreshold, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value healthy_threshold = 5; */
        if (message.healthyThreshold)
            UInt32Value.internalBinaryWrite(message.healthyThreshold, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value alt_port = 6; */
        if (message.altPort)
            UInt32Value.internalBinaryWrite(message.altPort, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue reuse_connection = 7; */
        if (message.reuseConnection)
            BoolValue.internalBinaryWrite(message.reuseConnection, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthCheck.HttpHealthCheck http_health_check = 8; */
        if (message.healthChecker.oneofKind === "httpHealthCheck")
            HealthCheck_HttpHealthCheck.internalBinaryWrite(message.healthChecker.httpHealthCheck, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthCheck.TcpHealthCheck tcp_health_check = 9; */
        if (message.healthChecker.oneofKind === "tcpHealthCheck")
            HealthCheck_TcpHealthCheck.internalBinaryWrite(message.healthChecker.tcpHealthCheck, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthCheck.GrpcHealthCheck grpc_health_check = 11; */
        if (message.healthChecker.oneofKind === "grpcHealthCheck")
            HealthCheck_GrpcHealthCheck.internalBinaryWrite(message.healthChecker.grpcHealthCheck, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.HealthCheck.CustomHealthCheck custom_health_check = 13; */
        if (message.healthChecker.oneofKind === "customHealthCheck")
            HealthCheck_CustomHealthCheck.internalBinaryWrite(message.healthChecker.customHealthCheck, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration no_traffic_interval = 12; */
        if (message.noTrafficInterval)
            Duration.internalBinaryWrite(message.noTrafficInterval, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration no_traffic_healthy_interval = 24; */
        if (message.noTrafficHealthyInterval)
            Duration.internalBinaryWrite(message.noTrafficHealthyInterval, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration unhealthy_interval = 14; */
        if (message.unhealthyInterval)
            Duration.internalBinaryWrite(message.unhealthyInterval, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration unhealthy_edge_interval = 15; */
        if (message.unhealthyEdgeInterval)
            Duration.internalBinaryWrite(message.unhealthyEdgeInterval, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration healthy_edge_interval = 16; */
        if (message.healthyEdgeInterval)
            Duration.internalBinaryWrite(message.healthyEdgeInterval, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string event_log_path = 17 [deprecated = true]; */
        if (message.eventLogPath !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.eventLogPath);
        /* repeated envoy.config.core.v3.TypedExtensionConfig event_logger = 25; */
        for (let i = 0; i < message.eventLogger.length; i++)
            TypedExtensionConfig.internalBinaryWrite(message.eventLogger[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.EventServiceConfig event_service = 22; */
        if (message.eventService)
            EventServiceConfig.internalBinaryWrite(message.eventService, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* bool always_log_health_check_failures = 19; */
        if (message.alwaysLogHealthCheckFailures !== false)
            writer.tag(19, WireType.Varint).bool(message.alwaysLogHealthCheckFailures);
        /* envoy.config.core.v3.HealthCheck.TlsOptions tls_options = 21; */
        if (message.tlsOptions)
            HealthCheck_TlsOptions.internalBinaryWrite(message.tlsOptions, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct transport_socket_match_criteria = 23; */
        if (message.transportSocketMatchCriteria)
            Struct.internalBinaryWrite(message.transportSocketMatchCriteria, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck
 */
export const HealthCheck = new HealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_Payload$Type extends MessageType<HealthCheck_Payload> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.Payload", [
            { no: 1, name: "text", kind: "scalar", oneof: "payload", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "binary", kind: "scalar", oneof: "payload", T: 12 /*ScalarType.BYTES*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.Payload" } });
    }
    create(value?: PartialMessage<HealthCheck_Payload>): HealthCheck_Payload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_Payload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_Payload): HealthCheck_Payload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.payload = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* bytes binary */ 2:
                    message.payload = {
                        oneofKind: "binary",
                        binary: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_Payload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.payload.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.payload.text);
        /* bytes binary = 2; */
        if (message.payload.oneofKind === "binary")
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload.binary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.Payload
 */
export const HealthCheck_Payload = new HealthCheck_Payload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_HttpHealthCheck$Type extends MessageType<HealthCheck_HttpHealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.HttpHealthCheck", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1", wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 3, name: "send", kind: "message", T: () => HealthCheck_Payload },
            { no: 4, name: "receive", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck_Payload },
            { no: 14, name: "response_buffer_size", kind: "message", T: () => UInt64Value, options: { "validate.rules": { uint64: { gte: "0" } } } },
            { no: 6, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 8, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } } } },
            { no: 9, name: "expected_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int64Range },
            { no: 12, name: "retriable_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int64Range },
            { no: 10, name: "codec_client_type", kind: "enum", T: () => ["envoy.type.v3.CodecClientType", CodecClientType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 11, name: "service_name_matcher", kind: "message", T: () => StringMatcher },
            { no: 13, name: "method", kind: "enum", T: () => ["envoy.config.core.v3.RequestMethod", RequestMethod], options: { "validate.rules": { enum: { definedOnly: true, notIn: [6] } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.HttpHealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck_HttpHealthCheck>): HealthCheck_HttpHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.path = "";
        message.receive = [];
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.expectedStatuses = [];
        message.retriableStatuses = [];
        message.codecClientType = 0;
        message.method = 0;
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_HttpHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_HttpHealthCheck): HealthCheck_HttpHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* envoy.config.core.v3.HealthCheck.Payload send */ 3:
                    message.send = HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options, message.send);
                    break;
                case /* repeated envoy.config.core.v3.HealthCheck.Payload receive */ 4:
                    message.receive.push(HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt64Value response_buffer_size */ 14:
                    message.responseBufferSize = UInt64Value.internalBinaryRead(reader, reader.uint32(), options, message.responseBufferSize);
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add */ 6:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 8:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.type.v3.Int64Range expected_statuses */ 9:
                    message.expectedStatuses.push(Int64Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.type.v3.Int64Range retriable_statuses */ 12:
                    message.retriableStatuses.push(Int64Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.type.v3.CodecClientType codec_client_type */ 10:
                    message.codecClientType = reader.int32();
                    break;
                case /* envoy.type.matcher.v3.StringMatcher service_name_matcher */ 11:
                    message.serviceNameMatcher = StringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.serviceNameMatcher);
                    break;
                case /* envoy.config.core.v3.RequestMethod method */ 13:
                    message.method = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_HttpHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* envoy.config.core.v3.HealthCheck.Payload send = 3; */
        if (message.send)
            HealthCheck_Payload.internalBinaryWrite(message.send, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HealthCheck.Payload receive = 4; */
        for (let i = 0; i < message.receive.length; i++)
            HealthCheck_Payload.internalBinaryWrite(message.receive[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt64Value response_buffer_size = 14; */
        if (message.responseBufferSize)
            UInt64Value.internalBinaryWrite(message.responseBufferSize, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HeaderValueOption request_headers_to_add = 6; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 8; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.type.v3.Int64Range expected_statuses = 9; */
        for (let i = 0; i < message.expectedStatuses.length; i++)
            Int64Range.internalBinaryWrite(message.expectedStatuses[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.v3.Int64Range retriable_statuses = 12; */
        for (let i = 0; i < message.retriableStatuses.length; i++)
            Int64Range.internalBinaryWrite(message.retriableStatuses[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.CodecClientType codec_client_type = 10; */
        if (message.codecClientType !== 0)
            writer.tag(10, WireType.Varint).int32(message.codecClientType);
        /* envoy.type.matcher.v3.StringMatcher service_name_matcher = 11; */
        if (message.serviceNameMatcher)
            StringMatcher.internalBinaryWrite(message.serviceNameMatcher, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.RequestMethod method = 13; */
        if (message.method !== 0)
            writer.tag(13, WireType.Varint).int32(message.method);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.HttpHealthCheck
 */
export const HealthCheck_HttpHealthCheck = new HealthCheck_HttpHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_TcpHealthCheck$Type extends MessageType<HealthCheck_TcpHealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.TcpHealthCheck", [
            { no: 1, name: "send", kind: "message", T: () => HealthCheck_Payload },
            { no: 2, name: "receive", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck_Payload }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.TcpHealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck_TcpHealthCheck>): HealthCheck_TcpHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.receive = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_TcpHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_TcpHealthCheck): HealthCheck_TcpHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.HealthCheck.Payload send */ 1:
                    message.send = HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options, message.send);
                    break;
                case /* repeated envoy.config.core.v3.HealthCheck.Payload receive */ 2:
                    message.receive.push(HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_TcpHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.HealthCheck.Payload send = 1; */
        if (message.send)
            HealthCheck_Payload.internalBinaryWrite(message.send, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.config.core.v3.HealthCheck.Payload receive = 2; */
        for (let i = 0; i < message.receive.length; i++)
            HealthCheck_Payload.internalBinaryWrite(message.receive[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.TcpHealthCheck
 */
export const HealthCheck_TcpHealthCheck = new HealthCheck_TcpHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_RedisHealthCheck$Type extends MessageType<HealthCheck_RedisHealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.RedisHealthCheck", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.RedisHealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck_RedisHealthCheck>): HealthCheck_RedisHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_RedisHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_RedisHealthCheck): HealthCheck_RedisHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_RedisHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.RedisHealthCheck
 */
export const HealthCheck_RedisHealthCheck = new HealthCheck_RedisHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_GrpcHealthCheck$Type extends MessageType<HealthCheck_GrpcHealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.GrpcHealthCheck", [
            { no: 1, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 3, name: "initial_metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.GrpcHealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck_GrpcHealthCheck>): HealthCheck_GrpcHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceName = "";
        message.authority = "";
        message.initialMetadata = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_GrpcHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_GrpcHealthCheck): HealthCheck_GrpcHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* string authority */ 2:
                    message.authority = reader.string();
                    break;
                case /* repeated envoy.config.core.v3.HeaderValueOption initial_metadata */ 3:
                    message.initialMetadata.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_GrpcHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* string authority = 2; */
        if (message.authority !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authority);
        /* repeated envoy.config.core.v3.HeaderValueOption initial_metadata = 3; */
        for (let i = 0; i < message.initialMetadata.length; i++)
            HeaderValueOption.internalBinaryWrite(message.initialMetadata[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.GrpcHealthCheck
 */
export const HealthCheck_GrpcHealthCheck = new HealthCheck_GrpcHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_CustomHealthCheck$Type extends MessageType<HealthCheck_CustomHealthCheck> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.CustomHealthCheck", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.CustomHealthCheck" } });
    }
    create(value?: PartialMessage<HealthCheck_CustomHealthCheck>): HealthCheck_CustomHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_CustomHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_CustomHealthCheck): HealthCheck_CustomHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_CustomHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.CustomHealthCheck
 */
export const HealthCheck_CustomHealthCheck = new HealthCheck_CustomHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_TlsOptions$Type extends MessageType<HealthCheck_TlsOptions> {
    constructor() {
        super("envoy.config.core.v3.HealthCheck.TlsOptions", [
            { no: 1, name: "alpn_protocols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.api.v2.core.HealthCheck.TlsOptions" } });
    }
    create(value?: PartialMessage<HealthCheck_TlsOptions>): HealthCheck_TlsOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.alpnProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_TlsOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_TlsOptions): HealthCheck_TlsOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string alpn_protocols */ 1:
                    message.alpnProtocols.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_TlsOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string alpn_protocols = 1; */
        for (let i = 0; i < message.alpnProtocols.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.alpnProtocols[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.config.core.v3.HealthCheck.TlsOptions
 */
export const HealthCheck_TlsOptions = new HealthCheck_TlsOptions$Type();
