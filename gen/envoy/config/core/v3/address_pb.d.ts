// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/config/core/v3/address.proto (package envoy.config.core.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { SocketOption, SocketOptionsOverride } from "./socket_option_pb.js";

/**
 * @generated from message envoy.config.core.v3.Pipe
 */
export declare class Pipe extends Message<Pipe> {
  /**
   * Unix Domain Socket path. On Linux, paths starting with '@' will use the
   * abstract namespace. The starting '@' is replaced by a null byte by Envoy.
   * Paths starting with '@' will result in an error in environments other than
   * Linux.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * The mode for the Pipe. Not applicable for abstract sockets.
   *
   * @generated from field: uint32 mode = 2;
   */
  mode: number;

  constructor(data?: PartialMessage<Pipe>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.Pipe";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Pipe;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Pipe;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Pipe;

  static equals(a: Pipe | PlainMessage<Pipe> | undefined, b: Pipe | PlainMessage<Pipe> | undefined): boolean;
}

/**
 * The address represents an envoy internal listener.
 * [#comment: TODO(asraa): When address available, remove workaround from test/server/server_fuzz_test.cc:30.]
 *
 * @generated from message envoy.config.core.v3.EnvoyInternalAddress
 */
export declare class EnvoyInternalAddress extends Message<EnvoyInternalAddress> {
  /**
   * @generated from oneof envoy.config.core.v3.EnvoyInternalAddress.address_name_specifier
   */
  addressNameSpecifier: {
    /**
     * Specifies the :ref:`name <envoy_v3_api_field_config.listener.v3.Listener.name>` of the
     * internal listener.
     *
     * @generated from field: string server_listener_name = 1;
     */
    value: string;
    case: "serverListenerName";
  } | { case: undefined; value?: undefined };

  /**
   * Specifies an endpoint identifier to distinguish between multiple endpoints for the same internal listener in a
   * single upstream pool. Only used in the upstream addresses for tracking changes to individual endpoints. This, for
   * example, may be set to the final destination IP for the target internal listener.
   *
   * @generated from field: string endpoint_id = 2;
   */
  endpointId: string;

  constructor(data?: PartialMessage<EnvoyInternalAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.EnvoyInternalAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnvoyInternalAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnvoyInternalAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnvoyInternalAddress;

  static equals(a: EnvoyInternalAddress | PlainMessage<EnvoyInternalAddress> | undefined, b: EnvoyInternalAddress | PlainMessage<EnvoyInternalAddress> | undefined): boolean;
}

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.config.core.v3.SocketAddress
 */
export declare class SocketAddress extends Message<SocketAddress> {
  /**
   * @generated from field: envoy.config.core.v3.SocketAddress.Protocol protocol = 1;
   */
  protocol: SocketAddress_Protocol;

  /**
   * The address for this socket. :ref:`Listeners <config_listeners>` will bind
   * to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``
   * to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:
   * It is possible to distinguish a Listener address via the prefix/suffix matching
   * in :ref:`FilterChainMatch <envoy_v3_api_msg_config.listener.v3.FilterChainMatch>`.] When used
   * within an upstream :ref:`BindConfig <envoy_v3_api_msg_config.core.v3.BindConfig>`, the address
   * controls the source address of outbound connections. For :ref:`clusters
   * <envoy_v3_api_msg_config.cluster.v3.Cluster>`, the cluster type determines whether the
   * address must be an IP (``STATIC`` or ``EDS`` clusters) or a hostname resolved by DNS
   * (``STRICT_DNS`` or ``LOGICAL_DNS`` clusters). Address resolution can be customized
   * via :ref:`resolver_name <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>`.
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * @generated from oneof envoy.config.core.v3.SocketAddress.port_specifier
   */
  portSpecifier: {
    /**
     * @generated from field: uint32 port_value = 3;
     */
    value: number;
    case: "portValue";
  } | {
    /**
     * This is only valid if :ref:`resolver_name
     * <envoy_v3_api_field_config.core.v3.SocketAddress.resolver_name>` is specified below and the
     * named resolver is capable of named port resolution.
     *
     * @generated from field: string named_port = 4;
     */
    value: string;
    case: "namedPort";
  } | { case: undefined; value?: undefined };

  /**
   * The name of the custom resolver. This must have been registered with Envoy. If
   * this is empty, a context dependent default applies. If the address is a concrete
   * IP address, no resolution will occur. If address is a hostname this
   * should be set for resolution other than DNS. Specifying a custom resolver with
   * ``STRICT_DNS`` or ``LOGICAL_DNS`` will generate an error at runtime.
   *
   * @generated from field: string resolver_name = 5;
   */
  resolverName: string;

  /**
   * When binding to an IPv6 address above, this enables `IPv4 compatibility
   * <https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
   * allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
   * IPv6 space as ``::FFFF:<IPv4-address>``.
   *
   * @generated from field: bool ipv4_compat = 6;
   */
  ipv4Compat: boolean;

  constructor(data?: PartialMessage<SocketAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.SocketAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SocketAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SocketAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SocketAddress;

  static equals(a: SocketAddress | PlainMessage<SocketAddress> | undefined, b: SocketAddress | PlainMessage<SocketAddress> | undefined): boolean;
}

/**
 * @generated from enum envoy.config.core.v3.SocketAddress.Protocol
 */
export declare enum SocketAddress_Protocol {
  /**
   * @generated from enum value: TCP = 0;
   */
  TCP = 0,

  /**
   * @generated from enum value: UDP = 1;
   */
  UDP = 1,
}

/**
 * @generated from message envoy.config.core.v3.TcpKeepalive
 */
export declare class TcpKeepalive extends Message<TcpKeepalive> {
  /**
   * Maximum number of keepalive probes to send without response before deciding
   * the connection is dead. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 9.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_probes = 1;
   */
  keepaliveProbes?: number;

  /**
   * The number of seconds a connection needs to be idle before keep-alive probes
   * start being sent. Default is to use the OS level configuration (unless
   * overridden, Linux defaults to 7200s (i.e., 2 hours.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_time = 2;
   */
  keepaliveTime?: number;

  /**
   * The number of seconds between keep-alive probes. Default is to use the OS
   * level configuration (unless overridden, Linux defaults to 75s.)
   *
   * @generated from field: google.protobuf.UInt32Value keepalive_interval = 3;
   */
  keepaliveInterval?: number;

  constructor(data?: PartialMessage<TcpKeepalive>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.TcpKeepalive";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpKeepalive;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpKeepalive;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpKeepalive;

  static equals(a: TcpKeepalive | PlainMessage<TcpKeepalive> | undefined, b: TcpKeepalive | PlainMessage<TcpKeepalive> | undefined): boolean;
}

/**
 * @generated from message envoy.config.core.v3.ExtraSourceAddress
 */
export declare class ExtraSourceAddress extends Message<ExtraSourceAddress> {
  /**
   * The additional address to bind.
   *
   * @generated from field: envoy.config.core.v3.SocketAddress address = 1;
   */
  address?: SocketAddress;

  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries. If specified, this will override the
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.BindConfig.socket_options>`
   * in the BindConfig. If specified with no
   * :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`
   * or an empty list of :ref:`socket_options <envoy_v3_api_field_config.core.v3.SocketOptionsOverride.socket_options>`,
   * it means no socket option will apply.
   *
   * @generated from field: envoy.config.core.v3.SocketOptionsOverride socket_options = 2;
   */
  socketOptions?: SocketOptionsOverride;

  constructor(data?: PartialMessage<ExtraSourceAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.ExtraSourceAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtraSourceAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtraSourceAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtraSourceAddress;

  static equals(a: ExtraSourceAddress | PlainMessage<ExtraSourceAddress> | undefined, b: ExtraSourceAddress | PlainMessage<ExtraSourceAddress> | undefined): boolean;
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.config.core.v3.BindConfig
 */
export declare class BindConfig extends Message<BindConfig> {
  /**
   * The address to bind to when creating a socket.
   *
   * @generated from field: envoy.config.core.v3.SocketAddress source_address = 1;
   */
  sourceAddress?: SocketAddress;

  /**
   * Whether to set the ``IP_FREEBIND`` option when creating the socket. When this
   * flag is set to true, allows the :ref:`source_address
   * <envoy_v3_api_field_config.core.v3.BindConfig.source_address>` to be an IP address
   * that is not configured on the system running Envoy. When this flag is set
   * to false, the option ``IP_FREEBIND`` is disabled on the socket. When this
   * flag is not set (default), the socket is not modified, i.e. the option is
   * neither enabled nor disabled.
   *
   * @generated from field: google.protobuf.BoolValue freebind = 2;
   */
  freebind?: boolean;

  /**
   * Additional socket options that may not be present in Envoy source code or
   * precompiled binaries.
   *
   * @generated from field: repeated envoy.config.core.v3.SocketOption socket_options = 3;
   */
  socketOptions: SocketOption[];

  /**
   * Extra source addresses appended to the address specified in the `source_address`
   * field. This enables to specify multiple source addresses. Currently, only one extra
   * address can be supported, and the extra address should have a different IP version
   * with the address in the `source_address` field. The address which has the same IP
   * version with the target host's address IP version will be used as bind address. If more
   * than one extra address specified, only the first address matched IP version will be
   * returned. If there is no same IP version address found, the address in the `source_address`
   * will be returned.
   *
   * @generated from field: repeated envoy.config.core.v3.ExtraSourceAddress extra_source_addresses = 5;
   */
  extraSourceAddresses: ExtraSourceAddress[];

  /**
   * Deprecated by
   * :ref:`extra_source_addresses <envoy_v3_api_field_config.core.v3.BindConfig.extra_source_addresses>`
   *
   * @generated from field: repeated envoy.config.core.v3.SocketAddress additional_source_addresses = 4 [deprecated = true];
   * @deprecated
   */
  additionalSourceAddresses: SocketAddress[];

  constructor(data?: PartialMessage<BindConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.BindConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindConfig;

  static equals(a: BindConfig | PlainMessage<BindConfig> | undefined, b: BindConfig | PlainMessage<BindConfig> | undefined): boolean;
}

/**
 * Addresses specify either a logical or physical address and port, which are
 * used to tell Envoy where to bind/listen, connect to upstream and find
 * management servers.
 *
 * @generated from message envoy.config.core.v3.Address
 */
export declare class Address extends Message<Address> {
  /**
   * @generated from oneof envoy.config.core.v3.Address.address
   */
  address: {
    /**
     * @generated from field: envoy.config.core.v3.SocketAddress socket_address = 1;
     */
    value: SocketAddress;
    case: "socketAddress";
  } | {
    /**
     * @generated from field: envoy.config.core.v3.Pipe pipe = 2;
     */
    value: Pipe;
    case: "pipe";
  } | {
    /**
     * Specifies a user-space address handled by :ref:`internal listeners
     * <envoy_v3_api_field_config.listener.v3.Listener.internal_listener>`.
     *
     * @generated from field: envoy.config.core.v3.EnvoyInternalAddress envoy_internal_address = 3;
     */
    value: EnvoyInternalAddress;
    case: "envoyInternalAddress";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Address>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.Address";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Address;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Address;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Address;

  static equals(a: Address | PlainMessage<Address> | undefined, b: Address | PlainMessage<Address> | undefined): boolean;
}

/**
 * CidrRange specifies an IP Address and a prefix length to construct
 * the subnet mask for a `CIDR <https://tools.ietf.org/html/rfc4632>`_ range.
 *
 * @generated from message envoy.config.core.v3.CidrRange
 */
export declare class CidrRange extends Message<CidrRange> {
  /**
   * IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
   *
   * @generated from field: string address_prefix = 1;
   */
  addressPrefix: string;

  /**
   * Length of prefix, e.g. 0, 32. Defaults to 0 when unset.
   *
   * @generated from field: google.protobuf.UInt32Value prefix_len = 2;
   */
  prefixLen?: number;

  constructor(data?: PartialMessage<CidrRange>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.config.core.v3.CidrRange";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CidrRange;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CidrRange;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CidrRange;

  static equals(a: CidrRange | PlainMessage<CidrRange> | undefined, b: CidrRange | PlainMessage<CidrRange> | undefined): boolean;
}

