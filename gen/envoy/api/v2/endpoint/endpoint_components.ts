// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/endpoint/endpoint_components.proto" (package "envoy.api.v2.endpoint", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Locality } from "../core/base";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Metadata } from "../core/base";
import { HealthStatus } from "../core/health_check";
import { Address } from "../core/address";
// [#protodoc-title: Endpoints]

/**
 * Upstream host identifier.
 *
 * @generated from protobuf message envoy.api.v2.endpoint.Endpoint
 */
export interface Endpoint {
    /**
     * The upstream host address.
     *
     * .. attention::
     *
     *   The form of host address depends on the given cluster type. For STATIC or EDS,
     *   it is expected to be a direct IP address (or something resolvable by the
     *   specified :ref:`resolver <envoy_api_field_core.SocketAddress.resolver_name>`
     *   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,
     *   and will be resolved via DNS.
     *
     * @generated from protobuf field: envoy.api.v2.core.Address address = 1;
     */
    address?: Address;
    /**
     * The optional health check configuration is used as configuration for the
     * health checker to contact the health checked host.
     *
     * .. attention::
     *
     *   This takes into effect only for upstream clusters with
     *   :ref:`active health checking <arch_overview_health_checking>` enabled.
     *
     * @generated from protobuf field: envoy.api.v2.endpoint.Endpoint.HealthCheckConfig health_check_config = 2;
     */
    healthCheckConfig?: Endpoint_HealthCheckConfig;
    /**
     * The hostname associated with this endpoint. This hostname is not used for routing or address
     * resolution. If provided, it will be associated with the endpoint, and can be used for features
     * that require a hostname, like
     * :ref:`auto_host_rewrite <envoy_api_field_route.RouteAction.auto_host_rewrite>`.
     *
     * @generated from protobuf field: string hostname = 3;
     */
    hostname: string;
}
/**
 * The optional health check configuration.
 *
 * @generated from protobuf message envoy.api.v2.endpoint.Endpoint.HealthCheckConfig
 */
export interface Endpoint_HealthCheckConfig {
    /**
     * Optional alternative health check port value.
     *
     * By default the health check address port of an upstream host is the same
     * as the host's serving address port. This provides an alternative health
     * check port. Setting this with a non-zero value allows an upstream host
     * to have different health check address port.
     *
     * @generated from protobuf field: uint32 port_value = 1;
     */
    portValue: number;
    /**
     * By default, the host header for L7 health checks is controlled by cluster level configuration
     * (see: :ref:`host <envoy_api_field_core.HealthCheck.HttpHealthCheck.host>` and
     * :ref:`authority <envoy_api_field_core.HealthCheck.GrpcHealthCheck.authority>`). Setting this
     * to a non-empty value allows overriding the cluster level configuration for a specific
     * endpoint.
     *
     * @generated from protobuf field: string hostname = 2;
     */
    hostname: string;
}
/**
 * An Endpoint that Envoy can route traffic to.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.api.v2.endpoint.LbEndpoint
 */
export interface LbEndpoint {
    /**
     * @generated from protobuf oneof: host_identifier
     */
    hostIdentifier: {
        oneofKind: "endpoint";
        /**
         * @generated from protobuf field: envoy.api.v2.endpoint.Endpoint endpoint = 1;
         */
        endpoint: Endpoint;
    } | {
        oneofKind: "endpointName";
        /**
         * [#not-implemented-hide:]
         *
         * @generated from protobuf field: string endpoint_name = 5;
         */
        endpointName: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional health status when known and supplied by EDS server.
     *
     * @generated from protobuf field: envoy.api.v2.core.HealthStatus health_status = 2;
     */
    healthStatus: HealthStatus;
    /**
     * The endpoint metadata specifies values that may be used by the load
     * balancer to select endpoints in a cluster for a given request. The filter
     * name should be specified as *envoy.lb*. An example boolean key-value pair
     * is *canary*, providing the optional canary status of the upstream host.
     * This may be matched against in a route's
     * :ref:`RouteAction <envoy_api_msg_route.RouteAction>` metadata_match field
     * to subset the endpoints considered in cluster load balancing.
     *
     * @generated from protobuf field: envoy.api.v2.core.Metadata metadata = 3;
     */
    metadata?: Metadata;
    /**
     * The optional load balancing weight of the upstream host; at least 1.
     * Envoy uses the load balancing weight in some of the built in load
     * balancers. The load balancing weight for an endpoint is divided by the sum
     * of the weights of all endpoints in the endpoint's locality to produce a
     * percentage of traffic for the endpoint. This percentage is then further
     * weighted by the endpoint's locality's load balancing weight from
     * LocalityLbEndpoints. If unspecified, each host is presumed to have equal
     * weight in a locality. The sum of the weights of all endpoints in the
     * endpoint's locality must not exceed uint32_t maximal value (4294967295).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value load_balancing_weight = 4;
     */
    loadBalancingWeight?: UInt32Value;
}
/**
 * A group of endpoints belonging to a Locality.
 * One can have multiple LocalityLbEndpoints for a locality, but this is
 * generally only done if the different groups need to have different load
 * balancing weights or different priorities.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.endpoint.LocalityLbEndpoints
 */
export interface LocalityLbEndpoints {
    /**
     * Identifies location of where the upstream hosts run.
     *
     * @generated from protobuf field: envoy.api.v2.core.Locality locality = 1;
     */
    locality?: Locality;
    /**
     * The group of endpoints belonging to the locality specified.
     *
     * @generated from protobuf field: repeated envoy.api.v2.endpoint.LbEndpoint lb_endpoints = 2;
     */
    lbEndpoints: LbEndpoint[];
    /**
     * Optional: Per priority/region/zone/sub_zone weight; at least 1. The load
     * balancing weight for a locality is divided by the sum of the weights of all
     * localities  at the same priority level to produce the effective percentage
     * of traffic for the locality. The sum of the weights of all localities at
     * the same priority level must not exceed uint32_t maximal value (4294967295).
     *
     * Locality weights are only considered when :ref:`locality weighted load
     * balancing <arch_overview_load_balancing_locality_weighted_lb>` is
     * configured. These weights are ignored otherwise. If no weights are
     * specified when locality weighted load balancing is enabled, the locality is
     * assigned no load.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value load_balancing_weight = 3;
     */
    loadBalancingWeight?: UInt32Value;
    /**
     * Optional: the priority for this LocalityLbEndpoints. If unspecified this will
     * default to the highest priority (0).
     *
     * Under usual circumstances, Envoy will only select endpoints for the highest
     * priority (0). In the event all endpoints for a particular priority are
     * unavailable/unhealthy, Envoy will fail over to selecting endpoints for the
     * next highest priority group.
     *
     * Priorities should range from 0 (highest) to N (lowest) without skipping.
     *
     * @generated from protobuf field: uint32 priority = 5;
     */
    priority: number;
    /**
     * Optional: Per locality proximity value which indicates how close this
     * locality is from the source locality. This value only provides ordering
     * information (lower the value, closer it is to the source locality).
     * This will be consumed by load balancing schemes that need proximity order
     * to determine where to route the requests.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value proximity = 6;
     */
    proximity?: UInt32Value;
}
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint$Type extends MessageType<Endpoint> {
    constructor() {
        super("envoy.api.v2.endpoint.Endpoint", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "health_check_config", kind: "message", T: () => Endpoint_HealthCheckConfig },
            { no: 3, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Endpoint>): Endpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<Endpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint): Endpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* envoy.api.v2.endpoint.Endpoint.HealthCheckConfig health_check_config */ 2:
                    message.healthCheckConfig = Endpoint_HealthCheckConfig.internalBinaryRead(reader, reader.uint32(), options, message.healthCheckConfig);
                    break;
                case /* string hostname */ 3:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.endpoint.Endpoint.HealthCheckConfig health_check_config = 2; */
        if (message.healthCheckConfig)
            Endpoint_HealthCheckConfig.internalBinaryWrite(message.healthCheckConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string hostname = 3; */
        if (message.hostname !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.endpoint.Endpoint
 */
export const Endpoint = new Endpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Endpoint_HealthCheckConfig$Type extends MessageType<Endpoint_HealthCheckConfig> {
    constructor() {
        super("envoy.api.v2.endpoint.Endpoint.HealthCheckConfig", [
            { no: 1, name: "port_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 65535 } } } },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Endpoint_HealthCheckConfig>): Endpoint_HealthCheckConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.portValue = 0;
        message.hostname = "";
        if (value !== undefined)
            reflectionMergePartial<Endpoint_HealthCheckConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Endpoint_HealthCheckConfig): Endpoint_HealthCheckConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 port_value */ 1:
                    message.portValue = reader.uint32();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Endpoint_HealthCheckConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 port_value = 1; */
        if (message.portValue !== 0)
            writer.tag(1, WireType.Varint).uint32(message.portValue);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.endpoint.Endpoint.HealthCheckConfig
 */
export const Endpoint_HealthCheckConfig = new Endpoint_HealthCheckConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LbEndpoint$Type extends MessageType<LbEndpoint> {
    constructor() {
        super("envoy.api.v2.endpoint.LbEndpoint", [
            { no: 1, name: "endpoint", kind: "message", oneof: "hostIdentifier", T: () => Endpoint },
            { no: 5, name: "endpoint_name", kind: "scalar", oneof: "hostIdentifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "health_status", kind: "enum", T: () => ["envoy.api.v2.core.HealthStatus", HealthStatus] },
            { no: 3, name: "metadata", kind: "message", T: () => Metadata },
            { no: 4, name: "load_balancing_weight", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } }
        ]);
    }
    create(value?: PartialMessage<LbEndpoint>): LbEndpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostIdentifier = { oneofKind: undefined };
        message.healthStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<LbEndpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LbEndpoint): LbEndpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.endpoint.Endpoint endpoint */ 1:
                    message.hostIdentifier = {
                        oneofKind: "endpoint",
                        endpoint: Endpoint.internalBinaryRead(reader, reader.uint32(), options, (message.hostIdentifier as any).endpoint)
                    };
                    break;
                case /* string endpoint_name */ 5:
                    message.hostIdentifier = {
                        oneofKind: "endpointName",
                        endpointName: reader.string()
                    };
                    break;
                case /* envoy.api.v2.core.HealthStatus health_status */ 2:
                    message.healthStatus = reader.int32();
                    break;
                case /* envoy.api.v2.core.Metadata metadata */ 3:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* google.protobuf.UInt32Value load_balancing_weight */ 4:
                    message.loadBalancingWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.loadBalancingWeight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LbEndpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.endpoint.Endpoint endpoint = 1; */
        if (message.hostIdentifier.oneofKind === "endpoint")
            Endpoint.internalBinaryWrite(message.hostIdentifier.endpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string endpoint_name = 5; */
        if (message.hostIdentifier.oneofKind === "endpointName")
            writer.tag(5, WireType.LengthDelimited).string(message.hostIdentifier.endpointName);
        /* envoy.api.v2.core.HealthStatus health_status = 2; */
        if (message.healthStatus !== 0)
            writer.tag(2, WireType.Varint).int32(message.healthStatus);
        /* envoy.api.v2.core.Metadata metadata = 3; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value load_balancing_weight = 4; */
        if (message.loadBalancingWeight)
            UInt32Value.internalBinaryWrite(message.loadBalancingWeight, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.endpoint.LbEndpoint
 */
export const LbEndpoint = new LbEndpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalityLbEndpoints$Type extends MessageType<LocalityLbEndpoints> {
    constructor() {
        super("envoy.api.v2.endpoint.LocalityLbEndpoints", [
            { no: 1, name: "locality", kind: "message", T: () => Locality },
            { no: 2, name: "lb_endpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LbEndpoint },
            { no: 3, name: "load_balancing_weight", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 5, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lte: 128 } } } },
            { no: 6, name: "proximity", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<LocalityLbEndpoints>): LocalityLbEndpoints {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.lbEndpoints = [];
        message.priority = 0;
        if (value !== undefined)
            reflectionMergePartial<LocalityLbEndpoints>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalityLbEndpoints): LocalityLbEndpoints {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Locality locality */ 1:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* repeated envoy.api.v2.endpoint.LbEndpoint lb_endpoints */ 2:
                    message.lbEndpoints.push(LbEndpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value load_balancing_weight */ 3:
                    message.loadBalancingWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.loadBalancingWeight);
                    break;
                case /* uint32 priority */ 5:
                    message.priority = reader.uint32();
                    break;
                case /* google.protobuf.UInt32Value proximity */ 6:
                    message.proximity = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.proximity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalityLbEndpoints, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Locality locality = 1; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.endpoint.LbEndpoint lb_endpoints = 2; */
        for (let i = 0; i < message.lbEndpoints.length; i++)
            LbEndpoint.internalBinaryWrite(message.lbEndpoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value load_balancing_weight = 3; */
        if (message.loadBalancingWeight)
            UInt32Value.internalBinaryWrite(message.loadBalancingWeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 priority = 5; */
        if (message.priority !== 0)
            writer.tag(5, WireType.Varint).uint32(message.priority);
        /* google.protobuf.UInt32Value proximity = 6; */
        if (message.proximity)
            UInt32Value.internalBinaryWrite(message.proximity, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.endpoint.LocalityLbEndpoints
 */
export const LocalityLbEndpoints = new LocalityLbEndpoints$Type();
