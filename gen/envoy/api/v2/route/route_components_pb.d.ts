// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/route/route_components.proto (package envoy.api.v2.route, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, BoolValue, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { DataSource, HeaderValueOption, Metadata, RequestMethod, RoutingPriority, RuntimeFractionalPercent } from "../core/base_pb.js";
import type { RegexMatchAndSubstitute, RegexMatcher } from "../../../type/matcher/regex_pb.js";
import type { StringMatcher } from "../../../type/matcher/string_pb.js";
import type { FractionalPercent } from "../../../type/percent_pb.js";
import type { CustomTag } from "../../../type/tracing/v2/custom_tag_pb.js";
import type { Int64Range } from "../../../type/range_pb.js";

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 21]
 *
 * @generated from message envoy.api.v2.route.VirtualHost
 */
export declare class VirtualHost extends Message<VirtualHost> {
  /**
   * The logical name of the virtual host. This is used when emitting certain
   * statistics but is not relevant for routing.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * A list of domains (host/authority header) that will be matched to this
   * virtual host. Wildcard hosts are supported in the suffix or prefix form.
   *
   * Domain search order:
   *  1. Exact domain names: ``www.foo.com``.
   *  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
   *  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
   *  4. Special wildcard ``*`` matching any domain.
   *
   * .. note::
   *
   *   The wildcard will not match the empty string.
   *   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
   *   The longest wildcards match first.
   *   Only a single virtual host in the entire route configuration can match on ``*``. A domain
   *   must be unique across all virtual hosts or the config will fail to load.
   *
   * Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
   *
   * @generated from field: repeated string domains = 2;
   */
  domains: string[];

  /**
   * The list of routes that will be matched, in order, for incoming requests.
   * The first route that matches will be used.
   *
   * @generated from field: repeated envoy.api.v2.route.Route routes = 3;
   */
  routes: Route[];

  /**
   * Specifies the type of TLS enforcement the virtual host expects. If this option is not
   * specified, there is no TLS requirement for the virtual host.
   *
   * @generated from field: envoy.api.v2.route.VirtualHost.TlsRequirementType require_tls = 4;
   */
  requireTls: VirtualHost_TlsRequirementType;

  /**
   * A list of virtual clusters defined for this virtual host. Virtual clusters
   * are used for additional statistics gathering.
   *
   * @generated from field: repeated envoy.api.v2.route.VirtualCluster virtual_clusters = 5;
   */
  virtualClusters: VirtualCluster[];

  /**
   * Specifies a set of rate limit configurations that will be applied to the
   * virtual host.
   *
   * @generated from field: repeated envoy.api.v2.route.RateLimit rate_limits = 6;
   */
  rateLimits: RateLimit[];

  /**
   * Specifies a list of HTTP headers that should be added to each request
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
   * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 7;
   */
  requestHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * handled by this virtual host.
   *
   * @generated from field: repeated string request_headers_to_remove = 13;
   */
  requestHeadersToRemove: string[];

  /**
   * Specifies a list of HTTP headers that should be added to each response
   * handled by this virtual host. Headers specified at this level are applied
   * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
   * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;
   */
  responseHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * handled by this virtual host.
   *
   * @generated from field: repeated string response_headers_to_remove = 11;
   */
  responseHeadersToRemove: string[];

  /**
   * Indicates that the virtual host has a CORS policy.
   *
   * @generated from field: envoy.api.v2.route.CorsPolicy cors = 8;
   */
  cors?: CorsPolicy;

  /**
   * The per_filter_config field can be used to provide virtual host-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Struct> per_filter_config = 12 [deprecated = true];
   * @deprecated
   */
  perFilterConfig: { [key: string]: Struct };

  /**
   * The per_filter_config field can be used to provide virtual host-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Any> typed_per_filter_config = 15;
   */
  typedPerFilterConfig: { [key: string]: Any };

  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the upstream request. Setting this option will cause it to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the upstream
   * will see the attempt count as perceived by the second Envoy. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
   *
   * [#next-major-version: rename to include_attempt_count_in_request.]
   *
   * @generated from field: bool include_request_attempt_count = 14;
   */
  includeRequestAttemptCount: boolean;

  /**
   * Decides whether the :ref:`x-envoy-attempt-count
   * <config_http_filters_router_x-envoy-attempt-count>` header should be included
   * in the downstream response. Setting this option will cause the router to override any existing header
   * value, so in the case of two Envoys on the request path with this option enabled, the downstream
   * will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
   * This header is unaffected by the
   * :ref:`suppress_envoy_headers
   * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
   *
   * @generated from field: bool include_attempt_count_in_response = 19;
   */
  includeAttemptCountInResponse: boolean;

  /**
   * Indicates the retry policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   *
   * @generated from field: envoy.api.v2.route.RetryPolicy retry_policy = 16;
   */
  retryPolicy?: RetryPolicy;

  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that setting a route level entry
   * will take precedence over this config and it'll be treated independently (e.g.: values are not
   * inherited). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>` should not be
   * set if this field is used.
   *
   * @generated from field: google.protobuf.Any retry_policy_typed_config = 20;
   */
  retryPolicyTypedConfig?: Any;

  /**
   * Indicates the hedge policy for all routes in this virtual host. Note that setting a
   * route level entry will take precedence over this config and it'll be treated
   * independently (e.g.: values are not inherited).
   *
   * @generated from field: envoy.api.v2.route.HedgePolicy hedge_policy = 17;
   */
  hedgePolicy?: HedgePolicy;

  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
   * value of this and the listener per_connection_buffer_limit_bytes.
   *
   * @generated from field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;
   */
  perRequestBufferLimitBytes?: number;

  constructor(data?: PartialMessage<VirtualHost>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.VirtualHost";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VirtualHost;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VirtualHost;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VirtualHost;

  static equals(a: VirtualHost | PlainMessage<VirtualHost> | undefined, b: VirtualHost | PlainMessage<VirtualHost> | undefined): boolean;
}

/**
 * @generated from enum envoy.api.v2.route.VirtualHost.TlsRequirementType
 */
export declare enum VirtualHost_TlsRequirementType {
  /**
   * No TLS requirement for the virtual host.
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * External requests must use TLS. If a request is external and it is not
   * using TLS, a 301 redirect will be sent telling the client to use HTTPS.
   *
   * @generated from enum value: EXTERNAL_ONLY = 1;
   */
  EXTERNAL_ONLY = 1,

  /**
   * All requests must use TLS. If a request is not using TLS, a 301 redirect
   * will be sent telling the client to use HTTPS.
   *
   * @generated from enum value: ALL = 2;
   */
  ALL = 2,
}

/**
 * A filter-defined action type.
 *
 * @generated from message envoy.api.v2.route.FilterAction
 */
export declare class FilterAction extends Message<FilterAction> {
  /**
   * @generated from field: google.protobuf.Any action = 1;
   */
  action?: Any;

  constructor(data?: PartialMessage<FilterAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.FilterAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterAction;

  static equals(a: FilterAction | PlainMessage<FilterAction> | undefined, b: FilterAction | PlainMessage<FilterAction> | undefined): boolean;
}

/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_api_msg_route.HeaderMatcher>`.
 * [#next-free-field: 18]
 *
 * @generated from message envoy.api.v2.route.Route
 */
export declare class Route extends Message<Route> {
  /**
   * Name for the route.
   *
   * @generated from field: string name = 14;
   */
  name: string;

  /**
   * Route matching parameters.
   *
   * @generated from field: envoy.api.v2.route.RouteMatch match = 1;
   */
  match?: RouteMatch;

  /**
   * @generated from oneof envoy.api.v2.route.Route.action
   */
  action: {
    /**
     * Route request to some upstream cluster.
     *
     * @generated from field: envoy.api.v2.route.RouteAction route = 2;
     */
    value: RouteAction;
    case: "route";
  } | {
    /**
     * Return a redirect.
     *
     * @generated from field: envoy.api.v2.route.RedirectAction redirect = 3;
     */
    value: RedirectAction;
    case: "redirect";
  } | {
    /**
     * Return an arbitrary HTTP response directly, without proxying.
     *
     * @generated from field: envoy.api.v2.route.DirectResponseAction direct_response = 7;
     */
    value: DirectResponseAction;
    case: "directResponse";
  } | {
    /**
     * [#not-implemented-hide:]
     * If true, a filter will define the action (e.g., it could dynamically generate the
     * RouteAction).
     *
     * @generated from field: envoy.api.v2.route.FilterAction filter_action = 17;
     */
    value: FilterAction;
    case: "filterAction";
  } | { case: undefined; value?: undefined };

  /**
   * The Metadata field can be used to provide additional information
   * about the route. It can be used for configuration, stats, and logging.
   * The metadata should go under the filter namespace that will need it.
   * For instance, if the metadata is intended for the Router filter,
   * the filter name should be specified as *envoy.filters.http.router*.
   *
   * @generated from field: envoy.api.v2.core.Metadata metadata = 4;
   */
  metadata?: Metadata;

  /**
   * Decorator for the matched route.
   *
   * @generated from field: envoy.api.v2.route.Decorator decorator = 5;
   */
  decorator?: Decorator;

  /**
   * The per_filter_config field can be used to provide route-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
   * if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];
   * @deprecated
   */
  perFilterConfig: { [key: string]: Struct };

  /**
   * The typed_per_filter_config field can be used to provide route-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
   * if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Any> typed_per_filter_config = 13;
   */
  typedPerFilterConfig: { [key: string]: Any };

  /**
   * Specifies a set of headers that will be added to requests matching this
   * route. Headers specified at this level are applied before headers from the
   * enclosing :ref:`envoy_api_msg_route.VirtualHost` and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 9;
   */
  requestHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each request
   * matching this route.
   *
   * @generated from field: repeated string request_headers_to_remove = 12;
   */
  requestHeadersToRemove: string[];

  /**
   * Specifies a set of headers that will be added to responses to requests
   * matching this route. Headers specified at this level are applied before
   * headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
   * details on header value syntax, see the documentation on
   * :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;
   */
  responseHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each response
   * to requests matching this route.
   *
   * @generated from field: repeated string response_headers_to_remove = 11;
   */
  responseHeadersToRemove: string[];

  /**
   * Presence of the object defines whether the connection manager's tracing configuration
   * is overridden by this route specific instance.
   *
   * @generated from field: envoy.api.v2.route.Tracing tracing = 15;
   */
  tracing?: Tracing;

  /**
   * The maximum bytes which will be buffered for retries and shadowing.
   * If set, the bytes actually buffered will be the minimum value of this and the
   * listener per_connection_buffer_limit_bytes.
   *
   * @generated from field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;
   */
  perRequestBufferLimitBytes?: number;

  constructor(data?: PartialMessage<Route>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.Route";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Route;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Route;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Route;

  static equals(a: Route | PlainMessage<Route> | undefined, b: Route | PlainMessage<Route> | undefined): boolean;
}

/**
 * Compared to the :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 *
 * @generated from message envoy.api.v2.route.WeightedCluster
 */
export declare class WeightedCluster extends Message<WeightedCluster> {
  /**
   * Specifies one or more upstream clusters associated with the route.
   *
   * @generated from field: repeated envoy.api.v2.route.WeightedCluster.ClusterWeight clusters = 1;
   */
  clusters: WeightedCluster_ClusterWeight[];

  /**
   * Specifies the total weight across all clusters. The sum of all cluster weights must equal this
   * value, which must be greater than 0. Defaults to 100.
   *
   * @generated from field: google.protobuf.UInt32Value total_weight = 3;
   */
  totalWeight?: number;

  /**
   * Specifies the runtime key prefix that should be used to construct the
   * runtime keys associated with each cluster. When the *runtime_key_prefix* is
   * specified, the router will look for weights associated with each upstream
   * cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
   * *cluster[i]* denotes an entry in the clusters array field. If the runtime
   * key for the cluster does not exist, the value specified in the
   * configuration file will be used as the default weight. See the :ref:`runtime documentation
   * <operations_runtime>` for how key names map to the underlying implementation.
   *
   * @generated from field: string runtime_key_prefix = 2;
   */
  runtimeKeyPrefix: string;

  constructor(data?: PartialMessage<WeightedCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.WeightedCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WeightedCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WeightedCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WeightedCluster;

  static equals(a: WeightedCluster | PlainMessage<WeightedCluster> | undefined, b: WeightedCluster | PlainMessage<WeightedCluster> | undefined): boolean;
}

/**
 * [#next-free-field: 11]
 *
 * @generated from message envoy.api.v2.route.WeightedCluster.ClusterWeight
 */
export declare class WeightedCluster_ClusterWeight extends Message<WeightedCluster_ClusterWeight> {
  /**
   * Name of the upstream cluster. The cluster must exist in the
   * :ref:`cluster manager configuration <config_cluster_manager>`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * An integer between 0 and :ref:`total_weight
   * <envoy_api_field_route.WeightedCluster.total_weight>`. When a request matches the route,
   * the choice of an upstream cluster is determined by its weight. The sum of weights across all
   * entries in the clusters array must add up to the total_weight, if total_weight is greater than 0.
   *
   * @generated from field: google.protobuf.UInt32Value weight = 2;
   */
  weight?: number;

  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
   * the upstream cluster with metadata matching what is set in this field will be considered for
   * load balancing. Note that this will be merged with what's provided in
   * :ref:`RouteAction.metadata_match <envoy_api_field_route.RouteAction.metadata_match>`, with
   * values here taking precedence. The filter name should be specified as *envoy.lb*.
   *
   * @generated from field: envoy.api.v2.core.Metadata metadata_match = 3;
   */
  metadataMatch?: Metadata;

  /**
   * Specifies a list of headers to be added to requests when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 4;
   */
  requestHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of HTTP headers that should be removed from each request when
   * this cluster is selected through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   *
   * @generated from field: repeated string request_headers_to_remove = 9;
   */
  requestHeadersToRemove: string[];

  /**
   * Specifies a list of headers to be added to responses when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   * Headers specified at this level are applied before headers from the enclosing
   * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
   * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
   * header value syntax, see the documentation on :ref:`custom request headers
   * <config_http_conn_man_headers_custom_request_headers>`.
   *
   * @generated from field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 5;
   */
  responseHeadersToAdd: HeaderValueOption[];

  /**
   * Specifies a list of headers to be removed from responses when this cluster is selected
   * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
   *
   * @generated from field: repeated string response_headers_to_remove = 6;
   */
  responseHeadersToRemove: string[];

  /**
   * The per_filter_config field can be used to provide weighted cluster-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];
   * @deprecated
   */
  perFilterConfig: { [key: string]: Struct };

  /**
   * The per_filter_config field can be used to provide weighted cluster-specific
   * configurations for filters. The key should match the filter name, such as
   * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
   * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
   * for if and how it is utilized.
   *
   * @generated from field: map<string, google.protobuf.Any> typed_per_filter_config = 10;
   */
  typedPerFilterConfig: { [key: string]: Any };

  constructor(data?: PartialMessage<WeightedCluster_ClusterWeight>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.WeightedCluster.ClusterWeight";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WeightedCluster_ClusterWeight;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WeightedCluster_ClusterWeight;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WeightedCluster_ClusterWeight;

  static equals(a: WeightedCluster_ClusterWeight | PlainMessage<WeightedCluster_ClusterWeight> | undefined, b: WeightedCluster_ClusterWeight | PlainMessage<WeightedCluster_ClusterWeight> | undefined): boolean;
}

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.RouteMatch
 */
export declare class RouteMatch extends Message<RouteMatch> {
  /**
   * @generated from oneof envoy.api.v2.route.RouteMatch.path_specifier
   */
  pathSpecifier: {
    /**
     * If specified, the route is a prefix rule meaning that the prefix must
     * match the beginning of the *:path* header.
     *
     * @generated from field: string prefix = 1;
     */
    value: string;
    case: "prefix";
  } | {
    /**
     * If specified, the route is an exact path rule meaning that the path must
     * exactly match the *:path* header once the query string is removed.
     *
     * @generated from field: string path = 2;
     */
    value: string;
    case: "path";
  } | {
    /**
     * If specified, the route is a regular expression rule meaning that the
     * regex must match the *:path* header once the query string is removed. The entire path
     * (without the query string) must match the regex. The rule will not match if only a
     * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
     * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
     *
     * Examples:
     *
     * * The regex ``/b[io]t`` matches the path *\/bit*
     * * The regex ``/b[io]t`` matches the path *\/bot*
     * * The regex ``/b[io]t`` does not match the path *\/bite*
     * * The regex ``/b[io]t`` does not match the path *\/bit/bot*
     *
     * .. attention::
     *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
     *   untrusted input in all cases.
     *
     * @generated from field: string regex = 3 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "regex";
  } | {
    /**
     * If specified, the route is a regular expression rule meaning that the
     * regex must match the *:path* header once the query string is removed. The entire path
     * (without the query string) must match the regex. The rule will not match if only a
     * subsequence of the *:path* header matches the regex.
     *
     * [#next-major-version: In the v3 API we should redo how path specification works such
     * that we utilize StringMatcher, and additionally have consistent options around whether we
     * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
     * to deprecate the existing options. We should even consider whether we want to do away with
     * path_specifier entirely and just rely on a set of header matchers which can already match
     * on :path, etc. The issue with that is it is unclear how to generically deal with query string
     * stripping. This needs more thought.]
     *
     * @generated from field: envoy.type.matcher.RegexMatcher safe_regex = 10;
     */
    value: RegexMatcher;
    case: "safeRegex";
  } | { case: undefined; value?: undefined };

  /**
   * Indicates that prefix/path matching should be case sensitive. The default
   * is true.
   *
   * @generated from field: google.protobuf.BoolValue case_sensitive = 4;
   */
  caseSensitive?: boolean;

  /**
   * Indicates that the route should additionally match on a runtime key. Every time the route
   * is considered for a match, it must also fall under the percentage of matches indicated by
   * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
   * route configuration can be used to roll out route changes in a gradual manner without full
   * code/config deploys. Refer to the :ref:`traffic shifting
   * <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
   *
   * .. note::
   *
   *    Parsing this field is implemented such that the runtime key's data may be represented
   *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
   *    integer with the assumption that the value is an integral percentage out of 100. For
   *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
   *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
   *
   * @generated from field: envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;
   */
  runtimeFraction?: RuntimeFractionalPercent;

  /**
   * Specifies a set of headers that the route should match on. The router will
   * check the request’s headers against all the specified headers in the route
   * config. A match will happen if all the headers in the route are present in
   * the request with the same values (or based on presence if the value field
   * is not in the config).
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher headers = 6;
   */
  headers: HeaderMatcher[];

  /**
   * Specifies a set of URL query parameters on which the route should
   * match. The router will check the query string from the *path* header
   * against all the specified query parameters. If the number of specified
   * query parameters is nonzero, they all must match the *path* header's
   * query string for a match to occur.
   *
   * @generated from field: repeated envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;
   */
  queryParameters: QueryParameterMatcher[];

  /**
   * If specified, only gRPC requests will be matched. The router will check
   * that the content-type header has a application/grpc or one of the various
   * application/grpc+ values.
   *
   * @generated from field: envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;
   */
  grpc?: RouteMatch_GrpcRouteMatchOptions;

  /**
   * If specified, the client tls context will be matched against the defined
   * match options.
   *
   * [#next-major-version: unify with RBAC]
   *
   * @generated from field: envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;
   */
  tlsContext?: RouteMatch_TlsContextMatchOptions;

  constructor(data?: PartialMessage<RouteMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatch;

  static equals(a: RouteMatch | PlainMessage<RouteMatch> | undefined, b: RouteMatch | PlainMessage<RouteMatch> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions
 */
export declare class RouteMatch_GrpcRouteMatchOptions extends Message<RouteMatch_GrpcRouteMatchOptions> {
  constructor(data?: PartialMessage<RouteMatch_GrpcRouteMatchOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatch_GrpcRouteMatchOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatch_GrpcRouteMatchOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatch_GrpcRouteMatchOptions;

  static equals(a: RouteMatch_GrpcRouteMatchOptions | PlainMessage<RouteMatch_GrpcRouteMatchOptions> | undefined, b: RouteMatch_GrpcRouteMatchOptions | PlainMessage<RouteMatch_GrpcRouteMatchOptions> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteMatch.TlsContextMatchOptions
 */
export declare class RouteMatch_TlsContextMatchOptions extends Message<RouteMatch_TlsContextMatchOptions> {
  /**
   * If specified, the route will match against whether or not a certificate is presented.
   * If not specified, certificate presentation status (true or false) will not be considered when route matching.
   *
   * @generated from field: google.protobuf.BoolValue presented = 1;
   */
  presented?: boolean;

  /**
   * If specified, the route will match against whether or not a certificate is validated.
   * If not specified, certificate validation status (true or false) will not be considered when route matching.
   *
   * @generated from field: google.protobuf.BoolValue validated = 2;
   */
  validated?: boolean;

  constructor(data?: PartialMessage<RouteMatch_TlsContextMatchOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteMatch_TlsContextMatchOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteMatch_TlsContextMatchOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteMatch_TlsContextMatchOptions;

  static equals(a: RouteMatch_TlsContextMatchOptions | PlainMessage<RouteMatch_TlsContextMatchOptions> | undefined, b: RouteMatch_TlsContextMatchOptions | PlainMessage<RouteMatch_TlsContextMatchOptions> | undefined): boolean;
}

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.CorsPolicy
 */
export declare class CorsPolicy extends Message<CorsPolicy> {
  /**
   * Specifies the origins that will be allowed to do CORS requests.
   *
   * An origin is allowed if either allow_origin or allow_origin_regex match.
   *
   * .. attention::
   *  This field has been deprecated in favor of `allow_origin_string_match`.
   *
   * @generated from field: repeated string allow_origin = 1 [deprecated = true];
   * @deprecated
   */
  allowOrigin: string[];

  /**
   * Specifies regex patterns that match allowed origins.
   *
   * An origin is allowed if either allow_origin or allow_origin_regex match.
   *
   * .. attention::
   *   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
   *   use with untrusted input in all cases.
   *
   * @generated from field: repeated string allow_origin_regex = 8 [deprecated = true];
   * @deprecated
   */
  allowOriginRegex: string[];

  /**
   * Specifies string patterns that match allowed origins. An origin is allowed if any of the
   * string matchers match.
   *
   * @generated from field: repeated envoy.type.matcher.StringMatcher allow_origin_string_match = 11;
   */
  allowOriginStringMatch: StringMatcher[];

  /**
   * Specifies the content for the *access-control-allow-methods* header.
   *
   * @generated from field: string allow_methods = 2;
   */
  allowMethods: string;

  /**
   * Specifies the content for the *access-control-allow-headers* header.
   *
   * @generated from field: string allow_headers = 3;
   */
  allowHeaders: string;

  /**
   * Specifies the content for the *access-control-expose-headers* header.
   *
   * @generated from field: string expose_headers = 4;
   */
  exposeHeaders: string;

  /**
   * Specifies the content for the *access-control-max-age* header.
   *
   * @generated from field: string max_age = 5;
   */
  maxAge: string;

  /**
   * Specifies whether the resource allows credentials.
   *
   * @generated from field: google.protobuf.BoolValue allow_credentials = 6;
   */
  allowCredentials?: boolean;

  /**
   * @generated from oneof envoy.api.v2.route.CorsPolicy.enabled_specifier
   */
  enabledSpecifier: {
    /**
     * Specifies if the CORS filter is enabled. Defaults to true. Only effective on route.
     *
     * .. attention::
     *
     *   **This field is deprecated**. Set the
     *   :ref:`filter_enabled<envoy_api_field_route.CorsPolicy.filter_enabled>` field instead.
     *
     * @generated from field: google.protobuf.BoolValue enabled = 7 [deprecated = true];
     * @deprecated
     */
    value: BoolValue;
    case: "enabled";
  } | {
    /**
     * Specifies the % of requests for which the CORS filter is enabled.
     *
     * If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
     * filter will be enabled for 100% of the requests.
     *
     * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is
     * specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
     *
     * @generated from field: envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9;
     */
    value: RuntimeFractionalPercent;
    case: "filterEnabled";
  } | { case: undefined; value?: undefined };

  /**
   * Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
   * enforced.
   *
   * This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
   * fields have to explicitly disable the filter in order for this setting to take effect.
   *
   * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
   * Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
   * and track the request's *Origin* to determine if it's valid but will not enforce any policies.
   *
   * @generated from field: envoy.api.v2.core.RuntimeFractionalPercent shadow_enabled = 10;
   */
  shadowEnabled?: RuntimeFractionalPercent;

  constructor(data?: PartialMessage<CorsPolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.CorsPolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CorsPolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CorsPolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CorsPolicy;

  static equals(a: CorsPolicy | PlainMessage<CorsPolicy> | undefined, b: CorsPolicy | PlainMessage<CorsPolicy> | undefined): boolean;
}

/**
 * [#next-free-field: 34]
 *
 * @generated from message envoy.api.v2.route.RouteAction
 */
export declare class RouteAction extends Message<RouteAction> {
  /**
   * @generated from oneof envoy.api.v2.route.RouteAction.cluster_specifier
   */
  clusterSpecifier: {
    /**
     * Indicates the upstream cluster to which the request should be routed
     * to.
     *
     * @generated from field: string cluster = 1;
     */
    value: string;
    case: "cluster";
  } | {
    /**
     * Envoy will determine the cluster to route to by reading the value of the
     * HTTP header named by cluster_header from the request headers. If the
     * header is not found or the referenced cluster does not exist, Envoy will
     * return a 404 response.
     *
     * .. attention::
     *
     *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
     *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from field: string cluster_header = 2;
     */
    value: string;
    case: "clusterHeader";
  } | {
    /**
     * Multiple upstream clusters can be specified for a given route. The
     * request is routed to one of the upstream clusters based on weights
     * assigned to each cluster. See
     * :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
     * for additional documentation.
     *
     * @generated from field: envoy.api.v2.route.WeightedCluster weighted_clusters = 3;
     */
    value: WeightedCluster;
    case: "weightedClusters";
  } | { case: undefined; value?: undefined };

  /**
   * The HTTP status code to use when configured cluster is not found.
   * The default response code is 503 Service Unavailable.
   *
   * @generated from field: envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20;
   */
  clusterNotFoundResponseCode: RouteAction_ClusterNotFoundResponseCode;

  /**
   * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
   * in the upstream cluster with metadata matching what's set in this field will be considered
   * for load balancing. If using :ref:`weighted_clusters
   * <envoy_api_field_route.RouteAction.weighted_clusters>`, metadata will be merged, with values
   * provided there taking precedence. The filter name should be specified as *envoy.lb*.
   *
   * @generated from field: envoy.api.v2.core.Metadata metadata_match = 4;
   */
  metadataMatch?: Metadata;

  /**
   * Indicates that during forwarding, the matched prefix (or path) should be
   * swapped with this value. This option allows application URLs to be rooted
   * at a different path from those exposed at the reverse proxy layer. The router filter will
   * place the original path before rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of *prefix_rewrite* or
   * :ref:`regex_rewrite <envoy_api_field_route.RouteAction.regex_rewrite>`
   * may be specified.
   *
   * .. attention::
   *
   *   Pay careful attention to the use of trailing slashes in the
   *   :ref:`route's match <envoy_api_field_route.Route.match>` prefix value.
   *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
   *   rewriting *\/prefix* to *\/* and *\/prefix/etc* to *\/etc* cannot be done in a single
   *   :ref:`Route <envoy_api_msg_route.Route>`, as shown by the below config entries:
   *
   *   .. code-block:: yaml
   *
   *     - match:
   *         prefix: "/prefix/"
   *       route:
   *         prefix_rewrite: "/"
   *     - match:
   *         prefix: "/prefix"
   *       route:
   *         prefix_rewrite: "/"
   *
   *   Having above entries in the config, requests to *\/prefix* will be stripped to *\/*, while
   *   requests to *\/prefix/etc* will be stripped to *\/etc*.
   *
   * @generated from field: string prefix_rewrite = 5;
   */
  prefixRewrite: string;

  /**
   * Indicates that during forwarding, portions of the path that match the
   * pattern should be rewritten, even allowing the substitution of capture
   * groups from the pattern into the new path as specified by the rewrite
   * substitution string. This is useful to allow application paths to be
   * rewritten in a way that is aware of segments with variable content like
   * identifiers. The router filter will place the original path as it was
   * before the rewrite into the :ref:`x-envoy-original-path
   * <config_http_filters_router_x-envoy-original-path>` header.
   *
   * Only one of :ref:`prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`
   * or *regex_rewrite* may be specified.
   *
   * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
   *
   * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
   *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
   *   into ``/v1/api/instance/foo``.
   *
   * * The pattern ``one`` paired with a substitution string of ``two`` would
   *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
   *
   * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
   *   ``\1two\2`` would replace only the first occurrence of ``one``,
   *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
   *
   * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
   *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
   *   ``/aaa/yyy/bbb``.
   *
   * @generated from field: envoy.type.matcher.RegexMatchAndSubstitute regex_rewrite = 32;
   */
  regexRewrite?: RegexMatchAndSubstitute;

  /**
   * @generated from oneof envoy.api.v2.route.RouteAction.host_rewrite_specifier
   */
  hostRewriteSpecifier: {
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * this value.
     *
     * @generated from field: string host_rewrite = 6;
     */
    value: string;
    case: "hostRewrite";
  } | {
    /**
     * Indicates that during forwarding, the host header will be swapped with
     * the hostname of the upstream host chosen by the cluster manager. This
     * option is applicable only when the destination cluster for a route is of
     * type ``STRICT_DNS``,  ``LOGICAL_DNS`` or ``STATIC``. For ``STATIC`` clusters, the
     * hostname attribute of the endpoint must be configured. Setting this to true
     * with other cluster types has no effect.
     *
     * @generated from field: google.protobuf.BoolValue auto_host_rewrite = 7;
     */
    value: BoolValue;
    case: "autoHostRewrite";
  } | {
    /**
     * Indicates that during forwarding, the host header will be swapped with the content of given
     * downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
     * If header value is empty, host header is left intact.
     *
     * .. attention::
     *
     *   Pay attention to the potential security implications of using this option. Provided header
     *   must come from trusted source.
     *
     * .. note::
     *
     *   If the header appears multiple times only the first value is used.
     *
     * @generated from field: string auto_host_rewrite_header = 29;
     */
    value: string;
    case: "autoHostRewriteHeader";
  } | { case: undefined; value?: undefined };

  /**
   * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
   * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
   * processed and when the upstream response has been completely processed. A value of 0 will
   * disable the route's timeout.
   *
   * .. note::
   *
   *   This timeout includes all retries. See also
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *   :ref:`retry overview <arch_overview_http_routing_retry>`.
   *
   * @generated from field: google.protobuf.Duration timeout = 8;
   */
  timeout?: Duration;

  /**
   * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
   * although the connection manager wide :ref:`stream_idle_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
   * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
   * connection manager stream idle timeout is configured.
   *
   * The idle timeout is distinct to :ref:`timeout
   * <envoy_api_field_route.RouteAction.timeout>`, which provides an upper bound
   * on the upstream response time; :ref:`idle_timeout
   * <envoy_api_field_route.RouteAction.idle_timeout>` instead bounds the amount
   * of time the request's stream may be idle.
   *
   * After header decoding, the idle timeout will apply on downstream and
   * upstream request events. Each time an encode/decode event for headers or
   * data is processed for the stream, the timer will be reset. If the timeout
   * fires, the stream is terminated with a 408 Request Timeout error code if no
   * upstream response header has been received, otherwise a stream reset
   * occurs.
   *
   * @generated from field: google.protobuf.Duration idle_timeout = 24;
   */
  idleTimeout?: Duration;

  /**
   * Indicates that the route has a retry policy. Note that if this is set,
   * it'll take precedence over the virtual host level retry policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   *
   * @generated from field: envoy.api.v2.route.RetryPolicy retry_policy = 9;
   */
  retryPolicy?: RetryPolicy;

  /**
   * [#not-implemented-hide:]
   * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
   * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
   * most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>`
   * should not be set if this field is used.
   *
   * @generated from field: google.protobuf.Any retry_policy_typed_config = 33;
   */
  retryPolicyTypedConfig?: Any;

  /**
   * Indicates that the route has a request mirroring policy.
   *
   * .. attention::
   *   This field has been deprecated in favor of `request_mirror_policies` which supports one or
   *   more mirroring policies.
   *
   * @generated from field: envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policy = 10 [deprecated = true];
   * @deprecated
   */
  requestMirrorPolicy?: RouteAction_RequestMirrorPolicy;

  /**
   * Indicates that the route has request mirroring policies.
   *
   * @generated from field: repeated envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;
   */
  requestMirrorPolicies: RouteAction_RequestMirrorPolicy[];

  /**
   * Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
   *
   * @generated from field: envoy.api.v2.core.RoutingPriority priority = 11;
   */
  priority: RoutingPriority;

  /**
   * Specifies a set of rate limit configurations that could be applied to the
   * route.
   *
   * @generated from field: repeated envoy.api.v2.route.RateLimit rate_limits = 13;
   */
  rateLimits: RateLimit[];

  /**
   * Specifies if the rate limit filter should include the virtual host rate
   * limits. By default, if the route configured rate limits, the virtual host
   * :ref:`rate_limits <envoy_api_field_route.VirtualHost.rate_limits>` are not applied to the
   * request.
   *
   * @generated from field: google.protobuf.BoolValue include_vh_rate_limits = 14;
   */
  includeVhRateLimits?: boolean;

  /**
   * Specifies a list of hash policies to use for ring hash load balancing. Each
   * hash policy is evaluated individually and the combined result is used to
   * route the request. The method of combination is deterministic such that
   * identical lists of hash policies will produce the same hash. Since a hash
   * policy examines specific parts of a request, it can fail to produce a hash
   * (i.e. if the hashed header is not present). If (and only if) all configured
   * hash policies fail to generate a hash, no hash will be produced for
   * the route. In this case, the behavior is the same as if no hash policies
   * were specified (i.e. the ring hash load balancer will choose a random
   * backend). If a hash policy has the "terminal" attribute set to true, and
   * there is already a hash generated, the hash is returned immediately,
   * ignoring the rest of the hash policy list.
   *
   * @generated from field: repeated envoy.api.v2.route.RouteAction.HashPolicy hash_policy = 15;
   */
  hashPolicy: RouteAction_HashPolicy[];

  /**
   * Indicates that the route has a CORS policy.
   *
   * @generated from field: envoy.api.v2.route.CorsPolicy cors = 17;
   */
  cors?: CorsPolicy;

  /**
   * If present, and the request is a gRPC request, use the
   * `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
   * or its default value (infinity) instead of
   * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>`, but limit the applied timeout
   * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
   * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
   * and gRPC requests time out like any other requests using
   * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>` or its default.
   * This can be used to prevent unexpected upstream request timeouts due to potentially long
   * time gaps between gRPC request and response in gRPC streaming mode.
   *
   * .. note::
   *
   *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
   *    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
   *    both are present. See also
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
   *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
   *    :ref:`retry overview <arch_overview_http_routing_retry>`.
   *
   * @generated from field: google.protobuf.Duration max_grpc_timeout = 23;
   */
  maxGrpcTimeout?: Duration;

  /**
   * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
   * the provided duration from the header. This is useful in allowing Envoy to set its global
   * timeout to be less than that of the deadline imposed by the calling client, which makes it more
   * likely that Envoy will handle the timeout instead of having the call canceled by the client.
   * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
   * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
   * infinity).
   *
   * @generated from field: google.protobuf.Duration grpc_timeout_offset = 28;
   */
  grpcTimeoutOffset?: Duration;

  /**
   * @generated from field: repeated envoy.api.v2.route.RouteAction.UpgradeConfig upgrade_configs = 25;
   */
  upgradeConfigs: RouteAction_UpgradeConfig[];

  /**
   * @generated from field: envoy.api.v2.route.RouteAction.InternalRedirectAction internal_redirect_action = 26;
   */
  internalRedirectAction: RouteAction_InternalRedirectAction;

  /**
   * An internal redirect is handled, iff the number of previous internal redirects that a
   * downstream request has encountered is lower than this value, and
   * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
   * is set to :ref:`HANDLE_INTERNAL_REDIRECT
   * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
   * In the case where a downstream request is bounced among multiple routes by internal redirect,
   * the first route that hits this threshold, or has
   * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
   * set to
   * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
   * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
   * will pass the redirect back to downstream.
   *
   * If not specified, at most one redirect will be followed.
   *
   * @generated from field: google.protobuf.UInt32Value max_internal_redirects = 31;
   */
  maxInternalRedirects?: number;

  /**
   * Indicates that the route has a hedge policy. Note that if this is set,
   * it'll take precedence over the virtual host level hedge policy entirely
   * (e.g.: policies are not merged, most internal one becomes the enforced policy).
   *
   * @generated from field: envoy.api.v2.route.HedgePolicy hedge_policy = 27;
   */
  hedgePolicy?: HedgePolicy;

  constructor(data?: PartialMessage<RouteAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction;

  static equals(a: RouteAction | PlainMessage<RouteAction> | undefined, b: RouteAction | PlainMessage<RouteAction> | undefined): boolean;
}

/**
 * @generated from enum envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode
 */
export declare enum RouteAction_ClusterNotFoundResponseCode {
  /**
   * HTTP status code - 503 Service Unavailable.
   *
   * @generated from enum value: SERVICE_UNAVAILABLE = 0;
   */
  SERVICE_UNAVAILABLE = 0,

  /**
   * HTTP status code - 404 Not Found.
   *
   * @generated from enum value: NOT_FOUND = 1;
   */
  NOT_FOUND = 1,
}

/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 *
 * @generated from enum envoy.api.v2.route.RouteAction.InternalRedirectAction
 */
export declare enum RouteAction_InternalRedirectAction {
  /**
   * @generated from enum value: PASS_THROUGH_INTERNAL_REDIRECT = 0;
   */
  PASS_THROUGH_INTERNAL_REDIRECT = 0,

  /**
   * @generated from enum value: HANDLE_INTERNAL_REDIRECT = 1;
   */
  HANDLE_INTERNAL_REDIRECT = 1,
}

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
 * useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * @generated from message envoy.api.v2.route.RouteAction.RequestMirrorPolicy
 */
export declare class RouteAction_RequestMirrorPolicy extends Message<RouteAction_RequestMirrorPolicy> {
  /**
   * Specifies the cluster that requests will be mirrored to. The cluster must
   * exist in the cluster manager configuration.
   *
   * @generated from field: string cluster = 1;
   */
  cluster: string;

  /**
   * If not specified, all requests to the target cluster will be mirrored. If
   * specified, Envoy will lookup the runtime key to get the % of requests to
   * mirror. Valid values are from 0 to 10000, allowing for increments of
   * 0.01% of requests to be mirrored. If the runtime key is specified in the
   * configuration but not present in runtime, 0 is the default and thus 0% of
   * requests will be mirrored.
   *
   * .. attention::
   *
   *   **This field is deprecated**. Set the
   *   :ref:`runtime_fraction
   *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
   *   field instead. Mirroring occurs if both this and
   *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
   *   are not set.
   *
   * @generated from field: string runtime_key = 2 [deprecated = true];
   * @deprecated
   */
  runtimeKey: string;

  /**
   * If not specified, all requests to the target cluster will be mirrored.
   *
   * If specified, this field takes precedence over the `runtime_key` field and requests must also
   * fall under the percentage of matches indicated by this field.
   *
   * For some fraction N/D, a random number in the range [0,D) is selected. If the
   * number is <= the value of the numerator N, or if the key is not present, the default
   * value, the request will be mirrored.
   *
   * @generated from field: envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 3;
   */
  runtimeFraction?: RuntimeFractionalPercent;

  /**
   * Determines if the trace span should be sampled. Defaults to true.
   *
   * @generated from field: google.protobuf.BoolValue trace_sampled = 4;
   */
  traceSampled?: boolean;

  constructor(data?: PartialMessage<RouteAction_RequestMirrorPolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.RequestMirrorPolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_RequestMirrorPolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_RequestMirrorPolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_RequestMirrorPolicy;

  static equals(a: RouteAction_RequestMirrorPolicy | PlainMessage<RouteAction_RequestMirrorPolicy> | undefined, b: RouteAction_RequestMirrorPolicy | PlainMessage<RouteAction_RequestMirrorPolicy> | undefined): boolean;
}

/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy
 */
export declare class RouteAction_HashPolicy extends Message<RouteAction_HashPolicy> {
  /**
   * @generated from oneof envoy.api.v2.route.RouteAction.HashPolicy.policy_specifier
   */
  policySpecifier: {
    /**
     * Header hash policy.
     *
     * @generated from field: envoy.api.v2.route.RouteAction.HashPolicy.Header header = 1;
     */
    value: RouteAction_HashPolicy_Header;
    case: "header";
  } | {
    /**
     * Cookie hash policy.
     *
     * @generated from field: envoy.api.v2.route.RouteAction.HashPolicy.Cookie cookie = 2;
     */
    value: RouteAction_HashPolicy_Cookie;
    case: "cookie";
  } | {
    /**
     * Connection properties hash policy.
     *
     * @generated from field: envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;
     */
    value: RouteAction_HashPolicy_ConnectionProperties;
    case: "connectionProperties";
  } | {
    /**
     * Query parameter hash policy.
     *
     * @generated from field: envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter query_parameter = 5;
     */
    value: RouteAction_HashPolicy_QueryParameter;
    case: "queryParameter";
  } | {
    /**
     * Filter state hash policy.
     *
     * @generated from field: envoy.api.v2.route.RouteAction.HashPolicy.FilterState filter_state = 6;
     */
    value: RouteAction_HashPolicy_FilterState;
    case: "filterState";
  } | { case: undefined; value?: undefined };

  /**
   * The flag that short-circuits the hash computing. This field provides a
   * 'fallback' style of configuration: "if a terminal policy doesn't work,
   * fallback to rest of the policy list", it saves time when the terminal
   * policy works.
   *
   * If true, and there is already a hash computed, ignore rest of the
   * list of hash polices.
   * For example, if the following hash methods are configured:
   *
   *  ========= ========
   *  specifier terminal
   *  ========= ========
   *  Header A  true
   *  Header B  false
   *  Header C  false
   *  ========= ========
   *
   * The generateHash process ends if policy "header A" generates a hash, as
   * it's a terminal policy.
   *
   * @generated from field: bool terminal = 4;
   */
  terminal: boolean;

  constructor(data?: PartialMessage<RouteAction_HashPolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy;

  static equals(a: RouteAction_HashPolicy | PlainMessage<RouteAction_HashPolicy> | undefined, b: RouteAction_HashPolicy | PlainMessage<RouteAction_HashPolicy> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.Header
 */
export declare class RouteAction_HashPolicy_Header extends Message<RouteAction_HashPolicy_Header> {
  /**
   * The name of the request header that will be used to obtain the hash
   * key. If the request header is not present, no hash will be produced.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  constructor(data?: PartialMessage<RouteAction_HashPolicy_Header>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy.Header";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy_Header;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_Header;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_Header;

  static equals(a: RouteAction_HashPolicy_Header | PlainMessage<RouteAction_HashPolicy_Header> | undefined, b: RouteAction_HashPolicy_Header | PlainMessage<RouteAction_HashPolicy_Header> | undefined): boolean;
}

/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 *
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.Cookie
 */
export declare class RouteAction_HashPolicy_Cookie extends Message<RouteAction_HashPolicy_Cookie> {
  /**
   * The name of the cookie that will be used to obtain the hash key. If the
   * cookie is not present and ttl below is not set, no hash will be
   * produced.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If specified, a cookie with the TTL will be generated if the cookie is
   * not present. If the TTL is present and zero, the generated cookie will
   * be a session cookie.
   *
   * @generated from field: google.protobuf.Duration ttl = 2;
   */
  ttl?: Duration;

  /**
   * The name of the path for the cookie. If no path is specified here, no path
   * will be set for the cookie.
   *
   * @generated from field: string path = 3;
   */
  path: string;

  constructor(data?: PartialMessage<RouteAction_HashPolicy_Cookie>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy.Cookie";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy_Cookie;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_Cookie;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_Cookie;

  static equals(a: RouteAction_HashPolicy_Cookie | PlainMessage<RouteAction_HashPolicy_Cookie> | undefined, b: RouteAction_HashPolicy_Cookie | PlainMessage<RouteAction_HashPolicy_Cookie> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties
 */
export declare class RouteAction_HashPolicy_ConnectionProperties extends Message<RouteAction_HashPolicy_ConnectionProperties> {
  /**
   * Hash on source IP address.
   *
   * @generated from field: bool source_ip = 1;
   */
  sourceIp: boolean;

  constructor(data?: PartialMessage<RouteAction_HashPolicy_ConnectionProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy_ConnectionProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_ConnectionProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_ConnectionProperties;

  static equals(a: RouteAction_HashPolicy_ConnectionProperties | PlainMessage<RouteAction_HashPolicy_ConnectionProperties> | undefined, b: RouteAction_HashPolicy_ConnectionProperties | PlainMessage<RouteAction_HashPolicy_ConnectionProperties> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter
 */
export declare class RouteAction_HashPolicy_QueryParameter extends Message<RouteAction_HashPolicy_QueryParameter> {
  /**
   * The name of the URL query parameter that will be used to obtain the hash
   * key. If the parameter is not present, no hash will be produced. Query
   * parameter names are case-sensitive.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  constructor(data?: PartialMessage<RouteAction_HashPolicy_QueryParameter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy_QueryParameter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_QueryParameter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_QueryParameter;

  static equals(a: RouteAction_HashPolicy_QueryParameter | PlainMessage<RouteAction_HashPolicy_QueryParameter> | undefined, b: RouteAction_HashPolicy_QueryParameter | PlainMessage<RouteAction_HashPolicy_QueryParameter> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.FilterState
 */
export declare class RouteAction_HashPolicy_FilterState extends Message<RouteAction_HashPolicy_FilterState> {
  /**
   * The name of the Object in the per-request filterState, which is an
   * Envoy::Hashable object. If there is no data associated with the key,
   * or the stored object is not Envoy::Hashable, no hash will be produced.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  constructor(data?: PartialMessage<RouteAction_HashPolicy_FilterState>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.HashPolicy.FilterState";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_HashPolicy_FilterState;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_FilterState;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_HashPolicy_FilterState;

  static equals(a: RouteAction_HashPolicy_FilterState | PlainMessage<RouteAction_HashPolicy_FilterState> | undefined, b: RouteAction_HashPolicy_FilterState | PlainMessage<RouteAction_HashPolicy_FilterState> | undefined): boolean;
}

/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 *
 * @generated from message envoy.api.v2.route.RouteAction.UpgradeConfig
 */
export declare class RouteAction_UpgradeConfig extends Message<RouteAction_UpgradeConfig> {
  /**
   * The case-insensitive name of this upgrade, e.g. "websocket".
   * For each upgrade type present in upgrade_configs, requests with
   * Upgrade: [upgrade_type] will be proxied upstream.
   *
   * @generated from field: string upgrade_type = 1;
   */
  upgradeType: string;

  /**
   * Determines if upgrades are available on this route. Defaults to true.
   *
   * @generated from field: google.protobuf.BoolValue enabled = 2;
   */
  enabled?: boolean;

  constructor(data?: PartialMessage<RouteAction_UpgradeConfig>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RouteAction.UpgradeConfig";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteAction_UpgradeConfig;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteAction_UpgradeConfig;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteAction_UpgradeConfig;

  static equals(a: RouteAction_UpgradeConfig | PlainMessage<RouteAction_UpgradeConfig> | undefined, b: RouteAction_UpgradeConfig | PlainMessage<RouteAction_UpgradeConfig> | undefined): boolean;
}

/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.api.v2.route.RetryPolicy
 */
export declare class RetryPolicy extends Message<RetryPolicy> {
  /**
   * Specifies the conditions under which retry takes place. These are the same
   * conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
   * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
   *
   * @generated from field: string retry_on = 1;
   */
  retryOn: string;

  /**
   * Specifies the allowed number of retries. This parameter is optional and
   * defaults to 1. These are the same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-max-retries`.
   *
   * @generated from field: google.protobuf.UInt32Value num_retries = 2;
   */
  numRetries?: number;

  /**
   * Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
   * same conditions documented for
   * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
   *
   * .. note::
   *
   *   If left unspecified, Envoy will use the global
   *   :ref:`route timeout <envoy_api_field_route.RouteAction.timeout>` for the request.
   *   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
   *   retry policy, a request that times out will not be retried as the total timeout budget
   *   would have been exhausted.
   *
   * @generated from field: google.protobuf.Duration per_try_timeout = 3;
   */
  perTryTimeout?: Duration;

  /**
   * Specifies an implementation of a RetryPriority which is used to determine the
   * distribution of load across priorities used for retries. Refer to
   * :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
   *
   * @generated from field: envoy.api.v2.route.RetryPolicy.RetryPriority retry_priority = 4;
   */
  retryPriority?: RetryPolicy_RetryPriority;

  /**
   * Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
   * for retries. If any of the predicates reject the host, host selection will be reattempted.
   * Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
   * details.
   *
   * @generated from field: repeated envoy.api.v2.route.RetryPolicy.RetryHostPredicate retry_host_predicate = 5;
   */
  retryHostPredicate: RetryPolicy_RetryHostPredicate[];

  /**
   * The maximum number of times host selection will be reattempted before giving up, at which
   * point the host that was last selected will be routed to. If unspecified, this will default to
   * retrying once.
   *
   * @generated from field: int64 host_selection_retry_max_attempts = 6;
   */
  hostSelectionRetryMaxAttempts: bigint;

  /**
   * HTTP status codes that should trigger a retry in addition to those specified by retry_on.
   *
   * @generated from field: repeated uint32 retriable_status_codes = 7;
   */
  retriableStatusCodes: number[];

  /**
   * Specifies parameters that control retry back off. This parameter is optional, in which case the
   * default base interval is 25 milliseconds or, if set, the current value of the
   * `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
   * the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
   * describes Envoy's back-off algorithm.
   *
   * @generated from field: envoy.api.v2.route.RetryPolicy.RetryBackOff retry_back_off = 8;
   */
  retryBackOff?: RetryPolicy_RetryBackOff;

  /**
   * HTTP response headers that trigger a retry if present in the response. A retry will be
   * triggered if any of the header matches match the upstream response headers.
   * The field is only consulted if 'retriable-headers' retry policy is active.
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher retriable_headers = 9;
   */
  retriableHeaders: HeaderMatcher[];

  /**
   * HTTP headers which must be present in the request for retries to be attempted.
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher retriable_request_headers = 10;
   */
  retriableRequestHeaders: HeaderMatcher[];

  constructor(data?: PartialMessage<RetryPolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RetryPolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy;

  static equals(a: RetryPolicy | PlainMessage<RetryPolicy> | undefined, b: RetryPolicy | PlainMessage<RetryPolicy> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryPriority
 */
export declare class RetryPolicy_RetryPriority extends Message<RetryPolicy_RetryPriority> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.api.v2.route.RetryPolicy.RetryPriority.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Struct config = 2 [deprecated = true];
     * @deprecated
     */
    value: Struct;
    case: "config";
  } | {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RetryPolicy_RetryPriority>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RetryPolicy.RetryPriority";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy_RetryPriority;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy_RetryPriority;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy_RetryPriority;

  static equals(a: RetryPolicy_RetryPriority | PlainMessage<RetryPolicy_RetryPriority> | undefined, b: RetryPolicy_RetryPriority | PlainMessage<RetryPolicy_RetryPriority> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryHostPredicate
 */
export declare class RetryPolicy_RetryHostPredicate extends Message<RetryPolicy_RetryHostPredicate> {
  /**
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof envoy.api.v2.route.RetryPolicy.RetryHostPredicate.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Struct config = 2 [deprecated = true];
     * @deprecated
     */
    value: Struct;
    case: "config";
  } | {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RetryPolicy_RetryHostPredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RetryPolicy.RetryHostPredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy_RetryHostPredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy_RetryHostPredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy_RetryHostPredicate;

  static equals(a: RetryPolicy_RetryHostPredicate | PlainMessage<RetryPolicy_RetryHostPredicate> | undefined, b: RetryPolicy_RetryHostPredicate | PlainMessage<RetryPolicy_RetryHostPredicate> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryBackOff
 */
export declare class RetryPolicy_RetryBackOff extends Message<RetryPolicy_RetryBackOff> {
  /**
   * Specifies the base interval between retries. This parameter is required and must be greater
   * than zero. Values less than 1 ms are rounded up to 1 ms.
   * See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
   * back-off algorithm.
   *
   * @generated from field: google.protobuf.Duration base_interval = 1;
   */
  baseInterval?: Duration;

  /**
   * Specifies the maximum interval between retries. This parameter is optional, but must be
   * greater than or equal to the `base_interval` if set. The default is 10 times the
   * `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
   * of Envoy's back-off algorithm.
   *
   * @generated from field: google.protobuf.Duration max_interval = 2;
   */
  maxInterval?: Duration;

  constructor(data?: PartialMessage<RetryPolicy_RetryBackOff>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RetryPolicy.RetryBackOff";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy_RetryBackOff;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy_RetryBackOff;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy_RetryBackOff;

  static equals(a: RetryPolicy_RetryBackOff | PlainMessage<RetryPolicy_RetryBackOff> | undefined, b: RetryPolicy_RetryBackOff | PlainMessage<RetryPolicy_RetryBackOff> | undefined): boolean;
}

/**
 * HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
 *
 * @generated from message envoy.api.v2.route.HedgePolicy
 */
export declare class HedgePolicy extends Message<HedgePolicy> {
  /**
   * Specifies the number of initial requests that should be sent upstream.
   * Must be at least 1.
   * Defaults to 1.
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.UInt32Value initial_requests = 1;
   */
  initialRequests?: number;

  /**
   * Specifies a probability that an additional upstream request should be sent
   * on top of what is specified by initial_requests.
   * Defaults to 0.
   * [#not-implemented-hide:]
   *
   * @generated from field: envoy.type.FractionalPercent additional_request_chance = 2;
   */
  additionalRequestChance?: FractionalPercent;

  /**
   * Indicates that a hedged request should be sent when the per-try timeout is hit.
   * This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
   * The first request to complete successfully will be the one returned to the caller.
   *
   * * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
   * * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
   *   if there are no more retries left.
   * * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
   *
   * Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_api_msg_route.RetryPolicy>` that retries at least
   * one error code and specifies a maximum number of retries.
   *
   * Defaults to false.
   *
   * @generated from field: bool hedge_on_per_try_timeout = 3;
   */
  hedgeOnPerTryTimeout: boolean;

  constructor(data?: PartialMessage<HedgePolicy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.HedgePolicy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HedgePolicy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HedgePolicy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HedgePolicy;

  static equals(a: HedgePolicy | PlainMessage<HedgePolicy> | undefined, b: HedgePolicy | PlainMessage<HedgePolicy> | undefined): boolean;
}

/**
 * [#next-free-field: 9]
 *
 * @generated from message envoy.api.v2.route.RedirectAction
 */
export declare class RedirectAction extends Message<RedirectAction> {
  /**
   * When the scheme redirection take place, the following rules apply:
   *  1. If the source URI scheme is `http` and the port is explicitly
   *     set to `:80`, the port will be removed after the redirection
   *  2. If the source URI scheme is `https` and the port is explicitly
   *     set to `:443`, the port will be removed after the redirection
   *
   * @generated from oneof envoy.api.v2.route.RedirectAction.scheme_rewrite_specifier
   */
  schemeRewriteSpecifier: {
    /**
     * The scheme portion of the URL will be swapped with "https".
     *
     * @generated from field: bool https_redirect = 4;
     */
    value: boolean;
    case: "httpsRedirect";
  } | {
    /**
     * The scheme portion of the URL will be swapped with this value.
     *
     * @generated from field: string scheme_redirect = 7;
     */
    value: string;
    case: "schemeRedirect";
  } | { case: undefined; value?: undefined };

  /**
   * The host portion of the URL will be swapped with this value.
   *
   * @generated from field: string host_redirect = 1;
   */
  hostRedirect: string;

  /**
   * The port value of the URL will be swapped with this value.
   *
   * @generated from field: uint32 port_redirect = 8;
   */
  portRedirect: number;

  /**
   * @generated from oneof envoy.api.v2.route.RedirectAction.path_rewrite_specifier
   */
  pathRewriteSpecifier: {
    /**
     * The path portion of the URL will be swapped with this value.
     * Please note that query string in path_redirect will override the
     * request's query string and will not be stripped.
     *
     * For example, let's say we have the following routes:
     *
     * - match: { path: "/old-path-1" }
     *   redirect: { path_redirect: "/new-path-1" }
     * - match: { path: "/old-path-2" }
     *   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
     * - match: { path: "/old-path-3" }
     *   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
     *
     * 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
     * 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
     * 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
     *
     * @generated from field: string path_redirect = 2;
     */
    value: string;
    case: "pathRedirect";
  } | {
    /**
     * Indicates that during redirection, the matched prefix (or path)
     * should be swapped with this value. This option allows redirect URLs be dynamically created
     * based on the request.
     *
     * .. attention::
     *
     *   Pay attention to the use of trailing slashes as mentioned in
     *   :ref:`RouteAction's prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`.
     *
     * @generated from field: string prefix_rewrite = 5;
     */
    value: string;
    case: "prefixRewrite";
  } | { case: undefined; value?: undefined };

  /**
   * The HTTP status code to use in the redirect response. The default response
   * code is MOVED_PERMANENTLY (301).
   *
   * @generated from field: envoy.api.v2.route.RedirectAction.RedirectResponseCode response_code = 3;
   */
  responseCode: RedirectAction_RedirectResponseCode;

  /**
   * Indicates that during redirection, the query portion of the URL will
   * be removed. Default value is false.
   *
   * @generated from field: bool strip_query = 6;
   */
  stripQuery: boolean;

  constructor(data?: PartialMessage<RedirectAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RedirectAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedirectAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedirectAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedirectAction;

  static equals(a: RedirectAction | PlainMessage<RedirectAction> | undefined, b: RedirectAction | PlainMessage<RedirectAction> | undefined): boolean;
}

/**
 * @generated from enum envoy.api.v2.route.RedirectAction.RedirectResponseCode
 */
export declare enum RedirectAction_RedirectResponseCode {
  /**
   * Moved Permanently HTTP Status Code - 301.
   *
   * @generated from enum value: MOVED_PERMANENTLY = 0;
   */
  MOVED_PERMANENTLY = 0,

  /**
   * Found HTTP Status Code - 302.
   *
   * @generated from enum value: FOUND = 1;
   */
  FOUND = 1,

  /**
   * See Other HTTP Status Code - 303.
   *
   * @generated from enum value: SEE_OTHER = 2;
   */
  SEE_OTHER = 2,

  /**
   * Temporary Redirect HTTP Status Code - 307.
   *
   * @generated from enum value: TEMPORARY_REDIRECT = 3;
   */
  TEMPORARY_REDIRECT = 3,

  /**
   * Permanent Redirect HTTP Status Code - 308.
   *
   * @generated from enum value: PERMANENT_REDIRECT = 4;
   */
  PERMANENT_REDIRECT = 4,
}

/**
 * @generated from message envoy.api.v2.route.DirectResponseAction
 */
export declare class DirectResponseAction extends Message<DirectResponseAction> {
  /**
   * Specifies the HTTP response status to be returned.
   *
   * @generated from field: uint32 status = 1;
   */
  status: number;

  /**
   * Specifies the content of the response body. If this setting is omitted,
   * no body is included in the generated response.
   *
   * .. note::
   *
   *   Headers can be specified using *response_headers_to_add* in the enclosing
   *   :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_RouteConfiguration` or
   *   :ref:`envoy_api_msg_route.VirtualHost`.
   *
   * @generated from field: envoy.api.v2.core.DataSource body = 2;
   */
  body?: DataSource;

  constructor(data?: PartialMessage<DirectResponseAction>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.DirectResponseAction";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectResponseAction;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectResponseAction;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectResponseAction;

  static equals(a: DirectResponseAction | PlainMessage<DirectResponseAction> | undefined, b: DirectResponseAction | PlainMessage<DirectResponseAction> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.Decorator
 */
export declare class Decorator extends Message<Decorator> {
  /**
   * The operation name associated with the request matched to this route. If tracing is
   * enabled, this information will be used as the span name reported for this request.
   *
   * .. note::
   *
   *   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
   *   by the :ref:`x-envoy-decorator-operation
   *   <config_http_filters_router_x-envoy-decorator-operation>` header.
   *
   * @generated from field: string operation = 1;
   */
  operation: string;

  /**
   * Whether the decorated details should be propagated to the other party. The default is true.
   *
   * @generated from field: google.protobuf.BoolValue propagate = 2;
   */
  propagate?: boolean;

  constructor(data?: PartialMessage<Decorator>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.Decorator";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decorator;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decorator;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decorator;

  static equals(a: Decorator | PlainMessage<Decorator> | undefined, b: Decorator | PlainMessage<Decorator> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.route.Tracing
 */
export declare class Tracing extends Message<Tracing> {
  /**
   * Target percentage of requests managed by this HTTP connection manager that will be force
   * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
   * header is set. This field is a direct analog for the runtime variable
   * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
   * <config_http_conn_man_runtime>`.
   * Default: 100%
   *
   * @generated from field: envoy.type.FractionalPercent client_sampling = 1;
   */
  clientSampling?: FractionalPercent;

  /**
   * Target percentage of requests managed by this HTTP connection manager that will be randomly
   * selected for trace generation, if not requested by the client or not forced. This field is
   * a direct analog for the runtime variable 'tracing.random_sampling' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   *
   * @generated from field: envoy.type.FractionalPercent random_sampling = 2;
   */
  randomSampling?: FractionalPercent;

  /**
   * Target percentage of requests managed by this HTTP connection manager that will be traced
   * after all other sampling checks have been applied (client-directed, force tracing, random
   * sampling). This field functions as an upper limit on the total configured sampling rate. For
   * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
   * of client requests with the appropriate headers to be force traced. This field is a direct
   * analog for the runtime variable 'tracing.global_enabled' in the
   * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
   * Default: 100%
   *
   * @generated from field: envoy.type.FractionalPercent overall_sampling = 3;
   */
  overallSampling?: FractionalPercent;

  /**
   * A list of custom tags with unique tag name to create tags for the active span.
   * It will take effect after merging with the :ref:`corresponding configuration
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.custom_tags>`
   * configured in the HTTP connection manager. If two tags with the same name are configured
   * each in the HTTP connection manager and the route level, the one configured here takes
   * priority.
   *
   * @generated from field: repeated envoy.type.tracing.v2.CustomTag custom_tags = 4;
   */
  customTags: CustomTag[];

  constructor(data?: PartialMessage<Tracing>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.Tracing";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tracing;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tracing;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tracing;

  static equals(a: Tracing | PlainMessage<Tracing> | undefined, b: Tracing | PlainMessage<Tracing> | undefined): boolean;
}

/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, it’s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get “perfect” statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 *
 * @generated from message envoy.api.v2.route.VirtualCluster
 */
export declare class VirtualCluster extends Message<VirtualCluster> {
  /**
   * Specifies a regex pattern to use for matching requests. The entire path of the request
   * must match the regex. The regex grammar used is defined `here
   * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
   *
   * Examples:
   *
   * * The regex ``/rides/\d+`` matches the path *\/rides/0*
   * * The regex ``/rides/\d+`` matches the path *\/rides/123*
   * * The regex ``/rides/\d+`` does not match the path *\/rides/123/456*
   *
   * .. attention::
   *   This field has been deprecated in favor of `headers` as it is not safe for use with
   *   untrusted input in all cases.
   *
   * @generated from field: string pattern = 1 [deprecated = true];
   * @deprecated
   */
  pattern: string;

  /**
   * Specifies a list of header matchers to use for matching requests. Each specified header must
   * match. The pseudo-headers `:path` and `:method` can be used to match the request path and
   * method, respectively.
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher headers = 4;
   */
  headers: HeaderMatcher[];

  /**
   * Specifies the name of the virtual cluster. The virtual cluster name as well
   * as the virtual host name are used when emitting statistics. The statistics are emitted by the
   * router filter and are documented :ref:`here <config_http_filters_router_stats>`.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Optionally specifies the HTTP method to match on. For example GET, PUT,
   * etc.
   *
   * .. attention::
   *   This field has been deprecated in favor of `headers`.
   *
   * @generated from field: envoy.api.v2.core.RequestMethod method = 3 [deprecated = true];
   * @deprecated
   */
  method: RequestMethod;

  constructor(data?: PartialMessage<VirtualCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.VirtualCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VirtualCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VirtualCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VirtualCluster;

  static equals(a: VirtualCluster | PlainMessage<VirtualCluster> | undefined, b: VirtualCluster | PlainMessage<VirtualCluster> | undefined): boolean;
}

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 *
 * @generated from message envoy.api.v2.route.RateLimit
 */
export declare class RateLimit extends Message<RateLimit> {
  /**
   * Refers to the stage set in the filter. The rate limit configuration only
   * applies to filters with the same stage number. The default stage number is
   * 0.
   *
   * .. note::
   *
   *   The filter supports a range of 0 - 10 inclusively for stage numbers.
   *
   * @generated from field: google.protobuf.UInt32Value stage = 1;
   */
  stage?: number;

  /**
   * The key to be set in runtime to disable this rate limit configuration.
   *
   * @generated from field: string disable_key = 2;
   */
  disableKey: string;

  /**
   * A list of actions that are to be applied for this rate limit configuration.
   * Order matters as the actions are processed sequentially and the descriptor
   * is composed by appending descriptor entries in that sequence. If an action
   * cannot append a descriptor entry, no descriptor is generated for the
   * configuration. See :ref:`composing actions
   * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
   *
   * @generated from field: repeated envoy.api.v2.route.RateLimit.Action actions = 3;
   */
  actions: RateLimit_Action[];

  constructor(data?: PartialMessage<RateLimit>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit;

  static equals(a: RateLimit | PlainMessage<RateLimit> | undefined, b: RateLimit | PlainMessage<RateLimit> | undefined): boolean;
}

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action
 */
export declare class RateLimit_Action extends Message<RateLimit_Action> {
  /**
   * @generated from oneof envoy.api.v2.route.RateLimit.Action.action_specifier
   */
  actionSpecifier: {
    /**
     * Rate limit on source cluster.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.SourceCluster source_cluster = 1;
     */
    value: RateLimit_Action_SourceCluster;
    case: "sourceCluster";
  } | {
    /**
     * Rate limit on destination cluster.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.DestinationCluster destination_cluster = 2;
     */
    value: RateLimit_Action_DestinationCluster;
    case: "destinationCluster";
  } | {
    /**
     * Rate limit on request headers.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.RequestHeaders request_headers = 3;
     */
    value: RateLimit_Action_RequestHeaders;
    case: "requestHeaders";
  } | {
    /**
     * Rate limit on remote address.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.RemoteAddress remote_address = 4;
     */
    value: RateLimit_Action_RemoteAddress;
    case: "remoteAddress";
  } | {
    /**
     * Rate limit on a generic key.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.GenericKey generic_key = 5;
     */
    value: RateLimit_Action_GenericKey;
    case: "genericKey";
  } | {
    /**
     * Rate limit on the existence of request headers.
     *
     * @generated from field: envoy.api.v2.route.RateLimit.Action.HeaderValueMatch header_value_match = 6;
     */
    value: RateLimit_Action_HeaderValueMatch;
    case: "headerValueMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RateLimit_Action>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action;

  static equals(a: RateLimit_Action | PlainMessage<RateLimit_Action> | undefined, b: RateLimit_Action | PlainMessage<RateLimit_Action> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.SourceCluster
 */
export declare class RateLimit_Action_SourceCluster extends Message<RateLimit_Action_SourceCluster> {
  constructor(data?: PartialMessage<RateLimit_Action_SourceCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.SourceCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_SourceCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_SourceCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_SourceCluster;

  static equals(a: RateLimit_Action_SourceCluster | PlainMessage<RateLimit_Action_SourceCluster> | undefined, b: RateLimit_Action_SourceCluster | PlainMessage<RateLimit_Action_SourceCluster> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.DestinationCluster
 */
export declare class RateLimit_Action_DestinationCluster extends Message<RateLimit_Action_DestinationCluster> {
  constructor(data?: PartialMessage<RateLimit_Action_DestinationCluster>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.DestinationCluster";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_DestinationCluster;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_DestinationCluster;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_DestinationCluster;

  static equals(a: RateLimit_Action_DestinationCluster | PlainMessage<RateLimit_Action_DestinationCluster> | undefined, b: RateLimit_Action_DestinationCluster | PlainMessage<RateLimit_Action_DestinationCluster> | undefined): boolean;
}

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * *header_name*:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.RequestHeaders
 */
export declare class RateLimit_Action_RequestHeaders extends Message<RateLimit_Action_RequestHeaders> {
  /**
   * The header name to be queried from the request headers. The header’s
   * value is used to populate the value of the descriptor entry for the
   * descriptor_key.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  /**
   * The key to use in the descriptor entry.
   *
   * @generated from field: string descriptor_key = 2;
   */
  descriptorKey: string;

  constructor(data?: PartialMessage<RateLimit_Action_RequestHeaders>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.RequestHeaders";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_RequestHeaders;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_RequestHeaders;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_RequestHeaders;

  static equals(a: RateLimit_Action_RequestHeaders | PlainMessage<RateLimit_Action_RequestHeaders> | undefined, b: RateLimit_Action_RequestHeaders | PlainMessage<RateLimit_Action_RequestHeaders> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.RemoteAddress
 */
export declare class RateLimit_Action_RemoteAddress extends Message<RateLimit_Action_RemoteAddress> {
  constructor(data?: PartialMessage<RateLimit_Action_RemoteAddress>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.RemoteAddress";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_RemoteAddress;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_RemoteAddress;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_RemoteAddress;

  static equals(a: RateLimit_Action_RemoteAddress | PlainMessage<RateLimit_Action_RemoteAddress> | undefined, b: RateLimit_Action_RemoteAddress | PlainMessage<RateLimit_Action_RemoteAddress> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.GenericKey
 */
export declare class RateLimit_Action_GenericKey extends Message<RateLimit_Action_GenericKey> {
  /**
   * The value to use in the descriptor entry.
   *
   * @generated from field: string descriptor_value = 1;
   */
  descriptorValue: string;

  constructor(data?: PartialMessage<RateLimit_Action_GenericKey>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.GenericKey";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_GenericKey;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_GenericKey;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_GenericKey;

  static equals(a: RateLimit_Action_GenericKey | PlainMessage<RateLimit_Action_GenericKey> | undefined, b: RateLimit_Action_GenericKey | PlainMessage<RateLimit_Action_GenericKey> | undefined): boolean;
}

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.HeaderValueMatch
 */
export declare class RateLimit_Action_HeaderValueMatch extends Message<RateLimit_Action_HeaderValueMatch> {
  /**
   * The value to use in the descriptor entry.
   *
   * @generated from field: string descriptor_value = 1;
   */
  descriptorValue: string;

  /**
   * If set to true, the action will append a descriptor entry when the
   * request matches the headers. If set to false, the action will append a
   * descriptor entry when the request does not match the headers. The
   * default value is true.
   *
   * @generated from field: google.protobuf.BoolValue expect_match = 2;
   */
  expectMatch?: boolean;

  /**
   * Specifies a set of headers that the rate limit action should match
   * on. The action will check the request’s headers against all the
   * specified headers in the config. A match will happen if all the
   * headers in the config are present in the request with the same values
   * (or based on presence if the value field is not in the config).
   *
   * @generated from field: repeated envoy.api.v2.route.HeaderMatcher headers = 3;
   */
  headers: HeaderMatcher[];

  constructor(data?: PartialMessage<RateLimit_Action_HeaderValueMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit_Action_HeaderValueMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit_Action_HeaderValueMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit_Action_HeaderValueMatch;

  static equals(a: RateLimit_Action_HeaderValueMatch | PlainMessage<RateLimit_Action_HeaderValueMatch> | undefined, b: RateLimit_Action_HeaderValueMatch | PlainMessage<RateLimit_Action_HeaderValueMatch> | undefined): boolean;
}

/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
 *   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "exact_match": "POST"
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.HeaderMatcher
 */
export declare class HeaderMatcher extends Message<HeaderMatcher> {
  /**
   * Specifies the name of the header in the request.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Specifies how the header match will be performed to route the request.
   *
   * @generated from oneof envoy.api.v2.route.HeaderMatcher.header_match_specifier
   */
  headerMatchSpecifier: {
    /**
     * If specified, header match will be performed based on the value of the header.
     *
     * @generated from field: string exact_match = 4;
     */
    value: string;
    case: "exactMatch";
  } | {
    /**
     * If specified, this regex string is a regular expression rule which implies the entire request
     * header value must match the regex. The rule will not match if only a subsequence of the
     * request header value matches the regex. The regex grammar used in the value field is defined
     * `here <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
     *
     * Examples:
     *
     * * The regex ``\d{3}`` matches the value *123*
     * * The regex ``\d{3}`` does not match the value *1234*
     * * The regex ``\d{3}`` does not match the value *123.456*
     *
     * .. attention::
     *   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
     *   with untrusted input in all cases.
     *
     * @generated from field: string regex_match = 5 [deprecated = true];
     * @deprecated
     */
    value: string;
    case: "regexMatch";
  } | {
    /**
     * If specified, this regex string is a regular expression rule which implies the entire request
     * header value must match the regex. The rule will not match if only a subsequence of the
     * request header value matches the regex.
     *
     * @generated from field: envoy.type.matcher.RegexMatcher safe_regex_match = 11;
     */
    value: RegexMatcher;
    case: "safeRegexMatch";
  } | {
    /**
     * If specified, header match will be performed based on range.
     * The rule will match if the request header value is within this range.
     * The entire request header value must represent an integer in base 10 notation: consisting of
     * an optional plus or minus sign followed by a sequence of digits. The rule will not match if
     * the header value does not represent an integer. Match will fail for empty values, floating
     * point numbers or if only a subsequence of the header value is an integer.
     *
     * Examples:
     *
     * * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
     *   "-1somestring"
     *
     * @generated from field: envoy.type.Int64Range range_match = 6;
     */
    value: Int64Range;
    case: "rangeMatch";
  } | {
    /**
     * If specified, header match will be performed based on whether the header is in the
     * request.
     *
     * @generated from field: bool present_match = 7;
     */
    value: boolean;
    case: "presentMatch";
  } | {
    /**
     * If specified, header match will be performed based on the prefix of the header value.
     * Note: empty prefix is not allowed, please use present_match instead.
     *
     * Examples:
     *
     * * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
     *
     * @generated from field: string prefix_match = 9;
     */
    value: string;
    case: "prefixMatch";
  } | {
    /**
     * If specified, header match will be performed based on the suffix of the header value.
     * Note: empty suffix is not allowed, please use present_match instead.
     *
     * Examples:
     *
     * * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
     *
     * @generated from field: string suffix_match = 10;
     */
    value: string;
    case: "suffixMatch";
  } | { case: undefined; value?: undefined };

  /**
   * If specified, the match result will be inverted before checking. Defaults to false.
   *
   * Examples:
   *
   * * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
   * * The range [-10,0) will match the value -1, so it will not match when inverted.
   *
   * @generated from field: bool invert_match = 8;
   */
  invertMatch: boolean;

  constructor(data?: PartialMessage<HeaderMatcher>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.HeaderMatcher";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderMatcher;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderMatcher;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderMatcher;

  static equals(a: HeaderMatcher | PlainMessage<HeaderMatcher> | undefined, b: HeaderMatcher | PlainMessage<HeaderMatcher> | undefined): boolean;
}

/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.QueryParameterMatcher
 */
export declare class QueryParameterMatcher extends Message<QueryParameterMatcher> {
  /**
   * Specifies the name of a key that must be present in the requested
   * *path*'s query string.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Specifies the value of the key. If the value is absent, a request
   * that contains the key in its query string will match, whether the
   * key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
   *
   * ..attention::
   *   This field is deprecated. Use an `exact` match inside the `string_match` field.
   *
   * @generated from field: string value = 3 [deprecated = true];
   * @deprecated
   */
  value: string;

  /**
   * Specifies whether the query parameter value is a regular expression.
   * Defaults to false. The entire query parameter value (i.e., the part to
   * the right of the equals sign in "key=value") must match the regex.
   * E.g., the regex ``\d+$`` will match *123* but not *a123* or *123a*.
   *
   * ..attention::
   *   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
   *
   * @generated from field: google.protobuf.BoolValue regex = 4 [deprecated = true];
   * @deprecated
   */
  regex?: boolean;

  /**
   * @generated from oneof envoy.api.v2.route.QueryParameterMatcher.query_parameter_match_specifier
   */
  queryParameterMatchSpecifier: {
    /**
     * Specifies whether a query parameter value should match against a string.
     *
     * @generated from field: envoy.type.matcher.StringMatcher string_match = 5;
     */
    value: StringMatcher;
    case: "stringMatch";
  } | {
    /**
     * Specifies whether a query parameter should be present.
     *
     * @generated from field: bool present_match = 6;
     */
    value: boolean;
    case: "presentMatch";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<QueryParameterMatcher>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.route.QueryParameterMatcher";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParameterMatcher;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParameterMatcher;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParameterMatcher;

  static equals(a: QueryParameterMatcher | PlainMessage<QueryParameterMatcher> | undefined, b: QueryParameterMatcher | PlainMessage<QueryParameterMatcher> | undefined): boolean;
}

