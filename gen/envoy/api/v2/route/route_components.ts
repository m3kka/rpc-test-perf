// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/route/route_components.proto" (package "envoy.api.v2.route", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int64Range } from "../../../type/range";
import { RequestMethod } from "../core/base";
import { CustomTag } from "../../../type/tracing/v2/custom_tag";
import { DataSource } from "../core/base";
import { FractionalPercent } from "../../../type/percent";
import { RoutingPriority } from "../core/base";
import { Duration } from "../../../../google/protobuf/duration";
import { RegexMatchAndSubstitute } from "../../../type/matcher/regex";
import { StringMatcher } from "../../../type/matcher/string";
import { RuntimeFractionalPercent } from "../core/base";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { RegexMatcher } from "../../../type/matcher/regex";
import { Metadata } from "../core/base";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
import { HeaderValueOption } from "../core/base";
// [#protodoc-title: HTTP route components]
// * Routing :ref:`architecture overview <arch_overview_http_routing>`
// * HTTP :ref:`router filter <config_http_filters_router>`

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 21]
 *
 * @generated from protobuf message envoy.api.v2.route.VirtualHost
 */
export interface VirtualHost {
    /**
     * The logical name of the virtual host. This is used when emitting certain
     * statistics but is not relevant for routing.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A list of domains (host/authority header) that will be matched to this
     * virtual host. Wildcard hosts are supported in the suffix or prefix form.
     *
     * Domain search order:
     *  1. Exact domain names: ``www.foo.com``.
     *  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
     *  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
     *  4. Special wildcard ``*`` matching any domain.
     *
     * .. note::
     *
     *   The wildcard will not match the empty string.
     *   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
     *   The longest wildcards match first.
     *   Only a single virtual host in the entire route configuration can match on ``*``. A domain
     *   must be unique across all virtual hosts or the config will fail to load.
     *
     * Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
     *
     * @generated from protobuf field: repeated string domains = 2;
     */
    domains: string[];
    /**
     * The list of routes that will be matched, in order, for incoming requests.
     * The first route that matches will be used.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.Route routes = 3;
     */
    routes: Route[];
    /**
     * Specifies the type of TLS enforcement the virtual host expects. If this option is not
     * specified, there is no TLS requirement for the virtual host.
     *
     * @generated from protobuf field: envoy.api.v2.route.VirtualHost.TlsRequirementType require_tls = 4;
     */
    requireTls: VirtualHost_TlsRequirementType;
    /**
     * A list of virtual clusters defined for this virtual host. Virtual clusters
     * are used for additional statistics gathering.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.VirtualCluster virtual_clusters = 5;
     */
    virtualClusters: VirtualCluster[];
    /**
     * Specifies a set of rate limit configurations that will be applied to the
     * virtual host.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RateLimit rate_limits = 6;
     */
    rateLimits: RateLimit[];
    /**
     * Specifies a list of HTTP headers that should be added to each request
     * handled by this virtual host. Headers specified at this level are applied
     * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
     * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 7;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request
     * handled by this virtual host.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 13;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a list of HTTP headers that should be added to each response
     * handled by this virtual host. Headers specified at this level are applied
     * after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
     * enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each response
     * handled by this virtual host.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 11;
     */
    responseHeadersToRemove: string[];
    /**
     * Indicates that the virtual host has a CORS policy.
     *
     * @generated from protobuf field: envoy.api.v2.route.CorsPolicy cors = 8;
     */
    cors?: CorsPolicy;
    /**
     * The per_filter_config field can be used to provide virtual host-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
     * for if and how it is utilized.
     *
     * @deprecated
     * @generated from protobuf field: map<string, google.protobuf.Struct> per_filter_config = 12 [deprecated = true];
     */
    perFilterConfig: {
        [key: string]: Struct;
    };
    /**
     * The per_filter_config field can be used to provide virtual host-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
     * for if and how it is utilized.
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 15;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
    /**
     * Decides whether the :ref:`x-envoy-attempt-count
     * <config_http_filters_router_x-envoy-attempt-count>` header should be included
     * in the upstream request. Setting this option will cause it to override any existing header
     * value, so in the case of two Envoys on the request path with this option enabled, the upstream
     * will see the attempt count as perceived by the second Envoy. Defaults to false.
     * This header is unaffected by the
     * :ref:`suppress_envoy_headers
     * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
     *
     * [#next-major-version: rename to include_attempt_count_in_request.]
     *
     * @generated from protobuf field: bool include_request_attempt_count = 14;
     */
    includeRequestAttemptCount: boolean;
    /**
     * Decides whether the :ref:`x-envoy-attempt-count
     * <config_http_filters_router_x-envoy-attempt-count>` header should be included
     * in the downstream response. Setting this option will cause the router to override any existing header
     * value, so in the case of two Envoys on the request path with this option enabled, the downstream
     * will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
     * This header is unaffected by the
     * :ref:`suppress_envoy_headers
     * <envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
     *
     * @generated from protobuf field: bool include_attempt_count_in_response = 19;
     */
    includeAttemptCountInResponse: boolean;
    /**
     * Indicates the retry policy for all routes in this virtual host. Note that setting a
     * route level entry will take precedence over this config and it'll be treated
     * independently (e.g.: values are not inherited).
     *
     * @generated from protobuf field: envoy.api.v2.route.RetryPolicy retry_policy = 16;
     */
    retryPolicy?: RetryPolicy;
    /**
     * [#not-implemented-hide:]
     * Specifies the configuration for retry policy extension. Note that setting a route level entry
     * will take precedence over this config and it'll be treated independently (e.g.: values are not
     * inherited). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>` should not be
     * set if this field is used.
     *
     * @generated from protobuf field: google.protobuf.Any retry_policy_typed_config = 20;
     */
    retryPolicyTypedConfig?: Any;
    /**
     * Indicates the hedge policy for all routes in this virtual host. Note that setting a
     * route level entry will take precedence over this config and it'll be treated
     * independently (e.g.: values are not inherited).
     *
     * @generated from protobuf field: envoy.api.v2.route.HedgePolicy hedge_policy = 17;
     */
    hedgePolicy?: HedgePolicy;
    /**
     * The maximum bytes which will be buffered for retries and shadowing.
     * If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
     * value of this and the listener per_connection_buffer_limit_bytes.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;
     */
    perRequestBufferLimitBytes?: UInt32Value;
}
/**
 * @generated from protobuf enum envoy.api.v2.route.VirtualHost.TlsRequirementType
 */
export enum VirtualHost_TlsRequirementType {
    /**
     * No TLS requirement for the virtual host.
     *
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * External requests must use TLS. If a request is external and it is not
     * using TLS, a 301 redirect will be sent telling the client to use HTTPS.
     *
     * @generated from protobuf enum value: EXTERNAL_ONLY = 1;
     */
    EXTERNAL_ONLY = 1,
    /**
     * All requests must use TLS. If a request is not using TLS, a 301 redirect
     * will be sent telling the client to use HTTPS.
     *
     * @generated from protobuf enum value: ALL = 2;
     */
    ALL = 2
}
/**
 * A filter-defined action type.
 *
 * @generated from protobuf message envoy.api.v2.route.FilterAction
 */
export interface FilterAction {
    /**
     * @generated from protobuf field: google.protobuf.Any action = 1;
     */
    action?: Any;
}
/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_api_msg_route.HeaderMatcher>`.
 * [#next-free-field: 18]
 *
 * @generated from protobuf message envoy.api.v2.route.Route
 */
export interface Route {
    /**
     * Name for the route.
     *
     * @generated from protobuf field: string name = 14;
     */
    name: string;
    /**
     * Route matching parameters.
     *
     * @generated from protobuf field: envoy.api.v2.route.RouteMatch match = 1;
     */
    match?: RouteMatch;
    /**
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "route";
        /**
         * Route request to some upstream cluster.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction route = 2;
         */
        route: RouteAction;
    } | {
        oneofKind: "redirect";
        /**
         * Return a redirect.
         *
         * @generated from protobuf field: envoy.api.v2.route.RedirectAction redirect = 3;
         */
        redirect: RedirectAction;
    } | {
        oneofKind: "directResponse";
        /**
         * Return an arbitrary HTTP response directly, without proxying.
         *
         * @generated from protobuf field: envoy.api.v2.route.DirectResponseAction direct_response = 7;
         */
        directResponse: DirectResponseAction;
    } | {
        oneofKind: "filterAction";
        /**
         * [#not-implemented-hide:]
         * If true, a filter will define the action (e.g., it could dynamically generate the
         * RouteAction).
         *
         * @generated from protobuf field: envoy.api.v2.route.FilterAction filter_action = 17;
         */
        filterAction: FilterAction;
    } | {
        oneofKind: undefined;
    };
    /**
     * The Metadata field can be used to provide additional information
     * about the route. It can be used for configuration, stats, and logging.
     * The metadata should go under the filter namespace that will need it.
     * For instance, if the metadata is intended for the Router filter,
     * the filter name should be specified as *envoy.filters.http.router*.
     *
     * @generated from protobuf field: envoy.api.v2.core.Metadata metadata = 4;
     */
    metadata?: Metadata;
    /**
     * Decorator for the matched route.
     *
     * @generated from protobuf field: envoy.api.v2.route.Decorator decorator = 5;
     */
    decorator?: Decorator;
    /**
     * The per_filter_config field can be used to provide route-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
     * if and how it is utilized.
     *
     * @deprecated
     * @generated from protobuf field: map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];
     */
    perFilterConfig: {
        [key: string]: Struct;
    };
    /**
     * The typed_per_filter_config field can be used to provide route-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
     * if and how it is utilized.
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 13;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
    /**
     * Specifies a set of headers that will be added to requests matching this
     * route. Headers specified at this level are applied before headers from the
     * enclosing :ref:`envoy_api_msg_route.VirtualHost` and
     * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 9;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request
     * matching this route.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 12;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a set of headers that will be added to responses to requests
     * matching this route. Headers specified at this level are applied before
     * headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
     * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
     * details on header value syntax, see the documentation on
     * :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each response
     * to requests matching this route.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 11;
     */
    responseHeadersToRemove: string[];
    /**
     * Presence of the object defines whether the connection manager's tracing configuration
     * is overridden by this route specific instance.
     *
     * @generated from protobuf field: envoy.api.v2.route.Tracing tracing = 15;
     */
    tracing?: Tracing;
    /**
     * The maximum bytes which will be buffered for retries and shadowing.
     * If set, the bytes actually buffered will be the minimum value of this and the
     * listener per_connection_buffer_limit_bytes.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;
     */
    perRequestBufferLimitBytes?: UInt32Value;
}
/**
 * Compared to the :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 *
 * @generated from protobuf message envoy.api.v2.route.WeightedCluster
 */
export interface WeightedCluster {
    /**
     * Specifies one or more upstream clusters associated with the route.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.WeightedCluster.ClusterWeight clusters = 1;
     */
    clusters: WeightedCluster_ClusterWeight[];
    /**
     * Specifies the total weight across all clusters. The sum of all cluster weights must equal this
     * value, which must be greater than 0. Defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value total_weight = 3;
     */
    totalWeight?: UInt32Value;
    /**
     * Specifies the runtime key prefix that should be used to construct the
     * runtime keys associated with each cluster. When the *runtime_key_prefix* is
     * specified, the router will look for weights associated with each upstream
     * cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
     * *cluster[i]* denotes an entry in the clusters array field. If the runtime
     * key for the cluster does not exist, the value specified in the
     * configuration file will be used as the default weight. See the :ref:`runtime documentation
     * <operations_runtime>` for how key names map to the underlying implementation.
     *
     * @generated from protobuf field: string runtime_key_prefix = 2;
     */
    runtimeKeyPrefix: string;
}
/**
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.api.v2.route.WeightedCluster.ClusterWeight
 */
export interface WeightedCluster_ClusterWeight {
    /**
     * Name of the upstream cluster. The cluster must exist in the
     * :ref:`cluster manager configuration <config_cluster_manager>`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * An integer between 0 and :ref:`total_weight
     * <envoy_api_field_route.WeightedCluster.total_weight>`. When a request matches the route,
     * the choice of an upstream cluster is determined by its weight. The sum of weights across all
     * entries in the clusters array must add up to the total_weight, if total_weight is greater than 0.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value weight = 2;
     */
    weight?: UInt32Value;
    /**
     * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
     * the upstream cluster with metadata matching what is set in this field will be considered for
     * load balancing. Note that this will be merged with what's provided in
     * :ref:`RouteAction.metadata_match <envoy_api_field_route.RouteAction.metadata_match>`, with
     * values here taking precedence. The filter name should be specified as *envoy.lb*.
     *
     * @generated from protobuf field: envoy.api.v2.core.Metadata metadata_match = 3;
     */
    metadataMatch?: Metadata;
    /**
     * Specifies a list of headers to be added to requests when this cluster is selected
     * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
     * Headers specified at this level are applied before headers from the enclosing
     * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
     * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 4;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request when
     * this cluster is selected through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 9;
     */
    requestHeadersToRemove: string[];
    /**
     * Specifies a list of headers to be added to responses when this cluster is selected
     * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
     * Headers specified at this level are applied before headers from the enclosing
     * :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
     * :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
     * header value syntax, see the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 5;
     */
    responseHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of headers to be removed from responses when this cluster is selected
     * through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
     *
     * @generated from protobuf field: repeated string response_headers_to_remove = 6;
     */
    responseHeadersToRemove: string[];
    /**
     * The per_filter_config field can be used to provide weighted cluster-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
     * for if and how it is utilized.
     *
     * @deprecated
     * @generated from protobuf field: map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];
     */
    perFilterConfig: {
        [key: string]: Struct;
    };
    /**
     * The per_filter_config field can be used to provide weighted cluster-specific
     * configurations for filters. The key should match the filter name, such as
     * *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
     * specific; see the :ref:`HTTP filter documentation <config_http_filters>`
     * for if and how it is utilized.
     *
     * @generated from protobuf field: map<string, google.protobuf.Any> typed_per_filter_config = 10;
     */
    typedPerFilterConfig: {
        [key: string]: Any;
    };
}
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.api.v2.route.RouteMatch
 */
export interface RouteMatch {
    /**
     * @generated from protobuf oneof: path_specifier
     */
    pathSpecifier: {
        oneofKind: "prefix";
        /**
         * If specified, the route is a prefix rule meaning that the prefix must
         * match the beginning of the *:path* header.
         *
         * @generated from protobuf field: string prefix = 1;
         */
        prefix: string;
    } | {
        oneofKind: "path";
        /**
         * If specified, the route is an exact path rule meaning that the path must
         * exactly match the *:path* header once the query string is removed.
         *
         * @generated from protobuf field: string path = 2;
         */
        path: string;
    } | {
        oneofKind: "regex";
        /**
         * If specified, the route is a regular expression rule meaning that the
         * regex must match the *:path* header once the query string is removed. The entire path
         * (without the query string) must match the regex. The rule will not match if only a
         * subsequence of the *:path* header matches the regex. The regex grammar is defined `here
         * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
         *
         * Examples:
         *
         * * The regex ``/b[io]t`` matches the path *\/bit*
         * * The regex ``/b[io]t`` matches the path *\/bot*
         * * The regex ``/b[io]t`` does not match the path *\/bite*
         * * The regex ``/b[io]t`` does not match the path *\/bit/bot*
         *
         * .. attention::
         *   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
         *   untrusted input in all cases.
         *
         * @deprecated
         * @generated from protobuf field: string regex = 3 [deprecated = true];
         */
        regex: string;
    } | {
        oneofKind: "safeRegex";
        /**
         * If specified, the route is a regular expression rule meaning that the
         * regex must match the *:path* header once the query string is removed. The entire path
         * (without the query string) must match the regex. The rule will not match if only a
         * subsequence of the *:path* header matches the regex.
         *
         * [#next-major-version: In the v3 API we should redo how path specification works such
         * that we utilize StringMatcher, and additionally have consistent options around whether we
         * strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
         * to deprecate the existing options. We should even consider whether we want to do away with
         * path_specifier entirely and just rely on a set of header matchers which can already match
         * on :path, etc. The issue with that is it is unclear how to generically deal with query string
         * stripping. This needs more thought.]
         *
         * @generated from protobuf field: envoy.type.matcher.RegexMatcher safe_regex = 10;
         */
        safeRegex: RegexMatcher;
    } | {
        oneofKind: undefined;
    };
    /**
     * Indicates that prefix/path matching should be case sensitive. The default
     * is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue case_sensitive = 4;
     */
    caseSensitive?: BoolValue;
    /**
     * Indicates that the route should additionally match on a runtime key. Every time the route
     * is considered for a match, it must also fall under the percentage of matches indicated by
     * this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
     * number is <= the value of the numerator N, or if the key is not present, the default
     * value, the router continues to evaluate the remaining match criteria. A runtime_fraction
     * route configuration can be used to roll out route changes in a gradual manner without full
     * code/config deploys. Refer to the :ref:`traffic shifting
     * <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
     *
     * .. note::
     *
     *    Parsing this field is implemented such that the runtime key's data may be represented
     *    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
     *    integer with the assumption that the value is an integral percentage out of 100. For
     *    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
     *    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Specifies a set of headers that the route should match on. The router will
     * check the requestâ€™s headers against all the specified headers in the route
     * config. A match will happen if all the headers in the route are present in
     * the request with the same values (or based on presence if the value field
     * is not in the config).
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher headers = 6;
     */
    headers: HeaderMatcher[];
    /**
     * Specifies a set of URL query parameters on which the route should
     * match. The router will check the query string from the *path* header
     * against all the specified query parameters. If the number of specified
     * query parameters is nonzero, they all must match the *path* header's
     * query string for a match to occur.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;
     */
    queryParameters: QueryParameterMatcher[];
    /**
     * If specified, only gRPC requests will be matched. The router will check
     * that the content-type header has a application/grpc or one of the various
     * application/grpc+ values.
     *
     * @generated from protobuf field: envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;
     */
    grpc?: RouteMatch_GrpcRouteMatchOptions;
    /**
     * If specified, the client tls context will be matched against the defined
     * match options.
     *
     * [#next-major-version: unify with RBAC]
     *
     * @generated from protobuf field: envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;
     */
    tlsContext?: RouteMatch_TlsContextMatchOptions;
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions
 */
export interface RouteMatch_GrpcRouteMatchOptions {
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteMatch.TlsContextMatchOptions
 */
export interface RouteMatch_TlsContextMatchOptions {
    /**
     * If specified, the route will match against whether or not a certificate is presented.
     * If not specified, certificate presentation status (true or false) will not be considered when route matching.
     *
     * @generated from protobuf field: google.protobuf.BoolValue presented = 1;
     */
    presented?: BoolValue;
    /**
     * If specified, the route will match against whether or not a certificate is validated.
     * If not specified, certificate validation status (true or false) will not be considered when route matching.
     *
     * @generated from protobuf field: google.protobuf.BoolValue validated = 2;
     */
    validated?: BoolValue;
}
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.api.v2.route.CorsPolicy
 */
export interface CorsPolicy {
    /**
     * Specifies the origins that will be allowed to do CORS requests.
     *
     * An origin is allowed if either allow_origin or allow_origin_regex match.
     *
     * .. attention::
     *  This field has been deprecated in favor of `allow_origin_string_match`.
     *
     * @deprecated
     * @generated from protobuf field: repeated string allow_origin = 1 [deprecated = true];
     */
    allowOrigin: string[];
    /**
     * Specifies regex patterns that match allowed origins.
     *
     * An origin is allowed if either allow_origin or allow_origin_regex match.
     *
     * .. attention::
     *   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
     *   use with untrusted input in all cases.
     *
     * @deprecated
     * @generated from protobuf field: repeated string allow_origin_regex = 8 [deprecated = true];
     */
    allowOriginRegex: string[];
    /**
     * Specifies string patterns that match allowed origins. An origin is allowed if any of the
     * string matchers match.
     *
     * @generated from protobuf field: repeated envoy.type.matcher.StringMatcher allow_origin_string_match = 11;
     */
    allowOriginStringMatch: StringMatcher[];
    /**
     * Specifies the content for the *access-control-allow-methods* header.
     *
     * @generated from protobuf field: string allow_methods = 2;
     */
    allowMethods: string;
    /**
     * Specifies the content for the *access-control-allow-headers* header.
     *
     * @generated from protobuf field: string allow_headers = 3;
     */
    allowHeaders: string;
    /**
     * Specifies the content for the *access-control-expose-headers* header.
     *
     * @generated from protobuf field: string expose_headers = 4;
     */
    exposeHeaders: string;
    /**
     * Specifies the content for the *access-control-max-age* header.
     *
     * @generated from protobuf field: string max_age = 5;
     */
    maxAge: string;
    /**
     * Specifies whether the resource allows credentials.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_credentials = 6;
     */
    allowCredentials?: BoolValue;
    /**
     * @generated from protobuf oneof: enabled_specifier
     */
    enabledSpecifier: {
        oneofKind: "enabled";
        /**
         * Specifies if the CORS filter is enabled. Defaults to true. Only effective on route.
         *
         * .. attention::
         *
         *   **This field is deprecated**. Set the
         *   :ref:`filter_enabled<envoy_api_field_route.CorsPolicy.filter_enabled>` field instead.
         *
         * @deprecated
         * @generated from protobuf field: google.protobuf.BoolValue enabled = 7 [deprecated = true];
         */
        enabled: BoolValue;
    } | {
        oneofKind: "filterEnabled";
        /**
         * Specifies the % of requests for which the CORS filter is enabled.
         *
         * If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
         * filter will be enabled for 100% of the requests.
         *
         * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is
         * specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
         *
         * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9;
         */
        filterEnabled: RuntimeFractionalPercent;
    } | {
        oneofKind: undefined;
    };
    /**
     * Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
     * enforced.
     *
     * This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
     * fields have to explicitly disable the filter in order for this setting to take effect.
     *
     * If :ref:`runtime_key <envoy_api_field_core.RuntimeFractionalPercent.runtime_key>` is specified,
     * Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
     * and track the request's *Origin* to determine if it's valid but will not enforce any policies.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent shadow_enabled = 10;
     */
    shadowEnabled?: RuntimeFractionalPercent;
}
/**
 * [#next-free-field: 34]
 *
 * @generated from protobuf message envoy.api.v2.route.RouteAction
 */
export interface RouteAction {
    /**
     * @generated from protobuf oneof: cluster_specifier
     */
    clusterSpecifier: {
        oneofKind: "cluster";
        /**
         * Indicates the upstream cluster to which the request should be routed
         * to.
         *
         * @generated from protobuf field: string cluster = 1;
         */
        cluster: string;
    } | {
        oneofKind: "clusterHeader";
        /**
         * Envoy will determine the cluster to route to by reading the value of the
         * HTTP header named by cluster_header from the request headers. If the
         * header is not found or the referenced cluster does not exist, Envoy will
         * return a 404 response.
         *
         * .. attention::
         *
         *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
         *   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
         *
         * .. note::
         *
         *   If the header appears multiple times only the first value is used.
         *
         * @generated from protobuf field: string cluster_header = 2;
         */
        clusterHeader: string;
    } | {
        oneofKind: "weightedClusters";
        /**
         * Multiple upstream clusters can be specified for a given route. The
         * request is routed to one of the upstream clusters based on weights
         * assigned to each cluster. See
         * :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
         * for additional documentation.
         *
         * @generated from protobuf field: envoy.api.v2.route.WeightedCluster weighted_clusters = 3;
         */
        weightedClusters: WeightedCluster;
    } | {
        oneofKind: undefined;
    };
    /**
     * The HTTP status code to use when configured cluster is not found.
     * The default response code is 503 Service Unavailable.
     *
     * @generated from protobuf field: envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20;
     */
    clusterNotFoundResponseCode: RouteAction_ClusterNotFoundResponseCode;
    /**
     * Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
     * in the upstream cluster with metadata matching what's set in this field will be considered
     * for load balancing. If using :ref:`weighted_clusters
     * <envoy_api_field_route.RouteAction.weighted_clusters>`, metadata will be merged, with values
     * provided there taking precedence. The filter name should be specified as *envoy.lb*.
     *
     * @generated from protobuf field: envoy.api.v2.core.Metadata metadata_match = 4;
     */
    metadataMatch?: Metadata;
    /**
     * Indicates that during forwarding, the matched prefix (or path) should be
     * swapped with this value. This option allows application URLs to be rooted
     * at a different path from those exposed at the reverse proxy layer. The router filter will
     * place the original path before rewrite into the :ref:`x-envoy-original-path
     * <config_http_filters_router_x-envoy-original-path>` header.
     *
     * Only one of *prefix_rewrite* or
     * :ref:`regex_rewrite <envoy_api_field_route.RouteAction.regex_rewrite>`
     * may be specified.
     *
     * .. attention::
     *
     *   Pay careful attention to the use of trailing slashes in the
     *   :ref:`route's match <envoy_api_field_route.Route.match>` prefix value.
     *   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
     *   rewriting *\/prefix* to *\/* and *\/prefix/etc* to *\/etc* cannot be done in a single
     *   :ref:`Route <envoy_api_msg_route.Route>`, as shown by the below config entries:
     *
     *   .. code-block:: yaml
     *
     *     - match:
     *         prefix: "/prefix/"
     *       route:
     *         prefix_rewrite: "/"
     *     - match:
     *         prefix: "/prefix"
     *       route:
     *         prefix_rewrite: "/"
     *
     *   Having above entries in the config, requests to *\/prefix* will be stripped to *\/*, while
     *   requests to *\/prefix/etc* will be stripped to *\/etc*.
     *
     * @generated from protobuf field: string prefix_rewrite = 5;
     */
    prefixRewrite: string;
    /**
     * Indicates that during forwarding, portions of the path that match the
     * pattern should be rewritten, even allowing the substitution of capture
     * groups from the pattern into the new path as specified by the rewrite
     * substitution string. This is useful to allow application paths to be
     * rewritten in a way that is aware of segments with variable content like
     * identifiers. The router filter will place the original path as it was
     * before the rewrite into the :ref:`x-envoy-original-path
     * <config_http_filters_router_x-envoy-original-path>` header.
     *
     * Only one of :ref:`prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`
     * or *regex_rewrite* may be specified.
     *
     * Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
     *
     * * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
     *   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
     *   into ``/v1/api/instance/foo``.
     *
     * * The pattern ``one`` paired with a substitution string of ``two`` would
     *   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
     *
     * * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
     *   ``\1two\2`` would replace only the first occurrence of ``one``,
     *   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
     *
     * * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
     *   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
     *   ``/aaa/yyy/bbb``.
     *
     * @generated from protobuf field: envoy.type.matcher.RegexMatchAndSubstitute regex_rewrite = 32;
     */
    regexRewrite?: RegexMatchAndSubstitute;
    /**
     * @generated from protobuf oneof: host_rewrite_specifier
     */
    hostRewriteSpecifier: {
        oneofKind: "hostRewrite";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * this value.
         *
         * @generated from protobuf field: string host_rewrite = 6;
         */
        hostRewrite: string;
    } | {
        oneofKind: "autoHostRewrite";
        /**
         * Indicates that during forwarding, the host header will be swapped with
         * the hostname of the upstream host chosen by the cluster manager. This
         * option is applicable only when the destination cluster for a route is of
         * type ``STRICT_DNS``,  ``LOGICAL_DNS`` or ``STATIC``. For ``STATIC`` clusters, the
         * hostname attribute of the endpoint must be configured. Setting this to true
         * with other cluster types has no effect.
         *
         * @generated from protobuf field: google.protobuf.BoolValue auto_host_rewrite = 7;
         */
        autoHostRewrite: BoolValue;
    } | {
        oneofKind: "autoHostRewriteHeader";
        /**
         * Indicates that during forwarding, the host header will be swapped with the content of given
         * downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
         * If header value is empty, host header is left intact.
         *
         * .. attention::
         *
         *   Pay attention to the potential security implications of using this option. Provided header
         *   must come from trusted source.
         *
         * .. note::
         *
         *   If the header appears multiple times only the first value is used.
         *
         * @generated from protobuf field: string auto_host_rewrite_header = 29;
         */
        autoHostRewriteHeader: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * Specifies the upstream timeout for the route. If not specified, the default is 15s. This
     * spans between the point at which the entire downstream request (i.e. end-of-stream) has been
     * processed and when the upstream response has been completely processed. A value of 0 will
     * disable the route's timeout.
     *
     * .. note::
     *
     *   This timeout includes all retries. See also
     *   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
     *   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
     *   :ref:`retry overview <arch_overview_http_routing_retry>`.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 8;
     */
    timeout?: Duration;
    /**
     * Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
     * although the connection manager wide :ref:`stream_idle_timeout
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
     * will still apply. A value of 0 will completely disable the route's idle timeout, even if a
     * connection manager stream idle timeout is configured.
     *
     * The idle timeout is distinct to :ref:`timeout
     * <envoy_api_field_route.RouteAction.timeout>`, which provides an upper bound
     * on the upstream response time; :ref:`idle_timeout
     * <envoy_api_field_route.RouteAction.idle_timeout>` instead bounds the amount
     * of time the request's stream may be idle.
     *
     * After header decoding, the idle timeout will apply on downstream and
     * upstream request events. Each time an encode/decode event for headers or
     * data is processed for the stream, the timer will be reset. If the timeout
     * fires, the stream is terminated with a 408 Request Timeout error code if no
     * upstream response header has been received, otherwise a stream reset
     * occurs.
     *
     * @generated from protobuf field: google.protobuf.Duration idle_timeout = 24;
     */
    idleTimeout?: Duration;
    /**
     * Indicates that the route has a retry policy. Note that if this is set,
     * it'll take precedence over the virtual host level retry policy entirely
     * (e.g.: policies are not merged, most internal one becomes the enforced policy).
     *
     * @generated from protobuf field: envoy.api.v2.route.RetryPolicy retry_policy = 9;
     */
    retryPolicy?: RetryPolicy;
    /**
     * [#not-implemented-hide:]
     * Specifies the configuration for retry policy extension. Note that if this is set, it'll take
     * precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
     * most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_route.VirtualHost.retry_policy>`
     * should not be set if this field is used.
     *
     * @generated from protobuf field: google.protobuf.Any retry_policy_typed_config = 33;
     */
    retryPolicyTypedConfig?: Any;
    /**
     * Indicates that the route has a request mirroring policy.
     *
     * .. attention::
     *   This field has been deprecated in favor of `request_mirror_policies` which supports one or
     *   more mirroring policies.
     *
     * @deprecated
     * @generated from protobuf field: envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policy = 10 [deprecated = true];
     */
    requestMirrorPolicy?: RouteAction_RequestMirrorPolicy;
    /**
     * Indicates that the route has request mirroring policies.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;
     */
    requestMirrorPolicies: RouteAction_RequestMirrorPolicy[];
    /**
     * Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
     *
     * @generated from protobuf field: envoy.api.v2.core.RoutingPriority priority = 11;
     */
    priority: RoutingPriority;
    /**
     * Specifies a set of rate limit configurations that could be applied to the
     * route.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RateLimit rate_limits = 13;
     */
    rateLimits: RateLimit[];
    /**
     * Specifies if the rate limit filter should include the virtual host rate
     * limits. By default, if the route configured rate limits, the virtual host
     * :ref:`rate_limits <envoy_api_field_route.VirtualHost.rate_limits>` are not applied to the
     * request.
     *
     * @generated from protobuf field: google.protobuf.BoolValue include_vh_rate_limits = 14;
     */
    includeVhRateLimits?: BoolValue;
    /**
     * Specifies a list of hash policies to use for ring hash load balancing. Each
     * hash policy is evaluated individually and the combined result is used to
     * route the request. The method of combination is deterministic such that
     * identical lists of hash policies will produce the same hash. Since a hash
     * policy examines specific parts of a request, it can fail to produce a hash
     * (i.e. if the hashed header is not present). If (and only if) all configured
     * hash policies fail to generate a hash, no hash will be produced for
     * the route. In this case, the behavior is the same as if no hash policies
     * were specified (i.e. the ring hash load balancer will choose a random
     * backend). If a hash policy has the "terminal" attribute set to true, and
     * there is already a hash generated, the hash is returned immediately,
     * ignoring the rest of the hash policy list.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RouteAction.HashPolicy hash_policy = 15;
     */
    hashPolicy: RouteAction_HashPolicy[];
    /**
     * Indicates that the route has a CORS policy.
     *
     * @generated from protobuf field: envoy.api.v2.route.CorsPolicy cors = 17;
     */
    cors?: CorsPolicy;
    /**
     * If present, and the request is a gRPC request, use the
     * `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
     * or its default value (infinity) instead of
     * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>`, but limit the applied timeout
     * to the maximum value specified here. If configured as 0, the maximum allowed timeout for
     * gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
     * and gRPC requests time out like any other requests using
     * :ref:`timeout <envoy_api_field_route.RouteAction.timeout>` or its default.
     * This can be used to prevent unexpected upstream request timeouts due to potentially long
     * time gaps between gRPC request and response in gRPC streaming mode.
     *
     * .. note::
     *
     *    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
     *    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
     *    both are present. See also
     *    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
     *    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
     *    :ref:`retry overview <arch_overview_http_routing_retry>`.
     *
     * @generated from protobuf field: google.protobuf.Duration max_grpc_timeout = 23;
     */
    maxGrpcTimeout?: Duration;
    /**
     * If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
     * the provided duration from the header. This is useful in allowing Envoy to set its global
     * timeout to be less than that of the deadline imposed by the calling client, which makes it more
     * likely that Envoy will handle the timeout instead of having the call canceled by the client.
     * The offset will only be applied if the provided grpc_timeout is greater than the offset. This
     * ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
     * infinity).
     *
     * @generated from protobuf field: google.protobuf.Duration grpc_timeout_offset = 28;
     */
    grpcTimeoutOffset?: Duration;
    /**
     * @generated from protobuf field: repeated envoy.api.v2.route.RouteAction.UpgradeConfig upgrade_configs = 25;
     */
    upgradeConfigs: RouteAction_UpgradeConfig[];
    /**
     * @generated from protobuf field: envoy.api.v2.route.RouteAction.InternalRedirectAction internal_redirect_action = 26;
     */
    internalRedirectAction: RouteAction_InternalRedirectAction;
    /**
     * An internal redirect is handled, iff the number of previous internal redirects that a
     * downstream request has encountered is lower than this value, and
     * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
     * is set to :ref:`HANDLE_INTERNAL_REDIRECT
     * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
     * In the case where a downstream request is bounced among multiple routes by internal redirect,
     * the first route that hits this threshold, or has
     * :ref:`internal_redirect_action <envoy_api_field_route.RouteAction.internal_redirect_action>`
     * set to
     * :ref:`PASS_THROUGH_INTERNAL_REDIRECT
     * <envoy_api_enum_value_route.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
     * will pass the redirect back to downstream.
     *
     * If not specified, at most one redirect will be followed.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_internal_redirects = 31;
     */
    maxInternalRedirects?: UInt32Value;
    /**
     * Indicates that the route has a hedge policy. Note that if this is set,
     * it'll take precedence over the virtual host level hedge policy entirely
     * (e.g.: policies are not merged, most internal one becomes the enforced policy).
     *
     * @generated from protobuf field: envoy.api.v2.route.HedgePolicy hedge_policy = 27;
     */
    hedgePolicy?: HedgePolicy;
}
/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
 * useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * @generated from protobuf message envoy.api.v2.route.RouteAction.RequestMirrorPolicy
 */
export interface RouteAction_RequestMirrorPolicy {
    /**
     * Specifies the cluster that requests will be mirrored to. The cluster must
     * exist in the cluster manager configuration.
     *
     * @generated from protobuf field: string cluster = 1;
     */
    cluster: string;
    /**
     * If not specified, all requests to the target cluster will be mirrored. If
     * specified, Envoy will lookup the runtime key to get the % of requests to
     * mirror. Valid values are from 0 to 10000, allowing for increments of
     * 0.01% of requests to be mirrored. If the runtime key is specified in the
     * configuration but not present in runtime, 0 is the default and thus 0% of
     * requests will be mirrored.
     *
     * .. attention::
     *
     *   **This field is deprecated**. Set the
     *   :ref:`runtime_fraction
     *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
     *   field instead. Mirroring occurs if both this and
     *   <envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>`
     *   are not set.
     *
     * @deprecated
     * @generated from protobuf field: string runtime_key = 2 [deprecated = true];
     */
    runtimeKey: string;
    /**
     * If not specified, all requests to the target cluster will be mirrored.
     *
     * If specified, this field takes precedence over the `runtime_key` field and requests must also
     * fall under the percentage of matches indicated by this field.
     *
     * For some fraction N/D, a random number in the range [0,D) is selected. If the
     * number is <= the value of the numerator N, or if the key is not present, the default
     * value, the request will be mirrored.
     *
     * @generated from protobuf field: envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 3;
     */
    runtimeFraction?: RuntimeFractionalPercent;
    /**
     * Determines if the trace span should be sampled. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue trace_sampled = 4;
     */
    traceSampled?: BoolValue;
}
/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy
 */
export interface RouteAction_HashPolicy {
    /**
     * @generated from protobuf oneof: policy_specifier
     */
    policySpecifier: {
        oneofKind: "header";
        /**
         * Header hash policy.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction.HashPolicy.Header header = 1;
         */
        header: RouteAction_HashPolicy_Header;
    } | {
        oneofKind: "cookie";
        /**
         * Cookie hash policy.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction.HashPolicy.Cookie cookie = 2;
         */
        cookie: RouteAction_HashPolicy_Cookie;
    } | {
        oneofKind: "connectionProperties";
        /**
         * Connection properties hash policy.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;
         */
        connectionProperties: RouteAction_HashPolicy_ConnectionProperties;
    } | {
        oneofKind: "queryParameter";
        /**
         * Query parameter hash policy.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter query_parameter = 5;
         */
        queryParameter: RouteAction_HashPolicy_QueryParameter;
    } | {
        oneofKind: "filterState";
        /**
         * Filter state hash policy.
         *
         * @generated from protobuf field: envoy.api.v2.route.RouteAction.HashPolicy.FilterState filter_state = 6;
         */
        filterState: RouteAction_HashPolicy_FilterState;
    } | {
        oneofKind: undefined;
    };
    /**
     * The flag that short-circuits the hash computing. This field provides a
     * 'fallback' style of configuration: "if a terminal policy doesn't work,
     * fallback to rest of the policy list", it saves time when the terminal
     * policy works.
     *
     * If true, and there is already a hash computed, ignore rest of the
     * list of hash polices.
     * For example, if the following hash methods are configured:
     *
     *  ========= ========
     *  specifier terminal
     *  ========= ========
     *  Header A  true
     *  Header B  false
     *  Header C  false
     *  ========= ========
     *
     * The generateHash process ends if policy "header A" generates a hash, as
     * it's a terminal policy.
     *
     * @generated from protobuf field: bool terminal = 4;
     */
    terminal: boolean;
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy.Header
 */
export interface RouteAction_HashPolicy_Header {
    /**
     * The name of the request header that will be used to obtain the hash
     * key. If the request header is not present, no hash will be produced.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
}
/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 *
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy.Cookie
 */
export interface RouteAction_HashPolicy_Cookie {
    /**
     * The name of the cookie that will be used to obtain the hash key. If the
     * cookie is not present and ttl below is not set, no hash will be
     * produced.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * If specified, a cookie with the TTL will be generated if the cookie is
     * not present. If the TTL is present and zero, the generated cookie will
     * be a session cookie.
     *
     * @generated from protobuf field: google.protobuf.Duration ttl = 2;
     */
    ttl?: Duration;
    /**
     * The name of the path for the cookie. If no path is specified here, no path
     * will be set for the cookie.
     *
     * @generated from protobuf field: string path = 3;
     */
    path: string;
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties
 */
export interface RouteAction_HashPolicy_ConnectionProperties {
    /**
     * Hash on source IP address.
     *
     * @generated from protobuf field: bool source_ip = 1;
     */
    sourceIp: boolean;
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter
 */
export interface RouteAction_HashPolicy_QueryParameter {
    /**
     * The name of the URL query parameter that will be used to obtain the hash
     * key. If the parameter is not present, no hash will be produced. Query
     * parameter names are case-sensitive.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * @generated from protobuf message envoy.api.v2.route.RouteAction.HashPolicy.FilterState
 */
export interface RouteAction_HashPolicy_FilterState {
    /**
     * The name of the Object in the per-request filterState, which is an
     * Envoy::Hashable object. If there is no data associated with the key,
     * or the stored object is not Envoy::Hashable, no hash will be produced.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 *
 * @generated from protobuf message envoy.api.v2.route.RouteAction.UpgradeConfig
 */
export interface RouteAction_UpgradeConfig {
    /**
     * The case-insensitive name of this upgrade, e.g. "websocket".
     * For each upgrade type present in upgrade_configs, requests with
     * Upgrade: [upgrade_type] will be proxied upstream.
     *
     * @generated from protobuf field: string upgrade_type = 1;
     */
    upgradeType: string;
    /**
     * Determines if upgrades are available on this route. Defaults to true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue enabled = 2;
     */
    enabled?: BoolValue;
}
/**
 * @generated from protobuf enum envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode
 */
export enum RouteAction_ClusterNotFoundResponseCode {
    /**
     * HTTP status code - 503 Service Unavailable.
     *
     * @generated from protobuf enum value: SERVICE_UNAVAILABLE = 0;
     */
    SERVICE_UNAVAILABLE = 0,
    /**
     * HTTP status code - 404 Not Found.
     *
     * @generated from protobuf enum value: NOT_FOUND = 1;
     */
    NOT_FOUND = 1
}
/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 *
 * @generated from protobuf enum envoy.api.v2.route.RouteAction.InternalRedirectAction
 */
export enum RouteAction_InternalRedirectAction {
    /**
     * @generated from protobuf enum value: PASS_THROUGH_INTERNAL_REDIRECT = 0;
     */
    PASS_THROUGH_INTERNAL_REDIRECT = 0,
    /**
     * @generated from protobuf enum value: HANDLE_INTERNAL_REDIRECT = 1;
     */
    HANDLE_INTERNAL_REDIRECT = 1
}
/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.api.v2.route.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * Specifies the conditions under which retry takes place. These are the same
     * conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
     * :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
     *
     * @generated from protobuf field: string retry_on = 1;
     */
    retryOn: string;
    /**
     * Specifies the allowed number of retries. This parameter is optional and
     * defaults to 1. These are the same conditions documented for
     * :ref:`config_http_filters_router_x-envoy-max-retries`.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value num_retries = 2;
     */
    numRetries?: UInt32Value;
    /**
     * Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
     * same conditions documented for
     * :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
     *
     * .. note::
     *
     *   If left unspecified, Envoy will use the global
     *   :ref:`route timeout <envoy_api_field_route.RouteAction.timeout>` for the request.
     *   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
     *   retry policy, a request that times out will not be retried as the total timeout budget
     *   would have been exhausted.
     *
     * @generated from protobuf field: google.protobuf.Duration per_try_timeout = 3;
     */
    perTryTimeout?: Duration;
    /**
     * Specifies an implementation of a RetryPriority which is used to determine the
     * distribution of load across priorities used for retries. Refer to
     * :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
     *
     * @generated from protobuf field: envoy.api.v2.route.RetryPolicy.RetryPriority retry_priority = 4;
     */
    retryPriority?: RetryPolicy_RetryPriority;
    /**
     * Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
     * for retries. If any of the predicates reject the host, host selection will be reattempted.
     * Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
     * details.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RetryPolicy.RetryHostPredicate retry_host_predicate = 5;
     */
    retryHostPredicate: RetryPolicy_RetryHostPredicate[];
    /**
     * The maximum number of times host selection will be reattempted before giving up, at which
     * point the host that was last selected will be routed to. If unspecified, this will default to
     * retrying once.
     *
     * @generated from protobuf field: int64 host_selection_retry_max_attempts = 6;
     */
    hostSelectionRetryMaxAttempts: bigint;
    /**
     * HTTP status codes that should trigger a retry in addition to those specified by retry_on.
     *
     * @generated from protobuf field: repeated uint32 retriable_status_codes = 7;
     */
    retriableStatusCodes: number[];
    /**
     * Specifies parameters that control retry back off. This parameter is optional, in which case the
     * default base interval is 25 milliseconds or, if set, the current value of the
     * `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
     * the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
     * describes Envoy's back-off algorithm.
     *
     * @generated from protobuf field: envoy.api.v2.route.RetryPolicy.RetryBackOff retry_back_off = 8;
     */
    retryBackOff?: RetryPolicy_RetryBackOff;
    /**
     * HTTP response headers that trigger a retry if present in the response. A retry will be
     * triggered if any of the header matches match the upstream response headers.
     * The field is only consulted if 'retriable-headers' retry policy is active.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher retriable_headers = 9;
     */
    retriableHeaders: HeaderMatcher[];
    /**
     * HTTP headers which must be present in the request for retries to be attempted.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher retriable_request_headers = 10;
     */
    retriableRequestHeaders: HeaderMatcher[];
}
/**
 * @generated from protobuf message envoy.api.v2.route.RetryPolicy.RetryPriority
 */
export interface RetryPolicy_RetryPriority {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.api.v2.route.RetryPolicy.RetryHostPredicate
 */
export interface RetryPolicy_RetryHostPredicate {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.api.v2.route.RetryPolicy.RetryBackOff
 */
export interface RetryPolicy_RetryBackOff {
    /**
     * Specifies the base interval between retries. This parameter is required and must be greater
     * than zero. Values less than 1 ms are rounded up to 1 ms.
     * See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
     * back-off algorithm.
     *
     * @generated from protobuf field: google.protobuf.Duration base_interval = 1;
     */
    baseInterval?: Duration;
    /**
     * Specifies the maximum interval between retries. This parameter is optional, but must be
     * greater than or equal to the `base_interval` if set. The default is 10 times the
     * `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
     * of Envoy's back-off algorithm.
     *
     * @generated from protobuf field: google.protobuf.Duration max_interval = 2;
     */
    maxInterval?: Duration;
}
/**
 * HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
 *
 * @generated from protobuf message envoy.api.v2.route.HedgePolicy
 */
export interface HedgePolicy {
    /**
     * Specifies the number of initial requests that should be sent upstream.
     * Must be at least 1.
     * Defaults to 1.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value initial_requests = 1;
     */
    initialRequests?: UInt32Value;
    /**
     * Specifies a probability that an additional upstream request should be sent
     * on top of what is specified by initial_requests.
     * Defaults to 0.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.type.FractionalPercent additional_request_chance = 2;
     */
    additionalRequestChance?: FractionalPercent;
    /**
     * Indicates that a hedged request should be sent when the per-try timeout is hit.
     * This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.
     * The first request to complete successfully will be the one returned to the caller.
     *
     * * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.
     * * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client
     *   if there are no more retries left.
     * * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.
     *
     * Note: For this to have effect, you must have a :ref:`RetryPolicy <envoy_api_msg_route.RetryPolicy>` that retries at least
     * one error code and specifies a maximum number of retries.
     *
     * Defaults to false.
     *
     * @generated from protobuf field: bool hedge_on_per_try_timeout = 3;
     */
    hedgeOnPerTryTimeout: boolean;
}
/**
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.api.v2.route.RedirectAction
 */
export interface RedirectAction {
    /**
     * @generated from protobuf oneof: scheme_rewrite_specifier
     */
    schemeRewriteSpecifier: {
        oneofKind: "httpsRedirect";
        /**
         * The scheme portion of the URL will be swapped with "https".
         *
         * @generated from protobuf field: bool https_redirect = 4;
         */
        httpsRedirect: boolean;
    } | {
        oneofKind: "schemeRedirect";
        /**
         * The scheme portion of the URL will be swapped with this value.
         *
         * @generated from protobuf field: string scheme_redirect = 7;
         */
        schemeRedirect: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * The host portion of the URL will be swapped with this value.
     *
     * @generated from protobuf field: string host_redirect = 1;
     */
    hostRedirect: string;
    /**
     * The port value of the URL will be swapped with this value.
     *
     * @generated from protobuf field: uint32 port_redirect = 8;
     */
    portRedirect: number;
    /**
     * @generated from protobuf oneof: path_rewrite_specifier
     */
    pathRewriteSpecifier: {
        oneofKind: "pathRedirect";
        /**
         * The path portion of the URL will be swapped with this value.
         * Please note that query string in path_redirect will override the
         * request's query string and will not be stripped.
         *
         * For example, let's say we have the following routes:
         *
         * - match: { path: "/old-path-1" }
         *   redirect: { path_redirect: "/new-path-1" }
         * - match: { path: "/old-path-2" }
         *   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
         * - match: { path: "/old-path-3" }
         *   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
         *
         * 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
         * 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
         * 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
         *
         * @generated from protobuf field: string path_redirect = 2;
         */
        pathRedirect: string;
    } | {
        oneofKind: "prefixRewrite";
        /**
         * Indicates that during redirection, the matched prefix (or path)
         * should be swapped with this value. This option allows redirect URLs be dynamically created
         * based on the request.
         *
         * .. attention::
         *
         *   Pay attention to the use of trailing slashes as mentioned in
         *   :ref:`RouteAction's prefix_rewrite <envoy_api_field_route.RouteAction.prefix_rewrite>`.
         *
         * @generated from protobuf field: string prefix_rewrite = 5;
         */
        prefixRewrite: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * The HTTP status code to use in the redirect response. The default response
     * code is MOVED_PERMANENTLY (301).
     *
     * @generated from protobuf field: envoy.api.v2.route.RedirectAction.RedirectResponseCode response_code = 3;
     */
    responseCode: RedirectAction_RedirectResponseCode;
    /**
     * Indicates that during redirection, the query portion of the URL will
     * be removed. Default value is false.
     *
     * @generated from protobuf field: bool strip_query = 6;
     */
    stripQuery: boolean;
}
/**
 * @generated from protobuf enum envoy.api.v2.route.RedirectAction.RedirectResponseCode
 */
export enum RedirectAction_RedirectResponseCode {
    /**
     * Moved Permanently HTTP Status Code - 301.
     *
     * @generated from protobuf enum value: MOVED_PERMANENTLY = 0;
     */
    MOVED_PERMANENTLY = 0,
    /**
     * Found HTTP Status Code - 302.
     *
     * @generated from protobuf enum value: FOUND = 1;
     */
    FOUND = 1,
    /**
     * See Other HTTP Status Code - 303.
     *
     * @generated from protobuf enum value: SEE_OTHER = 2;
     */
    SEE_OTHER = 2,
    /**
     * Temporary Redirect HTTP Status Code - 307.
     *
     * @generated from protobuf enum value: TEMPORARY_REDIRECT = 3;
     */
    TEMPORARY_REDIRECT = 3,
    /**
     * Permanent Redirect HTTP Status Code - 308.
     *
     * @generated from protobuf enum value: PERMANENT_REDIRECT = 4;
     */
    PERMANENT_REDIRECT = 4
}
/**
 * @generated from protobuf message envoy.api.v2.route.DirectResponseAction
 */
export interface DirectResponseAction {
    /**
     * Specifies the HTTP response status to be returned.
     *
     * @generated from protobuf field: uint32 status = 1;
     */
    status: number;
    /**
     * Specifies the content of the response body. If this setting is omitted,
     * no body is included in the generated response.
     *
     * .. note::
     *
     *   Headers can be specified using *response_headers_to_add* in the enclosing
     *   :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_RouteConfiguration` or
     *   :ref:`envoy_api_msg_route.VirtualHost`.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource body = 2;
     */
    body?: DataSource;
}
/**
 * @generated from protobuf message envoy.api.v2.route.Decorator
 */
export interface Decorator {
    /**
     * The operation name associated with the request matched to this route. If tracing is
     * enabled, this information will be used as the span name reported for this request.
     *
     * .. note::
     *
     *   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
     *   by the :ref:`x-envoy-decorator-operation
     *   <config_http_filters_router_x-envoy-decorator-operation>` header.
     *
     * @generated from protobuf field: string operation = 1;
     */
    operation: string;
    /**
     * Whether the decorated details should be propagated to the other party. The default is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue propagate = 2;
     */
    propagate?: BoolValue;
}
/**
 * @generated from protobuf message envoy.api.v2.route.Tracing
 */
export interface Tracing {
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be force
     * traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
     * header is set. This field is a direct analog for the runtime variable
     * 'tracing.client_enabled' in the :ref:`HTTP Connection Manager
     * <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.FractionalPercent client_sampling = 1;
     */
    clientSampling?: FractionalPercent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be randomly
     * selected for trace generation, if not requested by the client or not forced. This field is
     * a direct analog for the runtime variable 'tracing.random_sampling' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.FractionalPercent random_sampling = 2;
     */
    randomSampling?: FractionalPercent;
    /**
     * Target percentage of requests managed by this HTTP connection manager that will be traced
     * after all other sampling checks have been applied (client-directed, force tracing, random
     * sampling). This field functions as an upper limit on the total configured sampling rate. For
     * instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
     * of client requests with the appropriate headers to be force traced. This field is a direct
     * analog for the runtime variable 'tracing.global_enabled' in the
     * :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
     * Default: 100%
     *
     * @generated from protobuf field: envoy.type.FractionalPercent overall_sampling = 3;
     */
    overallSampling?: FractionalPercent;
    /**
     * A list of custom tags with unique tag name to create tags for the active span.
     * It will take effect after merging with the :ref:`corresponding configuration
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.custom_tags>`
     * configured in the HTTP connection manager. If two tags with the same name are configured
     * each in the HTTP connection manager and the route level, the one configured here takes
     * priority.
     *
     * @generated from protobuf field: repeated envoy.type.tracing.v2.CustomTag custom_tags = 4;
     */
    customTags: CustomTag[];
}
/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, itâ€™s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get â€œperfectâ€ statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 *
 * @generated from protobuf message envoy.api.v2.route.VirtualCluster
 */
export interface VirtualCluster {
    /**
     * Specifies a regex pattern to use for matching requests. The entire path of the request
     * must match the regex. The regex grammar used is defined `here
     * <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
     *
     * Examples:
     *
     * * The regex ``/rides/\d+`` matches the path *\/rides/0*
     * * The regex ``/rides/\d+`` matches the path *\/rides/123*
     * * The regex ``/rides/\d+`` does not match the path *\/rides/123/456*
     *
     * .. attention::
     *   This field has been deprecated in favor of `headers` as it is not safe for use with
     *   untrusted input in all cases.
     *
     * @deprecated
     * @generated from protobuf field: string pattern = 1 [deprecated = true];
     */
    pattern: string;
    /**
     * Specifies a list of header matchers to use for matching requests. Each specified header must
     * match. The pseudo-headers `:path` and `:method` can be used to match the request path and
     * method, respectively.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher headers = 4;
     */
    headers: HeaderMatcher[];
    /**
     * Specifies the name of the virtual cluster. The virtual cluster name as well
     * as the virtual host name are used when emitting statistics. The statistics are emitted by the
     * router filter and are documented :ref:`here <config_http_filters_router_stats>`.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Optionally specifies the HTTP method to match on. For example GET, PUT,
     * etc.
     *
     * .. attention::
     *   This field has been deprecated in favor of `headers`.
     *
     * @deprecated
     * @generated from protobuf field: envoy.api.v2.core.RequestMethod method = 3 [deprecated = true];
     */
    method: RequestMethod;
}
/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit
 */
export interface RateLimit {
    /**
     * Refers to the stage set in the filter. The rate limit configuration only
     * applies to filters with the same stage number. The default stage number is
     * 0.
     *
     * .. note::
     *
     *   The filter supports a range of 0 - 10 inclusively for stage numbers.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value stage = 1;
     */
    stage?: UInt32Value;
    /**
     * The key to be set in runtime to disable this rate limit configuration.
     *
     * @generated from protobuf field: string disable_key = 2;
     */
    disableKey: string;
    /**
     * A list of actions that are to be applied for this rate limit configuration.
     * Order matters as the actions are processed sequentially and the descriptor
     * is composed by appending descriptor entries in that sequence. If an action
     * cannot append a descriptor entry, no descriptor is generated for the
     * configuration. See :ref:`composing actions
     * <config_http_filters_rate_limit_composing_actions>` for additional documentation.
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.RateLimit.Action actions = 3;
     */
    actions: RateLimit_Action[];
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action
 */
export interface RateLimit_Action {
    /**
     * @generated from protobuf oneof: action_specifier
     */
    actionSpecifier: {
        oneofKind: "sourceCluster";
        /**
         * Rate limit on source cluster.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.SourceCluster source_cluster = 1;
         */
        sourceCluster: RateLimit_Action_SourceCluster;
    } | {
        oneofKind: "destinationCluster";
        /**
         * Rate limit on destination cluster.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.DestinationCluster destination_cluster = 2;
         */
        destinationCluster: RateLimit_Action_DestinationCluster;
    } | {
        oneofKind: "requestHeaders";
        /**
         * Rate limit on request headers.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.RequestHeaders request_headers = 3;
         */
        requestHeaders: RateLimit_Action_RequestHeaders;
    } | {
        oneofKind: "remoteAddress";
        /**
         * Rate limit on remote address.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.RemoteAddress remote_address = 4;
         */
        remoteAddress: RateLimit_Action_RemoteAddress;
    } | {
        oneofKind: "genericKey";
        /**
         * Rate limit on a generic key.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.GenericKey generic_key = 5;
         */
        genericKey: RateLimit_Action_GenericKey;
    } | {
        oneofKind: "headerValueMatch";
        /**
         * Rate limit on the existence of request headers.
         *
         * @generated from protobuf field: envoy.api.v2.route.RateLimit.Action.HeaderValueMatch header_value_match = 6;
         */
        headerValueMatch: RateLimit_Action_HeaderValueMatch;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.SourceCluster
 */
export interface RateLimit_Action_SourceCluster {
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.DestinationCluster
 */
export interface RateLimit_Action_DestinationCluster {
}
/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * *header_name*:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.RequestHeaders
 */
export interface RateLimit_Action_RequestHeaders {
    /**
     * The header name to be queried from the request headers. The headerâ€™s
     * value is used to populate the value of the descriptor entry for the
     * descriptor_key.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
    /**
     * The key to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_key = 2;
     */
    descriptorKey: string;
}
/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.RemoteAddress
 */
export interface RateLimit_Action_RemoteAddress {
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.GenericKey
 */
export interface RateLimit_Action_GenericKey {
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
}
/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from protobuf message envoy.api.v2.route.RateLimit.Action.HeaderValueMatch
 */
export interface RateLimit_Action_HeaderValueMatch {
    /**
     * The value to use in the descriptor entry.
     *
     * @generated from protobuf field: string descriptor_value = 1;
     */
    descriptorValue: string;
    /**
     * If set to true, the action will append a descriptor entry when the
     * request matches the headers. If set to false, the action will append a
     * descriptor entry when the request does not match the headers. The
     * default value is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue expect_match = 2;
     */
    expectMatch?: BoolValue;
    /**
     * Specifies a set of headers that the rate limit action should match
     * on. The action will check the requestâ€™s headers against all the
     * specified headers in the config. A match will happen if all the
     * headers in the config are present in the request with the same values
     * (or based on presence if the value field is not in the config).
     *
     * @generated from protobuf field: repeated envoy.api.v2.route.HeaderMatcher headers = 3;
     */
    headers: HeaderMatcher[];
}
/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
 *   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "exact_match": "POST"
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.api.v2.route.HeaderMatcher
 */
export interface HeaderMatcher {
    /**
     * Specifies the name of the header in the request.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: header_match_specifier
     */
    headerMatchSpecifier: {
        oneofKind: "exactMatch";
        /**
         * If specified, header match will be performed based on the value of the header.
         *
         * @generated from protobuf field: string exact_match = 4;
         */
        exactMatch: string;
    } | {
        oneofKind: "regexMatch";
        /**
         * If specified, this regex string is a regular expression rule which implies the entire request
         * header value must match the regex. The rule will not match if only a subsequence of the
         * request header value matches the regex. The regex grammar used in the value field is defined
         * `here <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
         *
         * Examples:
         *
         * * The regex ``\d{3}`` matches the value *123*
         * * The regex ``\d{3}`` does not match the value *1234*
         * * The regex ``\d{3}`` does not match the value *123.456*
         *
         * .. attention::
         *   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
         *   with untrusted input in all cases.
         *
         * @deprecated
         * @generated from protobuf field: string regex_match = 5 [deprecated = true];
         */
        regexMatch: string;
    } | {
        oneofKind: "safeRegexMatch";
        /**
         * If specified, this regex string is a regular expression rule which implies the entire request
         * header value must match the regex. The rule will not match if only a subsequence of the
         * request header value matches the regex.
         *
         * @generated from protobuf field: envoy.type.matcher.RegexMatcher safe_regex_match = 11;
         */
        safeRegexMatch: RegexMatcher;
    } | {
        oneofKind: "rangeMatch";
        /**
         * If specified, header match will be performed based on range.
         * The rule will match if the request header value is within this range.
         * The entire request header value must represent an integer in base 10 notation: consisting of
         * an optional plus or minus sign followed by a sequence of digits. The rule will not match if
         * the header value does not represent an integer. Match will fail for empty values, floating
         * point numbers or if only a subsequence of the header value is an integer.
         *
         * Examples:
         *
         * * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
         *   "-1somestring"
         *
         * @generated from protobuf field: envoy.type.Int64Range range_match = 6;
         */
        rangeMatch: Int64Range;
    } | {
        oneofKind: "presentMatch";
        /**
         * If specified, header match will be performed based on whether the header is in the
         * request.
         *
         * @generated from protobuf field: bool present_match = 7;
         */
        presentMatch: boolean;
    } | {
        oneofKind: "prefixMatch";
        /**
         * If specified, header match will be performed based on the prefix of the header value.
         * Note: empty prefix is not allowed, please use present_match instead.
         *
         * Examples:
         *
         * * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
         *
         * @generated from protobuf field: string prefix_match = 9;
         */
        prefixMatch: string;
    } | {
        oneofKind: "suffixMatch";
        /**
         * If specified, header match will be performed based on the suffix of the header value.
         * Note: empty suffix is not allowed, please use present_match instead.
         *
         * Examples:
         *
         * * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
         *
         * @generated from protobuf field: string suffix_match = 10;
         */
        suffixMatch: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * If specified, the match result will be inverted before checking. Defaults to false.
     *
     * Examples:
     *
     * * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
     * * The range [-10,0) will match the value -1, so it will not match when inverted.
     *
     * @generated from protobuf field: bool invert_match = 8;
     */
    invertMatch: boolean;
}
/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.route.QueryParameterMatcher
 */
export interface QueryParameterMatcher {
    /**
     * Specifies the name of a key that must be present in the requested
     * *path*'s query string.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Specifies the value of the key. If the value is absent, a request
     * that contains the key in its query string will match, whether the
     * key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
     *
     * ..attention::
     *   This field is deprecated. Use an `exact` match inside the `string_match` field.
     *
     * @deprecated
     * @generated from protobuf field: string value = 3 [deprecated = true];
     */
    value: string;
    /**
     * Specifies whether the query parameter value is a regular expression.
     * Defaults to false. The entire query parameter value (i.e., the part to
     * the right of the equals sign in "key=value") must match the regex.
     * E.g., the regex ``\d+$`` will match *123* but not *a123* or *123a*.
     *
     * ..attention::
     *   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
     *
     * @deprecated
     * @generated from protobuf field: google.protobuf.BoolValue regex = 4 [deprecated = true];
     */
    regex?: BoolValue;
    /**
     * @generated from protobuf oneof: query_parameter_match_specifier
     */
    queryParameterMatchSpecifier: {
        oneofKind: "stringMatch";
        /**
         * Specifies whether a query parameter value should match against a string.
         *
         * @generated from protobuf field: envoy.type.matcher.StringMatcher string_match = 5;
         */
        stringMatch: StringMatcher;
    } | {
        oneofKind: "presentMatch";
        /**
         * Specifies whether a query parameter should be present.
         *
         * @generated from protobuf field: bool present_match = 6;
         */
        presentMatch: boolean;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class VirtualHost$Type extends MessageType<VirtualHost> {
    constructor() {
        super("envoy.api.v2.route.VirtualHost", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "domains", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { minItems: "1", items: { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } } } },
            { no: 3, name: "routes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Route },
            { no: 4, name: "require_tls", kind: "enum", T: () => ["envoy.api.v2.route.VirtualHost.TlsRequirementType", VirtualHost_TlsRequirementType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 5, name: "virtual_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VirtualCluster },
            { no: 6, name: "rate_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit },
            { no: 7, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 13, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 11, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "cors", kind: "message", T: () => CorsPolicy },
            { no: 12, name: "per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 15, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 14, name: "include_request_attempt_count", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "include_attempt_count_in_response", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 20, name: "retry_policy_typed_config", kind: "message", T: () => Any },
            { no: 17, name: "hedge_policy", kind: "message", T: () => HedgePolicy },
            { no: 18, name: "per_request_buffer_limit_bytes", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<VirtualHost>): VirtualHost {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.domains = [];
        message.routes = [];
        message.requireTls = 0;
        message.virtualClusters = [];
        message.rateLimits = [];
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        message.perFilterConfig = {};
        message.typedPerFilterConfig = {};
        message.includeRequestAttemptCount = false;
        message.includeAttemptCountInResponse = false;
        if (value !== undefined)
            reflectionMergePartial<VirtualHost>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VirtualHost): VirtualHost {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string domains */ 2:
                    message.domains.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.route.Route routes */ 3:
                    message.routes.push(Route.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.api.v2.route.VirtualHost.TlsRequirementType require_tls */ 4:
                    message.requireTls = reader.int32();
                    break;
                case /* repeated envoy.api.v2.route.VirtualCluster virtual_clusters */ 5:
                    message.virtualClusters.push(VirtualCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.route.RateLimit rate_limits */ 6:
                    message.rateLimits.push(RateLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add */ 7:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 13:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add */ 10:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 11:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* envoy.api.v2.route.CorsPolicy cors */ 8:
                    message.cors = CorsPolicy.internalBinaryRead(reader, reader.uint32(), options, message.cors);
                    break;
                case /* map<string, google.protobuf.Struct> per_filter_config = 12 [deprecated = true];*/ 12:
                    this.binaryReadMap12(message.perFilterConfig, reader, options);
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 15:
                    this.binaryReadMap15(message.typedPerFilterConfig, reader, options);
                    break;
                case /* bool include_request_attempt_count */ 14:
                    message.includeRequestAttemptCount = reader.bool();
                    break;
                case /* bool include_attempt_count_in_response */ 19:
                    message.includeAttemptCountInResponse = reader.bool();
                    break;
                case /* envoy.api.v2.route.RetryPolicy retry_policy */ 16:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* google.protobuf.Any retry_policy_typed_config */ 20:
                    message.retryPolicyTypedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicyTypedConfig);
                    break;
                case /* envoy.api.v2.route.HedgePolicy hedge_policy */ 17:
                    message.hedgePolicy = HedgePolicy.internalBinaryRead(reader, reader.uint32(), options, message.hedgePolicy);
                    break;
                case /* google.protobuf.UInt32Value per_request_buffer_limit_bytes */ 18:
                    message.perRequestBufferLimitBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.perRequestBufferLimitBytes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap12(map: VirtualHost["perFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof VirtualHost["perFilterConfig"] | undefined, val: VirtualHost["perFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.VirtualHost.per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    private binaryReadMap15(map: VirtualHost["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof VirtualHost["typedPerFilterConfig"] | undefined, val: VirtualHost["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.VirtualHost.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: VirtualHost, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string domains = 2; */
        for (let i = 0; i < message.domains.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.domains[i]);
        /* repeated envoy.api.v2.route.Route routes = 3; */
        for (let i = 0; i < message.routes.length; i++)
            Route.internalBinaryWrite(message.routes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.VirtualHost.TlsRequirementType require_tls = 4; */
        if (message.requireTls !== 0)
            writer.tag(4, WireType.Varint).int32(message.requireTls);
        /* repeated envoy.api.v2.route.VirtualCluster virtual_clusters = 5; */
        for (let i = 0; i < message.virtualClusters.length; i++)
            VirtualCluster.internalBinaryWrite(message.virtualClusters[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.RateLimit rate_limits = 6; */
        for (let i = 0; i < message.rateLimits.length; i++)
            RateLimit.internalBinaryWrite(message.rateLimits[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 7; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 13; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 11; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* envoy.api.v2.route.CorsPolicy cors = 8; */
        if (message.cors)
            CorsPolicy.internalBinaryWrite(message.cors, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Struct> per_filter_config = 12 [deprecated = true]; */
        for (let k of globalThis.Object.keys(message.perFilterConfig)) {
            writer.tag(12, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.perFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.Any> typed_per_filter_config = 15; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(15, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* bool include_request_attempt_count = 14; */
        if (message.includeRequestAttemptCount !== false)
            writer.tag(14, WireType.Varint).bool(message.includeRequestAttemptCount);
        /* bool include_attempt_count_in_response = 19; */
        if (message.includeAttemptCountInResponse !== false)
            writer.tag(19, WireType.Varint).bool(message.includeAttemptCountInResponse);
        /* envoy.api.v2.route.RetryPolicy retry_policy = 16; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any retry_policy_typed_config = 20; */
        if (message.retryPolicyTypedConfig)
            Any.internalBinaryWrite(message.retryPolicyTypedConfig, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.HedgePolicy hedge_policy = 17; */
        if (message.hedgePolicy)
            HedgePolicy.internalBinaryWrite(message.hedgePolicy, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18; */
        if (message.perRequestBufferLimitBytes)
            UInt32Value.internalBinaryWrite(message.perRequestBufferLimitBytes, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.VirtualHost
 */
export const VirtualHost = new VirtualHost$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterAction$Type extends MessageType<FilterAction> {
    constructor() {
        super("envoy.api.v2.route.FilterAction", [
            { no: 1, name: "action", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<FilterAction>): FilterAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FilterAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterAction): FilterAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any action */ 1:
                    message.action = Any.internalBinaryRead(reader, reader.uint32(), options, message.action);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any action = 1; */
        if (message.action)
            Any.internalBinaryWrite(message.action, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.FilterAction
 */
export const FilterAction = new FilterAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Route$Type extends MessageType<Route> {
    constructor() {
        super("envoy.api.v2.route.Route", [
            { no: 14, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "match", kind: "message", T: () => RouteMatch, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "route", kind: "message", oneof: "action", T: () => RouteAction },
            { no: 3, name: "redirect", kind: "message", oneof: "action", T: () => RedirectAction },
            { no: 7, name: "direct_response", kind: "message", oneof: "action", T: () => DirectResponseAction },
            { no: 17, name: "filter_action", kind: "message", oneof: "action", T: () => FilterAction },
            { no: 4, name: "metadata", kind: "message", T: () => Metadata },
            { no: 5, name: "decorator", kind: "message", T: () => Decorator },
            { no: 8, name: "per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 13, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } },
            { no: 9, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 12, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 11, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "tracing", kind: "message", T: () => Tracing },
            { no: 16, name: "per_request_buffer_limit_bytes", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<Route>): Route {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.action = { oneofKind: undefined };
        message.perFilterConfig = {};
        message.typedPerFilterConfig = {};
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        if (value !== undefined)
            reflectionMergePartial<Route>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Route): Route {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 14:
                    message.name = reader.string();
                    break;
                case /* envoy.api.v2.route.RouteMatch match */ 1:
                    message.match = RouteMatch.internalBinaryRead(reader, reader.uint32(), options, message.match);
                    break;
                case /* envoy.api.v2.route.RouteAction route */ 2:
                    message.action = {
                        oneofKind: "route",
                        route: RouteAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).route)
                    };
                    break;
                case /* envoy.api.v2.route.RedirectAction redirect */ 3:
                    message.action = {
                        oneofKind: "redirect",
                        redirect: RedirectAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).redirect)
                    };
                    break;
                case /* envoy.api.v2.route.DirectResponseAction direct_response */ 7:
                    message.action = {
                        oneofKind: "directResponse",
                        directResponse: DirectResponseAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).directResponse)
                    };
                    break;
                case /* envoy.api.v2.route.FilterAction filter_action */ 17:
                    message.action = {
                        oneofKind: "filterAction",
                        filterAction: FilterAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).filterAction)
                    };
                    break;
                case /* envoy.api.v2.core.Metadata metadata */ 4:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.api.v2.route.Decorator decorator */ 5:
                    message.decorator = Decorator.internalBinaryRead(reader, reader.uint32(), options, message.decorator);
                    break;
                case /* map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];*/ 8:
                    this.binaryReadMap8(message.perFilterConfig, reader, options);
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 13:
                    this.binaryReadMap13(message.typedPerFilterConfig, reader, options);
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add */ 9:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 12:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add */ 10:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 11:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* envoy.api.v2.route.Tracing tracing */ 15:
                    message.tracing = Tracing.internalBinaryRead(reader, reader.uint32(), options, message.tracing);
                    break;
                case /* google.protobuf.UInt32Value per_request_buffer_limit_bytes */ 16:
                    message.perRequestBufferLimitBytes = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.perRequestBufferLimitBytes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: Route["perFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Route["perFilterConfig"] | undefined, val: Route["perFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.Route.per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    private binaryReadMap13(map: Route["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Route["typedPerFilterConfig"] | undefined, val: Route["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.Route.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: Route, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 14; */
        if (message.name !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.name);
        /* envoy.api.v2.route.RouteMatch match = 1; */
        if (message.match)
            RouteMatch.internalBinaryWrite(message.match, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction route = 2; */
        if (message.action.oneofKind === "route")
            RouteAction.internalBinaryWrite(message.action.route, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RedirectAction redirect = 3; */
        if (message.action.oneofKind === "redirect")
            RedirectAction.internalBinaryWrite(message.action.redirect, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.DirectResponseAction direct_response = 7; */
        if (message.action.oneofKind === "directResponse")
            DirectResponseAction.internalBinaryWrite(message.action.directResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.FilterAction filter_action = 17; */
        if (message.action.oneofKind === "filterAction")
            FilterAction.internalBinaryWrite(message.action.filterAction, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.Metadata metadata = 4; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.Decorator decorator = 5; */
        if (message.decorator)
            Decorator.internalBinaryWrite(message.decorator, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true]; */
        for (let k of globalThis.Object.keys(message.perFilterConfig)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.perFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.Any> typed_per_filter_config = 13; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(13, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 9; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 12; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 11; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* envoy.api.v2.route.Tracing tracing = 15; */
        if (message.tracing)
            Tracing.internalBinaryWrite(message.tracing, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16; */
        if (message.perRequestBufferLimitBytes)
            UInt32Value.internalBinaryWrite(message.perRequestBufferLimitBytes, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.Route
 */
export const Route = new Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightedCluster$Type extends MessageType<WeightedCluster> {
    constructor() {
        super("envoy.api.v2.route.WeightedCluster", [
            { no: 1, name: "clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WeightedCluster_ClusterWeight, options: { "validate.rules": { repeated: { minItems: "1" } } } },
            { no: 3, name: "total_weight", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 2, name: "runtime_key_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WeightedCluster>): WeightedCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusters = [];
        message.runtimeKeyPrefix = "";
        if (value !== undefined)
            reflectionMergePartial<WeightedCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightedCluster): WeightedCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.route.WeightedCluster.ClusterWeight clusters */ 1:
                    message.clusters.push(WeightedCluster_ClusterWeight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.UInt32Value total_weight */ 3:
                    message.totalWeight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.totalWeight);
                    break;
                case /* string runtime_key_prefix */ 2:
                    message.runtimeKeyPrefix = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WeightedCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.route.WeightedCluster.ClusterWeight clusters = 1; */
        for (let i = 0; i < message.clusters.length; i++)
            WeightedCluster_ClusterWeight.internalBinaryWrite(message.clusters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value total_weight = 3; */
        if (message.totalWeight)
            UInt32Value.internalBinaryWrite(message.totalWeight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key_prefix = 2; */
        if (message.runtimeKeyPrefix !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKeyPrefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.WeightedCluster
 */
export const WeightedCluster = new WeightedCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WeightedCluster_ClusterWeight$Type extends MessageType<WeightedCluster_ClusterWeight> {
    constructor() {
        super("envoy.api.v2.route.WeightedCluster.ClusterWeight", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "weight", kind: "message", T: () => UInt32Value },
            { no: 3, name: "metadata_match", kind: "message", T: () => Metadata },
            { no: 4, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 9, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "response_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 6, name: "response_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } },
            { no: 10, name: "typed_per_filter_config", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } }
        ]);
    }
    create(value?: PartialMessage<WeightedCluster_ClusterWeight>): WeightedCluster_ClusterWeight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.responseHeadersToAdd = [];
        message.responseHeadersToRemove = [];
        message.perFilterConfig = {};
        message.typedPerFilterConfig = {};
        if (value !== undefined)
            reflectionMergePartial<WeightedCluster_ClusterWeight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WeightedCluster_ClusterWeight): WeightedCluster_ClusterWeight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.UInt32Value weight */ 2:
                    message.weight = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.weight);
                    break;
                case /* envoy.api.v2.core.Metadata metadata_match */ 3:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add */ 4:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 9:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add */ 5:
                    message.responseHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string response_headers_to_remove */ 6:
                    message.responseHeadersToRemove.push(reader.string());
                    break;
                case /* map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true];*/ 8:
                    this.binaryReadMap8(message.perFilterConfig, reader, options);
                    break;
                case /* map<string, google.protobuf.Any> typed_per_filter_config */ 10:
                    this.binaryReadMap10(message.typedPerFilterConfig, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: WeightedCluster_ClusterWeight["perFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeightedCluster_ClusterWeight["perFilterConfig"] | undefined, val: WeightedCluster_ClusterWeight["perFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.WeightedCluster.ClusterWeight.per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    private binaryReadMap10(map: WeightedCluster_ClusterWeight["typedPerFilterConfig"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WeightedCluster_ClusterWeight["typedPerFilterConfig"] | undefined, val: WeightedCluster_ClusterWeight["typedPerFilterConfig"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.route.WeightedCluster.ClusterWeight.typed_per_filter_config");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: WeightedCluster_ClusterWeight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.UInt32Value weight = 2; */
        if (message.weight)
            UInt32Value.internalBinaryWrite(message.weight, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.Metadata metadata_match = 3; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 4; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 9; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* repeated envoy.api.v2.core.HeaderValueOption response_headers_to_add = 5; */
        for (let i = 0; i < message.responseHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.responseHeadersToAdd[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated string response_headers_to_remove = 6; */
        for (let i = 0; i < message.responseHeadersToRemove.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.responseHeadersToRemove[i]);
        /* map<string, google.protobuf.Struct> per_filter_config = 8 [deprecated = true]; */
        for (let k of globalThis.Object.keys(message.perFilterConfig)) {
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.perFilterConfig[k], writer, options);
            writer.join().join();
        }
        /* map<string, google.protobuf.Any> typed_per_filter_config = 10; */
        for (let k of globalThis.Object.keys(message.typedPerFilterConfig)) {
            writer.tag(10, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.typedPerFilterConfig[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.WeightedCluster.ClusterWeight
 */
export const WeightedCluster_ClusterWeight = new WeightedCluster_ClusterWeight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch$Type extends MessageType<RouteMatch> {
    constructor() {
        super("envoy.api.v2.route.RouteMatch", [
            { no: 1, name: "prefix", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "regex", kind: "scalar", oneof: "pathSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024" } }, "envoy.annotations.disallowed_by_default": true } },
            { no: 10, name: "safe_regex", kind: "message", oneof: "pathSpecifier", T: () => RegexMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "case_sensitive", kind: "message", T: () => BoolValue },
            { no: 9, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 6, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 7, name: "query_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryParameterMatcher },
            { no: 8, name: "grpc", kind: "message", T: () => RouteMatch_GrpcRouteMatchOptions },
            { no: 11, name: "tls_context", kind: "message", T: () => RouteMatch_TlsContextMatchOptions }
        ]);
    }
    create(value?: PartialMessage<RouteMatch>): RouteMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pathSpecifier = { oneofKind: undefined };
        message.headers = [];
        message.queryParameters = [];
        if (value !== undefined)
            reflectionMergePartial<RouteMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch): RouteMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string prefix */ 1:
                    message.pathSpecifier = {
                        oneofKind: "prefix",
                        prefix: reader.string()
                    };
                    break;
                case /* string path */ 2:
                    message.pathSpecifier = {
                        oneofKind: "path",
                        path: reader.string()
                    };
                    break;
                case /* string regex = 3 [deprecated = true];*/ 3:
                    message.pathSpecifier = {
                        oneofKind: "regex",
                        regex: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.RegexMatcher safe_regex */ 10:
                    message.pathSpecifier = {
                        oneofKind: "safeRegex",
                        safeRegex: RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.pathSpecifier as any).safeRegex)
                    };
                    break;
                case /* google.protobuf.BoolValue case_sensitive */ 4:
                    message.caseSensitive = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.caseSensitive);
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction */ 9:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* repeated envoy.api.v2.route.HeaderMatcher headers */ 6:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.route.QueryParameterMatcher query_parameters */ 7:
                    message.queryParameters.push(QueryParameterMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc */ 8:
                    message.grpc = RouteMatch_GrpcRouteMatchOptions.internalBinaryRead(reader, reader.uint32(), options, message.grpc);
                    break;
                case /* envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context */ 11:
                    message.tlsContext = RouteMatch_TlsContextMatchOptions.internalBinaryRead(reader, reader.uint32(), options, message.tlsContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string prefix = 1; */
        if (message.pathSpecifier.oneofKind === "prefix")
            writer.tag(1, WireType.LengthDelimited).string(message.pathSpecifier.prefix);
        /* string path = 2; */
        if (message.pathSpecifier.oneofKind === "path")
            writer.tag(2, WireType.LengthDelimited).string(message.pathSpecifier.path);
        /* string regex = 3 [deprecated = true]; */
        if (message.pathSpecifier.oneofKind === "regex")
            writer.tag(3, WireType.LengthDelimited).string(message.pathSpecifier.regex);
        /* envoy.type.matcher.RegexMatcher safe_regex = 10; */
        if (message.pathSpecifier.oneofKind === "safeRegex")
            RegexMatcher.internalBinaryWrite(message.pathSpecifier.safeRegex, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue case_sensitive = 4; */
        if (message.caseSensitive)
            BoolValue.internalBinaryWrite(message.caseSensitive, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.HeaderMatcher headers = 6; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.QueryParameterMatcher query_parameters = 7; */
        for (let i = 0; i < message.queryParameters.length; i++)
            QueryParameterMatcher.internalBinaryWrite(message.queryParameters[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8; */
        if (message.grpc)
            RouteMatch_GrpcRouteMatchOptions.internalBinaryWrite(message.grpc, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11; */
        if (message.tlsContext)
            RouteMatch_TlsContextMatchOptions.internalBinaryWrite(message.tlsContext, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteMatch
 */
export const RouteMatch = new RouteMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch_GrpcRouteMatchOptions$Type extends MessageType<RouteMatch_GrpcRouteMatchOptions> {
    constructor() {
        super("envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions", []);
    }
    create(value?: PartialMessage<RouteMatch_GrpcRouteMatchOptions>): RouteMatch_GrpcRouteMatchOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteMatch_GrpcRouteMatchOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch_GrpcRouteMatchOptions): RouteMatch_GrpcRouteMatchOptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RouteMatch_GrpcRouteMatchOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions
 */
export const RouteMatch_GrpcRouteMatchOptions = new RouteMatch_GrpcRouteMatchOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteMatch_TlsContextMatchOptions$Type extends MessageType<RouteMatch_TlsContextMatchOptions> {
    constructor() {
        super("envoy.api.v2.route.RouteMatch.TlsContextMatchOptions", [
            { no: 1, name: "presented", kind: "message", T: () => BoolValue },
            { no: 2, name: "validated", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<RouteMatch_TlsContextMatchOptions>): RouteMatch_TlsContextMatchOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RouteMatch_TlsContextMatchOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteMatch_TlsContextMatchOptions): RouteMatch_TlsContextMatchOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue presented */ 1:
                    message.presented = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.presented);
                    break;
                case /* google.protobuf.BoolValue validated */ 2:
                    message.validated = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.validated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteMatch_TlsContextMatchOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue presented = 1; */
        if (message.presented)
            BoolValue.internalBinaryWrite(message.presented, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue validated = 2; */
        if (message.validated)
            BoolValue.internalBinaryWrite(message.validated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteMatch.TlsContextMatchOptions
 */
export const RouteMatch_TlsContextMatchOptions = new RouteMatch_TlsContextMatchOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CorsPolicy$Type extends MessageType<CorsPolicy> {
    constructor() {
        super("envoy.api.v2.route.CorsPolicy", [
            { no: 1, name: "allow_origin", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 8, name: "allow_origin_regex", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { maxBytes: "1024" } } } } } },
            { no: 11, name: "allow_origin_string_match", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringMatcher },
            { no: 2, name: "allow_methods", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "allow_headers", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "expose_headers", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "max_age", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "allow_credentials", kind: "message", T: () => BoolValue },
            { no: 7, name: "enabled", kind: "message", oneof: "enabledSpecifier", T: () => BoolValue, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 9, name: "filter_enabled", kind: "message", oneof: "enabledSpecifier", T: () => RuntimeFractionalPercent },
            { no: 10, name: "shadow_enabled", kind: "message", T: () => RuntimeFractionalPercent }
        ]);
    }
    create(value?: PartialMessage<CorsPolicy>): CorsPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowOrigin = [];
        message.allowOriginRegex = [];
        message.allowOriginStringMatch = [];
        message.allowMethods = "";
        message.allowHeaders = "";
        message.exposeHeaders = "";
        message.maxAge = "";
        message.enabledSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<CorsPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CorsPolicy): CorsPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string allow_origin = 1 [deprecated = true];*/ 1:
                    message.allowOrigin.push(reader.string());
                    break;
                case /* repeated string allow_origin_regex = 8 [deprecated = true];*/ 8:
                    message.allowOriginRegex.push(reader.string());
                    break;
                case /* repeated envoy.type.matcher.StringMatcher allow_origin_string_match */ 11:
                    message.allowOriginStringMatch.push(StringMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string allow_methods */ 2:
                    message.allowMethods = reader.string();
                    break;
                case /* string allow_headers */ 3:
                    message.allowHeaders = reader.string();
                    break;
                case /* string expose_headers */ 4:
                    message.exposeHeaders = reader.string();
                    break;
                case /* string max_age */ 5:
                    message.maxAge = reader.string();
                    break;
                case /* google.protobuf.BoolValue allow_credentials */ 6:
                    message.allowCredentials = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowCredentials);
                    break;
                case /* google.protobuf.BoolValue enabled = 7 [deprecated = true];*/ 7:
                    message.enabledSpecifier = {
                        oneofKind: "enabled",
                        enabled: BoolValue.internalBinaryRead(reader, reader.uint32(), options, (message.enabledSpecifier as any).enabled)
                    };
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent filter_enabled */ 9:
                    message.enabledSpecifier = {
                        oneofKind: "filterEnabled",
                        filterEnabled: RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, (message.enabledSpecifier as any).filterEnabled)
                    };
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent shadow_enabled */ 10:
                    message.shadowEnabled = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.shadowEnabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CorsPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string allow_origin = 1 [deprecated = true]; */
        for (let i = 0; i < message.allowOrigin.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.allowOrigin[i]);
        /* repeated string allow_origin_regex = 8 [deprecated = true]; */
        for (let i = 0; i < message.allowOriginRegex.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.allowOriginRegex[i]);
        /* repeated envoy.type.matcher.StringMatcher allow_origin_string_match = 11; */
        for (let i = 0; i < message.allowOriginStringMatch.length; i++)
            StringMatcher.internalBinaryWrite(message.allowOriginStringMatch[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string allow_methods = 2; */
        if (message.allowMethods !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.allowMethods);
        /* string allow_headers = 3; */
        if (message.allowHeaders !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.allowHeaders);
        /* string expose_headers = 4; */
        if (message.exposeHeaders !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.exposeHeaders);
        /* string max_age = 5; */
        if (message.maxAge !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.maxAge);
        /* google.protobuf.BoolValue allow_credentials = 6; */
        if (message.allowCredentials)
            BoolValue.internalBinaryWrite(message.allowCredentials, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue enabled = 7 [deprecated = true]; */
        if (message.enabledSpecifier.oneofKind === "enabled")
            BoolValue.internalBinaryWrite(message.enabledSpecifier.enabled, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9; */
        if (message.enabledSpecifier.oneofKind === "filterEnabled")
            RuntimeFractionalPercent.internalBinaryWrite(message.enabledSpecifier.filterEnabled, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RuntimeFractionalPercent shadow_enabled = 10; */
        if (message.shadowEnabled)
            RuntimeFractionalPercent.internalBinaryWrite(message.shadowEnabled, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.CorsPolicy
 */
export const CorsPolicy = new CorsPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction$Type extends MessageType<RouteAction> {
    constructor() {
        super("envoy.api.v2.route.RouteAction", [
            { no: 1, name: "cluster", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "cluster_header", kind: "scalar", oneof: "clusterSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 3, name: "weighted_clusters", kind: "message", oneof: "clusterSpecifier", T: () => WeightedCluster },
            { no: 20, name: "cluster_not_found_response_code", kind: "enum", T: () => ["envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode", RouteAction_ClusterNotFoundResponseCode], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 4, name: "metadata_match", kind: "message", T: () => Metadata },
            { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 32, name: "regex_rewrite", kind: "message", T: () => RegexMatchAndSubstitute },
            { no: 6, name: "host_rewrite", kind: "scalar", oneof: "hostRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } }, "udpa.annotations.field_migrate": { rename: "host_rewrite_literal" } } },
            { no: 7, name: "auto_host_rewrite", kind: "message", oneof: "hostRewriteSpecifier", T: () => BoolValue },
            { no: 29, name: "auto_host_rewrite_header", kind: "scalar", oneof: "hostRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } }, "udpa.annotations.field_migrate": { rename: "host_rewrite_header" } } },
            { no: 8, name: "timeout", kind: "message", T: () => Duration },
            { no: 24, name: "idle_timeout", kind: "message", T: () => Duration },
            { no: 9, name: "retry_policy", kind: "message", T: () => RetryPolicy },
            { no: 33, name: "retry_policy_typed_config", kind: "message", T: () => Any },
            { no: 10, name: "request_mirror_policy", kind: "message", T: () => RouteAction_RequestMirrorPolicy },
            { no: 30, name: "request_mirror_policies", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_RequestMirrorPolicy },
            { no: 11, name: "priority", kind: "enum", T: () => ["envoy.api.v2.core.RoutingPriority", RoutingPriority], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 13, name: "rate_limits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit },
            { no: 14, name: "include_vh_rate_limits", kind: "message", T: () => BoolValue },
            { no: 15, name: "hash_policy", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_HashPolicy },
            { no: 17, name: "cors", kind: "message", T: () => CorsPolicy },
            { no: 23, name: "max_grpc_timeout", kind: "message", T: () => Duration },
            { no: 28, name: "grpc_timeout_offset", kind: "message", T: () => Duration },
            { no: 25, name: "upgrade_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RouteAction_UpgradeConfig },
            { no: 26, name: "internal_redirect_action", kind: "enum", T: () => ["envoy.api.v2.route.RouteAction.InternalRedirectAction", RouteAction_InternalRedirectAction] },
            { no: 31, name: "max_internal_redirects", kind: "message", T: () => UInt32Value },
            { no: 27, name: "hedge_policy", kind: "message", T: () => HedgePolicy }
        ]);
    }
    create(value?: PartialMessage<RouteAction>): RouteAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterSpecifier = { oneofKind: undefined };
        message.clusterNotFoundResponseCode = 0;
        message.prefixRewrite = "";
        message.hostRewriteSpecifier = { oneofKind: undefined };
        message.requestMirrorPolicies = [];
        message.priority = 0;
        message.rateLimits = [];
        message.hashPolicy = [];
        message.upgradeConfigs = [];
        message.internalRedirectAction = 0;
        if (value !== undefined)
            reflectionMergePartial<RouteAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction): RouteAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.clusterSpecifier = {
                        oneofKind: "cluster",
                        cluster: reader.string()
                    };
                    break;
                case /* string cluster_header */ 2:
                    message.clusterSpecifier = {
                        oneofKind: "clusterHeader",
                        clusterHeader: reader.string()
                    };
                    break;
                case /* envoy.api.v2.route.WeightedCluster weighted_clusters */ 3:
                    message.clusterSpecifier = {
                        oneofKind: "weightedClusters",
                        weightedClusters: WeightedCluster.internalBinaryRead(reader, reader.uint32(), options, (message.clusterSpecifier as any).weightedClusters)
                    };
                    break;
                case /* envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code */ 20:
                    message.clusterNotFoundResponseCode = reader.int32();
                    break;
                case /* envoy.api.v2.core.Metadata metadata_match */ 4:
                    message.metadataMatch = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadataMatch);
                    break;
                case /* string prefix_rewrite */ 5:
                    message.prefixRewrite = reader.string();
                    break;
                case /* envoy.type.matcher.RegexMatchAndSubstitute regex_rewrite */ 32:
                    message.regexRewrite = RegexMatchAndSubstitute.internalBinaryRead(reader, reader.uint32(), options, message.regexRewrite);
                    break;
                case /* string host_rewrite */ 6:
                    message.hostRewriteSpecifier = {
                        oneofKind: "hostRewrite",
                        hostRewrite: reader.string()
                    };
                    break;
                case /* google.protobuf.BoolValue auto_host_rewrite */ 7:
                    message.hostRewriteSpecifier = {
                        oneofKind: "autoHostRewrite",
                        autoHostRewrite: BoolValue.internalBinaryRead(reader, reader.uint32(), options, (message.hostRewriteSpecifier as any).autoHostRewrite)
                    };
                    break;
                case /* string auto_host_rewrite_header */ 29:
                    message.hostRewriteSpecifier = {
                        oneofKind: "autoHostRewriteHeader",
                        autoHostRewriteHeader: reader.string()
                    };
                    break;
                case /* google.protobuf.Duration timeout */ 8:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* google.protobuf.Duration idle_timeout */ 24:
                    message.idleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.idleTimeout);
                    break;
                case /* envoy.api.v2.route.RetryPolicy retry_policy */ 9:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                case /* google.protobuf.Any retry_policy_typed_config */ 33:
                    message.retryPolicyTypedConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicyTypedConfig);
                    break;
                case /* envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policy = 10 [deprecated = true];*/ 10:
                    message.requestMirrorPolicy = RouteAction_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options, message.requestMirrorPolicy);
                    break;
                case /* repeated envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policies */ 30:
                    message.requestMirrorPolicies.push(RouteAction_RequestMirrorPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.api.v2.core.RoutingPriority priority */ 11:
                    message.priority = reader.int32();
                    break;
                case /* repeated envoy.api.v2.route.RateLimit rate_limits */ 13:
                    message.rateLimits.push(RateLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue include_vh_rate_limits */ 14:
                    message.includeVhRateLimits = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.includeVhRateLimits);
                    break;
                case /* repeated envoy.api.v2.route.RouteAction.HashPolicy hash_policy */ 15:
                    message.hashPolicy.push(RouteAction_HashPolicy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.api.v2.route.CorsPolicy cors */ 17:
                    message.cors = CorsPolicy.internalBinaryRead(reader, reader.uint32(), options, message.cors);
                    break;
                case /* google.protobuf.Duration max_grpc_timeout */ 23:
                    message.maxGrpcTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxGrpcTimeout);
                    break;
                case /* google.protobuf.Duration grpc_timeout_offset */ 28:
                    message.grpcTimeoutOffset = Duration.internalBinaryRead(reader, reader.uint32(), options, message.grpcTimeoutOffset);
                    break;
                case /* repeated envoy.api.v2.route.RouteAction.UpgradeConfig upgrade_configs */ 25:
                    message.upgradeConfigs.push(RouteAction_UpgradeConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.api.v2.route.RouteAction.InternalRedirectAction internal_redirect_action */ 26:
                    message.internalRedirectAction = reader.int32();
                    break;
                case /* google.protobuf.UInt32Value max_internal_redirects */ 31:
                    message.maxInternalRedirects = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxInternalRedirects);
                    break;
                case /* envoy.api.v2.route.HedgePolicy hedge_policy */ 27:
                    message.hedgePolicy = HedgePolicy.internalBinaryRead(reader, reader.uint32(), options, message.hedgePolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.clusterSpecifier.oneofKind === "cluster")
            writer.tag(1, WireType.LengthDelimited).string(message.clusterSpecifier.cluster);
        /* string cluster_header = 2; */
        if (message.clusterSpecifier.oneofKind === "clusterHeader")
            writer.tag(2, WireType.LengthDelimited).string(message.clusterSpecifier.clusterHeader);
        /* envoy.api.v2.route.WeightedCluster weighted_clusters = 3; */
        if (message.clusterSpecifier.oneofKind === "weightedClusters")
            WeightedCluster.internalBinaryWrite(message.clusterSpecifier.weightedClusters, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20; */
        if (message.clusterNotFoundResponseCode !== 0)
            writer.tag(20, WireType.Varint).int32(message.clusterNotFoundResponseCode);
        /* envoy.api.v2.core.Metadata metadata_match = 4; */
        if (message.metadataMatch)
            Metadata.internalBinaryWrite(message.metadataMatch, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string prefix_rewrite = 5; */
        if (message.prefixRewrite !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.prefixRewrite);
        /* envoy.type.matcher.RegexMatchAndSubstitute regex_rewrite = 32; */
        if (message.regexRewrite)
            RegexMatchAndSubstitute.internalBinaryWrite(message.regexRewrite, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* string host_rewrite = 6; */
        if (message.hostRewriteSpecifier.oneofKind === "hostRewrite")
            writer.tag(6, WireType.LengthDelimited).string(message.hostRewriteSpecifier.hostRewrite);
        /* google.protobuf.BoolValue auto_host_rewrite = 7; */
        if (message.hostRewriteSpecifier.oneofKind === "autoHostRewrite")
            BoolValue.internalBinaryWrite(message.hostRewriteSpecifier.autoHostRewrite, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string auto_host_rewrite_header = 29; */
        if (message.hostRewriteSpecifier.oneofKind === "autoHostRewriteHeader")
            writer.tag(29, WireType.LengthDelimited).string(message.hostRewriteSpecifier.autoHostRewriteHeader);
        /* google.protobuf.Duration timeout = 8; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration idle_timeout = 24; */
        if (message.idleTimeout)
            Duration.internalBinaryWrite(message.idleTimeout, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RetryPolicy retry_policy = 9; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any retry_policy_typed_config = 33; */
        if (message.retryPolicyTypedConfig)
            Any.internalBinaryWrite(message.retryPolicyTypedConfig, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policy = 10 [deprecated = true]; */
        if (message.requestMirrorPolicy)
            RouteAction_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicy, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policies = 30; */
        for (let i = 0; i < message.requestMirrorPolicies.length; i++)
            RouteAction_RequestMirrorPolicy.internalBinaryWrite(message.requestMirrorPolicies[i], writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RoutingPriority priority = 11; */
        if (message.priority !== 0)
            writer.tag(11, WireType.Varint).int32(message.priority);
        /* repeated envoy.api.v2.route.RateLimit rate_limits = 13; */
        for (let i = 0; i < message.rateLimits.length; i++)
            RateLimit.internalBinaryWrite(message.rateLimits[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue include_vh_rate_limits = 14; */
        if (message.includeVhRateLimits)
            BoolValue.internalBinaryWrite(message.includeVhRateLimits, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.RouteAction.HashPolicy hash_policy = 15; */
        for (let i = 0; i < message.hashPolicy.length; i++)
            RouteAction_HashPolicy.internalBinaryWrite(message.hashPolicy[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.CorsPolicy cors = 17; */
        if (message.cors)
            CorsPolicy.internalBinaryWrite(message.cors, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_grpc_timeout = 23; */
        if (message.maxGrpcTimeout)
            Duration.internalBinaryWrite(message.maxGrpcTimeout, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration grpc_timeout_offset = 28; */
        if (message.grpcTimeoutOffset)
            Duration.internalBinaryWrite(message.grpcTimeoutOffset, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.RouteAction.UpgradeConfig upgrade_configs = 25; */
        for (let i = 0; i < message.upgradeConfigs.length; i++)
            RouteAction_UpgradeConfig.internalBinaryWrite(message.upgradeConfigs[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.InternalRedirectAction internal_redirect_action = 26; */
        if (message.internalRedirectAction !== 0)
            writer.tag(26, WireType.Varint).int32(message.internalRedirectAction);
        /* google.protobuf.UInt32Value max_internal_redirects = 31; */
        if (message.maxInternalRedirects)
            UInt32Value.internalBinaryWrite(message.maxInternalRedirects, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.HedgePolicy hedge_policy = 27; */
        if (message.hedgePolicy)
            HedgePolicy.internalBinaryWrite(message.hedgePolicy, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction
 */
export const RouteAction = new RouteAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_RequestMirrorPolicy$Type extends MessageType<RouteAction_RequestMirrorPolicy> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.RequestMirrorPolicy", [
            { no: 1, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 3, name: "runtime_fraction", kind: "message", T: () => RuntimeFractionalPercent },
            { no: 4, name: "trace_sampled", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<RouteAction_RequestMirrorPolicy>): RouteAction_RequestMirrorPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cluster = "";
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_RequestMirrorPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_RequestMirrorPolicy): RouteAction_RequestMirrorPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cluster */ 1:
                    message.cluster = reader.string();
                    break;
                case /* string runtime_key = 2 [deprecated = true];*/ 2:
                    message.runtimeKey = reader.string();
                    break;
                case /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction */ 3:
                    message.runtimeFraction = RuntimeFractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.runtimeFraction);
                    break;
                case /* google.protobuf.BoolValue trace_sampled */ 4:
                    message.traceSampled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.traceSampled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_RequestMirrorPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cluster = 1; */
        if (message.cluster !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cluster);
        /* string runtime_key = 2 [deprecated = true]; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        /* envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 3; */
        if (message.runtimeFraction)
            RuntimeFractionalPercent.internalBinaryWrite(message.runtimeFraction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue trace_sampled = 4; */
        if (message.traceSampled)
            BoolValue.internalBinaryWrite(message.traceSampled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.RequestMirrorPolicy
 */
export const RouteAction_RequestMirrorPolicy = new RouteAction_RequestMirrorPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy$Type extends MessageType<RouteAction_HashPolicy> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy", [
            { no: 1, name: "header", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_Header },
            { no: 2, name: "cookie", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_Cookie },
            { no: 3, name: "connection_properties", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_ConnectionProperties },
            { no: 5, name: "query_parameter", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_QueryParameter },
            { no: 6, name: "filter_state", kind: "message", oneof: "policySpecifier", T: () => RouteAction_HashPolicy_FilterState },
            { no: 4, name: "terminal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy>): RouteAction_HashPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.policySpecifier = { oneofKind: undefined };
        message.terminal = false;
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy): RouteAction_HashPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.route.RouteAction.HashPolicy.Header header */ 1:
                    message.policySpecifier = {
                        oneofKind: "header",
                        header: RouteAction_HashPolicy_Header.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).header)
                    };
                    break;
                case /* envoy.api.v2.route.RouteAction.HashPolicy.Cookie cookie */ 2:
                    message.policySpecifier = {
                        oneofKind: "cookie",
                        cookie: RouteAction_HashPolicy_Cookie.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).cookie)
                    };
                    break;
                case /* envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties connection_properties */ 3:
                    message.policySpecifier = {
                        oneofKind: "connectionProperties",
                        connectionProperties: RouteAction_HashPolicy_ConnectionProperties.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).connectionProperties)
                    };
                    break;
                case /* envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter query_parameter */ 5:
                    message.policySpecifier = {
                        oneofKind: "queryParameter",
                        queryParameter: RouteAction_HashPolicy_QueryParameter.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).queryParameter)
                    };
                    break;
                case /* envoy.api.v2.route.RouteAction.HashPolicy.FilterState filter_state */ 6:
                    message.policySpecifier = {
                        oneofKind: "filterState",
                        filterState: RouteAction_HashPolicy_FilterState.internalBinaryRead(reader, reader.uint32(), options, (message.policySpecifier as any).filterState)
                    };
                    break;
                case /* bool terminal */ 4:
                    message.terminal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.route.RouteAction.HashPolicy.Header header = 1; */
        if (message.policySpecifier.oneofKind === "header")
            RouteAction_HashPolicy_Header.internalBinaryWrite(message.policySpecifier.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.HashPolicy.Cookie cookie = 2; */
        if (message.policySpecifier.oneofKind === "cookie")
            RouteAction_HashPolicy_Cookie.internalBinaryWrite(message.policySpecifier.cookie, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3; */
        if (message.policySpecifier.oneofKind === "connectionProperties")
            RouteAction_HashPolicy_ConnectionProperties.internalBinaryWrite(message.policySpecifier.connectionProperties, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter query_parameter = 5; */
        if (message.policySpecifier.oneofKind === "queryParameter")
            RouteAction_HashPolicy_QueryParameter.internalBinaryWrite(message.policySpecifier.queryParameter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RouteAction.HashPolicy.FilterState filter_state = 6; */
        if (message.policySpecifier.oneofKind === "filterState")
            RouteAction_HashPolicy_FilterState.internalBinaryWrite(message.policySpecifier.filterState, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool terminal = 4; */
        if (message.terminal !== false)
            writer.tag(4, WireType.Varint).bool(message.terminal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy
 */
export const RouteAction_HashPolicy = new RouteAction_HashPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_Header$Type extends MessageType<RouteAction_HashPolicy_Header> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy.Header", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_Header>): RouteAction_HashPolicy_Header {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_Header>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_Header): RouteAction_HashPolicy_Header {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy.Header
 */
export const RouteAction_HashPolicy_Header = new RouteAction_HashPolicy_Header$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_Cookie$Type extends MessageType<RouteAction_HashPolicy_Cookie> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy.Cookie", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "ttl", kind: "message", T: () => Duration },
            { no: 3, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_Cookie>): RouteAction_HashPolicy_Cookie {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_Cookie>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_Cookie): RouteAction_HashPolicy_Cookie {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Duration ttl */ 2:
                    message.ttl = Duration.internalBinaryRead(reader, reader.uint32(), options, message.ttl);
                    break;
                case /* string path */ 3:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_Cookie, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Duration ttl = 2; */
        if (message.ttl)
            Duration.internalBinaryWrite(message.ttl, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string path = 3; */
        if (message.path !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy.Cookie
 */
export const RouteAction_HashPolicy_Cookie = new RouteAction_HashPolicy_Cookie$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_ConnectionProperties$Type extends MessageType<RouteAction_HashPolicy_ConnectionProperties> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties", [
            { no: 1, name: "source_ip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_ConnectionProperties>): RouteAction_HashPolicy_ConnectionProperties {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sourceIp = false;
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_ConnectionProperties>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_ConnectionProperties): RouteAction_HashPolicy_ConnectionProperties {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool source_ip */ 1:
                    message.sourceIp = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_ConnectionProperties, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool source_ip = 1; */
        if (message.sourceIp !== false)
            writer.tag(1, WireType.Varint).bool(message.sourceIp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties
 */
export const RouteAction_HashPolicy_ConnectionProperties = new RouteAction_HashPolicy_ConnectionProperties$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_QueryParameter$Type extends MessageType<RouteAction_HashPolicy_QueryParameter> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_QueryParameter>): RouteAction_HashPolicy_QueryParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_QueryParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_QueryParameter): RouteAction_HashPolicy_QueryParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_QueryParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter
 */
export const RouteAction_HashPolicy_QueryParameter = new RouteAction_HashPolicy_QueryParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_HashPolicy_FilterState$Type extends MessageType<RouteAction_HashPolicy_FilterState> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.HashPolicy.FilterState", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RouteAction_HashPolicy_FilterState>): RouteAction_HashPolicy_FilterState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_HashPolicy_FilterState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_HashPolicy_FilterState): RouteAction_HashPolicy_FilterState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_HashPolicy_FilterState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.HashPolicy.FilterState
 */
export const RouteAction_HashPolicy_FilterState = new RouteAction_HashPolicy_FilterState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteAction_UpgradeConfig$Type extends MessageType<RouteAction_UpgradeConfig> {
    constructor() {
        super("envoy.api.v2.route.RouteAction.UpgradeConfig", [
            { no: 1, name: "upgrade_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 2, name: "enabled", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<RouteAction_UpgradeConfig>): RouteAction_UpgradeConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.upgradeType = "";
        if (value !== undefined)
            reflectionMergePartial<RouteAction_UpgradeConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RouteAction_UpgradeConfig): RouteAction_UpgradeConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string upgrade_type */ 1:
                    message.upgradeType = reader.string();
                    break;
                case /* google.protobuf.BoolValue enabled */ 2:
                    message.enabled = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.enabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RouteAction_UpgradeConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string upgrade_type = 1; */
        if (message.upgradeType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.upgradeType);
        /* google.protobuf.BoolValue enabled = 2; */
        if (message.enabled)
            BoolValue.internalBinaryWrite(message.enabled, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RouteAction.UpgradeConfig
 */
export const RouteAction_UpgradeConfig = new RouteAction_UpgradeConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("envoy.api.v2.route.RetryPolicy", [
            { no: 1, name: "retry_on", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num_retries", kind: "message", T: () => UInt32Value },
            { no: 3, name: "per_try_timeout", kind: "message", T: () => Duration },
            { no: 4, name: "retry_priority", kind: "message", T: () => RetryPolicy_RetryPriority },
            { no: 5, name: "retry_host_predicate", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetryPolicy_RetryHostPredicate },
            { no: 6, name: "host_selection_retry_max_attempts", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "retriable_status_codes", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "retry_back_off", kind: "message", T: () => RetryPolicy_RetryBackOff },
            { no: 9, name: "retriable_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 10, name: "retriable_request_headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.retryOn = "";
        message.retryHostPredicate = [];
        message.hostSelectionRetryMaxAttempts = 0n;
        message.retriableStatusCodes = [];
        message.retriableHeaders = [];
        message.retriableRequestHeaders = [];
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string retry_on */ 1:
                    message.retryOn = reader.string();
                    break;
                case /* google.protobuf.UInt32Value num_retries */ 2:
                    message.numRetries = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.numRetries);
                    break;
                case /* google.protobuf.Duration per_try_timeout */ 3:
                    message.perTryTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.perTryTimeout);
                    break;
                case /* envoy.api.v2.route.RetryPolicy.RetryPriority retry_priority */ 4:
                    message.retryPriority = RetryPolicy_RetryPriority.internalBinaryRead(reader, reader.uint32(), options, message.retryPriority);
                    break;
                case /* repeated envoy.api.v2.route.RetryPolicy.RetryHostPredicate retry_host_predicate */ 5:
                    message.retryHostPredicate.push(RetryPolicy_RetryHostPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 host_selection_retry_max_attempts */ 6:
                    message.hostSelectionRetryMaxAttempts = reader.int64().toBigInt();
                    break;
                case /* repeated uint32 retriable_status_codes */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.retriableStatusCodes.push(reader.uint32());
                    else
                        message.retriableStatusCodes.push(reader.uint32());
                    break;
                case /* envoy.api.v2.route.RetryPolicy.RetryBackOff retry_back_off */ 8:
                    message.retryBackOff = RetryPolicy_RetryBackOff.internalBinaryRead(reader, reader.uint32(), options, message.retryBackOff);
                    break;
                case /* repeated envoy.api.v2.route.HeaderMatcher retriable_headers */ 9:
                    message.retriableHeaders.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.api.v2.route.HeaderMatcher retriable_request_headers */ 10:
                    message.retriableRequestHeaders.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string retry_on = 1; */
        if (message.retryOn !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.retryOn);
        /* google.protobuf.UInt32Value num_retries = 2; */
        if (message.numRetries)
            UInt32Value.internalBinaryWrite(message.numRetries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration per_try_timeout = 3; */
        if (message.perTryTimeout)
            Duration.internalBinaryWrite(message.perTryTimeout, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RetryPolicy.RetryPriority retry_priority = 4; */
        if (message.retryPriority)
            RetryPolicy_RetryPriority.internalBinaryWrite(message.retryPriority, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.RetryPolicy.RetryHostPredicate retry_host_predicate = 5; */
        for (let i = 0; i < message.retryHostPredicate.length; i++)
            RetryPolicy_RetryHostPredicate.internalBinaryWrite(message.retryHostPredicate[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int64 host_selection_retry_max_attempts = 6; */
        if (message.hostSelectionRetryMaxAttempts !== 0n)
            writer.tag(6, WireType.Varint).int64(message.hostSelectionRetryMaxAttempts);
        /* repeated uint32 retriable_status_codes = 7; */
        if (message.retriableStatusCodes.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.retriableStatusCodes.length; i++)
                writer.uint32(message.retriableStatusCodes[i]);
            writer.join();
        }
        /* envoy.api.v2.route.RetryPolicy.RetryBackOff retry_back_off = 8; */
        if (message.retryBackOff)
            RetryPolicy_RetryBackOff.internalBinaryWrite(message.retryBackOff, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.HeaderMatcher retriable_headers = 9; */
        for (let i = 0; i < message.retriableHeaders.length; i++)
            HeaderMatcher.internalBinaryWrite(message.retriableHeaders[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.HeaderMatcher retriable_request_headers = 10; */
        for (let i = 0; i < message.retriableRequestHeaders.length; i++)
            HeaderMatcher.internalBinaryWrite(message.retriableRequestHeaders[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryPriority$Type extends MessageType<RetryPolicy_RetryPriority> {
    constructor() {
        super("envoy.api.v2.route.RetryPolicy.RetryPriority", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy_RetryPriority>): RetryPolicy_RetryPriority {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryPriority>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryPriority): RetryPolicy_RetryPriority {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryPriority, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RetryPolicy.RetryPriority
 */
export const RetryPolicy_RetryPriority = new RetryPolicy_RetryPriority$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryHostPredicate$Type extends MessageType<RetryPolicy_RetryHostPredicate> {
    constructor() {
        super("envoy.api.v2.route.RetryPolicy.RetryHostPredicate", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy_RetryHostPredicate>): RetryPolicy_RetryHostPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryHostPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryHostPredicate): RetryPolicy_RetryHostPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryHostPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RetryPolicy.RetryHostPredicate
 */
export const RetryPolicy_RetryHostPredicate = new RetryPolicy_RetryHostPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy_RetryBackOff$Type extends MessageType<RetryPolicy_RetryBackOff> {
    constructor() {
        super("envoy.api.v2.route.RetryPolicy.RetryBackOff", [
            { no: 1, name: "base_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 2, name: "max_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy_RetryBackOff>): RetryPolicy_RetryBackOff {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy_RetryBackOff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy_RetryBackOff): RetryPolicy_RetryBackOff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration base_interval */ 1:
                    message.baseInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.baseInterval);
                    break;
                case /* google.protobuf.Duration max_interval */ 2:
                    message.maxInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxInterval);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy_RetryBackOff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration base_interval = 1; */
        if (message.baseInterval)
            Duration.internalBinaryWrite(message.baseInterval, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_interval = 2; */
        if (message.maxInterval)
            Duration.internalBinaryWrite(message.maxInterval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RetryPolicy.RetryBackOff
 */
export const RetryPolicy_RetryBackOff = new RetryPolicy_RetryBackOff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HedgePolicy$Type extends MessageType<HedgePolicy> {
    constructor() {
        super("envoy.api.v2.route.HedgePolicy", [
            { no: 1, name: "initial_requests", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 2, name: "additional_request_chance", kind: "message", T: () => FractionalPercent },
            { no: 3, name: "hedge_on_per_try_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HedgePolicy>): HedgePolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hedgeOnPerTryTimeout = false;
        if (value !== undefined)
            reflectionMergePartial<HedgePolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HedgePolicy): HedgePolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value initial_requests */ 1:
                    message.initialRequests = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.initialRequests);
                    break;
                case /* envoy.type.FractionalPercent additional_request_chance */ 2:
                    message.additionalRequestChance = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.additionalRequestChance);
                    break;
                case /* bool hedge_on_per_try_timeout */ 3:
                    message.hedgeOnPerTryTimeout = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HedgePolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value initial_requests = 1; */
        if (message.initialRequests)
            UInt32Value.internalBinaryWrite(message.initialRequests, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.FractionalPercent additional_request_chance = 2; */
        if (message.additionalRequestChance)
            FractionalPercent.internalBinaryWrite(message.additionalRequestChance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool hedge_on_per_try_timeout = 3; */
        if (message.hedgeOnPerTryTimeout !== false)
            writer.tag(3, WireType.Varint).bool(message.hedgeOnPerTryTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.HedgePolicy
 */
export const HedgePolicy = new HedgePolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedirectAction$Type extends MessageType<RedirectAction> {
    constructor() {
        super("envoy.api.v2.route.RedirectAction", [
            { no: 4, name: "https_redirect", kind: "scalar", oneof: "schemeRewriteSpecifier", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "scheme_redirect", kind: "scalar", oneof: "schemeRewriteSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "host_redirect", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 8, name: "port_redirect", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "path_redirect", kind: "scalar", oneof: "pathRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 5, name: "prefix_rewrite", kind: "scalar", oneof: "pathRewriteSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } },
            { no: 3, name: "response_code", kind: "enum", T: () => ["envoy.api.v2.route.RedirectAction.RedirectResponseCode", RedirectAction_RedirectResponseCode], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 6, name: "strip_query", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RedirectAction>): RedirectAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.schemeRewriteSpecifier = { oneofKind: undefined };
        message.hostRedirect = "";
        message.portRedirect = 0;
        message.pathRewriteSpecifier = { oneofKind: undefined };
        message.responseCode = 0;
        message.stripQuery = false;
        if (value !== undefined)
            reflectionMergePartial<RedirectAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedirectAction): RedirectAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool https_redirect */ 4:
                    message.schemeRewriteSpecifier = {
                        oneofKind: "httpsRedirect",
                        httpsRedirect: reader.bool()
                    };
                    break;
                case /* string scheme_redirect */ 7:
                    message.schemeRewriteSpecifier = {
                        oneofKind: "schemeRedirect",
                        schemeRedirect: reader.string()
                    };
                    break;
                case /* string host_redirect */ 1:
                    message.hostRedirect = reader.string();
                    break;
                case /* uint32 port_redirect */ 8:
                    message.portRedirect = reader.uint32();
                    break;
                case /* string path_redirect */ 2:
                    message.pathRewriteSpecifier = {
                        oneofKind: "pathRedirect",
                        pathRedirect: reader.string()
                    };
                    break;
                case /* string prefix_rewrite */ 5:
                    message.pathRewriteSpecifier = {
                        oneofKind: "prefixRewrite",
                        prefixRewrite: reader.string()
                    };
                    break;
                case /* envoy.api.v2.route.RedirectAction.RedirectResponseCode response_code */ 3:
                    message.responseCode = reader.int32();
                    break;
                case /* bool strip_query */ 6:
                    message.stripQuery = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedirectAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool https_redirect = 4; */
        if (message.schemeRewriteSpecifier.oneofKind === "httpsRedirect")
            writer.tag(4, WireType.Varint).bool(message.schemeRewriteSpecifier.httpsRedirect);
        /* string scheme_redirect = 7; */
        if (message.schemeRewriteSpecifier.oneofKind === "schemeRedirect")
            writer.tag(7, WireType.LengthDelimited).string(message.schemeRewriteSpecifier.schemeRedirect);
        /* string host_redirect = 1; */
        if (message.hostRedirect !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostRedirect);
        /* uint32 port_redirect = 8; */
        if (message.portRedirect !== 0)
            writer.tag(8, WireType.Varint).uint32(message.portRedirect);
        /* string path_redirect = 2; */
        if (message.pathRewriteSpecifier.oneofKind === "pathRedirect")
            writer.tag(2, WireType.LengthDelimited).string(message.pathRewriteSpecifier.pathRedirect);
        /* string prefix_rewrite = 5; */
        if (message.pathRewriteSpecifier.oneofKind === "prefixRewrite")
            writer.tag(5, WireType.LengthDelimited).string(message.pathRewriteSpecifier.prefixRewrite);
        /* envoy.api.v2.route.RedirectAction.RedirectResponseCode response_code = 3; */
        if (message.responseCode !== 0)
            writer.tag(3, WireType.Varint).int32(message.responseCode);
        /* bool strip_query = 6; */
        if (message.stripQuery !== false)
            writer.tag(6, WireType.Varint).bool(message.stripQuery);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RedirectAction
 */
export const RedirectAction = new RedirectAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DirectResponseAction$Type extends MessageType<DirectResponseAction> {
    constructor() {
        super("envoy.api.v2.route.DirectResponseAction", [
            { no: 1, name: "status", kind: "scalar", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { lt: 600, gte: 100 } } } },
            { no: 2, name: "body", kind: "message", T: () => DataSource }
        ]);
    }
    create(value?: PartialMessage<DirectResponseAction>): DirectResponseAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        if (value !== undefined)
            reflectionMergePartial<DirectResponseAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DirectResponseAction): DirectResponseAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 status */ 1:
                    message.status = reader.uint32();
                    break;
                case /* envoy.api.v2.core.DataSource body */ 2:
                    message.body = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.body);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DirectResponseAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).uint32(message.status);
        /* envoy.api.v2.core.DataSource body = 2; */
        if (message.body)
            DataSource.internalBinaryWrite(message.body, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.DirectResponseAction
 */
export const DirectResponseAction = new DirectResponseAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Decorator$Type extends MessageType<Decorator> {
    constructor() {
        super("envoy.api.v2.route.Decorator", [
            { no: 1, name: "operation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "propagate", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<Decorator>): Decorator {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operation = "";
        if (value !== undefined)
            reflectionMergePartial<Decorator>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Decorator): Decorator {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string operation */ 1:
                    message.operation = reader.string();
                    break;
                case /* google.protobuf.BoolValue propagate */ 2:
                    message.propagate = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.propagate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Decorator, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string operation = 1; */
        if (message.operation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.operation);
        /* google.protobuf.BoolValue propagate = 2; */
        if (message.propagate)
            BoolValue.internalBinaryWrite(message.propagate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.Decorator
 */
export const Decorator = new Decorator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tracing$Type extends MessageType<Tracing> {
    constructor() {
        super("envoy.api.v2.route.Tracing", [
            { no: 1, name: "client_sampling", kind: "message", T: () => FractionalPercent },
            { no: 2, name: "random_sampling", kind: "message", T: () => FractionalPercent },
            { no: 3, name: "overall_sampling", kind: "message", T: () => FractionalPercent },
            { no: 4, name: "custom_tags", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomTag }
        ]);
    }
    create(value?: PartialMessage<Tracing>): Tracing {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.customTags = [];
        if (value !== undefined)
            reflectionMergePartial<Tracing>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tracing): Tracing {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.FractionalPercent client_sampling */ 1:
                    message.clientSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.clientSampling);
                    break;
                case /* envoy.type.FractionalPercent random_sampling */ 2:
                    message.randomSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.randomSampling);
                    break;
                case /* envoy.type.FractionalPercent overall_sampling */ 3:
                    message.overallSampling = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.overallSampling);
                    break;
                case /* repeated envoy.type.tracing.v2.CustomTag custom_tags */ 4:
                    message.customTags.push(CustomTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tracing, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.FractionalPercent client_sampling = 1; */
        if (message.clientSampling)
            FractionalPercent.internalBinaryWrite(message.clientSampling, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.FractionalPercent random_sampling = 2; */
        if (message.randomSampling)
            FractionalPercent.internalBinaryWrite(message.randomSampling, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.FractionalPercent overall_sampling = 3; */
        if (message.overallSampling)
            FractionalPercent.internalBinaryWrite(message.overallSampling, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.type.tracing.v2.CustomTag custom_tags = 4; */
        for (let i = 0; i < message.customTags.length; i++)
            CustomTag.internalBinaryWrite(message.customTags[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.Tracing
 */
export const Tracing = new Tracing$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VirtualCluster$Type extends MessageType<VirtualCluster> {
    constructor() {
        super("envoy.api.v2.route.VirtualCluster", [
            { no: 1, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024" } }, "envoy.annotations.disallowed_by_default": true } },
            { no: 4, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 3, name: "method", kind: "enum", T: () => ["envoy.api.v2.core.RequestMethod", RequestMethod], options: { "envoy.annotations.disallowed_by_default": true } }
        ]);
    }
    create(value?: PartialMessage<VirtualCluster>): VirtualCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pattern = "";
        message.headers = [];
        message.name = "";
        message.method = 0;
        if (value !== undefined)
            reflectionMergePartial<VirtualCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VirtualCluster): VirtualCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pattern = 1 [deprecated = true];*/ 1:
                    message.pattern = reader.string();
                    break;
                case /* repeated envoy.api.v2.route.HeaderMatcher headers */ 4:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* envoy.api.v2.core.RequestMethod method = 3 [deprecated = true];*/ 3:
                    message.method = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VirtualCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pattern = 1 [deprecated = true]; */
        if (message.pattern !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pattern);
        /* repeated envoy.api.v2.route.HeaderMatcher headers = 4; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* envoy.api.v2.core.RequestMethod method = 3 [deprecated = true]; */
        if (message.method !== 0)
            writer.tag(3, WireType.Varint).int32(message.method);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.VirtualCluster
 */
export const VirtualCluster = new VirtualCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit$Type extends MessageType<RateLimit> {
    constructor() {
        super("envoy.api.v2.route.RateLimit", [
            { no: 1, name: "stage", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 10 } } } },
            { no: 2, name: "disable_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "actions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RateLimit_Action, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit>): RateLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.disableKey = "";
        message.actions = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit): RateLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value stage */ 1:
                    message.stage = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.stage);
                    break;
                case /* string disable_key */ 2:
                    message.disableKey = reader.string();
                    break;
                case /* repeated envoy.api.v2.route.RateLimit.Action actions */ 3:
                    message.actions.push(RateLimit_Action.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value stage = 1; */
        if (message.stage)
            UInt32Value.internalBinaryWrite(message.stage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string disable_key = 2; */
        if (message.disableKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.disableKey);
        /* repeated envoy.api.v2.route.RateLimit.Action actions = 3; */
        for (let i = 0; i < message.actions.length; i++)
            RateLimit_Action.internalBinaryWrite(message.actions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit
 */
export const RateLimit = new RateLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action$Type extends MessageType<RateLimit_Action> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action", [
            { no: 1, name: "source_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_SourceCluster },
            { no: 2, name: "destination_cluster", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_DestinationCluster },
            { no: 3, name: "request_headers", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_RequestHeaders },
            { no: 4, name: "remote_address", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_RemoteAddress },
            { no: 5, name: "generic_key", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_GenericKey },
            { no: 6, name: "header_value_match", kind: "message", oneof: "actionSpecifier", T: () => RateLimit_Action_HeaderValueMatch }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action>): RateLimit_Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action): RateLimit_Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.route.RateLimit.Action.SourceCluster source_cluster */ 1:
                    message.actionSpecifier = {
                        oneofKind: "sourceCluster",
                        sourceCluster: RateLimit_Action_SourceCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).sourceCluster)
                    };
                    break;
                case /* envoy.api.v2.route.RateLimit.Action.DestinationCluster destination_cluster */ 2:
                    message.actionSpecifier = {
                        oneofKind: "destinationCluster",
                        destinationCluster: RateLimit_Action_DestinationCluster.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).destinationCluster)
                    };
                    break;
                case /* envoy.api.v2.route.RateLimit.Action.RequestHeaders request_headers */ 3:
                    message.actionSpecifier = {
                        oneofKind: "requestHeaders",
                        requestHeaders: RateLimit_Action_RequestHeaders.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).requestHeaders)
                    };
                    break;
                case /* envoy.api.v2.route.RateLimit.Action.RemoteAddress remote_address */ 4:
                    message.actionSpecifier = {
                        oneofKind: "remoteAddress",
                        remoteAddress: RateLimit_Action_RemoteAddress.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).remoteAddress)
                    };
                    break;
                case /* envoy.api.v2.route.RateLimit.Action.GenericKey generic_key */ 5:
                    message.actionSpecifier = {
                        oneofKind: "genericKey",
                        genericKey: RateLimit_Action_GenericKey.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).genericKey)
                    };
                    break;
                case /* envoy.api.v2.route.RateLimit.Action.HeaderValueMatch header_value_match */ 6:
                    message.actionSpecifier = {
                        oneofKind: "headerValueMatch",
                        headerValueMatch: RateLimit_Action_HeaderValueMatch.internalBinaryRead(reader, reader.uint32(), options, (message.actionSpecifier as any).headerValueMatch)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.route.RateLimit.Action.SourceCluster source_cluster = 1; */
        if (message.actionSpecifier.oneofKind === "sourceCluster")
            RateLimit_Action_SourceCluster.internalBinaryWrite(message.actionSpecifier.sourceCluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RateLimit.Action.DestinationCluster destination_cluster = 2; */
        if (message.actionSpecifier.oneofKind === "destinationCluster")
            RateLimit_Action_DestinationCluster.internalBinaryWrite(message.actionSpecifier.destinationCluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RateLimit.Action.RequestHeaders request_headers = 3; */
        if (message.actionSpecifier.oneofKind === "requestHeaders")
            RateLimit_Action_RequestHeaders.internalBinaryWrite(message.actionSpecifier.requestHeaders, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RateLimit.Action.RemoteAddress remote_address = 4; */
        if (message.actionSpecifier.oneofKind === "remoteAddress")
            RateLimit_Action_RemoteAddress.internalBinaryWrite(message.actionSpecifier.remoteAddress, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RateLimit.Action.GenericKey generic_key = 5; */
        if (message.actionSpecifier.oneofKind === "genericKey")
            RateLimit_Action_GenericKey.internalBinaryWrite(message.actionSpecifier.genericKey, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.route.RateLimit.Action.HeaderValueMatch header_value_match = 6; */
        if (message.actionSpecifier.oneofKind === "headerValueMatch")
            RateLimit_Action_HeaderValueMatch.internalBinaryWrite(message.actionSpecifier.headerValueMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action
 */
export const RateLimit_Action = new RateLimit_Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_SourceCluster$Type extends MessageType<RateLimit_Action_SourceCluster> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.SourceCluster", []);
    }
    create(value?: PartialMessage<RateLimit_Action_SourceCluster>): RateLimit_Action_SourceCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_SourceCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_SourceCluster): RateLimit_Action_SourceCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_SourceCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.SourceCluster
 */
export const RateLimit_Action_SourceCluster = new RateLimit_Action_SourceCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_DestinationCluster$Type extends MessageType<RateLimit_Action_DestinationCluster> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.DestinationCluster", []);
    }
    create(value?: PartialMessage<RateLimit_Action_DestinationCluster>): RateLimit_Action_DestinationCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_DestinationCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_DestinationCluster): RateLimit_Action_DestinationCluster {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_DestinationCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.DestinationCluster
 */
export const RateLimit_Action_DestinationCluster = new RateLimit_Action_DestinationCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_RequestHeaders$Type extends MessageType<RateLimit_Action_RequestHeaders> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.RequestHeaders", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_RequestHeaders>): RateLimit_Action_RequestHeaders {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        message.descriptorKey = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_RequestHeaders>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_RequestHeaders): RateLimit_Action_RequestHeaders {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                case /* string descriptor_key */ 2:
                    message.descriptorKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_RequestHeaders, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        /* string descriptor_key = 2; */
        if (message.descriptorKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.descriptorKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.RequestHeaders
 */
export const RateLimit_Action_RequestHeaders = new RateLimit_Action_RequestHeaders$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_RemoteAddress$Type extends MessageType<RateLimit_Action_RemoteAddress> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.RemoteAddress", []);
    }
    create(value?: PartialMessage<RateLimit_Action_RemoteAddress>): RateLimit_Action_RemoteAddress {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_RemoteAddress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_RemoteAddress): RateLimit_Action_RemoteAddress {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RateLimit_Action_RemoteAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.RemoteAddress
 */
export const RateLimit_Action_RemoteAddress = new RateLimit_Action_RemoteAddress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_GenericKey$Type extends MessageType<RateLimit_Action_GenericKey> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.GenericKey", [
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_GenericKey>): RateLimit_Action_GenericKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorValue = "";
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_GenericKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_GenericKey): RateLimit_Action_GenericKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_GenericKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.GenericKey
 */
export const RateLimit_Action_GenericKey = new RateLimit_Action_GenericKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimit_Action_HeaderValueMatch$Type extends MessageType<RateLimit_Action_HeaderValueMatch> {
    constructor() {
        super("envoy.api.v2.route.RateLimit.Action.HeaderValueMatch", [
            { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "expect_match", kind: "message", T: () => BoolValue },
            { no: 3, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderMatcher, options: { "validate.rules": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimit_Action_HeaderValueMatch>): RateLimit_Action_HeaderValueMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptorValue = "";
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<RateLimit_Action_HeaderValueMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimit_Action_HeaderValueMatch): RateLimit_Action_HeaderValueMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string descriptor_value */ 1:
                    message.descriptorValue = reader.string();
                    break;
                case /* google.protobuf.BoolValue expect_match */ 2:
                    message.expectMatch = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.expectMatch);
                    break;
                case /* repeated envoy.api.v2.route.HeaderMatcher headers */ 3:
                    message.headers.push(HeaderMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimit_Action_HeaderValueMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string descriptor_value = 1; */
        if (message.descriptorValue !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.descriptorValue);
        /* google.protobuf.BoolValue expect_match = 2; */
        if (message.expectMatch)
            BoolValue.internalBinaryWrite(message.expectMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.route.HeaderMatcher headers = 3; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderMatcher.internalBinaryWrite(message.headers[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.RateLimit.Action.HeaderValueMatch
 */
export const RateLimit_Action_HeaderValueMatch = new RateLimit_Action_HeaderValueMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMatcher$Type extends MessageType<HeaderMatcher> {
    constructor() {
        super("envoy.api.v2.route.HeaderMatcher", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 4, name: "exact_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "regex_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "1024" } }, "envoy.annotations.disallowed_by_default": true } },
            { no: 11, name: "safe_regex_match", kind: "message", oneof: "headerMatchSpecifier", T: () => RegexMatcher },
            { no: 6, name: "range_match", kind: "message", oneof: "headerMatchSpecifier", T: () => Int64Range },
            { no: 7, name: "present_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "prefix_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 10, name: "suffix_match", kind: "scalar", oneof: "headerMatchSpecifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 8, name: "invert_match", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HeaderMatcher>): HeaderMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.headerMatchSpecifier = { oneofKind: undefined };
        message.invertMatch = false;
        if (value !== undefined)
            reflectionMergePartial<HeaderMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMatcher): HeaderMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string exact_match */ 4:
                    message.headerMatchSpecifier = {
                        oneofKind: "exactMatch",
                        exactMatch: reader.string()
                    };
                    break;
                case /* string regex_match = 5 [deprecated = true];*/ 5:
                    message.headerMatchSpecifier = {
                        oneofKind: "regexMatch",
                        regexMatch: reader.string()
                    };
                    break;
                case /* envoy.type.matcher.RegexMatcher safe_regex_match */ 11:
                    message.headerMatchSpecifier = {
                        oneofKind: "safeRegexMatch",
                        safeRegexMatch: RegexMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.headerMatchSpecifier as any).safeRegexMatch)
                    };
                    break;
                case /* envoy.type.Int64Range range_match */ 6:
                    message.headerMatchSpecifier = {
                        oneofKind: "rangeMatch",
                        rangeMatch: Int64Range.internalBinaryRead(reader, reader.uint32(), options, (message.headerMatchSpecifier as any).rangeMatch)
                    };
                    break;
                case /* bool present_match */ 7:
                    message.headerMatchSpecifier = {
                        oneofKind: "presentMatch",
                        presentMatch: reader.bool()
                    };
                    break;
                case /* string prefix_match */ 9:
                    message.headerMatchSpecifier = {
                        oneofKind: "prefixMatch",
                        prefixMatch: reader.string()
                    };
                    break;
                case /* string suffix_match */ 10:
                    message.headerMatchSpecifier = {
                        oneofKind: "suffixMatch",
                        suffixMatch: reader.string()
                    };
                    break;
                case /* bool invert_match */ 8:
                    message.invertMatch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string exact_match = 4; */
        if (message.headerMatchSpecifier.oneofKind === "exactMatch")
            writer.tag(4, WireType.LengthDelimited).string(message.headerMatchSpecifier.exactMatch);
        /* string regex_match = 5 [deprecated = true]; */
        if (message.headerMatchSpecifier.oneofKind === "regexMatch")
            writer.tag(5, WireType.LengthDelimited).string(message.headerMatchSpecifier.regexMatch);
        /* envoy.type.matcher.RegexMatcher safe_regex_match = 11; */
        if (message.headerMatchSpecifier.oneofKind === "safeRegexMatch")
            RegexMatcher.internalBinaryWrite(message.headerMatchSpecifier.safeRegexMatch, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.Int64Range range_match = 6; */
        if (message.headerMatchSpecifier.oneofKind === "rangeMatch")
            Int64Range.internalBinaryWrite(message.headerMatchSpecifier.rangeMatch, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool present_match = 7; */
        if (message.headerMatchSpecifier.oneofKind === "presentMatch")
            writer.tag(7, WireType.Varint).bool(message.headerMatchSpecifier.presentMatch);
        /* string prefix_match = 9; */
        if (message.headerMatchSpecifier.oneofKind === "prefixMatch")
            writer.tag(9, WireType.LengthDelimited).string(message.headerMatchSpecifier.prefixMatch);
        /* string suffix_match = 10; */
        if (message.headerMatchSpecifier.oneofKind === "suffixMatch")
            writer.tag(10, WireType.LengthDelimited).string(message.headerMatchSpecifier.suffixMatch);
        /* bool invert_match = 8; */
        if (message.invertMatch !== false)
            writer.tag(8, WireType.Varint).bool(message.invertMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.HeaderMatcher
 */
export const HeaderMatcher = new HeaderMatcher$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryParameterMatcher$Type extends MessageType<QueryParameterMatcher> {
    constructor() {
        super("envoy.api.v2.route.QueryParameterMatcher", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", maxBytes: "1024" } } } },
            { no: 3, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 4, name: "regex", kind: "message", T: () => BoolValue, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 5, name: "string_match", kind: "message", oneof: "queryParameterMatchSpecifier", T: () => StringMatcher, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "present_match", kind: "scalar", oneof: "queryParameterMatchSpecifier", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<QueryParameterMatcher>): QueryParameterMatcher {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.value = "";
        message.queryParameterMatchSpecifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<QueryParameterMatcher>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryParameterMatcher): QueryParameterMatcher {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string value = 3 [deprecated = true];*/ 3:
                    message.value = reader.string();
                    break;
                case /* google.protobuf.BoolValue regex = 4 [deprecated = true];*/ 4:
                    message.regex = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.regex);
                    break;
                case /* envoy.type.matcher.StringMatcher string_match */ 5:
                    message.queryParameterMatchSpecifier = {
                        oneofKind: "stringMatch",
                        stringMatch: StringMatcher.internalBinaryRead(reader, reader.uint32(), options, (message.queryParameterMatchSpecifier as any).stringMatch)
                    };
                    break;
                case /* bool present_match */ 6:
                    message.queryParameterMatchSpecifier = {
                        oneofKind: "presentMatch",
                        presentMatch: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryParameterMatcher, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string value = 3 [deprecated = true]; */
        if (message.value !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.value);
        /* google.protobuf.BoolValue regex = 4 [deprecated = true]; */
        if (message.regex)
            BoolValue.internalBinaryWrite(message.regex, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.matcher.StringMatcher string_match = 5; */
        if (message.queryParameterMatchSpecifier.oneofKind === "stringMatch")
            StringMatcher.internalBinaryWrite(message.queryParameterMatchSpecifier.stringMatch, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool present_match = 6; */
        if (message.queryParameterMatchSpecifier.oneofKind === "presentMatch")
            writer.tag(6, WireType.Varint).bool(message.queryParameterMatchSpecifier.presentMatch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.route.QueryParameterMatcher
 */
export const QueryParameterMatcher = new QueryParameterMatcher$Type();
