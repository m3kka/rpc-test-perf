// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/route/route_components.proto (package envoy.api.v2.route, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, Duration, proto3, Struct, UInt32Value } from "@bufbuild/protobuf";
import { DataSource, HeaderValueOption, Metadata, RequestMethod, RoutingPriority, RuntimeFractionalPercent } from "../core/base_pb.js";
import { RegexMatchAndSubstitute, RegexMatcher } from "../../../type/matcher/regex_pb.js";
import { StringMatcher } from "../../../type/matcher/string_pb.js";
import { FractionalPercent } from "../../../type/percent_pb.js";
import { CustomTag } from "../../../type/tracing/v2/custom_tag_pb.js";
import { Int64Range } from "../../../type/range_pb.js";

/**
 * The top level element in the routing configuration is a virtual host. Each virtual host has
 * a logical name as well as a set of domains that get routed to it based on the incoming request's
 * host header. This allows a single listener to service multiple top level domain path trees. Once
 * a virtual host is selected based on the domain, the routes are processed in order to see which
 * upstream cluster to route to or whether to perform a redirect.
 * [#next-free-field: 21]
 *
 * @generated from message envoy.api.v2.route.VirtualHost
 */
export const VirtualHost = proto3.makeMessageType(
  "envoy.api.v2.route.VirtualHost",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "domains", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "routes", kind: "message", T: Route, repeated: true },
    { no: 4, name: "require_tls", kind: "enum", T: proto3.getEnumType(VirtualHost_TlsRequirementType) },
    { no: 5, name: "virtual_clusters", kind: "message", T: VirtualCluster, repeated: true },
    { no: 6, name: "rate_limits", kind: "message", T: RateLimit, repeated: true },
    { no: 7, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 13, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 11, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "cors", kind: "message", T: CorsPolicy },
    { no: 12, name: "per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Struct} },
    { no: 15, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 14, name: "include_request_attempt_count", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "include_attempt_count_in_response", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 20, name: "retry_policy_typed_config", kind: "message", T: Any },
    { no: 17, name: "hedge_policy", kind: "message", T: HedgePolicy },
    { no: 18, name: "per_request_buffer_limit_bytes", kind: "message", T: UInt32Value },
  ],
);

/**
 * @generated from enum envoy.api.v2.route.VirtualHost.TlsRequirementType
 */
export const VirtualHost_TlsRequirementType = proto3.makeEnum(
  "envoy.api.v2.route.VirtualHost.TlsRequirementType",
  [
    {no: 0, name: "NONE"},
    {no: 1, name: "EXTERNAL_ONLY"},
    {no: 2, name: "ALL"},
  ],
);

/**
 * A filter-defined action type.
 *
 * @generated from message envoy.api.v2.route.FilterAction
 */
export const FilterAction = proto3.makeMessageType(
  "envoy.api.v2.route.FilterAction",
  () => [
    { no: 1, name: "action", kind: "message", T: Any },
  ],
);

/**
 * A route is both a specification of how to match a request as well as an indication of what to do
 * next (e.g., redirect, forward, rewrite, etc.).
 *
 * .. attention::
 *
 *   Envoy supports routing on HTTP method via :ref:`header matching
 *   <envoy_api_msg_route.HeaderMatcher>`.
 * [#next-free-field: 18]
 *
 * @generated from message envoy.api.v2.route.Route
 */
export const Route = proto3.makeMessageType(
  "envoy.api.v2.route.Route",
  () => [
    { no: 14, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "match", kind: "message", T: RouteMatch },
    { no: 2, name: "route", kind: "message", T: RouteAction, oneof: "action" },
    { no: 3, name: "redirect", kind: "message", T: RedirectAction, oneof: "action" },
    { no: 7, name: "direct_response", kind: "message", T: DirectResponseAction, oneof: "action" },
    { no: 17, name: "filter_action", kind: "message", T: FilterAction, oneof: "action" },
    { no: 4, name: "metadata", kind: "message", T: Metadata },
    { no: 5, name: "decorator", kind: "message", T: Decorator },
    { no: 8, name: "per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Struct} },
    { no: 13, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 9, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 12, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 11, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "tracing", kind: "message", T: Tracing },
    { no: 16, name: "per_request_buffer_limit_bytes", kind: "message", T: UInt32Value },
  ],
);

/**
 * Compared to the :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` field that specifies a
 * single upstream cluster as the target of a request, the :ref:`weighted_clusters
 * <envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
 * multiple upstream clusters along with weights that indicate the percentage of
 * traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
 * weights.
 *
 * @generated from message envoy.api.v2.route.WeightedCluster
 */
export const WeightedCluster = proto3.makeMessageType(
  "envoy.api.v2.route.WeightedCluster",
  () => [
    { no: 1, name: "clusters", kind: "message", T: WeightedCluster_ClusterWeight, repeated: true },
    { no: 3, name: "total_weight", kind: "message", T: UInt32Value },
    { no: 2, name: "runtime_key_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * [#next-free-field: 11]
 *
 * @generated from message envoy.api.v2.route.WeightedCluster.ClusterWeight
 */
export const WeightedCluster_ClusterWeight = proto3.makeMessageType(
  "envoy.api.v2.route.WeightedCluster.ClusterWeight",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "message", T: UInt32Value },
    { no: 3, name: "metadata_match", kind: "message", T: Metadata },
    { no: 4, name: "request_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 9, name: "request_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "response_headers_to_add", kind: "message", T: HeaderValueOption, repeated: true },
    { no: 6, name: "response_headers_to_remove", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Struct} },
    { no: 10, name: "typed_per_filter_config", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
  ],
  {localName: "WeightedCluster_ClusterWeight"},
);

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.RouteMatch
 */
export const RouteMatch = proto3.makeMessageType(
  "envoy.api.v2.route.RouteMatch",
  () => [
    { no: 1, name: "prefix", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 3, name: "regex", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_specifier" },
    { no: 10, name: "safe_regex", kind: "message", T: RegexMatcher, oneof: "path_specifier" },
    { no: 4, name: "case_sensitive", kind: "message", T: BoolValue },
    { no: 9, name: "runtime_fraction", kind: "message", T: RuntimeFractionalPercent },
    { no: 6, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 7, name: "query_parameters", kind: "message", T: QueryParameterMatcher, repeated: true },
    { no: 8, name: "grpc", kind: "message", T: RouteMatch_GrpcRouteMatchOptions },
    { no: 11, name: "tls_context", kind: "message", T: RouteMatch_TlsContextMatchOptions },
  ],
);

/**
 * @generated from message envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions
 */
export const RouteMatch_GrpcRouteMatchOptions = proto3.makeMessageType(
  "envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions",
  [],
  {localName: "RouteMatch_GrpcRouteMatchOptions"},
);

/**
 * @generated from message envoy.api.v2.route.RouteMatch.TlsContextMatchOptions
 */
export const RouteMatch_TlsContextMatchOptions = proto3.makeMessageType(
  "envoy.api.v2.route.RouteMatch.TlsContextMatchOptions",
  () => [
    { no: 1, name: "presented", kind: "message", T: BoolValue },
    { no: 2, name: "validated", kind: "message", T: BoolValue },
  ],
  {localName: "RouteMatch_TlsContextMatchOptions"},
);

/**
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.CorsPolicy
 */
export const CorsPolicy = proto3.makeMessageType(
  "envoy.api.v2.route.CorsPolicy",
  () => [
    { no: 1, name: "allow_origin", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "allow_origin_regex", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "allow_origin_string_match", kind: "message", T: StringMatcher, repeated: true },
    { no: 2, name: "allow_methods", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "allow_headers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expose_headers", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "max_age", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "allow_credentials", kind: "message", T: BoolValue },
    { no: 7, name: "enabled", kind: "message", T: BoolValue, oneof: "enabled_specifier" },
    { no: 9, name: "filter_enabled", kind: "message", T: RuntimeFractionalPercent, oneof: "enabled_specifier" },
    { no: 10, name: "shadow_enabled", kind: "message", T: RuntimeFractionalPercent },
  ],
);

/**
 * [#next-free-field: 34]
 *
 * @generated from message envoy.api.v2.route.RouteAction
 */
export const RouteAction = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction",
  () => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "cluster_specifier" },
    { no: 2, name: "cluster_header", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "cluster_specifier" },
    { no: 3, name: "weighted_clusters", kind: "message", T: WeightedCluster, oneof: "cluster_specifier" },
    { no: 20, name: "cluster_not_found_response_code", kind: "enum", T: proto3.getEnumType(RouteAction_ClusterNotFoundResponseCode) },
    { no: 4, name: "metadata_match", kind: "message", T: Metadata },
    { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 32, name: "regex_rewrite", kind: "message", T: RegexMatchAndSubstitute },
    { no: 6, name: "host_rewrite", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_rewrite_specifier" },
    { no: 7, name: "auto_host_rewrite", kind: "message", T: BoolValue, oneof: "host_rewrite_specifier" },
    { no: 29, name: "auto_host_rewrite_header", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "host_rewrite_specifier" },
    { no: 8, name: "timeout", kind: "message", T: Duration },
    { no: 24, name: "idle_timeout", kind: "message", T: Duration },
    { no: 9, name: "retry_policy", kind: "message", T: RetryPolicy },
    { no: 33, name: "retry_policy_typed_config", kind: "message", T: Any },
    { no: 10, name: "request_mirror_policy", kind: "message", T: RouteAction_RequestMirrorPolicy },
    { no: 30, name: "request_mirror_policies", kind: "message", T: RouteAction_RequestMirrorPolicy, repeated: true },
    { no: 11, name: "priority", kind: "enum", T: proto3.getEnumType(RoutingPriority) },
    { no: 13, name: "rate_limits", kind: "message", T: RateLimit, repeated: true },
    { no: 14, name: "include_vh_rate_limits", kind: "message", T: BoolValue },
    { no: 15, name: "hash_policy", kind: "message", T: RouteAction_HashPolicy, repeated: true },
    { no: 17, name: "cors", kind: "message", T: CorsPolicy },
    { no: 23, name: "max_grpc_timeout", kind: "message", T: Duration },
    { no: 28, name: "grpc_timeout_offset", kind: "message", T: Duration },
    { no: 25, name: "upgrade_configs", kind: "message", T: RouteAction_UpgradeConfig, repeated: true },
    { no: 26, name: "internal_redirect_action", kind: "enum", T: proto3.getEnumType(RouteAction_InternalRedirectAction) },
    { no: 31, name: "max_internal_redirects", kind: "message", T: UInt32Value },
    { no: 27, name: "hedge_policy", kind: "message", T: HedgePolicy },
  ],
);

/**
 * @generated from enum envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode
 */
export const RouteAction_ClusterNotFoundResponseCode = proto3.makeEnum(
  "envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode",
  [
    {no: 0, name: "SERVICE_UNAVAILABLE"},
    {no: 1, name: "NOT_FOUND"},
  ],
);

/**
 * Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
 *
 * @generated from enum envoy.api.v2.route.RouteAction.InternalRedirectAction
 */
export const RouteAction_InternalRedirectAction = proto3.makeEnum(
  "envoy.api.v2.route.RouteAction.InternalRedirectAction",
  [
    {no: 0, name: "PASS_THROUGH_INTERNAL_REDIRECT"},
    {no: 1, name: "HANDLE_INTERNAL_REDIRECT"},
  ],
);

/**
 * The router is capable of shadowing traffic from one cluster to another. The current
 * implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
 * respond before returning the response from the primary cluster. All normal statistics are
 * collected for the shadow cluster making this feature useful for testing.
 *
 * During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
 * useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
 *
 * .. note::
 *
 *   Shadowing will not be triggered if the primary cluster does not exist.
 *
 * @generated from message envoy.api.v2.route.RouteAction.RequestMirrorPolicy
 */
export const RouteAction_RequestMirrorPolicy = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.RequestMirrorPolicy",
  () => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "runtime_fraction", kind: "message", T: RuntimeFractionalPercent },
    { no: 4, name: "trace_sampled", kind: "message", T: BoolValue },
  ],
  {localName: "RouteAction_RequestMirrorPolicy"},
);

/**
 * Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
 * <arch_overview_load_balancing_types>`.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy
 */
export const RouteAction_HashPolicy = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy",
  () => [
    { no: 1, name: "header", kind: "message", T: RouteAction_HashPolicy_Header, oneof: "policy_specifier" },
    { no: 2, name: "cookie", kind: "message", T: RouteAction_HashPolicy_Cookie, oneof: "policy_specifier" },
    { no: 3, name: "connection_properties", kind: "message", T: RouteAction_HashPolicy_ConnectionProperties, oneof: "policy_specifier" },
    { no: 5, name: "query_parameter", kind: "message", T: RouteAction_HashPolicy_QueryParameter, oneof: "policy_specifier" },
    { no: 6, name: "filter_state", kind: "message", T: RouteAction_HashPolicy_FilterState, oneof: "policy_specifier" },
    { no: 4, name: "terminal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RouteAction_HashPolicy"},
);

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.Header
 */
export const RouteAction_HashPolicy_Header = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy.Header",
  () => [
    { no: 1, name: "header_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_Header"},
);

/**
 * Envoy supports two types of cookie affinity:
 *
 * 1. Passive. Envoy takes a cookie that's present in the cookies header and
 *    hashes on its value.
 *
 * 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
 *    on the first request from the client in its response to the client,
 *    based on the endpoint the request gets sent to. The client then
 *    presents this on the next and all subsequent requests. The hash of
 *    this is sufficient to ensure these requests get sent to the same
 *    endpoint. The cookie is generated by hashing the source and
 *    destination ports and addresses so that multiple independent HTTP2
 *    streams on the same connection will independently receive the same
 *    cookie, even if they arrive at the Envoy simultaneously.
 *
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.Cookie
 */
export const RouteAction_HashPolicy_Cookie = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy.Cookie",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ttl", kind: "message", T: Duration },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_Cookie"},
);

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties
 */
export const RouteAction_HashPolicy_ConnectionProperties = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties",
  () => [
    { no: 1, name: "source_ip", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "RouteAction_HashPolicy_ConnectionProperties"},
);

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter
 */
export const RouteAction_HashPolicy_QueryParameter = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_QueryParameter"},
);

/**
 * @generated from message envoy.api.v2.route.RouteAction.HashPolicy.FilterState
 */
export const RouteAction_HashPolicy_FilterState = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.HashPolicy.FilterState",
  () => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RouteAction_HashPolicy_FilterState"},
);

/**
 * Allows enabling and disabling upgrades on a per-route basis.
 * This overrides any enabled/disabled upgrade filter chain specified in the
 * HttpConnectionManager
 * :ref:`upgrade_configs
 * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`
 * but does not affect any custom filter chain specified there.
 *
 * @generated from message envoy.api.v2.route.RouteAction.UpgradeConfig
 */
export const RouteAction_UpgradeConfig = proto3.makeMessageType(
  "envoy.api.v2.route.RouteAction.UpgradeConfig",
  () => [
    { no: 1, name: "upgrade_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "message", T: BoolValue },
  ],
  {localName: "RouteAction_UpgradeConfig"},
);

/**
 * HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
 * [#next-free-field: 11]
 *
 * @generated from message envoy.api.v2.route.RetryPolicy
 */
export const RetryPolicy = proto3.makeMessageType(
  "envoy.api.v2.route.RetryPolicy",
  () => [
    { no: 1, name: "retry_on", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "num_retries", kind: "message", T: UInt32Value },
    { no: 3, name: "per_try_timeout", kind: "message", T: Duration },
    { no: 4, name: "retry_priority", kind: "message", T: RetryPolicy_RetryPriority },
    { no: 5, name: "retry_host_predicate", kind: "message", T: RetryPolicy_RetryHostPredicate, repeated: true },
    { no: 6, name: "host_selection_retry_max_attempts", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "retriable_status_codes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 8, name: "retry_back_off", kind: "message", T: RetryPolicy_RetryBackOff },
    { no: 9, name: "retriable_headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 10, name: "retriable_request_headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
);

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryPriority
 */
export const RetryPolicy_RetryPriority = proto3.makeMessageType(
  "envoy.api.v2.route.RetryPolicy.RetryPriority",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct, oneof: "config_type" },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
  {localName: "RetryPolicy_RetryPriority"},
);

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryHostPredicate
 */
export const RetryPolicy_RetryHostPredicate = proto3.makeMessageType(
  "envoy.api.v2.route.RetryPolicy.RetryHostPredicate",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct, oneof: "config_type" },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
  {localName: "RetryPolicy_RetryHostPredicate"},
);

/**
 * @generated from message envoy.api.v2.route.RetryPolicy.RetryBackOff
 */
export const RetryPolicy_RetryBackOff = proto3.makeMessageType(
  "envoy.api.v2.route.RetryPolicy.RetryBackOff",
  () => [
    { no: 1, name: "base_interval", kind: "message", T: Duration },
    { no: 2, name: "max_interval", kind: "message", T: Duration },
  ],
  {localName: "RetryPolicy_RetryBackOff"},
);

/**
 * HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
 *
 * @generated from message envoy.api.v2.route.HedgePolicy
 */
export const HedgePolicy = proto3.makeMessageType(
  "envoy.api.v2.route.HedgePolicy",
  () => [
    { no: 1, name: "initial_requests", kind: "message", T: UInt32Value },
    { no: 2, name: "additional_request_chance", kind: "message", T: FractionalPercent },
    { no: 3, name: "hedge_on_per_try_timeout", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * [#next-free-field: 9]
 *
 * @generated from message envoy.api.v2.route.RedirectAction
 */
export const RedirectAction = proto3.makeMessageType(
  "envoy.api.v2.route.RedirectAction",
  () => [
    { no: 4, name: "https_redirect", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "scheme_rewrite_specifier" },
    { no: 7, name: "scheme_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "scheme_rewrite_specifier" },
    { no: 1, name: "host_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "port_redirect", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "path_redirect", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_rewrite_specifier" },
    { no: 5, name: "prefix_rewrite", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "path_rewrite_specifier" },
    { no: 3, name: "response_code", kind: "enum", T: proto3.getEnumType(RedirectAction_RedirectResponseCode) },
    { no: 6, name: "strip_query", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * @generated from enum envoy.api.v2.route.RedirectAction.RedirectResponseCode
 */
export const RedirectAction_RedirectResponseCode = proto3.makeEnum(
  "envoy.api.v2.route.RedirectAction.RedirectResponseCode",
  [
    {no: 0, name: "MOVED_PERMANENTLY"},
    {no: 1, name: "FOUND"},
    {no: 2, name: "SEE_OTHER"},
    {no: 3, name: "TEMPORARY_REDIRECT"},
    {no: 4, name: "PERMANENT_REDIRECT"},
  ],
);

/**
 * @generated from message envoy.api.v2.route.DirectResponseAction
 */
export const DirectResponseAction = proto3.makeMessageType(
  "envoy.api.v2.route.DirectResponseAction",
  () => [
    { no: 1, name: "status", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "body", kind: "message", T: DataSource },
  ],
);

/**
 * @generated from message envoy.api.v2.route.Decorator
 */
export const Decorator = proto3.makeMessageType(
  "envoy.api.v2.route.Decorator",
  () => [
    { no: 1, name: "operation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "propagate", kind: "message", T: BoolValue },
  ],
);

/**
 * @generated from message envoy.api.v2.route.Tracing
 */
export const Tracing = proto3.makeMessageType(
  "envoy.api.v2.route.Tracing",
  () => [
    { no: 1, name: "client_sampling", kind: "message", T: FractionalPercent },
    { no: 2, name: "random_sampling", kind: "message", T: FractionalPercent },
    { no: 3, name: "overall_sampling", kind: "message", T: FractionalPercent },
    { no: 4, name: "custom_tags", kind: "message", T: CustomTag, repeated: true },
  ],
);

/**
 * A virtual cluster is a way of specifying a regex matching rule against
 * certain important endpoints such that statistics are generated explicitly for
 * the matched requests. The reason this is useful is that when doing
 * prefix/path matching Envoy does not always know what the application
 * considers to be an endpoint. Thus, it’s impossible for Envoy to generically
 * emit per endpoint statistics. However, often systems have highly critical
 * endpoints that they wish to get “perfect” statistics on. Virtual cluster
 * statistics are perfect in the sense that they are emitted on the downstream
 * side such that they include network level failures.
 *
 * Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
 *
 * .. note::
 *
 *    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
 *    every application endpoint. This is both not easily maintainable and as well the matching and
 *    statistics output are not free.
 *
 * @generated from message envoy.api.v2.route.VirtualCluster
 */
export const VirtualCluster = proto3.makeMessageType(
  "envoy.api.v2.route.VirtualCluster",
  () => [
    { no: 1, name: "pattern", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "method", kind: "enum", T: proto3.getEnumType(RequestMethod) },
  ],
);

/**
 * Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
 *
 * @generated from message envoy.api.v2.route.RateLimit
 */
export const RateLimit = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit",
  () => [
    { no: 1, name: "stage", kind: "message", T: UInt32Value },
    { no: 2, name: "disable_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "actions", kind: "message", T: RateLimit_Action, repeated: true },
  ],
);

/**
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action
 */
export const RateLimit_Action = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action",
  () => [
    { no: 1, name: "source_cluster", kind: "message", T: RateLimit_Action_SourceCluster, oneof: "action_specifier" },
    { no: 2, name: "destination_cluster", kind: "message", T: RateLimit_Action_DestinationCluster, oneof: "action_specifier" },
    { no: 3, name: "request_headers", kind: "message", T: RateLimit_Action_RequestHeaders, oneof: "action_specifier" },
    { no: 4, name: "remote_address", kind: "message", T: RateLimit_Action_RemoteAddress, oneof: "action_specifier" },
    { no: 5, name: "generic_key", kind: "message", T: RateLimit_Action_GenericKey, oneof: "action_specifier" },
    { no: 6, name: "header_value_match", kind: "message", T: RateLimit_Action_HeaderValueMatch, oneof: "action_specifier" },
  ],
  {localName: "RateLimit_Action"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("source_cluster", "<local service cluster>")
 *
 * <local service cluster> is derived from the :option:`--service-cluster` option.
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.SourceCluster
 */
export const RateLimit_Action_SourceCluster = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.SourceCluster",
  [],
  {localName: "RateLimit_Action_SourceCluster"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("destination_cluster", "<routed target cluster>")
 *
 * Once a request matches against a route table rule, a routed cluster is determined by one of
 * the following :ref:`route table configuration <envoy_api_msg_RouteConfiguration>`
 * settings:
 *
 * * :ref:`cluster <envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
 *   to route to.
 * * :ref:`weighted_clusters <envoy_api_field_route.RouteAction.weighted_clusters>`
 *   chooses a cluster randomly from a set of clusters with attributed weight.
 * * :ref:`cluster_header <envoy_api_field_route.RouteAction.cluster_header>` indicates which
 *   header in the request contains the target cluster.
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.DestinationCluster
 */
export const RateLimit_Action_DestinationCluster = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.DestinationCluster",
  [],
  {localName: "RateLimit_Action_DestinationCluster"},
);

/**
 * The following descriptor entry is appended when a header contains a key that matches the
 * *header_name*:
 *
 * .. code-block:: cpp
 *
 *   ("<descriptor_key>", "<header_value_queried_from_header>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.RequestHeaders
 */
export const RateLimit_Action_RequestHeaders = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.RequestHeaders",
  () => [
    { no: 1, name: "header_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "descriptor_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RateLimit_Action_RequestHeaders"},
);

/**
 * The following descriptor entry is appended to the descriptor and is populated using the
 * trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
 *
 * .. code-block:: cpp
 *
 *   ("remote_address", "<trusted address from x-forwarded-for>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.RemoteAddress
 */
export const RateLimit_Action_RemoteAddress = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.RemoteAddress",
  [],
  {localName: "RateLimit_Action_RemoteAddress"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("generic_key", "<descriptor_value>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.GenericKey
 */
export const RateLimit_Action_GenericKey = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.GenericKey",
  () => [
    { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "RateLimit_Action_GenericKey"},
);

/**
 * The following descriptor entry is appended to the descriptor:
 *
 * .. code-block:: cpp
 *
 *   ("header_match", "<descriptor_value>")
 *
 * @generated from message envoy.api.v2.route.RateLimit.Action.HeaderValueMatch
 */
export const RateLimit_Action_HeaderValueMatch = proto3.makeMessageType(
  "envoy.api.v2.route.RateLimit.Action.HeaderValueMatch",
  () => [
    { no: 1, name: "descriptor_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expect_match", kind: "message", T: BoolValue },
    { no: 3, name: "headers", kind: "message", T: HeaderMatcher, repeated: true },
  ],
  {localName: "RateLimit_Action_HeaderValueMatch"},
);

/**
 * .. attention::
 *
 *   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
 *   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
 *
 * .. attention::
 *
 *   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
 *   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
 *
 *   .. code-block:: json
 *
 *     {
 *       "name": ":method",
 *       "exact_match": "POST"
 *     }
 *
 * .. attention::
 *   In the absence of any header match specifier, match will default to :ref:`present_match
 *   <envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
 *   <envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
 *   value.
 *
 *  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.route.HeaderMatcher
 */
export const HeaderMatcher = proto3.makeMessageType(
  "envoy.api.v2.route.HeaderMatcher",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "exact_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 5, name: "regex_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 11, name: "safe_regex_match", kind: "message", T: RegexMatcher, oneof: "header_match_specifier" },
    { no: 6, name: "range_match", kind: "message", T: Int64Range, oneof: "header_match_specifier" },
    { no: 7, name: "present_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "header_match_specifier" },
    { no: 9, name: "prefix_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 10, name: "suffix_match", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "header_match_specifier" },
    { no: 8, name: "invert_match", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Query parameter matching treats the query string of a request's :path header
 * as an ampersand-separated list of keys and/or key=value elements.
 * [#next-free-field: 7]
 *
 * @generated from message envoy.api.v2.route.QueryParameterMatcher
 */
export const QueryParameterMatcher = proto3.makeMessageType(
  "envoy.api.v2.route.QueryParameterMatcher",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "regex", kind: "message", T: BoolValue },
    { no: 5, name: "string_match", kind: "message", T: StringMatcher, oneof: "query_parameter_match_specifier" },
    { no: 6, name: "present_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "query_parameter_match_specifier" },
  ],
);

