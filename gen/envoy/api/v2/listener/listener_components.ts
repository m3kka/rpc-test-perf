// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/listener/listener_components.proto" (package "envoy.api.v2.listener", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Int32Range } from "../../../type/range";
import { TransportSocket } from "../core/base";
import { Metadata } from "../core/base";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { DownstreamTlsContext } from "../auth/tls";
import { CidrRange } from "../core/address";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
// [#protodoc-title: Listener components]
// Listener :ref:`configuration overview <config_listeners>`

/**
 * @generated from protobuf message envoy.api.v2.listener.Filter
 */
export interface Filter {
    /**
     * The name of the filter to instantiate. The name must match a
     * :ref:`supported filter <config_network_filters>`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 4;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Source type (e.g. any, local or external network).
 * 7. Source IP address.
 * 8. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 13]
 *
 * @generated from protobuf message envoy.api.v2.listener.FilterChainMatch
 */
export interface FilterChainMatch {
    /**
     * Optional destination port to consider when use_original_dst is set on the
     * listener in determining a filter chain match.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value destination_port = 8;
     */
    destinationPort?: UInt32Value;
    /**
     * If non-empty, an IP address and prefix length to match addresses when the
     * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.CidrRange prefix_ranges = 3;
     */
    prefixRanges: CidrRange[];
    /**
     * If non-empty, an IP address and suffix length to match addresses when the
     * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string address_suffix = 4;
     */
    addressSuffix: string;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value suffix_len = 5;
     */
    suffixLen?: UInt32Value;
    /**
     * Specifies the connection source IP match type. Can be any, local or external network.
     *
     * @generated from protobuf field: envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType source_type = 12;
     */
    sourceType: FilterChainMatch_ConnectionSourceType;
    /**
     * The criteria is satisfied if the source IP address of the downstream
     * connection is contained in at least one of the specified subnets. If the
     * parameter is not specified or the list is empty, the source IP address is
     * ignored.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.CidrRange source_prefix_ranges = 6;
     */
    sourcePrefixRanges: CidrRange[];
    /**
     * The criteria is satisfied if the source port of the downstream connection
     * is contained in at least one of the specified ports. If the parameter is
     * not specified, the source port is ignored.
     *
     * @generated from protobuf field: repeated uint32 source_ports = 7;
     */
    sourcePorts: number[];
    /**
     * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
     * a filter chain match. Those values will be compared against the server names of a new
     * connection, when detected by one of the listener filters.
     *
     * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
     * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
     *
     * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
     *
     * .. attention::
     *
     *   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
     *   information.
     *
     * @generated from protobuf field: repeated string server_names = 11;
     */
    serverNames: string[];
    /**
     * If non-empty, a transport protocol to consider when determining a filter chain match.
     * This value will be compared against the transport protocol of a new connection, when
     * it's detected by one of the listener filters.
     *
     * Suggested values include:
     *
     * * ``raw_buffer`` - default, used when no transport protocol is detected,
     * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
     *   when TLS protocol is detected.
     *
     * @generated from protobuf field: string transport_protocol = 9;
     */
    transportProtocol: string;
    /**
     * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
     * determining a filter chain match. Those values will be compared against the application
     * protocols of a new connection, when detected by one of the listener filters.
     *
     * Suggested values include:
     *
     * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
     *   <config_listener_filters_tls_inspector>`,
     * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
     *
     * .. attention::
     *
     *   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
     *   application protocol detection based on the requested
     *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
     *
     *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
     *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
     *   unless all connecting clients are known to use ALPN.
     *
     * @generated from protobuf field: repeated string application_protocols = 10;
     */
    applicationProtocols: string[];
}
/**
 * @generated from protobuf enum envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType
 */
export enum FilterChainMatch_ConnectionSourceType {
    /**
     * Any connection source matches.
     *
     * @generated from protobuf enum value: ANY = 0;
     */
    ANY = 0,
    /**
     * Match a connection originating from the same host.
     *
     * @generated from protobuf enum value: LOCAL = 1;
     */
    LOCAL = 1,
    /**
     * Match a connection originating from a different host.
     *
     * @generated from protobuf enum value: EXTERNAL = 2;
     */
    EXTERNAL = 2
}
/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.api.v2.listener.FilterChain
 */
export interface FilterChain {
    /**
     * The criteria to use when matching a connection to this filter chain.
     *
     * @generated from protobuf field: envoy.api.v2.listener.FilterChainMatch filter_chain_match = 1;
     */
    filterChainMatch?: FilterChainMatch;
    /**
     * The TLS context for this filter chain.
     *
     * .. attention::
     *
     *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
     *   set, `transport_socket` takes priority.
     *
     * @deprecated
     * @generated from protobuf field: envoy.api.v2.auth.DownstreamTlsContext tls_context = 2 [deprecated = true];
     */
    tlsContext?: DownstreamTlsContext;
    /**
     * A list of individual network filters that make up the filter chain for
     * connections established with the listener. Order matters as the filters are
     * processed sequentially as connection events happen. Note: If the filter
     * list is empty, the connection will close by default.
     *
     * @generated from protobuf field: repeated envoy.api.v2.listener.Filter filters = 3;
     */
    filters: Filter[];
    /**
     * Whether the listener should expect a PROXY protocol V1 header on new
     * connections. If this option is enabled, the listener will assume that that
     * remote address of the connection is the one specified in the header. Some
     * load balancers including the AWS ELB support this option. If the option is
     * absent or set to false, Envoy will use the physical peer address of the
     * connection as the remote address.
     *
     * @generated from protobuf field: google.protobuf.BoolValue use_proxy_proto = 4;
     */
    useProxyProto?: BoolValue;
    /**
     * [#not-implemented-hide:] filter chain metadata.
     *
     * @generated from protobuf field: envoy.api.v2.core.Metadata metadata = 5;
     */
    metadata?: Metadata;
    /**
     * Optional custom transport socket implementation to use for downstream connections.
     * To setup TLS, set a transport socket with name `tls` and
     * :ref:`DownstreamTlsContext <envoy_api_msg_auth.DownstreamTlsContext>` in the `typed_config`.
     * If no transport socket configuration is specified, new connections
     * will be set up with plaintext.
     *
     * @generated from protobuf field: envoy.api.v2.core.TransportSocket transport_socket = 6;
     */
    transportSocket?: TransportSocket;
    /**
     * [#not-implemented-hide:] The unique name (or empty) by which this filter chain is known. If no
     * name is provided, Envoy will allocate an internal UUID for the filter chain. If the filter
     * chain is to be dynamically updated or removed via FCDS a unique name must be provided.
     *
     * @generated from protobuf field: string name = 7;
     */
    name: string;
}
/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.api.v2.listener.ListenerFilterChainMatchPredicate
 */
export interface ListenerFilterChainMatchPredicate {
    /**
     * @generated from protobuf oneof: rule
     */
    rule: {
        oneofKind: "orMatch";
        /**
         * A set that describes a logical OR. If any member of the set matches, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet or_match = 1;
         */
        orMatch: ListenerFilterChainMatchPredicate_MatchSet;
    } | {
        oneofKind: "andMatch";
        /**
         * A set that describes a logical AND. If all members of the set match, the match configuration
         * matches.
         *
         * @generated from protobuf field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet and_match = 2;
         */
        andMatch: ListenerFilterChainMatchPredicate_MatchSet;
    } | {
        oneofKind: "notMatch";
        /**
         * A negation match. The match configuration will match if the negated match condition matches.
         *
         * @generated from protobuf field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate not_match = 3;
         */
        notMatch: ListenerFilterChainMatchPredicate;
    } | {
        oneofKind: "anyMatch";
        /**
         * The match configuration will always match.
         *
         * @generated from protobuf field: bool any_match = 4;
         */
        anyMatch: boolean;
    } | {
        oneofKind: "destinationPortRange";
        /**
         * Match destination port. Particularly, the match evaluation must use the recovered local port if
         * the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
         *
         * @generated from protobuf field: envoy.type.Int32Range destination_port_range = 5;
         */
        destinationPortRange: Int32Range;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A set of match configurations used for logical operations.
 *
 * @generated from protobuf message envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet
 */
export interface ListenerFilterChainMatchPredicate_MatchSet {
    /**
     * The list of rules that make up the set.
     *
     * @generated from protobuf field: repeated envoy.api.v2.listener.ListenerFilterChainMatchPredicate rules = 1;
     */
    rules: ListenerFilterChainMatchPredicate[];
}
/**
 * @generated from protobuf message envoy.api.v2.listener.ListenerFilter
 */
export interface ListenerFilter {
    /**
     * The name of the filter to instantiate. The name must match a
     * :ref:`supported filter <config_listener_filters>`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
    /**
     * Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
     * See :ref:`ListenerFilterChainMatchPredicate <envoy_api_msg_listener.ListenerFilterChainMatchPredicate>`
     * for further examples.
     *
     * @generated from protobuf field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate filter_disabled = 4;
     */
    filterDisabled?: ListenerFilterChainMatchPredicate;
}
// @generated message type with reflection information, may provide speed optimized methods
class Filter$Type extends MessageType<Filter> {
    constructor() {
        super("envoy.api.v2.listener.Filter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 4, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Filter>): Filter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Filter): Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 4:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 4; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.Filter
 */
export const Filter = new Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterChainMatch$Type extends MessageType<FilterChainMatch> {
    constructor() {
        super("envoy.api.v2.listener.FilterChainMatch", [
            { no: 8, name: "destination_port", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 65535, gte: 1 } } } },
            { no: 3, name: "prefix_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 4, name: "address_suffix", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "suffix_len", kind: "message", T: () => UInt32Value },
            { no: 12, name: "source_type", kind: "enum", T: () => ["envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType", FilterChainMatch_ConnectionSourceType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 6, name: "source_prefix_ranges", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CidrRange },
            { no: 7, name: "source_ports", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { repeated: { items: { uint32: { lte: 65535, gte: 1 } } } } } },
            { no: 11, name: "server_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "transport_protocol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "application_protocols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilterChainMatch>): FilterChainMatch {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.prefixRanges = [];
        message.addressSuffix = "";
        message.sourceType = 0;
        message.sourcePrefixRanges = [];
        message.sourcePorts = [];
        message.serverNames = [];
        message.transportProtocol = "";
        message.applicationProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<FilterChainMatch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterChainMatch): FilterChainMatch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value destination_port */ 8:
                    message.destinationPort = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.destinationPort);
                    break;
                case /* repeated envoy.api.v2.core.CidrRange prefix_ranges */ 3:
                    message.prefixRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string address_suffix */ 4:
                    message.addressSuffix = reader.string();
                    break;
                case /* google.protobuf.UInt32Value suffix_len */ 5:
                    message.suffixLen = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.suffixLen);
                    break;
                case /* envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType source_type */ 12:
                    message.sourceType = reader.int32();
                    break;
                case /* repeated envoy.api.v2.core.CidrRange source_prefix_ranges */ 6:
                    message.sourcePrefixRanges.push(CidrRange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated uint32 source_ports */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sourcePorts.push(reader.uint32());
                    else
                        message.sourcePorts.push(reader.uint32());
                    break;
                case /* repeated string server_names */ 11:
                    message.serverNames.push(reader.string());
                    break;
                case /* string transport_protocol */ 9:
                    message.transportProtocol = reader.string();
                    break;
                case /* repeated string application_protocols */ 10:
                    message.applicationProtocols.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterChainMatch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value destination_port = 8; */
        if (message.destinationPort)
            UInt32Value.internalBinaryWrite(message.destinationPort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.CidrRange prefix_ranges = 3; */
        for (let i = 0; i < message.prefixRanges.length; i++)
            CidrRange.internalBinaryWrite(message.prefixRanges[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string address_suffix = 4; */
        if (message.addressSuffix !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.addressSuffix);
        /* google.protobuf.UInt32Value suffix_len = 5; */
        if (message.suffixLen)
            UInt32Value.internalBinaryWrite(message.suffixLen, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType source_type = 12; */
        if (message.sourceType !== 0)
            writer.tag(12, WireType.Varint).int32(message.sourceType);
        /* repeated envoy.api.v2.core.CidrRange source_prefix_ranges = 6; */
        for (let i = 0; i < message.sourcePrefixRanges.length; i++)
            CidrRange.internalBinaryWrite(message.sourcePrefixRanges[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated uint32 source_ports = 7; */
        if (message.sourcePorts.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sourcePorts.length; i++)
                writer.uint32(message.sourcePorts[i]);
            writer.join();
        }
        /* repeated string server_names = 11; */
        for (let i = 0; i < message.serverNames.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.serverNames[i]);
        /* string transport_protocol = 9; */
        if (message.transportProtocol !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.transportProtocol);
        /* repeated string application_protocols = 10; */
        for (let i = 0; i < message.applicationProtocols.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.applicationProtocols[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.FilterChainMatch
 */
export const FilterChainMatch = new FilterChainMatch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterChain$Type extends MessageType<FilterChain> {
    constructor() {
        super("envoy.api.v2.listener.FilterChain", [
            { no: 1, name: "filter_chain_match", kind: "message", T: () => FilterChainMatch },
            { no: 2, name: "tls_context", kind: "message", T: () => DownstreamTlsContext },
            { no: 3, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Filter },
            { no: 4, name: "use_proxy_proto", kind: "message", T: () => BoolValue },
            { no: 5, name: "metadata", kind: "message", T: () => Metadata },
            { no: 6, name: "transport_socket", kind: "message", T: () => TransportSocket },
            { no: 7, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilterChain>): FilterChain {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<FilterChain>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterChain): FilterChain {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.listener.FilterChainMatch filter_chain_match */ 1:
                    message.filterChainMatch = FilterChainMatch.internalBinaryRead(reader, reader.uint32(), options, message.filterChainMatch);
                    break;
                case /* envoy.api.v2.auth.DownstreamTlsContext tls_context = 2 [deprecated = true];*/ 2:
                    message.tlsContext = DownstreamTlsContext.internalBinaryRead(reader, reader.uint32(), options, message.tlsContext);
                    break;
                case /* repeated envoy.api.v2.listener.Filter filters */ 3:
                    message.filters.push(Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue use_proxy_proto */ 4:
                    message.useProxyProto = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.useProxyProto);
                    break;
                case /* envoy.api.v2.core.Metadata metadata */ 5:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.api.v2.core.TransportSocket transport_socket */ 6:
                    message.transportSocket = TransportSocket.internalBinaryRead(reader, reader.uint32(), options, message.transportSocket);
                    break;
                case /* string name */ 7:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterChain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.listener.FilterChainMatch filter_chain_match = 1; */
        if (message.filterChainMatch)
            FilterChainMatch.internalBinaryWrite(message.filterChainMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.auth.DownstreamTlsContext tls_context = 2 [deprecated = true]; */
        if (message.tlsContext)
            DownstreamTlsContext.internalBinaryWrite(message.tlsContext, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.listener.Filter filters = 3; */
        for (let i = 0; i < message.filters.length; i++)
            Filter.internalBinaryWrite(message.filters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue use_proxy_proto = 4; */
        if (message.useProxyProto)
            BoolValue.internalBinaryWrite(message.useProxyProto, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.Metadata metadata = 5; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.TransportSocket transport_socket = 6; */
        if (message.transportSocket)
            TransportSocket.internalBinaryWrite(message.transportSocket, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string name = 7; */
        if (message.name !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.FilterChain
 */
export const FilterChain = new FilterChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilterChainMatchPredicate$Type extends MessageType<ListenerFilterChainMatchPredicate> {
    constructor() {
        super("envoy.api.v2.listener.ListenerFilterChainMatchPredicate", [
            { no: 1, name: "or_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate_MatchSet },
            { no: 2, name: "and_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate_MatchSet },
            { no: 3, name: "not_match", kind: "message", oneof: "rule", T: () => ListenerFilterChainMatchPredicate },
            { no: 4, name: "any_match", kind: "scalar", oneof: "rule", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 5, name: "destination_port_range", kind: "message", oneof: "rule", T: () => Int32Range }
        ]);
    }
    create(value?: PartialMessage<ListenerFilterChainMatchPredicate>): ListenerFilterChainMatchPredicate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rule = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ListenerFilterChainMatchPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilterChainMatchPredicate): ListenerFilterChainMatchPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet or_match */ 1:
                    message.rule = {
                        oneofKind: "orMatch",
                        orMatch: ListenerFilterChainMatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).orMatch)
                    };
                    break;
                case /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet and_match */ 2:
                    message.rule = {
                        oneofKind: "andMatch",
                        andMatch: ListenerFilterChainMatchPredicate_MatchSet.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).andMatch)
                    };
                    break;
                case /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate not_match */ 3:
                    message.rule = {
                        oneofKind: "notMatch",
                        notMatch: ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).notMatch)
                    };
                    break;
                case /* bool any_match */ 4:
                    message.rule = {
                        oneofKind: "anyMatch",
                        anyMatch: reader.bool()
                    };
                    break;
                case /* envoy.type.Int32Range destination_port_range */ 5:
                    message.rule = {
                        oneofKind: "destinationPortRange",
                        destinationPortRange: Int32Range.internalBinaryRead(reader, reader.uint32(), options, (message.rule as any).destinationPortRange)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilterChainMatchPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet or_match = 1; */
        if (message.rule.oneofKind === "orMatch")
            ListenerFilterChainMatchPredicate_MatchSet.internalBinaryWrite(message.rule.orMatch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet and_match = 2; */
        if (message.rule.oneofKind === "andMatch")
            ListenerFilterChainMatchPredicate_MatchSet.internalBinaryWrite(message.rule.andMatch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate not_match = 3; */
        if (message.rule.oneofKind === "notMatch")
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.rule.notMatch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool any_match = 4; */
        if (message.rule.oneofKind === "anyMatch")
            writer.tag(4, WireType.Varint).bool(message.rule.anyMatch);
        /* envoy.type.Int32Range destination_port_range = 5; */
        if (message.rule.oneofKind === "destinationPortRange")
            Int32Range.internalBinaryWrite(message.rule.destinationPortRange, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.ListenerFilterChainMatchPredicate
 */
export const ListenerFilterChainMatchPredicate = new ListenerFilterChainMatchPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilterChainMatchPredicate_MatchSet$Type extends MessageType<ListenerFilterChainMatchPredicate_MatchSet> {
    constructor() {
        super("envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet", [
            { no: 1, name: "rules", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenerFilterChainMatchPredicate, options: { "validate.rules": { repeated: { minItems: "2" } } } }
        ]);
    }
    create(value?: PartialMessage<ListenerFilterChainMatchPredicate_MatchSet>): ListenerFilterChainMatchPredicate_MatchSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<ListenerFilterChainMatchPredicate_MatchSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilterChainMatchPredicate_MatchSet): ListenerFilterChainMatchPredicate_MatchSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.listener.ListenerFilterChainMatchPredicate rules */ 1:
                    message.rules.push(ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilterChainMatchPredicate_MatchSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.listener.ListenerFilterChainMatchPredicate rules = 1; */
        for (let i = 0; i < message.rules.length; i++)
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.rules[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet
 */
export const ListenerFilterChainMatchPredicate_MatchSet = new ListenerFilterChainMatchPredicate_MatchSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenerFilter$Type extends MessageType<ListenerFilter> {
    constructor() {
        super("envoy.api.v2.listener.ListenerFilter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any },
            { no: 4, name: "filter_disabled", kind: "message", T: () => ListenerFilterChainMatchPredicate }
        ]);
    }
    create(value?: PartialMessage<ListenerFilter>): ListenerFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ListenerFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenerFilter): ListenerFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                case /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate filter_disabled */ 4:
                    message.filterDisabled = ListenerFilterChainMatchPredicate.internalBinaryRead(reader, reader.uint32(), options, message.filterDisabled);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenerFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.listener.ListenerFilterChainMatchPredicate filter_disabled = 4; */
        if (message.filterDisabled)
            ListenerFilterChainMatchPredicate.internalBinaryWrite(message.filterDisabled, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.listener.ListenerFilter
 */
export const ListenerFilter = new ListenerFilter$Type();
