// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/listener/listener_components.proto (package envoy.api.v2.listener, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, proto3, Struct, UInt32Value } from "@bufbuild/protobuf";
import { CidrRange } from "../core/address_pb.js";
import { DownstreamTlsContext } from "../auth/tls_pb.js";
import { Metadata, TransportSocket } from "../core/base_pb.js";
import { Int32Range } from "../../../type/range_pb.js";

/**
 * @generated from message envoy.api.v2.listener.Filter
 */
export const Filter = proto3.makeMessageType(
  "envoy.api.v2.listener.Filter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct, oneof: "config_type" },
    { no: 4, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
);

/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Source type (e.g. any, local or external network).
 * 7. Source IP address.
 * 8. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 13]
 *
 * @generated from message envoy.api.v2.listener.FilterChainMatch
 */
export const FilterChainMatch = proto3.makeMessageType(
  "envoy.api.v2.listener.FilterChainMatch",
  () => [
    { no: 8, name: "destination_port", kind: "message", T: UInt32Value },
    { no: 3, name: "prefix_ranges", kind: "message", T: CidrRange, repeated: true },
    { no: 4, name: "address_suffix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "suffix_len", kind: "message", T: UInt32Value },
    { no: 12, name: "source_type", kind: "enum", T: proto3.getEnumType(FilterChainMatch_ConnectionSourceType) },
    { no: 6, name: "source_prefix_ranges", kind: "message", T: CidrRange, repeated: true },
    { no: 7, name: "source_ports", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 11, name: "server_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "transport_protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "application_protocols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
);

/**
 * @generated from enum envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType
 */
export const FilterChainMatch_ConnectionSourceType = proto3.makeEnum(
  "envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType",
  [
    {no: 0, name: "ANY"},
    {no: 1, name: "LOCAL"},
    {no: 2, name: "EXTERNAL"},
  ],
);

/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.api.v2.listener.FilterChain
 */
export const FilterChain = proto3.makeMessageType(
  "envoy.api.v2.listener.FilterChain",
  () => [
    { no: 1, name: "filter_chain_match", kind: "message", T: FilterChainMatch },
    { no: 2, name: "tls_context", kind: "message", T: DownstreamTlsContext },
    { no: 3, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 4, name: "use_proxy_proto", kind: "message", T: BoolValue },
    { no: 5, name: "metadata", kind: "message", T: Metadata },
    { no: 6, name: "transport_socket", kind: "message", T: TransportSocket },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.listener.ListenerFilterChainMatchPredicate
 */
export const ListenerFilterChainMatchPredicate = proto3.makeMessageType(
  "envoy.api.v2.listener.ListenerFilterChainMatchPredicate",
  () => [
    { no: 1, name: "or_match", kind: "message", T: ListenerFilterChainMatchPredicate_MatchSet, oneof: "rule" },
    { no: 2, name: "and_match", kind: "message", T: ListenerFilterChainMatchPredicate_MatchSet, oneof: "rule" },
    { no: 3, name: "not_match", kind: "message", T: ListenerFilterChainMatchPredicate, oneof: "rule" },
    { no: 4, name: "any_match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "rule" },
    { no: 5, name: "destination_port_range", kind: "message", T: Int32Range, oneof: "rule" },
  ],
);

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet
 */
export const ListenerFilterChainMatchPredicate_MatchSet = proto3.makeMessageType(
  "envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet",
  () => [
    { no: 1, name: "rules", kind: "message", T: ListenerFilterChainMatchPredicate, repeated: true },
  ],
  {localName: "ListenerFilterChainMatchPredicate_MatchSet"},
);

/**
 * @generated from message envoy.api.v2.listener.ListenerFilter
 */
export const ListenerFilter = proto3.makeMessageType(
  "envoy.api.v2.listener.ListenerFilter",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct, oneof: "config_type" },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
    { no: 4, name: "filter_disabled", kind: "message", T: ListenerFilterChainMatchPredicate },
  ],
);

