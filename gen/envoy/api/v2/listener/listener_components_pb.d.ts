// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/listener/listener_components.proto (package envoy.api.v2.listener, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { Any, BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Struct } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { CidrRange } from "../core/address_pb.js";
import type { DownstreamTlsContext } from "../auth/tls_pb.js";
import type { Metadata, TransportSocket } from "../core/base_pb.js";
import type { Int32Range } from "../../../type/range_pb.js";

/**
 * @generated from message envoy.api.v2.listener.Filter
 */
export declare class Filter extends Message<Filter> {
  /**
   * The name of the filter to instantiate. The name must match a
   * :ref:`supported filter <config_network_filters>`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Filter specific configuration which depends on the filter being
   * instantiated. See the supported filters for further documentation.
   *
   * @generated from oneof envoy.api.v2.listener.Filter.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Struct config = 2 [deprecated = true];
     * @deprecated
     */
    value: Struct;
    case: "config";
  } | {
    /**
     * @generated from field: google.protobuf.Any typed_config = 4;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Filter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.Filter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter;

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean;
}

/**
 * Specifies the match criteria for selecting a specific filter chain for a
 * listener.
 *
 * In order for a filter chain to be selected, *ALL* of its criteria must be
 * fulfilled by the incoming connection, properties of which are set by the
 * networking stack and/or listener filters.
 *
 * The following order applies:
 *
 * 1. Destination port.
 * 2. Destination IP address.
 * 3. Server name (e.g. SNI for TLS protocol),
 * 4. Transport protocol.
 * 5. Application protocols (e.g. ALPN for TLS protocol).
 * 6. Source type (e.g. any, local or external network).
 * 7. Source IP address.
 * 8. Source port.
 *
 * For criteria that allow ranges or wildcards, the most specific value in any
 * of the configured filter chains that matches the incoming connection is going
 * to be used (e.g. for SNI ``www.example.com`` the most specific match would be
 * ``www.example.com``, then ``*.example.com``, then ``*.com``, then any filter
 * chain without ``server_names`` requirements).
 *
 * [#comment: Implemented rules are kept in the preference order, with deprecated fields
 * listed at the end, because that's how we want to list them in the docs.
 *
 * [#comment:TODO(PiotrSikora): Add support for configurable precedence of the rules]
 * [#next-free-field: 13]
 *
 * @generated from message envoy.api.v2.listener.FilterChainMatch
 */
export declare class FilterChainMatch extends Message<FilterChainMatch> {
  /**
   * Optional destination port to consider when use_original_dst is set on the
   * listener in determining a filter chain match.
   *
   * @generated from field: google.protobuf.UInt32Value destination_port = 8;
   */
  destinationPort?: number;

  /**
   * If non-empty, an IP address and prefix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   *
   * @generated from field: repeated envoy.api.v2.core.CidrRange prefix_ranges = 3;
   */
  prefixRanges: CidrRange[];

  /**
   * If non-empty, an IP address and suffix length to match addresses when the
   * listener is bound to 0.0.0.0/:: or when use_original_dst is specified.
   * [#not-implemented-hide:]
   *
   * @generated from field: string address_suffix = 4;
   */
  addressSuffix: string;

  /**
   * [#not-implemented-hide:]
   *
   * @generated from field: google.protobuf.UInt32Value suffix_len = 5;
   */
  suffixLen?: number;

  /**
   * Specifies the connection source IP match type. Can be any, local or external network.
   *
   * @generated from field: envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType source_type = 12;
   */
  sourceType: FilterChainMatch_ConnectionSourceType;

  /**
   * The criteria is satisfied if the source IP address of the downstream
   * connection is contained in at least one of the specified subnets. If the
   * parameter is not specified or the list is empty, the source IP address is
   * ignored.
   *
   * @generated from field: repeated envoy.api.v2.core.CidrRange source_prefix_ranges = 6;
   */
  sourcePrefixRanges: CidrRange[];

  /**
   * The criteria is satisfied if the source port of the downstream connection
   * is contained in at least one of the specified ports. If the parameter is
   * not specified, the source port is ignored.
   *
   * @generated from field: repeated uint32 source_ports = 7;
   */
  sourcePorts: number[];

  /**
   * If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining
   * a filter chain match. Those values will be compared against the server names of a new
   * connection, when detected by one of the listener filters.
   *
   * The server name will be matched against all wildcard domains, i.e. ``www.example.com``
   * will be first matched against ``www.example.com``, then ``*.example.com``, then ``*.com``.
   *
   * Note that partial wildcards are not supported, and values like ``*w.example.com`` are invalid.
   *
   * .. attention::
   *
   *   See the :ref:`FAQ entry <faq_how_to_setup_sni>` on how to configure SNI for more
   *   information.
   *
   * @generated from field: repeated string server_names = 11;
   */
  serverNames: string[];

  /**
   * If non-empty, a transport protocol to consider when determining a filter chain match.
   * This value will be compared against the transport protocol of a new connection, when
   * it's detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``raw_buffer`` - default, used when no transport protocol is detected,
   * * ``tls`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *   when TLS protocol is detected.
   *
   * @generated from field: string transport_protocol = 9;
   */
  transportProtocol: string;

  /**
   * If non-empty, a list of application protocols (e.g. ALPN for TLS protocol) to consider when
   * determining a filter chain match. Those values will be compared against the application
   * protocols of a new connection, when detected by one of the listener filters.
   *
   * Suggested values include:
   *
   * * ``http/1.1`` - set by :ref:`envoy.filters.listener.tls_inspector
   *   <config_listener_filters_tls_inspector>`,
   * * ``h2`` - set by :ref:`envoy.filters.listener.tls_inspector <config_listener_filters_tls_inspector>`
   *
   * .. attention::
   *
   *   Currently, only :ref:`TLS Inspector <config_listener_filters_tls_inspector>` provides
   *   application protocol detection based on the requested
   *   `ALPN <https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation>`_ values.
   *
   *   However, the use of ALPN is pretty much limited to the HTTP/2 traffic on the Internet,
   *   and matching on values other than ``h2`` is going to lead to a lot of false negatives,
   *   unless all connecting clients are known to use ALPN.
   *
   * @generated from field: repeated string application_protocols = 10;
   */
  applicationProtocols: string[];

  constructor(data?: PartialMessage<FilterChainMatch>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.FilterChainMatch";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterChainMatch;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterChainMatch;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterChainMatch;

  static equals(a: FilterChainMatch | PlainMessage<FilterChainMatch> | undefined, b: FilterChainMatch | PlainMessage<FilterChainMatch> | undefined): boolean;
}

/**
 * @generated from enum envoy.api.v2.listener.FilterChainMatch.ConnectionSourceType
 */
export declare enum FilterChainMatch_ConnectionSourceType {
  /**
   * Any connection source matches.
   *
   * @generated from enum value: ANY = 0;
   */
  ANY = 0,

  /**
   * Match a connection originating from the same host.
   *
   * @generated from enum value: LOCAL = 1;
   */
  LOCAL = 1,

  /**
   * Match a connection originating from a different host.
   *
   * @generated from enum value: EXTERNAL = 2;
   */
  EXTERNAL = 2,
}

/**
 * A filter chain wraps a set of match criteria, an option TLS context, a set of filters, and
 * various other parameters.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.api.v2.listener.FilterChain
 */
export declare class FilterChain extends Message<FilterChain> {
  /**
   * The criteria to use when matching a connection to this filter chain.
   *
   * @generated from field: envoy.api.v2.listener.FilterChainMatch filter_chain_match = 1;
   */
  filterChainMatch?: FilterChainMatch;

  /**
   * The TLS context for this filter chain.
   *
   * .. attention::
   *
   *   **This field is deprecated**. Use `transport_socket` with name `tls` instead. If both are
   *   set, `transport_socket` takes priority.
   *
   * @generated from field: envoy.api.v2.auth.DownstreamTlsContext tls_context = 2 [deprecated = true];
   * @deprecated
   */
  tlsContext?: DownstreamTlsContext;

  /**
   * A list of individual network filters that make up the filter chain for
   * connections established with the listener. Order matters as the filters are
   * processed sequentially as connection events happen. Note: If the filter
   * list is empty, the connection will close by default.
   *
   * @generated from field: repeated envoy.api.v2.listener.Filter filters = 3;
   */
  filters: Filter[];

  /**
   * Whether the listener should expect a PROXY protocol V1 header on new
   * connections. If this option is enabled, the listener will assume that that
   * remote address of the connection is the one specified in the header. Some
   * load balancers including the AWS ELB support this option. If the option is
   * absent or set to false, Envoy will use the physical peer address of the
   * connection as the remote address.
   *
   * @generated from field: google.protobuf.BoolValue use_proxy_proto = 4;
   */
  useProxyProto?: boolean;

  /**
   * [#not-implemented-hide:] filter chain metadata.
   *
   * @generated from field: envoy.api.v2.core.Metadata metadata = 5;
   */
  metadata?: Metadata;

  /**
   * Optional custom transport socket implementation to use for downstream connections.
   * To setup TLS, set a transport socket with name `tls` and
   * :ref:`DownstreamTlsContext <envoy_api_msg_auth.DownstreamTlsContext>` in the `typed_config`.
   * If no transport socket configuration is specified, new connections
   * will be set up with plaintext.
   *
   * @generated from field: envoy.api.v2.core.TransportSocket transport_socket = 6;
   */
  transportSocket?: TransportSocket;

  /**
   * [#not-implemented-hide:] The unique name (or empty) by which this filter chain is known. If no
   * name is provided, Envoy will allocate an internal UUID for the filter chain. If the filter
   * chain is to be dynamically updated or removed via FCDS a unique name must be provided.
   *
   * @generated from field: string name = 7;
   */
  name: string;

  constructor(data?: PartialMessage<FilterChain>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.FilterChain";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterChain;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterChain;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterChain;

  static equals(a: FilterChain | PlainMessage<FilterChain> | undefined, b: FilterChain | PlainMessage<FilterChain> | undefined): boolean;
}

/**
 * Listener filter chain match configuration. This is a recursive structure which allows complex
 * nested match configurations to be built using various logical operators.
 *
 * Examples:
 *
 * * Matches if the destination port is 3306.
 *
 * .. code-block:: yaml
 *
 *  destination_port_range:
 *   start: 3306
 *   end: 3307
 *
 * * Matches if the destination port is 3306 or 15000.
 *
 * .. code-block:: yaml
 *
 *  or_match:
 *    rules:
 *      - destination_port_range:
 *          start: 3306
 *          end: 3307
 *      - destination_port_range:
 *          start: 15000
 *          end: 15001
 *
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.listener.ListenerFilterChainMatchPredicate
 */
export declare class ListenerFilterChainMatchPredicate extends Message<ListenerFilterChainMatchPredicate> {
  /**
   * @generated from oneof envoy.api.v2.listener.ListenerFilterChainMatchPredicate.rule
   */
  rule: {
    /**
     * A set that describes a logical OR. If any member of the set matches, the match configuration
     * matches.
     *
     * @generated from field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet or_match = 1;
     */
    value: ListenerFilterChainMatchPredicate_MatchSet;
    case: "orMatch";
  } | {
    /**
     * A set that describes a logical AND. If all members of the set match, the match configuration
     * matches.
     *
     * @generated from field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet and_match = 2;
     */
    value: ListenerFilterChainMatchPredicate_MatchSet;
    case: "andMatch";
  } | {
    /**
     * A negation match. The match configuration will match if the negated match condition matches.
     *
     * @generated from field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate not_match = 3;
     */
    value: ListenerFilterChainMatchPredicate;
    case: "notMatch";
  } | {
    /**
     * The match configuration will always match.
     *
     * @generated from field: bool any_match = 4;
     */
    value: boolean;
    case: "anyMatch";
  } | {
    /**
     * Match destination port. Particularly, the match evaluation must use the recovered local port if
     * the owning listener filter is after :ref:`an original_dst listener filter <config_listener_filters_original_dst>`.
     *
     * @generated from field: envoy.type.Int32Range destination_port_range = 5;
     */
    value: Int32Range;
    case: "destinationPortRange";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ListenerFilterChainMatchPredicate>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.ListenerFilterChainMatchPredicate";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilterChainMatchPredicate;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate;

  static equals(a: ListenerFilterChainMatchPredicate | PlainMessage<ListenerFilterChainMatchPredicate> | undefined, b: ListenerFilterChainMatchPredicate | PlainMessage<ListenerFilterChainMatchPredicate> | undefined): boolean;
}

/**
 * A set of match configurations used for logical operations.
 *
 * @generated from message envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet
 */
export declare class ListenerFilterChainMatchPredicate_MatchSet extends Message<ListenerFilterChainMatchPredicate_MatchSet> {
  /**
   * The list of rules that make up the set.
   *
   * @generated from field: repeated envoy.api.v2.listener.ListenerFilterChainMatchPredicate rules = 1;
   */
  rules: ListenerFilterChainMatchPredicate[];

  constructor(data?: PartialMessage<ListenerFilterChainMatchPredicate_MatchSet>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.ListenerFilterChainMatchPredicate.MatchSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilterChainMatchPredicate_MatchSet;

  static equals(a: ListenerFilterChainMatchPredicate_MatchSet | PlainMessage<ListenerFilterChainMatchPredicate_MatchSet> | undefined, b: ListenerFilterChainMatchPredicate_MatchSet | PlainMessage<ListenerFilterChainMatchPredicate_MatchSet> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.listener.ListenerFilter
 */
export declare class ListenerFilter extends Message<ListenerFilter> {
  /**
   * The name of the filter to instantiate. The name must match a
   * :ref:`supported filter <config_listener_filters>`.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Filter specific configuration which depends on the filter being instantiated.
   * See the supported filters for further documentation.
   *
   * @generated from oneof envoy.api.v2.listener.ListenerFilter.config_type
   */
  configType: {
    /**
     * @generated from field: google.protobuf.Struct config = 2 [deprecated = true];
     * @deprecated
     */
    value: Struct;
    case: "config";
  } | {
    /**
     * @generated from field: google.protobuf.Any typed_config = 3;
     */
    value: Any;
    case: "typedConfig";
  } | { case: undefined; value?: undefined };

  /**
   * Optional match predicate used to disable the filter. The filter is enabled when this field is empty.
   * See :ref:`ListenerFilterChainMatchPredicate <envoy_api_msg_listener.ListenerFilterChainMatchPredicate>`
   * for further examples.
   *
   * @generated from field: envoy.api.v2.listener.ListenerFilterChainMatchPredicate filter_disabled = 4;
   */
  filterDisabled?: ListenerFilterChainMatchPredicate;

  constructor(data?: PartialMessage<ListenerFilter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.listener.ListenerFilter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenerFilter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenerFilter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenerFilter;

  static equals(a: ListenerFilter | PlainMessage<ListenerFilter> | undefined, b: ListenerFilter | PlainMessage<ListenerFilter> | undefined): boolean;
}

