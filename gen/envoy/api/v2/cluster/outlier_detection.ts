// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/cluster/outlier_detection.proto" (package "envoy.api.v2.cluster", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "../../../../google/protobuf/duration";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
// [#protodoc-title: Outlier detection]

/**
 * See the :ref:`architecture overview <arch_overview_outlier_detection>` for
 * more information on outlier detection.
 * [#next-free-field: 21]
 *
 * @generated from protobuf message envoy.api.v2.cluster.OutlierDetection
 */
export interface OutlierDetection {
    /**
     * The number of consecutive server-side error responses (for HTTP traffic,
     * 5xx responses; for TCP traffic, connection failures; for Redis, failure to
     * respond PONG; etc.) before a consecutive 5xx ejection occurs. Defaults to 5.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value consecutive_5xx = 1 [json_name = "consecutive5xx"];
     */
    consecutive5Xx?: UInt32Value;
    /**
     * The time interval between ejection analysis sweeps. This can result in
     * both new ejections as well as hosts being returned to service. Defaults
     * to 10000ms or 10s.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 2;
     */
    interval?: Duration;
    /**
     * The base time that a host is ejected for. The real time is equal to the
     * base time multiplied by the number of times the host has been ejected.
     * Defaults to 30000ms or 30s.
     *
     * @generated from protobuf field: google.protobuf.Duration base_ejection_time = 3;
     */
    baseEjectionTime?: Duration;
    /**
     * The maximum % of an upstream cluster that can be ejected due to outlier
     * detection. Defaults to 10% but will eject at least one host regardless of the value.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_ejection_percent = 4;
     */
    maxEjectionPercent?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status
     * is detected through consecutive 5xx. This setting can be used to disable
     * ejection or to ramp it up slowly. Defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [json_name = "enforcingConsecutive5xx"];
     */
    enforcingConsecutive5Xx?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status
     * is detected through success rate statistics. This setting can be used to
     * disable ejection or to ramp it up slowly. Defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_success_rate = 6;
     */
    enforcingSuccessRate?: UInt32Value;
    /**
     * The number of hosts in a cluster that must have enough request volume to
     * detect success rate outliers. If the number of hosts is less than this
     * setting, outlier detection via success rate statistics is not performed
     * for any host in the cluster. Defaults to 5.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value success_rate_minimum_hosts = 7;
     */
    successRateMinimumHosts?: UInt32Value;
    /**
     * The minimum number of total requests that must be collected in one
     * interval (as defined by the interval duration above) to include this host
     * in success rate based outlier detection. If the volume is lower than this
     * setting, outlier detection via success rate statistics is not performed
     * for that host. Defaults to 100.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value success_rate_request_volume = 8;
     */
    successRateRequestVolume?: UInt32Value;
    /**
     * This factor is used to determine the ejection threshold for success rate
     * outlier ejection. The ejection threshold is the difference between the
     * mean success rate, and the product of this factor and the standard
     * deviation of the mean success rate: mean - (stdev *
     * success_rate_stdev_factor). This factor is divided by a thousand to get a
     * double. That is, if the desired factor is 1.9, the runtime value should
     * be 1900. Defaults to 1900.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value success_rate_stdev_factor = 9;
     */
    successRateStdevFactor?: UInt32Value;
    /**
     * The number of consecutive gateway failures (502, 503, 504 status codes)
     * before a consecutive gateway failure ejection occurs. Defaults to 5.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value consecutive_gateway_failure = 10;
     */
    consecutiveGatewayFailure?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status
     * is detected through consecutive gateway failures. This setting can be
     * used to disable ejection or to ramp it up slowly. Defaults to 0.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_consecutive_gateway_failure = 11;
     */
    enforcingConsecutiveGatewayFailure?: UInt32Value;
    /**
     * Determines whether to distinguish local origin failures from external errors. If set to true
     * the following configuration parameters are taken into account:
     * :ref:`consecutive_local_origin_failure<envoy_api_field_cluster.OutlierDetection.consecutive_local_origin_failure>`,
     * :ref:`enforcing_consecutive_local_origin_failure<envoy_api_field_cluster.OutlierDetection.enforcing_consecutive_local_origin_failure>`
     * and
     * :ref:`enforcing_local_origin_success_rate<envoy_api_field_cluster.OutlierDetection.enforcing_local_origin_success_rate>`.
     * Defaults to false.
     *
     * @generated from protobuf field: bool split_external_local_origin_errors = 12;
     */
    splitExternalLocalOriginErrors: boolean;
    /**
     * The number of consecutive locally originated failures before ejection
     * occurs. Defaults to 5. Parameter takes effect only when
     * :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is set to true.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value consecutive_local_origin_failure = 13;
     */
    consecutiveLocalOriginFailure?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status
     * is detected through consecutive locally originated failures. This setting can be
     * used to disable ejection or to ramp it up slowly. Defaults to 100.
     * Parameter takes effect only when
     * :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is set to true.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_consecutive_local_origin_failure = 14;
     */
    enforcingConsecutiveLocalOriginFailure?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status
     * is detected through success rate statistics for locally originated errors.
     * This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
     * Parameter takes effect only when
     * :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
     * is set to true.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_local_origin_success_rate = 15;
     */
    enforcingLocalOriginSuccessRate?: UInt32Value;
    /**
     * The failure percentage to use when determining failure percentage-based outlier detection. If
     * the failure percentage of a given host is greater than or equal to this value, it will be
     * ejected. Defaults to 85.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value failure_percentage_threshold = 16;
     */
    failurePercentageThreshold?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status is detected through
     * failure percentage statistics. This setting can be used to disable ejection or to ramp it up
     * slowly. Defaults to 0.
     *
     * [#next-major-version: setting this without setting failure_percentage_threshold should be
     * invalid in v4.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_failure_percentage = 17;
     */
    enforcingFailurePercentage?: UInt32Value;
    /**
     * The % chance that a host will be actually ejected when an outlier status is detected through
     * local-origin failure percentage statistics. This setting can be used to disable ejection or to
     * ramp it up slowly. Defaults to 0.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value enforcing_failure_percentage_local_origin = 18;
     */
    enforcingFailurePercentageLocalOrigin?: UInt32Value;
    /**
     * The minimum number of hosts in a cluster in order to perform failure percentage-based ejection.
     * If the total number of hosts in the cluster is less than this value, failure percentage-based
     * ejection will not be performed. Defaults to 5.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value failure_percentage_minimum_hosts = 19;
     */
    failurePercentageMinimumHosts?: UInt32Value;
    /**
     * The minimum number of total requests that must be collected in one interval (as defined by the
     * interval duration above) to perform failure percentage-based ejection for this host. If the
     * volume is lower than this setting, failure percentage-based ejection will not be performed for
     * this host. Defaults to 50.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value failure_percentage_request_volume = 20;
     */
    failurePercentageRequestVolume?: UInt32Value;
}
// @generated message type with reflection information, may provide speed optimized methods
class OutlierDetection$Type extends MessageType<OutlierDetection> {
    constructor() {
        super("envoy.api.v2.cluster.OutlierDetection", [
            { no: 1, name: "consecutive_5xx", kind: "message", jsonName: "consecutive5xx", T: () => UInt32Value },
            { no: 2, name: "interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 3, name: "base_ejection_time", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 4, name: "max_ejection_percent", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 5, name: "enforcing_consecutive_5xx", kind: "message", jsonName: "enforcingConsecutive5xx", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 6, name: "enforcing_success_rate", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 7, name: "success_rate_minimum_hosts", kind: "message", T: () => UInt32Value },
            { no: 8, name: "success_rate_request_volume", kind: "message", T: () => UInt32Value },
            { no: 9, name: "success_rate_stdev_factor", kind: "message", T: () => UInt32Value },
            { no: 10, name: "consecutive_gateway_failure", kind: "message", T: () => UInt32Value },
            { no: 11, name: "enforcing_consecutive_gateway_failure", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 12, name: "split_external_local_origin_errors", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "consecutive_local_origin_failure", kind: "message", T: () => UInt32Value },
            { no: 14, name: "enforcing_consecutive_local_origin_failure", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 15, name: "enforcing_local_origin_success_rate", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 16, name: "failure_percentage_threshold", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 17, name: "enforcing_failure_percentage", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 18, name: "enforcing_failure_percentage_local_origin", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 100 } } } },
            { no: 19, name: "failure_percentage_minimum_hosts", kind: "message", T: () => UInt32Value },
            { no: 20, name: "failure_percentage_request_volume", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<OutlierDetection>): OutlierDetection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.splitExternalLocalOriginErrors = false;
        if (value !== undefined)
            reflectionMergePartial<OutlierDetection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OutlierDetection): OutlierDetection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value consecutive_5xx = 1 [json_name = "consecutive5xx"];*/ 1:
                    message.consecutive5Xx = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.consecutive5Xx);
                    break;
                case /* google.protobuf.Duration interval */ 2:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                case /* google.protobuf.Duration base_ejection_time */ 3:
                    message.baseEjectionTime = Duration.internalBinaryRead(reader, reader.uint32(), options, message.baseEjectionTime);
                    break;
                case /* google.protobuf.UInt32Value max_ejection_percent */ 4:
                    message.maxEjectionPercent = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxEjectionPercent);
                    break;
                case /* google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [json_name = "enforcingConsecutive5xx"];*/ 5:
                    message.enforcingConsecutive5Xx = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingConsecutive5Xx);
                    break;
                case /* google.protobuf.UInt32Value enforcing_success_rate */ 6:
                    message.enforcingSuccessRate = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingSuccessRate);
                    break;
                case /* google.protobuf.UInt32Value success_rate_minimum_hosts */ 7:
                    message.successRateMinimumHosts = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.successRateMinimumHosts);
                    break;
                case /* google.protobuf.UInt32Value success_rate_request_volume */ 8:
                    message.successRateRequestVolume = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.successRateRequestVolume);
                    break;
                case /* google.protobuf.UInt32Value success_rate_stdev_factor */ 9:
                    message.successRateStdevFactor = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.successRateStdevFactor);
                    break;
                case /* google.protobuf.UInt32Value consecutive_gateway_failure */ 10:
                    message.consecutiveGatewayFailure = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.consecutiveGatewayFailure);
                    break;
                case /* google.protobuf.UInt32Value enforcing_consecutive_gateway_failure */ 11:
                    message.enforcingConsecutiveGatewayFailure = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingConsecutiveGatewayFailure);
                    break;
                case /* bool split_external_local_origin_errors */ 12:
                    message.splitExternalLocalOriginErrors = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value consecutive_local_origin_failure */ 13:
                    message.consecutiveLocalOriginFailure = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.consecutiveLocalOriginFailure);
                    break;
                case /* google.protobuf.UInt32Value enforcing_consecutive_local_origin_failure */ 14:
                    message.enforcingConsecutiveLocalOriginFailure = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingConsecutiveLocalOriginFailure);
                    break;
                case /* google.protobuf.UInt32Value enforcing_local_origin_success_rate */ 15:
                    message.enforcingLocalOriginSuccessRate = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingLocalOriginSuccessRate);
                    break;
                case /* google.protobuf.UInt32Value failure_percentage_threshold */ 16:
                    message.failurePercentageThreshold = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.failurePercentageThreshold);
                    break;
                case /* google.protobuf.UInt32Value enforcing_failure_percentage */ 17:
                    message.enforcingFailurePercentage = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingFailurePercentage);
                    break;
                case /* google.protobuf.UInt32Value enforcing_failure_percentage_local_origin */ 18:
                    message.enforcingFailurePercentageLocalOrigin = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.enforcingFailurePercentageLocalOrigin);
                    break;
                case /* google.protobuf.UInt32Value failure_percentage_minimum_hosts */ 19:
                    message.failurePercentageMinimumHosts = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.failurePercentageMinimumHosts);
                    break;
                case /* google.protobuf.UInt32Value failure_percentage_request_volume */ 20:
                    message.failurePercentageRequestVolume = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.failurePercentageRequestVolume);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OutlierDetection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value consecutive_5xx = 1 [json_name = "consecutive5xx"]; */
        if (message.consecutive5Xx)
            UInt32Value.internalBinaryWrite(message.consecutive5Xx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval = 2; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration base_ejection_time = 3; */
        if (message.baseEjectionTime)
            Duration.internalBinaryWrite(message.baseEjectionTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_ejection_percent = 4; */
        if (message.maxEjectionPercent)
            UInt32Value.internalBinaryWrite(message.maxEjectionPercent, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [json_name = "enforcingConsecutive5xx"]; */
        if (message.enforcingConsecutive5Xx)
            UInt32Value.internalBinaryWrite(message.enforcingConsecutive5Xx, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_success_rate = 6; */
        if (message.enforcingSuccessRate)
            UInt32Value.internalBinaryWrite(message.enforcingSuccessRate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value success_rate_minimum_hosts = 7; */
        if (message.successRateMinimumHosts)
            UInt32Value.internalBinaryWrite(message.successRateMinimumHosts, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value success_rate_request_volume = 8; */
        if (message.successRateRequestVolume)
            UInt32Value.internalBinaryWrite(message.successRateRequestVolume, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value success_rate_stdev_factor = 9; */
        if (message.successRateStdevFactor)
            UInt32Value.internalBinaryWrite(message.successRateStdevFactor, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value consecutive_gateway_failure = 10; */
        if (message.consecutiveGatewayFailure)
            UInt32Value.internalBinaryWrite(message.consecutiveGatewayFailure, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_consecutive_gateway_failure = 11; */
        if (message.enforcingConsecutiveGatewayFailure)
            UInt32Value.internalBinaryWrite(message.enforcingConsecutiveGatewayFailure, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool split_external_local_origin_errors = 12; */
        if (message.splitExternalLocalOriginErrors !== false)
            writer.tag(12, WireType.Varint).bool(message.splitExternalLocalOriginErrors);
        /* google.protobuf.UInt32Value consecutive_local_origin_failure = 13; */
        if (message.consecutiveLocalOriginFailure)
            UInt32Value.internalBinaryWrite(message.consecutiveLocalOriginFailure, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_consecutive_local_origin_failure = 14; */
        if (message.enforcingConsecutiveLocalOriginFailure)
            UInt32Value.internalBinaryWrite(message.enforcingConsecutiveLocalOriginFailure, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_local_origin_success_rate = 15; */
        if (message.enforcingLocalOriginSuccessRate)
            UInt32Value.internalBinaryWrite(message.enforcingLocalOriginSuccessRate, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value failure_percentage_threshold = 16; */
        if (message.failurePercentageThreshold)
            UInt32Value.internalBinaryWrite(message.failurePercentageThreshold, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_failure_percentage = 17; */
        if (message.enforcingFailurePercentage)
            UInt32Value.internalBinaryWrite(message.enforcingFailurePercentage, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value enforcing_failure_percentage_local_origin = 18; */
        if (message.enforcingFailurePercentageLocalOrigin)
            UInt32Value.internalBinaryWrite(message.enforcingFailurePercentageLocalOrigin, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value failure_percentage_minimum_hosts = 19; */
        if (message.failurePercentageMinimumHosts)
            UInt32Value.internalBinaryWrite(message.failurePercentageMinimumHosts, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value failure_percentage_request_volume = 20; */
        if (message.failurePercentageRequestVolume)
            UInt32Value.internalBinaryWrite(message.failurePercentageRequestVolume, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.cluster.OutlierDetection
 */
export const OutlierDetection = new OutlierDetection$Type();
