// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/discovery.proto" (package "envoy.api.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ControlPlane } from "./core/base";
import { Any } from "../../../google/protobuf/any";
import { Status } from "../../../google/rpc/status";
import { Node } from "./core/base";
// [#protodoc-title: Common discovery API components]

/**
 * A DiscoveryRequest requests a set of versioned resources of the same type for
 * a given Envoy node on some API.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.DiscoveryRequest
 */
export interface DiscoveryRequest {
    /**
     * The version_info provided in the request messages will be the version_info
     * received with the most recent successfully processed response or empty on
     * the first request. It is expected that no new request is sent after a
     * response is received until the Envoy instance is ready to ACK/NACK the new
     * configuration. ACK/NACK takes place by returning the new API config version
     * as applied or the previous API config version respectively. Each type_url
     * (see below) has an independent version associated with it.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The node making the request.
     *
     * @generated from protobuf field: envoy.api.v2.core.Node node = 2;
     */
    node?: Node;
    /**
     * List of resources to subscribe to, e.g. list of cluster names or a route
     * configuration name. If this is empty, all resources for the API are
     * returned. LDS/CDS may have empty resource_names, which will cause all
     * resources for the Envoy instance to be returned. The LDS and CDS responses
     * will then imply a number of resources that need to be fetched via EDS/RDS,
     * which will be explicitly enumerated in resource_names.
     *
     * @generated from protobuf field: repeated string resource_names = 3;
     */
    resourceNames: string[];
    /**
     * Type of the resource that is being requested, e.g.
     * "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
     * in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
     * required for ADS.
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
     * discussion on version_info and the DiscoveryResponse nonce comment. This
     * may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
     * or 2) the client has not yet accepted an update in this xDS stream (unlike
     * delta, where it is populated only for new explicit ACKs).
     *
     * @generated from protobuf field: string response_nonce = 5;
     */
    responseNonce: string;
    /**
     * This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
     * failed to update configuration. The *message* field in *error_details* provides the Envoy
     * internal exception related to the failure. It is only intended for consumption during manual
     * debugging, the string provided is not guaranteed to be stable across Envoy versions.
     *
     * @generated from protobuf field: google.rpc.Status error_detail = 6;
     */
    errorDetail?: Status;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.DiscoveryResponse
 */
export interface DiscoveryResponse {
    /**
     * The version of the response data.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The response resources. These resources are typed and depend on the API being called.
     *
     * @generated from protobuf field: repeated google.protobuf.Any resources = 2;
     */
    resources: Any[];
    /**
     * [#not-implemented-hide:]
     * Canary is used to support two Envoy command line flags:
     *
     * * --terminate-on-canary-transition-failure. When set, Envoy is able to
     *   terminate if it detects that configuration is stuck at canary. Consider
     *   this example sequence of updates:
     *   - Management server applies a canary config successfully.
     *   - Management server rolls back to a production config.
     *   - Envoy rejects the new production config.
     *   Since there is no sensible way to continue receiving configuration
     *   updates, Envoy will then terminate and apply production config from a
     *   clean slate.
     * * --dry-run-canary. When set, a canary response will never be applied, only
     *   validated via a dry run.
     *
     * @generated from protobuf field: bool canary = 3;
     */
    canary: boolean;
    /**
     * Type URL for resources. Identifies the xDS API when muxing over ADS.
     * Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * For gRPC based subscriptions, the nonce provides a way to explicitly ack a
     * specific DiscoveryResponse in a following DiscoveryRequest. Additional
     * messages may have been sent by Envoy to the management server for the
     * previous version on the stream prior to this DiscoveryResponse, that were
     * unprocessed at response send time. The nonce allows the management server
     * to ignore any further DiscoveryRequests for the previous version until a
     * DiscoveryRequest bearing the nonce. The nonce is optional and is not
     * required for non-stream based xDS implementations.
     *
     * @generated from protobuf field: string nonce = 5;
     */
    nonce: string;
    /**
     * [#not-implemented-hide:]
     * The control plane instance that sent the response.
     *
     * @generated from protobuf field: envoy.api.v2.core.ControlPlane control_plane = 6;
     */
    controlPlane?: ControlPlane;
}
/**
 * DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
 * endpoint for Delta xDS.
 *
 * With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
 * snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
 * diff to the state of a xDS client.
 * In Delta XDS there are per-resource versions, which allow tracking state at
 * the resource granularity.
 * An xDS Delta session is always in the context of a gRPC bidirectional
 * stream. This allows the xDS server to keep track of the state of xDS clients
 * connected to it.
 *
 * In Delta xDS the nonce field is required and used to pair
 * DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
 * Optionally, a response message level system_version_info is present for
 * debugging purposes only.
 *
 * DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
 * can be either or both of: [1] informing the server of what resources the
 * client has gained/lost interest in (using resource_names_subscribe and
 * resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
 * the server (using response_nonce, with presence of error_detail making it a NACK).
 * Additionally, the first message (for a given type_url) of a reconnected gRPC stream
 * has a third role: informing the server of the resources (and their versions)
 * that the client already possesses, using the initial_resource_versions field.
 *
 * As with state-of-the-world, when multiple resource types are multiplexed (ADS),
 * all requests/acknowledgments/updates are logically walled off by type_url:
 * a Cluster ACK exists in a completely separate world from a prior Route NACK.
 * In particular, initial_resource_versions being sent at the "start" of every
 * gRPC stream actually entails a message for each type_url, each with its own
 * initial_resource_versions.
 * [#next-free-field: 8]
 *
 * @generated from protobuf message envoy.api.v2.DeltaDiscoveryRequest
 */
export interface DeltaDiscoveryRequest {
    /**
     * The node making the request.
     *
     * @generated from protobuf field: envoy.api.v2.core.Node node = 1;
     */
    node?: Node;
    /**
     * Type of the resource that is being requested, e.g.
     * "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment".
     *
     * @generated from protobuf field: string type_url = 2;
     */
    typeUrl: string;
    /**
     * DeltaDiscoveryRequests allow the client to add or remove individual
     * resources to the set of tracked resources in the context of a stream.
     * All resource names in the resource_names_subscribe list are added to the
     * set of tracked resources and all resource names in the resource_names_unsubscribe
     * list are removed from the set of tracked resources.
     *
     * *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
     * resource_names_unsubscribe list simply means that no resources are to be
     * added or removed to the resource list.
     * *Like* state-of-the-world xDS, the server must send updates for all tracked
     * resources, but can also send updates for resources the client has not subscribed to.
     *
     * NOTE: the server must respond with all resources listed in resource_names_subscribe,
     * even if it believes the client has the most recent version of them. The reason:
     * the client may have dropped them, but then regained interest before it had a chance
     * to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
     *
     * These two fields can be set in any DeltaDiscoveryRequest, including ACKs
     * and initial_resource_versions.
     *
     * A list of Resource names to add to the list of tracked resources.
     *
     * @generated from protobuf field: repeated string resource_names_subscribe = 3;
     */
    resourceNamesSubscribe: string[];
    /**
     * A list of Resource names to remove from the list of tracked resources.
     *
     * @generated from protobuf field: repeated string resource_names_unsubscribe = 4;
     */
    resourceNamesUnsubscribe: string[];
    /**
     * Informs the server of the versions of the resources the xDS client knows of, to enable the
     * client to continue the same logical xDS session even in the face of gRPC stream reconnection.
     * It will not be populated: [1] in the very first stream of a session, since the client will
     * not yet have any resources,  [2] in any message after the first in a stream (for a given
     * type_url), since the server will already be correctly tracking the client's state.
     * (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
     * The map's keys are names of xDS resources known to the xDS client.
     * The map's values are opaque resource versions.
     *
     * @generated from protobuf field: map<string, string> initial_resource_versions = 5;
     */
    initialResourceVersions: {
        [key: string]: string;
    };
    /**
     * When the DeltaDiscoveryRequest is a ACK or NACK message in response
     * to a previous DeltaDiscoveryResponse, the response_nonce must be the
     * nonce in the DeltaDiscoveryResponse.
     * Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
     *
     * @generated from protobuf field: string response_nonce = 6;
     */
    responseNonce: string;
    /**
     * This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_DiscoveryResponse>`
     * failed to update configuration. The *message* field in *error_details*
     * provides the Envoy internal exception related to the failure.
     *
     * @generated from protobuf field: google.rpc.Status error_detail = 7;
     */
    errorDetail?: Status;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.DeltaDiscoveryResponse
 */
export interface DeltaDiscoveryResponse {
    /**
     * The version of the response data (used for debugging).
     *
     * @generated from protobuf field: string system_version_info = 1;
     */
    systemVersionInfo: string;
    /**
     * The response resources. These are typed resources, whose types must match
     * the type_url field.
     *
     * @generated from protobuf field: repeated envoy.api.v2.Resource resources = 2;
     */
    resources: Resource[];
    // field id 3 IS available!

    /**
     * Type URL for resources. Identifies the xDS API when muxing over ADS.
     * Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
     *
     * @generated from protobuf field: string type_url = 4;
     */
    typeUrl: string;
    /**
     * Resources names of resources that have be deleted and to be removed from the xDS Client.
     * Removed resources for missing resources can be ignored.
     *
     * @generated from protobuf field: repeated string removed_resources = 6;
     */
    removedResources: string[];
    /**
     * The nonce provides a way for DeltaDiscoveryRequests to uniquely
     * reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
     *
     * @generated from protobuf field: string nonce = 5;
     */
    nonce: string;
}
/**
 * @generated from protobuf message envoy.api.v2.Resource
 */
export interface Resource {
    /**
     * The resource's name, to distinguish it from others of the same type of resource.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * The aliases are a list of other names that this resource can go by.
     *
     * @generated from protobuf field: repeated string aliases = 4;
     */
    aliases: string[];
    /**
     * The resource level version. It allows xDS to track the state of individual
     * resources.
     *
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * The resource being tracked.
     *
     * @generated from protobuf field: google.protobuf.Any resource = 2;
     */
    resource?: Any;
}
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryRequest$Type extends MessageType<DiscoveryRequest> {
    constructor() {
        super("envoy.api.v2.DiscoveryRequest", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "node", kind: "message", T: () => Node },
            { no: 3, name: "resource_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "response_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "error_detail", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<DiscoveryRequest>): DiscoveryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.resourceNames = [];
        message.typeUrl = "";
        message.responseNonce = "";
        if (value !== undefined)
            reflectionMergePartial<DiscoveryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryRequest): DiscoveryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* envoy.api.v2.core.Node node */ 2:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* repeated string resource_names */ 3:
                    message.resourceNames.push(reader.string());
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* string response_nonce */ 5:
                    message.responseNonce = reader.string();
                    break;
                case /* google.rpc.Status error_detail */ 6:
                    message.errorDetail = Status.internalBinaryRead(reader, reader.uint32(), options, message.errorDetail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* envoy.api.v2.core.Node node = 2; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string resource_names = 3; */
        for (let i = 0; i < message.resourceNames.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.resourceNames[i]);
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* string response_nonce = 5; */
        if (message.responseNonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.responseNonce);
        /* google.rpc.Status error_detail = 6; */
        if (message.errorDetail)
            Status.internalBinaryWrite(message.errorDetail, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.DiscoveryRequest
 */
export const DiscoveryRequest = new DiscoveryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiscoveryResponse$Type extends MessageType<DiscoveryResponse> {
    constructor() {
        super("envoy.api.v2.DiscoveryResponse", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 3, name: "canary", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "control_plane", kind: "message", T: () => ControlPlane }
        ]);
    }
    create(value?: PartialMessage<DiscoveryResponse>): DiscoveryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.resources = [];
        message.canary = false;
        message.typeUrl = "";
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<DiscoveryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiscoveryResponse): DiscoveryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated google.protobuf.Any resources */ 2:
                    message.resources.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool canary */ 3:
                    message.canary = reader.bool();
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* string nonce */ 5:
                    message.nonce = reader.string();
                    break;
                case /* envoy.api.v2.core.ControlPlane control_plane */ 6:
                    message.controlPlane = ControlPlane.internalBinaryRead(reader, reader.uint32(), options, message.controlPlane);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiscoveryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated google.protobuf.Any resources = 2; */
        for (let i = 0; i < message.resources.length; i++)
            Any.internalBinaryWrite(message.resources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool canary = 3; */
        if (message.canary !== false)
            writer.tag(3, WireType.Varint).bool(message.canary);
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* string nonce = 5; */
        if (message.nonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nonce);
        /* envoy.api.v2.core.ControlPlane control_plane = 6; */
        if (message.controlPlane)
            ControlPlane.internalBinaryWrite(message.controlPlane, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.DiscoveryResponse
 */
export const DiscoveryResponse = new DiscoveryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeltaDiscoveryRequest$Type extends MessageType<DeltaDiscoveryRequest> {
    constructor() {
        super("envoy.api.v2.DeltaDiscoveryRequest", [
            { no: 1, name: "node", kind: "message", T: () => Node },
            { no: 2, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "resource_names_subscribe", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "resource_names_unsubscribe", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "initial_resource_versions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 6, name: "response_nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "error_detail", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<DeltaDiscoveryRequest>): DeltaDiscoveryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.typeUrl = "";
        message.resourceNamesSubscribe = [];
        message.resourceNamesUnsubscribe = [];
        message.initialResourceVersions = {};
        message.responseNonce = "";
        if (value !== undefined)
            reflectionMergePartial<DeltaDiscoveryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeltaDiscoveryRequest): DeltaDiscoveryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Node node */ 1:
                    message.node = Node.internalBinaryRead(reader, reader.uint32(), options, message.node);
                    break;
                case /* string type_url */ 2:
                    message.typeUrl = reader.string();
                    break;
                case /* repeated string resource_names_subscribe */ 3:
                    message.resourceNamesSubscribe.push(reader.string());
                    break;
                case /* repeated string resource_names_unsubscribe */ 4:
                    message.resourceNamesUnsubscribe.push(reader.string());
                    break;
                case /* map<string, string> initial_resource_versions */ 5:
                    this.binaryReadMap5(message.initialResourceVersions, reader, options);
                    break;
                case /* string response_nonce */ 6:
                    message.responseNonce = reader.string();
                    break;
                case /* google.rpc.Status error_detail */ 7:
                    message.errorDetail = Status.internalBinaryRead(reader, reader.uint32(), options, message.errorDetail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: DeltaDiscoveryRequest["initialResourceVersions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeltaDiscoveryRequest["initialResourceVersions"] | undefined, val: DeltaDiscoveryRequest["initialResourceVersions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.DeltaDiscoveryRequest.initial_resource_versions");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeltaDiscoveryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Node node = 1; */
        if (message.node)
            Node.internalBinaryWrite(message.node, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string type_url = 2; */
        if (message.typeUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.typeUrl);
        /* repeated string resource_names_subscribe = 3; */
        for (let i = 0; i < message.resourceNamesSubscribe.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.resourceNamesSubscribe[i]);
        /* repeated string resource_names_unsubscribe = 4; */
        for (let i = 0; i < message.resourceNamesUnsubscribe.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.resourceNamesUnsubscribe[i]);
        /* map<string, string> initial_resource_versions = 5; */
        for (let k of globalThis.Object.keys(message.initialResourceVersions))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.initialResourceVersions[k]).join();
        /* string response_nonce = 6; */
        if (message.responseNonce !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.responseNonce);
        /* google.rpc.Status error_detail = 7; */
        if (message.errorDetail)
            Status.internalBinaryWrite(message.errorDetail, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.DeltaDiscoveryRequest
 */
export const DeltaDiscoveryRequest = new DeltaDiscoveryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeltaDiscoveryResponse$Type extends MessageType<DeltaDiscoveryResponse> {
    constructor() {
        super("envoy.api.v2.DeltaDiscoveryResponse", [
            { no: 1, name: "system_version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resources", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Resource },
            { no: 4, name: "type_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "removed_resources", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "nonce", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeltaDiscoveryResponse>): DeltaDiscoveryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.systemVersionInfo = "";
        message.resources = [];
        message.typeUrl = "";
        message.removedResources = [];
        message.nonce = "";
        if (value !== undefined)
            reflectionMergePartial<DeltaDiscoveryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeltaDiscoveryResponse): DeltaDiscoveryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string system_version_info */ 1:
                    message.systemVersionInfo = reader.string();
                    break;
                case /* repeated envoy.api.v2.Resource resources */ 2:
                    message.resources.push(Resource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string type_url */ 4:
                    message.typeUrl = reader.string();
                    break;
                case /* repeated string removed_resources */ 6:
                    message.removedResources.push(reader.string());
                    break;
                case /* string nonce */ 5:
                    message.nonce = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeltaDiscoveryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string system_version_info = 1; */
        if (message.systemVersionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.systemVersionInfo);
        /* repeated envoy.api.v2.Resource resources = 2; */
        for (let i = 0; i < message.resources.length; i++)
            Resource.internalBinaryWrite(message.resources[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string type_url = 4; */
        if (message.typeUrl !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.typeUrl);
        /* repeated string removed_resources = 6; */
        for (let i = 0; i < message.removedResources.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.removedResources[i]);
        /* string nonce = 5; */
        if (message.nonce !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nonce);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.DeltaDiscoveryResponse
 */
export const DeltaDiscoveryResponse = new DeltaDiscoveryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resource$Type extends MessageType<Resource> {
    constructor() {
        super("envoy.api.v2.Resource", [
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "aliases", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "resource", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Resource>): Resource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.aliases = [];
        message.version = "";
        if (value !== undefined)
            reflectionMergePartial<Resource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resource): Resource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* repeated string aliases */ 4:
                    message.aliases.push(reader.string());
                    break;
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* google.protobuf.Any resource */ 2:
                    message.resource = Any.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* repeated string aliases = 4; */
        for (let i = 0; i < message.aliases.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.aliases[i]);
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* google.protobuf.Any resource = 2; */
        if (message.resource)
            Any.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.Resource
 */
export const Resource = new Resource$Type();
