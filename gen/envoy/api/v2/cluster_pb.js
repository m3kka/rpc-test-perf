// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/cluster.proto (package envoy.api.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, Duration, proto3, Struct, UInt32Value, UInt64Value } from "@bufbuild/protobuf";
import { Address, BindConfig, TcpKeepalive } from "./core/address_pb.js";
import { ClusterLoadAssignment } from "./endpoint_pb.js";
import { HealthCheck } from "./core/health_check_pb.js";
import { CircuitBreakers } from "./cluster/circuit_breaker_pb.js";
import { UpstreamTlsContext } from "./auth/tls_pb.js";
import { Http1ProtocolOptions, Http2ProtocolOptions, HttpProtocolOptions, UpstreamHttpProtocolOptions } from "./core/protocol_pb.js";
import { OutlierDetection } from "./cluster/outlier_detection_pb.js";
import { Metadata, TransportSocket } from "./core/base_pb.js";
import { Filter } from "./cluster/filter_pb.js";
import { ConfigSource } from "./core/config_source_pb.js";
import { Percent } from "../../type/percent_pb.js";

/**
 * Configuration for a single upstream cluster.
 * [#next-free-field: 48]
 *
 * @generated from message envoy.api.v2.Cluster
 */
export const Cluster = proto3.makeMessageType(
  "envoy.api.v2.Cluster",
  () => [
    { no: 43, name: "transport_socket_matches", kind: "message", T: Cluster_TransportSocketMatch, repeated: true },
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 28, name: "alt_stat_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Cluster_DiscoveryType), oneof: "cluster_discovery_type" },
    { no: 38, name: "cluster_type", kind: "message", T: Cluster_CustomClusterType, oneof: "cluster_discovery_type" },
    { no: 3, name: "eds_cluster_config", kind: "message", T: Cluster_EdsClusterConfig },
    { no: 4, name: "connect_timeout", kind: "message", T: Duration },
    { no: 5, name: "per_connection_buffer_limit_bytes", kind: "message", T: UInt32Value },
    { no: 6, name: "lb_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbPolicy) },
    { no: 7, name: "hosts", kind: "message", T: Address, repeated: true },
    { no: 33, name: "load_assignment", kind: "message", T: ClusterLoadAssignment },
    { no: 8, name: "health_checks", kind: "message", T: HealthCheck, repeated: true },
    { no: 9, name: "max_requests_per_connection", kind: "message", T: UInt32Value },
    { no: 10, name: "circuit_breakers", kind: "message", T: CircuitBreakers },
    { no: 11, name: "tls_context", kind: "message", T: UpstreamTlsContext },
    { no: 46, name: "upstream_http_protocol_options", kind: "message", T: UpstreamHttpProtocolOptions },
    { no: 29, name: "common_http_protocol_options", kind: "message", T: HttpProtocolOptions },
    { no: 13, name: "http_protocol_options", kind: "message", T: Http1ProtocolOptions },
    { no: 14, name: "http2_protocol_options", kind: "message", T: Http2ProtocolOptions },
    { no: 35, name: "extension_protocol_options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Struct} },
    { no: 36, name: "typed_extension_protocol_options", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Any} },
    { no: 16, name: "dns_refresh_rate", kind: "message", T: Duration },
    { no: 44, name: "dns_failure_refresh_rate", kind: "message", T: Cluster_RefreshRate },
    { no: 39, name: "respect_dns_ttl", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "dns_lookup_family", kind: "enum", T: proto3.getEnumType(Cluster_DnsLookupFamily) },
    { no: 18, name: "dns_resolvers", kind: "message", T: Address, repeated: true },
    { no: 45, name: "use_tcp_for_dns_lookups", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "outlier_detection", kind: "message", T: OutlierDetection },
    { no: 20, name: "cleanup_interval", kind: "message", T: Duration },
    { no: 21, name: "upstream_bind_config", kind: "message", T: BindConfig },
    { no: 22, name: "lb_subset_config", kind: "message", T: Cluster_LbSubsetConfig },
    { no: 23, name: "ring_hash_lb_config", kind: "message", T: Cluster_RingHashLbConfig, oneof: "lb_config" },
    { no: 34, name: "original_dst_lb_config", kind: "message", T: Cluster_OriginalDstLbConfig, oneof: "lb_config" },
    { no: 37, name: "least_request_lb_config", kind: "message", T: Cluster_LeastRequestLbConfig, oneof: "lb_config" },
    { no: 27, name: "common_lb_config", kind: "message", T: Cluster_CommonLbConfig },
    { no: 24, name: "transport_socket", kind: "message", T: TransportSocket },
    { no: 25, name: "metadata", kind: "message", T: Metadata },
    { no: 26, name: "protocol_selection", kind: "enum", T: proto3.getEnumType(Cluster_ClusterProtocolSelection) },
    { no: 30, name: "upstream_connection_options", kind: "message", T: UpstreamConnectionOptions },
    { no: 31, name: "close_connections_on_host_health_failure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 32, name: "drain_connections_on_host_removal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 40, name: "filters", kind: "message", T: Filter, repeated: true },
    { no: 41, name: "load_balancing_policy", kind: "message", T: LoadBalancingPolicy },
    { no: 42, name: "lrs_server", kind: "message", T: ConfigSource },
    { no: 47, name: "track_timeout_budgets", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
 * for an explanation on each type.
 *
 * @generated from enum envoy.api.v2.Cluster.DiscoveryType
 */
export const Cluster_DiscoveryType = proto3.makeEnum(
  "envoy.api.v2.Cluster.DiscoveryType",
  [
    {no: 0, name: "STATIC"},
    {no: 1, name: "STRICT_DNS"},
    {no: 2, name: "LOGICAL_DNS"},
    {no: 3, name: "EDS"},
    {no: 4, name: "ORIGINAL_DST"},
  ],
);

/**
 * Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
 * overview section for information on each type.
 *
 * @generated from enum envoy.api.v2.Cluster.LbPolicy
 */
export const Cluster_LbPolicy = proto3.makeEnum(
  "envoy.api.v2.Cluster.LbPolicy",
  [
    {no: 0, name: "ROUND_ROBIN"},
    {no: 1, name: "LEAST_REQUEST"},
    {no: 2, name: "RING_HASH"},
    {no: 3, name: "RANDOM"},
    {no: 4, name: "ORIGINAL_DST_LB"},
    {no: 5, name: "MAGLEV"},
    {no: 6, name: "CLUSTER_PROVIDED"},
    {no: 7, name: "LOAD_BALANCING_POLICY_CONFIG"},
  ],
);

/**
 * When V4_ONLY is selected, the DNS resolver will only perform a lookup for
 * addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
 * only perform a lookup for addresses in the IPv6 family. If AUTO is
 * specified, the DNS resolver will first perform a lookup for addresses in
 * the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
 * For cluster types other than
 * :ref:`STRICT_DNS<envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
 * :ref:`LOGICAL_DNS<envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
 * this setting is
 * ignored.
 *
 * @generated from enum envoy.api.v2.Cluster.DnsLookupFamily
 */
export const Cluster_DnsLookupFamily = proto3.makeEnum(
  "envoy.api.v2.Cluster.DnsLookupFamily",
  [
    {no: 0, name: "AUTO"},
    {no: 1, name: "V4_ONLY"},
    {no: 2, name: "V6_ONLY"},
  ],
);

/**
 * @generated from enum envoy.api.v2.Cluster.ClusterProtocolSelection
 */
export const Cluster_ClusterProtocolSelection = proto3.makeEnum(
  "envoy.api.v2.Cluster.ClusterProtocolSelection",
  [
    {no: 0, name: "USE_CONFIGURED_PROTOCOL"},
    {no: 1, name: "USE_DOWNSTREAM_PROTOCOL"},
  ],
);

/**
 * TransportSocketMatch specifies what transport socket config will be used
 * when the match conditions are satisfied.
 *
 * @generated from message envoy.api.v2.Cluster.TransportSocketMatch
 */
export const Cluster_TransportSocketMatch = proto3.makeMessageType(
  "envoy.api.v2.Cluster.TransportSocketMatch",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "match", kind: "message", T: Struct },
    { no: 3, name: "transport_socket", kind: "message", T: TransportSocket },
  ],
  {localName: "Cluster_TransportSocketMatch"},
);

/**
 * Extended cluster type.
 *
 * @generated from message envoy.api.v2.Cluster.CustomClusterType
 */
export const Cluster_CustomClusterType = proto3.makeMessageType(
  "envoy.api.v2.Cluster.CustomClusterType",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "typed_config", kind: "message", T: Any },
  ],
  {localName: "Cluster_CustomClusterType"},
);

/**
 * Only valid when discovery type is EDS.
 *
 * @generated from message envoy.api.v2.Cluster.EdsClusterConfig
 */
export const Cluster_EdsClusterConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.EdsClusterConfig",
  () => [
    { no: 1, name: "eds_config", kind: "message", T: ConfigSource },
    { no: 2, name: "service_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "Cluster_EdsClusterConfig"},
);

/**
 * Optionally divide the endpoints in this cluster into subsets defined by
 * endpoint metadata and selected by route and weighted cluster metadata.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.api.v2.Cluster.LbSubsetConfig
 */
export const Cluster_LbSubsetConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.LbSubsetConfig",
  () => [
    { no: 1, name: "fallback_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbSubsetConfig_LbSubsetFallbackPolicy) },
    { no: 2, name: "default_subset", kind: "message", T: Struct },
    { no: 3, name: "subset_selectors", kind: "message", T: Cluster_LbSubsetConfig_LbSubsetSelector, repeated: true },
    { no: 4, name: "locality_weight_aware", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "scale_locality_weight", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "panic_mode_any", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "list_as_any", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Cluster_LbSubsetConfig"},
);

/**
 * If NO_FALLBACK is selected, a result
 * equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
 * any cluster endpoint may be returned (subject to policy, health checks,
 * etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
 * endpoints matching the values from the default_subset field.
 *
 * @generated from enum envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy
 */
export const Cluster_LbSubsetConfig_LbSubsetFallbackPolicy = proto3.makeEnum(
  "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy",
  [
    {no: 0, name: "NO_FALLBACK"},
    {no: 1, name: "ANY_ENDPOINT"},
    {no: 2, name: "DEFAULT_SUBSET"},
  ],
);

/**
 * Specifications for subsets.
 *
 * @generated from message envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector
 */
export const Cluster_LbSubsetConfig_LbSubsetSelector = proto3.makeMessageType(
  "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector",
  () => [
    { no: 1, name: "keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "fallback_policy", kind: "enum", T: proto3.getEnumType(Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy) },
    { no: 3, name: "fallback_keys_subset", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ],
  {localName: "Cluster_LbSubsetConfig_LbSubsetSelector"},
);

/**
 * Allows to override top level fallback policy per selector.
 *
 * @generated from enum envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy
 */
export const Cluster_LbSubsetConfig_LbSubsetSelector_LbSubsetSelectorFallbackPolicy = proto3.makeEnum(
  "envoy.api.v2.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy",
  [
    {no: 0, name: "NOT_DEFINED"},
    {no: 1, name: "NO_FALLBACK"},
    {no: 2, name: "ANY_ENDPOINT"},
    {no: 3, name: "DEFAULT_SUBSET"},
    {no: 4, name: "KEYS_SUBSET"},
  ],
);

/**
 * Specific configuration for the LeastRequest load balancing policy.
 *
 * @generated from message envoy.api.v2.Cluster.LeastRequestLbConfig
 */
export const Cluster_LeastRequestLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.LeastRequestLbConfig",
  () => [
    { no: 1, name: "choice_count", kind: "message", T: UInt32Value },
  ],
  {localName: "Cluster_LeastRequestLbConfig"},
);

/**
 * Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
 * load balancing policy.
 *
 * @generated from message envoy.api.v2.Cluster.RingHashLbConfig
 */
export const Cluster_RingHashLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.RingHashLbConfig",
  () => [
    { no: 1, name: "minimum_ring_size", kind: "message", T: UInt64Value },
    { no: 3, name: "hash_function", kind: "enum", T: proto3.getEnumType(Cluster_RingHashLbConfig_HashFunction) },
    { no: 4, name: "maximum_ring_size", kind: "message", T: UInt64Value },
  ],
  {localName: "Cluster_RingHashLbConfig"},
);

/**
 * The hash function used to hash hosts onto the ketama ring.
 *
 * @generated from enum envoy.api.v2.Cluster.RingHashLbConfig.HashFunction
 */
export const Cluster_RingHashLbConfig_HashFunction = proto3.makeEnum(
  "envoy.api.v2.Cluster.RingHashLbConfig.HashFunction",
  [
    {no: 0, name: "XX_HASH"},
    {no: 1, name: "MURMUR_HASH_2"},
  ],
);

/**
 * Specific configuration for the
 * :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
 * load balancing policy.
 *
 * @generated from message envoy.api.v2.Cluster.OriginalDstLbConfig
 */
export const Cluster_OriginalDstLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.OriginalDstLbConfig",
  () => [
    { no: 1, name: "use_http_header", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Cluster_OriginalDstLbConfig"},
);

/**
 * Common configuration for all load balancer implementations.
 * [#next-free-field: 8]
 *
 * @generated from message envoy.api.v2.Cluster.CommonLbConfig
 */
export const Cluster_CommonLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.CommonLbConfig",
  () => [
    { no: 1, name: "healthy_panic_threshold", kind: "message", T: Percent },
    { no: 2, name: "zone_aware_lb_config", kind: "message", T: Cluster_CommonLbConfig_ZoneAwareLbConfig, oneof: "locality_config_specifier" },
    { no: 3, name: "locality_weighted_lb_config", kind: "message", T: Cluster_CommonLbConfig_LocalityWeightedLbConfig, oneof: "locality_config_specifier" },
    { no: 4, name: "update_merge_window", kind: "message", T: Duration },
    { no: 5, name: "ignore_new_hosts_until_first_hc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "close_connections_on_host_set_change", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "consistent_hashing_lb_config", kind: "message", T: Cluster_CommonLbConfig_ConsistentHashingLbConfig },
  ],
  {localName: "Cluster_CommonLbConfig"},
);

/**
 * Configuration for :ref:`zone aware routing
 * <arch_overview_load_balancing_zone_aware_routing>`.
 *
 * @generated from message envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig
 */
export const Cluster_CommonLbConfig_ZoneAwareLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.CommonLbConfig.ZoneAwareLbConfig",
  () => [
    { no: 1, name: "routing_enabled", kind: "message", T: Percent },
    { no: 2, name: "min_cluster_size", kind: "message", T: UInt64Value },
    { no: 3, name: "fail_traffic_on_panic", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Cluster_CommonLbConfig_ZoneAwareLbConfig"},
);

/**
 * Configuration for :ref:`locality weighted load balancing
 * <arch_overview_load_balancing_locality_weighted_lb>`
 *
 * @generated from message envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig
 */
export const Cluster_CommonLbConfig_LocalityWeightedLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.CommonLbConfig.LocalityWeightedLbConfig",
  [],
  {localName: "Cluster_CommonLbConfig_LocalityWeightedLbConfig"},
);

/**
 * Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
 *
 * @generated from message envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig
 */
export const Cluster_CommonLbConfig_ConsistentHashingLbConfig = proto3.makeMessageType(
  "envoy.api.v2.Cluster.CommonLbConfig.ConsistentHashingLbConfig",
  () => [
    { no: 1, name: "use_hostname_for_hashing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Cluster_CommonLbConfig_ConsistentHashingLbConfig"},
);

/**
 * @generated from message envoy.api.v2.Cluster.RefreshRate
 */
export const Cluster_RefreshRate = proto3.makeMessageType(
  "envoy.api.v2.Cluster.RefreshRate",
  () => [
    { no: 1, name: "base_interval", kind: "message", T: Duration },
    { no: 2, name: "max_interval", kind: "message", T: Duration },
  ],
  {localName: "Cluster_RefreshRate"},
);

/**
 * [#not-implemented-hide:] Extensible load balancing policy configuration.
 *
 * Every LB policy defined via this mechanism will be identified via a unique name using reverse
 * DNS notation. If the policy needs configuration parameters, it must define a message for its
 * own configuration, which will be stored in the config field. The name of the policy will tell
 * clients which type of message they should expect to see in the config field.
 *
 * Note that there are cases where it is useful to be able to independently select LB policies
 * for choosing a locality and for choosing an endpoint within that locality. For example, a
 * given deployment may always use the same policy to choose the locality, but for choosing the
 * endpoint within the locality, some clusters may use weighted-round-robin, while others may
 * use some sort of session-based balancing.
 *
 * This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
 * child LB policy for each locality. For each request, the parent chooses the locality and then
 * delegates to the child policy for that locality to choose the endpoint within the locality.
 *
 * To facilitate this, the config message for the top-level LB policy may include a field of
 * type LoadBalancingPolicy that specifies the child policy.
 *
 * @generated from message envoy.api.v2.LoadBalancingPolicy
 */
export const LoadBalancingPolicy = proto3.makeMessageType(
  "envoy.api.v2.LoadBalancingPolicy",
  () => [
    { no: 1, name: "policies", kind: "message", T: LoadBalancingPolicy_Policy, repeated: true },
  ],
);

/**
 * @generated from message envoy.api.v2.LoadBalancingPolicy.Policy
 */
export const LoadBalancingPolicy_Policy = proto3.makeMessageType(
  "envoy.api.v2.LoadBalancingPolicy.Policy",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct },
    { no: 3, name: "typed_config", kind: "message", T: Any },
  ],
  {localName: "LoadBalancingPolicy_Policy"},
);

/**
 * An extensible structure containing the address Envoy should bind to when
 * establishing upstream connections.
 *
 * @generated from message envoy.api.v2.UpstreamBindConfig
 */
export const UpstreamBindConfig = proto3.makeMessageType(
  "envoy.api.v2.UpstreamBindConfig",
  () => [
    { no: 1, name: "source_address", kind: "message", T: Address },
  ],
);

/**
 * @generated from message envoy.api.v2.UpstreamConnectionOptions
 */
export const UpstreamConnectionOptions = proto3.makeMessageType(
  "envoy.api.v2.UpstreamConnectionOptions",
  () => [
    { no: 1, name: "tcp_keepalive", kind: "message", T: TcpKeepalive },
  ],
);

