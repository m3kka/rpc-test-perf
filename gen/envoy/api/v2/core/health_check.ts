// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/core/health_check.proto" (package "envoy.api.v2.core", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
import { StringMatcher } from "../../../type/matcher/string";
import { CodecClientType } from "../../../type/http";
import { Int64Range } from "../../../type/range";
import { HeaderValueOption } from "./base";
import { EventServiceConfig } from "./event_service_config";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Duration } from "../../../../google/protobuf/duration";
/**
 * [#next-free-field: 23]
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck
 */
export interface HealthCheck {
    /**
     * The time to wait for a health check response. If the timeout is reached the
     * health check attempt will be considered a failure.
     *
     * @generated from protobuf field: google.protobuf.Duration timeout = 1;
     */
    timeout?: Duration;
    /**
     * The interval between health checks.
     *
     * @generated from protobuf field: google.protobuf.Duration interval = 2;
     */
    interval?: Duration;
    /**
     * An optional jitter amount in milliseconds. If specified, Envoy will start health
     * checking after for a random time in ms between 0 and initial_jitter. This only
     * applies to the first health check.
     *
     * @generated from protobuf field: google.protobuf.Duration initial_jitter = 20;
     */
    initialJitter?: Duration;
    /**
     * An optional jitter amount in milliseconds. If specified, during every
     * interval Envoy will add interval_jitter to the wait time.
     *
     * @generated from protobuf field: google.protobuf.Duration interval_jitter = 3;
     */
    intervalJitter?: Duration;
    /**
     * An optional jitter amount as a percentage of interval_ms. If specified,
     * during every interval Envoy will add interval_ms *
     * interval_jitter_percent / 100 to the wait time.
     *
     * If interval_jitter_ms and interval_jitter_percent are both set, both of
     * them will be used to increase the wait time.
     *
     * @generated from protobuf field: uint32 interval_jitter_percent = 18;
     */
    intervalJitterPercent: number;
    /**
     * The number of unhealthy health checks required before a host is marked
     * unhealthy. Note that for *http* health checking if a host responds with 503
     * this threshold is ignored and the host is considered unhealthy immediately.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value unhealthy_threshold = 4;
     */
    unhealthyThreshold?: UInt32Value;
    /**
     * The number of healthy health checks required before a host is marked
     * healthy. Note that during startup, only a single successful health check is
     * required to mark a host healthy.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value healthy_threshold = 5;
     */
    healthyThreshold?: UInt32Value;
    /**
     * [#not-implemented-hide:] Non-serving port for health checking.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value alt_port = 6;
     */
    altPort?: UInt32Value;
    /**
     * Reuse health check connection between health checks. Default is true.
     *
     * @generated from protobuf field: google.protobuf.BoolValue reuse_connection = 7;
     */
    reuseConnection?: BoolValue;
    /**
     * @generated from protobuf oneof: health_checker
     */
    healthChecker: {
        oneofKind: "httpHealthCheck";
        /**
         * HTTP health check.
         *
         * @generated from protobuf field: envoy.api.v2.core.HealthCheck.HttpHealthCheck http_health_check = 8;
         */
        httpHealthCheck: HealthCheck_HttpHealthCheck;
    } | {
        oneofKind: "tcpHealthCheck";
        /**
         * TCP health check.
         *
         * @generated from protobuf field: envoy.api.v2.core.HealthCheck.TcpHealthCheck tcp_health_check = 9;
         */
        tcpHealthCheck: HealthCheck_TcpHealthCheck;
    } | {
        oneofKind: "grpcHealthCheck";
        /**
         * gRPC health check.
         *
         * @generated from protobuf field: envoy.api.v2.core.HealthCheck.GrpcHealthCheck grpc_health_check = 11;
         */
        grpcHealthCheck: HealthCheck_GrpcHealthCheck;
    } | {
        oneofKind: "customHealthCheck";
        /**
         * Custom health check.
         *
         * @generated from protobuf field: envoy.api.v2.core.HealthCheck.CustomHealthCheck custom_health_check = 13;
         */
        customHealthCheck: HealthCheck_CustomHealthCheck;
    } | {
        oneofKind: undefined;
    };
    /**
     * The "no traffic interval" is a special health check interval that is used when a cluster has
     * never had traffic routed to it. This lower interval allows cluster information to be kept up to
     * date, without sending a potentially large amount of active health checking traffic for no
     * reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
     * standard health check interval that is defined. Note that this interval takes precedence over
     * any other.
     *
     * The default value for "no traffic interval" is 60 seconds.
     *
     * @generated from protobuf field: google.protobuf.Duration no_traffic_interval = 12;
     */
    noTrafficInterval?: Duration;
    /**
     * The "unhealthy interval" is a health check interval that is used for hosts that are marked as
     * unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
     * standard health check interval that is defined.
     *
     * The default value for "unhealthy interval" is the same as "interval".
     *
     * @generated from protobuf field: google.protobuf.Duration unhealthy_interval = 14;
     */
    unhealthyInterval?: Duration;
    /**
     * The "unhealthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as unhealthy. For subsequent health checks
     * Envoy will shift back to using either "unhealthy interval" if present or the standard health
     * check interval that is defined.
     *
     * The default value for "unhealthy edge interval" is the same as "unhealthy interval".
     *
     * @generated from protobuf field: google.protobuf.Duration unhealthy_edge_interval = 15;
     */
    unhealthyEdgeInterval?: Duration;
    /**
     * The "healthy edge interval" is a special health check interval that is used for the first
     * health check right after a host is marked as healthy. For subsequent health checks
     * Envoy will shift back to using the standard health check interval that is defined.
     *
     * The default value for "healthy edge interval" is the same as the default interval.
     *
     * @generated from protobuf field: google.protobuf.Duration healthy_edge_interval = 16;
     */
    healthyEdgeInterval?: Duration;
    /**
     * Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
     * If empty, no event log will be written.
     *
     * @generated from protobuf field: string event_log_path = 17;
     */
    eventLogPath: string;
    /**
     * [#not-implemented-hide:]
     * The gRPC service for the health check event service.
     * If empty, health check events won't be sent to a remote endpoint.
     *
     * @generated from protobuf field: envoy.api.v2.core.EventServiceConfig event_service = 22;
     */
    eventService?: EventServiceConfig;
    /**
     * If set to true, health check failure events will always be logged. If set to false, only the
     * initial health check failure event will be logged.
     * The default value is false.
     *
     * @generated from protobuf field: bool always_log_health_check_failures = 19;
     */
    alwaysLogHealthCheckFailures: boolean;
    /**
     * This allows overriding the cluster TLS settings, just for health check connections.
     *
     * @generated from protobuf field: envoy.api.v2.core.HealthCheck.TlsOptions tls_options = 21;
     */
    tlsOptions?: HealthCheck_TlsOptions;
}
/**
 * Describes the encoding of the payload bytes in the payload.
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.Payload
 */
export interface HealthCheck_Payload {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "text";
        /**
         * Hex encoded payload. E.g., "000000FF".
         *
         * @generated from protobuf field: string text = 1;
         */
        text: string;
    } | {
        oneofKind: "binary";
        /**
         * [#not-implemented-hide:] Binary payload.
         *
         * @generated from protobuf field: bytes binary = 2;
         */
        binary: Uint8Array;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.HttpHealthCheck
 */
export interface HealthCheck_HttpHealthCheck {
    /**
     * The value of the host header in the HTTP health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The host header can be customized for a specific endpoint by setting the
     * :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from protobuf field: string host = 1;
     */
    host: string;
    /**
     * Specifies the HTTP path that will be requested during health checking. For example
     * *\/healthcheck*.
     *
     * @generated from protobuf field: string path = 2;
     */
    path: string;
    /**
     * [#not-implemented-hide:] HTTP specific payload.
     *
     * @generated from protobuf field: envoy.api.v2.core.HealthCheck.Payload send = 3;
     */
    send?: HealthCheck_Payload;
    /**
     * [#not-implemented-hide:] HTTP specific response.
     *
     * @generated from protobuf field: envoy.api.v2.core.HealthCheck.Payload receive = 4;
     */
    receive?: HealthCheck_Payload;
    /**
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster. See the :ref:`architecture overview
     * <arch_overview_health_checking_identity>` for more information.
     *
     * .. attention::
     *
     *   This field has been deprecated in favor of `service_name_matcher` for better flexibility
     *   over matching with service-cluster name.
     *
     * @deprecated
     * @generated from protobuf field: string service_name = 5 [deprecated = true];
     */
    serviceName: string;
    /**
     * Specifies a list of HTTP headers that should be added to each request that is sent to the
     * health checked cluster. For more information, including details on header value syntax, see
     * the documentation on :ref:`custom request headers
     * <config_http_conn_man_headers_custom_request_headers>`.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 6;
     */
    requestHeadersToAdd: HeaderValueOption[];
    /**
     * Specifies a list of HTTP headers that should be removed from each request that is sent to the
     * health checked cluster.
     *
     * @generated from protobuf field: repeated string request_headers_to_remove = 8;
     */
    requestHeadersToRemove: string[];
    /**
     * If set, health checks will be made using http/2.
     * Deprecated, use :ref:`codec_client_type
     * <envoy_api_field_core.HealthCheck.HttpHealthCheck.codec_client_type>` instead.
     *
     * @deprecated
     * @generated from protobuf field: bool use_http2 = 7 [deprecated = true];
     */
    useHttp2: boolean;
    /**
     * Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
     * 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
     * semantics of :ref:`Int64Range <envoy_api_msg_type.Int64Range>`. The start and end of each
     * range are required. Only statuses in the range [100, 600) are allowed.
     *
     * @generated from protobuf field: repeated envoy.type.Int64Range expected_statuses = 9;
     */
    expectedStatuses: Int64Range[];
    /**
     * Use specified application protocol for health checks.
     *
     * @generated from protobuf field: envoy.type.CodecClientType codec_client_type = 10;
     */
    codecClientType: CodecClientType;
    /**
     * An optional service name parameter which is used to validate the identity of
     * the health checked cluster using a :ref:`StringMatcher
     * <envoy_api_msg_type.matcher.StringMatcher>`. See the :ref:`architecture overview
     * <arch_overview_health_checking_identity>` for more information.
     *
     * @generated from protobuf field: envoy.type.matcher.StringMatcher service_name_matcher = 11;
     */
    serviceNameMatcher?: StringMatcher;
}
/**
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.TcpHealthCheck
 */
export interface HealthCheck_TcpHealthCheck {
    /**
     * Empty payloads imply a connect-only health check.
     *
     * @generated from protobuf field: envoy.api.v2.core.HealthCheck.Payload send = 1;
     */
    send?: HealthCheck_Payload;
    /**
     * When checking the response, “fuzzy” matching is performed such that each
     * binary block must be found, and in the order specified, but not
     * necessarily contiguous.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.HealthCheck.Payload receive = 2;
     */
    receive: HealthCheck_Payload[];
}
/**
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.RedisHealthCheck
 */
export interface HealthCheck_RedisHealthCheck {
    /**
     * If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
     * from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
     * than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
     * by setting the specified key to any value and waiting for traffic to drain.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
}
/**
 * `grpc.health.v1.Health
 * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
 * healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
 * for details.
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.GrpcHealthCheck
 */
export interface HealthCheck_GrpcHealthCheck {
    /**
     * An optional service name parameter which will be sent to gRPC service in
     * `grpc.health.v1.HealthCheckRequest
     * <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
     * message. See `gRPC health-checking overview
     * <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
     *
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * The value of the :authority header in the gRPC health check request. If
     * left empty (default value), the name of the cluster this health check is associated
     * with will be used. The authority header can be customized for a specific endpoint by setting
     * the :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
     *
     * @generated from protobuf field: string authority = 2;
     */
    authority: string;
}
/**
 * Custom health check.
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.CustomHealthCheck
 */
export interface HealthCheck_CustomHealthCheck {
    /**
     * The registered name of the custom health checker.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Health checks occur over the transport socket specified for the cluster. This implies that if a
 * cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
 *
 * This allows overriding the cluster TLS settings, just for health check connections.
 *
 * @generated from protobuf message envoy.api.v2.core.HealthCheck.TlsOptions
 */
export interface HealthCheck_TlsOptions {
    /**
     * Specifies the ALPN protocols for health check connections. This is useful if the
     * corresponding upstream is using ALPN-based :ref:`FilterChainMatch
     * <envoy_api_msg_listener.FilterChainMatch>` along with different protocols for health checks
     * versus data connections. If empty, no ALPN protocols will be set on health check connections.
     *
     * @generated from protobuf field: repeated string alpn_protocols = 1;
     */
    alpnProtocols: string[];
}
// [#protodoc-title: Health check]
// * Health checking :ref:`architecture overview <arch_overview_health_checking>`.
// * If health checking is configured for a cluster, additional statistics are emitted. They are
//   documented :ref:`here <config_cluster_manager_cluster_stats>`.

/**
 * Endpoint health status.
 *
 * @generated from protobuf enum envoy.api.v2.core.HealthStatus
 */
export enum HealthStatus {
    /**
     * The health status is not known. This is interpreted by Envoy as *HEALTHY*.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Healthy.
     *
     * @generated from protobuf enum value: HEALTHY = 1;
     */
    HEALTHY = 1,
    /**
     * Unhealthy.
     *
     * @generated from protobuf enum value: UNHEALTHY = 2;
     */
    UNHEALTHY = 2,
    /**
     * Connection draining in progress. E.g.,
     * `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
     * or
     * `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
     * This is interpreted by Envoy as *UNHEALTHY*.
     *
     * @generated from protobuf enum value: DRAINING = 3;
     */
    DRAINING = 3,
    /**
     * Health check timed out. This is part of HDS and is interpreted by Envoy as
     * *UNHEALTHY*.
     *
     * @generated from protobuf enum value: TIMEOUT = 4;
     */
    TIMEOUT = 4,
    /**
     * Degraded.
     *
     * @generated from protobuf enum value: DEGRADED = 5;
     */
    DEGRADED = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck$Type extends MessageType<HealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck", [
            { no: 1, name: "timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 2, name: "interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { required: true, gt: {} } } } },
            { no: 20, name: "initial_jitter", kind: "message", T: () => Duration },
            { no: 3, name: "interval_jitter", kind: "message", T: () => Duration },
            { no: 18, name: "interval_jitter_percent", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "unhealthy_threshold", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true } } } },
            { no: 5, name: "healthy_threshold", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "alt_port", kind: "message", T: () => UInt32Value },
            { no: 7, name: "reuse_connection", kind: "message", T: () => BoolValue },
            { no: 8, name: "http_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_HttpHealthCheck },
            { no: 9, name: "tcp_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_TcpHealthCheck },
            { no: 11, name: "grpc_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_GrpcHealthCheck },
            { no: 13, name: "custom_health_check", kind: "message", oneof: "healthChecker", T: () => HealthCheck_CustomHealthCheck },
            { no: 12, name: "no_traffic_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 14, name: "unhealthy_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 15, name: "unhealthy_edge_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 16, name: "healthy_edge_interval", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 17, name: "event_log_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "event_service", kind: "message", T: () => EventServiceConfig },
            { no: 19, name: "always_log_health_check_failures", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "tls_options", kind: "message", T: () => HealthCheck_TlsOptions }
        ]);
    }
    create(value?: PartialMessage<HealthCheck>): HealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.intervalJitterPercent = 0;
        message.healthChecker = { oneofKind: undefined };
        message.eventLogPath = "";
        message.alwaysLogHealthCheckFailures = false;
        if (value !== undefined)
            reflectionMergePartial<HealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck): HealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration timeout */ 1:
                    message.timeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.timeout);
                    break;
                case /* google.protobuf.Duration interval */ 2:
                    message.interval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.interval);
                    break;
                case /* google.protobuf.Duration initial_jitter */ 20:
                    message.initialJitter = Duration.internalBinaryRead(reader, reader.uint32(), options, message.initialJitter);
                    break;
                case /* google.protobuf.Duration interval_jitter */ 3:
                    message.intervalJitter = Duration.internalBinaryRead(reader, reader.uint32(), options, message.intervalJitter);
                    break;
                case /* uint32 interval_jitter_percent */ 18:
                    message.intervalJitterPercent = reader.uint32();
                    break;
                case /* google.protobuf.UInt32Value unhealthy_threshold */ 4:
                    message.unhealthyThreshold = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyThreshold);
                    break;
                case /* google.protobuf.UInt32Value healthy_threshold */ 5:
                    message.healthyThreshold = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.healthyThreshold);
                    break;
                case /* google.protobuf.UInt32Value alt_port */ 6:
                    message.altPort = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.altPort);
                    break;
                case /* google.protobuf.BoolValue reuse_connection */ 7:
                    message.reuseConnection = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.reuseConnection);
                    break;
                case /* envoy.api.v2.core.HealthCheck.HttpHealthCheck http_health_check */ 8:
                    message.healthChecker = {
                        oneofKind: "httpHealthCheck",
                        httpHealthCheck: HealthCheck_HttpHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).httpHealthCheck)
                    };
                    break;
                case /* envoy.api.v2.core.HealthCheck.TcpHealthCheck tcp_health_check */ 9:
                    message.healthChecker = {
                        oneofKind: "tcpHealthCheck",
                        tcpHealthCheck: HealthCheck_TcpHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).tcpHealthCheck)
                    };
                    break;
                case /* envoy.api.v2.core.HealthCheck.GrpcHealthCheck grpc_health_check */ 11:
                    message.healthChecker = {
                        oneofKind: "grpcHealthCheck",
                        grpcHealthCheck: HealthCheck_GrpcHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).grpcHealthCheck)
                    };
                    break;
                case /* envoy.api.v2.core.HealthCheck.CustomHealthCheck custom_health_check */ 13:
                    message.healthChecker = {
                        oneofKind: "customHealthCheck",
                        customHealthCheck: HealthCheck_CustomHealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.healthChecker as any).customHealthCheck)
                    };
                    break;
                case /* google.protobuf.Duration no_traffic_interval */ 12:
                    message.noTrafficInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.noTrafficInterval);
                    break;
                case /* google.protobuf.Duration unhealthy_interval */ 14:
                    message.unhealthyInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyInterval);
                    break;
                case /* google.protobuf.Duration unhealthy_edge_interval */ 15:
                    message.unhealthyEdgeInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.unhealthyEdgeInterval);
                    break;
                case /* google.protobuf.Duration healthy_edge_interval */ 16:
                    message.healthyEdgeInterval = Duration.internalBinaryRead(reader, reader.uint32(), options, message.healthyEdgeInterval);
                    break;
                case /* string event_log_path */ 17:
                    message.eventLogPath = reader.string();
                    break;
                case /* envoy.api.v2.core.EventServiceConfig event_service */ 22:
                    message.eventService = EventServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.eventService);
                    break;
                case /* bool always_log_health_check_failures */ 19:
                    message.alwaysLogHealthCheckFailures = reader.bool();
                    break;
                case /* envoy.api.v2.core.HealthCheck.TlsOptions tls_options */ 21:
                    message.tlsOptions = HealthCheck_TlsOptions.internalBinaryRead(reader, reader.uint32(), options, message.tlsOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration timeout = 1; */
        if (message.timeout)
            Duration.internalBinaryWrite(message.timeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval = 2; */
        if (message.interval)
            Duration.internalBinaryWrite(message.interval, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration initial_jitter = 20; */
        if (message.initialJitter)
            Duration.internalBinaryWrite(message.initialJitter, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration interval_jitter = 3; */
        if (message.intervalJitter)
            Duration.internalBinaryWrite(message.intervalJitter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 interval_jitter_percent = 18; */
        if (message.intervalJitterPercent !== 0)
            writer.tag(18, WireType.Varint).uint32(message.intervalJitterPercent);
        /* google.protobuf.UInt32Value unhealthy_threshold = 4; */
        if (message.unhealthyThreshold)
            UInt32Value.internalBinaryWrite(message.unhealthyThreshold, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value healthy_threshold = 5; */
        if (message.healthyThreshold)
            UInt32Value.internalBinaryWrite(message.healthyThreshold, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value alt_port = 6; */
        if (message.altPort)
            UInt32Value.internalBinaryWrite(message.altPort, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue reuse_connection = 7; */
        if (message.reuseConnection)
            BoolValue.internalBinaryWrite(message.reuseConnection, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthCheck.HttpHealthCheck http_health_check = 8; */
        if (message.healthChecker.oneofKind === "httpHealthCheck")
            HealthCheck_HttpHealthCheck.internalBinaryWrite(message.healthChecker.httpHealthCheck, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthCheck.TcpHealthCheck tcp_health_check = 9; */
        if (message.healthChecker.oneofKind === "tcpHealthCheck")
            HealthCheck_TcpHealthCheck.internalBinaryWrite(message.healthChecker.tcpHealthCheck, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthCheck.GrpcHealthCheck grpc_health_check = 11; */
        if (message.healthChecker.oneofKind === "grpcHealthCheck")
            HealthCheck_GrpcHealthCheck.internalBinaryWrite(message.healthChecker.grpcHealthCheck, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthCheck.CustomHealthCheck custom_health_check = 13; */
        if (message.healthChecker.oneofKind === "customHealthCheck")
            HealthCheck_CustomHealthCheck.internalBinaryWrite(message.healthChecker.customHealthCheck, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration no_traffic_interval = 12; */
        if (message.noTrafficInterval)
            Duration.internalBinaryWrite(message.noTrafficInterval, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration unhealthy_interval = 14; */
        if (message.unhealthyInterval)
            Duration.internalBinaryWrite(message.unhealthyInterval, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration unhealthy_edge_interval = 15; */
        if (message.unhealthyEdgeInterval)
            Duration.internalBinaryWrite(message.unhealthyEdgeInterval, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration healthy_edge_interval = 16; */
        if (message.healthyEdgeInterval)
            Duration.internalBinaryWrite(message.healthyEdgeInterval, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* string event_log_path = 17; */
        if (message.eventLogPath !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.eventLogPath);
        /* envoy.api.v2.core.EventServiceConfig event_service = 22; */
        if (message.eventService)
            EventServiceConfig.internalBinaryWrite(message.eventService, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* bool always_log_health_check_failures = 19; */
        if (message.alwaysLogHealthCheckFailures !== false)
            writer.tag(19, WireType.Varint).bool(message.alwaysLogHealthCheckFailures);
        /* envoy.api.v2.core.HealthCheck.TlsOptions tls_options = 21; */
        if (message.tlsOptions)
            HealthCheck_TlsOptions.internalBinaryWrite(message.tlsOptions, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck
 */
export const HealthCheck = new HealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_Payload$Type extends MessageType<HealthCheck_Payload> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.Payload", [
            { no: 1, name: "text", kind: "scalar", oneof: "payload", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "binary", kind: "scalar", oneof: "payload", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_Payload>): HealthCheck_Payload {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_Payload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_Payload): HealthCheck_Payload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.payload = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* bytes binary */ 2:
                    message.payload = {
                        oneofKind: "binary",
                        binary: reader.bytes()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_Payload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.payload.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.payload.text);
        /* bytes binary = 2; */
        if (message.payload.oneofKind === "binary")
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload.binary);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.Payload
 */
export const HealthCheck_Payload = new HealthCheck_Payload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_HttpHealthCheck$Type extends MessageType<HealthCheck_HttpHealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.HttpHealthCheck", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 3, name: "send", kind: "message", T: () => HealthCheck_Payload },
            { no: 4, name: "receive", kind: "message", T: () => HealthCheck_Payload },
            { no: 5, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "request_headers_to_add", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValueOption, options: { "validate.rules": { repeated: { maxItems: "1000" } } } },
            { no: 8, name: "request_headers_to_remove", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "use_http2", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "envoy.annotations.disallowed_by_default": true } },
            { no: 9, name: "expected_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Int64Range },
            { no: 10, name: "codec_client_type", kind: "enum", T: () => ["envoy.type.CodecClientType", CodecClientType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 11, name: "service_name_matcher", kind: "message", T: () => StringMatcher }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_HttpHealthCheck>): HealthCheck_HttpHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.path = "";
        message.serviceName = "";
        message.requestHeadersToAdd = [];
        message.requestHeadersToRemove = [];
        message.useHttp2 = false;
        message.expectedStatuses = [];
        message.codecClientType = 0;
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_HttpHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_HttpHealthCheck): HealthCheck_HttpHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* envoy.api.v2.core.HealthCheck.Payload send */ 3:
                    message.send = HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options, message.send);
                    break;
                case /* envoy.api.v2.core.HealthCheck.Payload receive */ 4:
                    message.receive = HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options, message.receive);
                    break;
                case /* string service_name = 5 [deprecated = true];*/ 5:
                    message.serviceName = reader.string();
                    break;
                case /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add */ 6:
                    message.requestHeadersToAdd.push(HeaderValueOption.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string request_headers_to_remove */ 8:
                    message.requestHeadersToRemove.push(reader.string());
                    break;
                case /* bool use_http2 = 7 [deprecated = true];*/ 7:
                    message.useHttp2 = reader.bool();
                    break;
                case /* repeated envoy.type.Int64Range expected_statuses */ 9:
                    message.expectedStatuses.push(Int64Range.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.type.CodecClientType codec_client_type */ 10:
                    message.codecClientType = reader.int32();
                    break;
                case /* envoy.type.matcher.StringMatcher service_name_matcher */ 11:
                    message.serviceNameMatcher = StringMatcher.internalBinaryRead(reader, reader.uint32(), options, message.serviceNameMatcher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_HttpHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* envoy.api.v2.core.HealthCheck.Payload send = 3; */
        if (message.send)
            HealthCheck_Payload.internalBinaryWrite(message.send, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HealthCheck.Payload receive = 4; */
        if (message.receive)
            HealthCheck_Payload.internalBinaryWrite(message.receive, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string service_name = 5 [deprecated = true]; */
        if (message.serviceName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.serviceName);
        /* repeated envoy.api.v2.core.HeaderValueOption request_headers_to_add = 6; */
        for (let i = 0; i < message.requestHeadersToAdd.length; i++)
            HeaderValueOption.internalBinaryWrite(message.requestHeadersToAdd[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated string request_headers_to_remove = 8; */
        for (let i = 0; i < message.requestHeadersToRemove.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.requestHeadersToRemove[i]);
        /* bool use_http2 = 7 [deprecated = true]; */
        if (message.useHttp2 !== false)
            writer.tag(7, WireType.Varint).bool(message.useHttp2);
        /* repeated envoy.type.Int64Range expected_statuses = 9; */
        for (let i = 0; i < message.expectedStatuses.length; i++)
            Int64Range.internalBinaryWrite(message.expectedStatuses[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.CodecClientType codec_client_type = 10; */
        if (message.codecClientType !== 0)
            writer.tag(10, WireType.Varint).int32(message.codecClientType);
        /* envoy.type.matcher.StringMatcher service_name_matcher = 11; */
        if (message.serviceNameMatcher)
            StringMatcher.internalBinaryWrite(message.serviceNameMatcher, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.HttpHealthCheck
 */
export const HealthCheck_HttpHealthCheck = new HealthCheck_HttpHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_TcpHealthCheck$Type extends MessageType<HealthCheck_TcpHealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.TcpHealthCheck", [
            { no: 1, name: "send", kind: "message", T: () => HealthCheck_Payload },
            { no: 2, name: "receive", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HealthCheck_Payload }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_TcpHealthCheck>): HealthCheck_TcpHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.receive = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_TcpHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_TcpHealthCheck): HealthCheck_TcpHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.HealthCheck.Payload send */ 1:
                    message.send = HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options, message.send);
                    break;
                case /* repeated envoy.api.v2.core.HealthCheck.Payload receive */ 2:
                    message.receive.push(HealthCheck_Payload.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_TcpHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.HealthCheck.Payload send = 1; */
        if (message.send)
            HealthCheck_Payload.internalBinaryWrite(message.send, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.HealthCheck.Payload receive = 2; */
        for (let i = 0; i < message.receive.length; i++)
            HealthCheck_Payload.internalBinaryWrite(message.receive[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.TcpHealthCheck
 */
export const HealthCheck_TcpHealthCheck = new HealthCheck_TcpHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_RedisHealthCheck$Type extends MessageType<HealthCheck_RedisHealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.RedisHealthCheck", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_RedisHealthCheck>): HealthCheck_RedisHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_RedisHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_RedisHealthCheck): HealthCheck_RedisHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_RedisHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.RedisHealthCheck
 */
export const HealthCheck_RedisHealthCheck = new HealthCheck_RedisHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_GrpcHealthCheck$Type extends MessageType<HealthCheck_GrpcHealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.GrpcHealthCheck", [
            { no: 1, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_GrpcHealthCheck>): HealthCheck_GrpcHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceName = "";
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_GrpcHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_GrpcHealthCheck): HealthCheck_GrpcHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* string authority */ 2:
                    message.authority = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_GrpcHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* string authority = 2; */
        if (message.authority !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.authority);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.GrpcHealthCheck
 */
export const HealthCheck_GrpcHealthCheck = new HealthCheck_GrpcHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_CustomHealthCheck$Type extends MessageType<HealthCheck_CustomHealthCheck> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.CustomHealthCheck", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_CustomHealthCheck>): HealthCheck_CustomHealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_CustomHealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_CustomHealthCheck): HealthCheck_CustomHealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_CustomHealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.CustomHealthCheck
 */
export const HealthCheck_CustomHealthCheck = new HealthCheck_CustomHealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck_TlsOptions$Type extends MessageType<HealthCheck_TlsOptions> {
    constructor() {
        super("envoy.api.v2.core.HealthCheck.TlsOptions", [
            { no: 1, name: "alpn_protocols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheck_TlsOptions>): HealthCheck_TlsOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.alpnProtocols = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheck_TlsOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck_TlsOptions): HealthCheck_TlsOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string alpn_protocols */ 1:
                    message.alpnProtocols.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck_TlsOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string alpn_protocols = 1; */
        for (let i = 0; i < message.alpnProtocols.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.alpnProtocols[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HealthCheck.TlsOptions
 */
export const HealthCheck_TlsOptions = new HealthCheck_TlsOptions$Type();
