// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/core/base.proto" (package "envoy.api.v2.core", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FractionalPercent } from "../../../type/percent";
import { Any } from "../../../../google/protobuf/any";
import { HttpUri } from "./http_uri";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { BackoffStrategy } from "./backoff";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { Address } from "./address";
import { Struct } from "../../../../google/protobuf/struct";
import { SemanticVersion } from "../../../type/semantic_version";
/**
 * Identifies location of where either Envoy runs or where upstream hosts run.
 *
 * @generated from protobuf message envoy.api.v2.core.Locality
 */
export interface Locality {
    /**
     * Region this :ref:`zone <envoy_api_field_core.Locality.zone>` belongs to.
     *
     * @generated from protobuf field: string region = 1;
     */
    region: string;
    /**
     * Defines the local service zone where Envoy is running. Though optional, it
     * should be set if discovery service routing is used and the discovery
     * service exposes :ref:`zone data <envoy_api_field_endpoint.LocalityLbEndpoints.locality>`,
     * either in this message or via :option:`--service-zone`. The meaning of zone
     * is context dependent, e.g. `Availability Zone (AZ)
     * <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
     * on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
     * GCP, etc.
     *
     * @generated from protobuf field: string zone = 2;
     */
    zone: string;
    /**
     * When used for locality of upstream hosts, this field further splits zone
     * into smaller chunks of sub-zones so they can be load balanced
     * independently.
     *
     * @generated from protobuf field: string sub_zone = 3;
     */
    subZone: string;
}
/**
 * BuildVersion combines SemVer version of extension with free-form build information
 * (i.e. 'alpha', 'private-build') as a set of strings.
 *
 * @generated from protobuf message envoy.api.v2.core.BuildVersion
 */
export interface BuildVersion {
    /**
     * SemVer version of extension.
     *
     * @generated from protobuf field: envoy.type.SemanticVersion version = 1;
     */
    version?: SemanticVersion;
    /**
     * Free-form build information.
     * Envoy defines several well known keys in the source/common/version/version.h file
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 2;
     */
    metadata?: Struct;
}
/**
 * Version and identification for an Envoy extension.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.api.v2.core.Extension
 */
export interface Extension {
    /**
     * This is the name of the Envoy filter as specified in the Envoy
     * configuration, e.g. envoy.filters.http.router, com.acme.widget.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Category of the extension.
     * Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
     * for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
     * acme.com vendor.
     * [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
     *
     * @generated from protobuf field: string category = 2;
     */
    category: string;
    /**
     * [#not-implemented-hide:] Type descriptor of extension configuration proto.
     * [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
     * [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
     *
     * @generated from protobuf field: string type_descriptor = 3;
     */
    typeDescriptor: string;
    /**
     * The version is a property of the extension and maintained independently
     * of other extensions and the Envoy API.
     * This field is not set when extension did not provide version information.
     *
     * @generated from protobuf field: envoy.api.v2.core.BuildVersion version = 4;
     */
    version?: BuildVersion;
    /**
     * Indicates that the extension is present but was disabled via dynamic configuration.
     *
     * @generated from protobuf field: bool disabled = 5;
     */
    disabled: boolean;
}
/**
 * Identifies a specific Envoy instance. The node identifier is presented to the
 * management server, which may use this identifier to distinguish per Envoy
 * configuration for serving.
 * [#next-free-field: 12]
 *
 * @generated from protobuf message envoy.api.v2.core.Node
 */
export interface Node {
    /**
     * An opaque node identifier for the Envoy node. This also provides the local
     * service node name. It should be set if any of the following features are
     * used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
     * <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-node`.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * Defines the local service cluster name where Envoy is running. Though
     * optional, it should be set if any of the following features are used:
     * :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
     * verification
     * <envoy_api_field_core.HealthCheck.HttpHealthCheck.service_name_matcher>`,
     * :ref:`runtime override directory <envoy_api_msg_config.bootstrap.v2.Runtime>`,
     * :ref:`user agent addition
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.add_user_agent>`,
     * :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
     * :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
     * <arch_overview_tracing>`, either in this message or via
     * :option:`--service-cluster`.
     *
     * @generated from protobuf field: string cluster = 2;
     */
    cluster: string;
    /**
     * Opaque metadata extending the node identifier. Envoy will pass this
     * directly to the management server.
     *
     * @generated from protobuf field: google.protobuf.Struct metadata = 3;
     */
    metadata?: Struct;
    /**
     * Locality specifying where the Envoy instance is running.
     *
     * @generated from protobuf field: envoy.api.v2.core.Locality locality = 4;
     */
    locality?: Locality;
    /**
     * This is motivated by informing a management server during canary which
     * version of Envoy is being tested in a heterogeneous fleet. This will be set
     * by Envoy in management server RPCs.
     * This field is deprecated in favor of the user_agent_name and user_agent_version values.
     *
     * @deprecated
     * @generated from protobuf field: string build_version = 5 [deprecated = true];
     */
    buildVersion: string;
    /**
     * Free-form string that identifies the entity requesting config.
     * E.g. "envoy" or "grpc"
     *
     * @generated from protobuf field: string user_agent_name = 6;
     */
    userAgentName: string;
    /**
     * @generated from protobuf oneof: user_agent_version_type
     */
    userAgentVersionType: {
        oneofKind: "userAgentVersion";
        /**
         * Free-form string that identifies the version of the entity requesting config.
         * E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
         *
         * @generated from protobuf field: string user_agent_version = 7;
         */
        userAgentVersion: string;
    } | {
        oneofKind: "userAgentBuildVersion";
        /**
         * Structured version of the entity requesting config.
         *
         * @generated from protobuf field: envoy.api.v2.core.BuildVersion user_agent_build_version = 8;
         */
        userAgentBuildVersion: BuildVersion;
    } | {
        oneofKind: undefined;
    };
    /**
     * List of extensions and their versions supported by the node.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.Extension extensions = 9;
     */
    extensions: Extension[];
    /**
     * Client feature support list. These are well known features described
     * in the Envoy API repository for a given major version of an API. Client features
     * use reverse DNS naming scheme, for example `com.acme.feature`.
     * See :ref:`the list of features <client_features>` that xDS client may
     * support.
     *
     * @generated from protobuf field: repeated string client_features = 10;
     */
    clientFeatures: string[];
    /**
     * Known listening ports on the node as a generic hint to the management server
     * for filtering :ref:`listeners <config_listeners>` to be returned. For example,
     * if there is a listener bound to port 80, the list can optionally contain the
     * SocketAddress `(0.0.0.0,80)`. The field is optional and just a hint.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.Address listening_addresses = 11;
     */
    listeningAddresses: Address[];
}
/**
 * Metadata provides additional inputs to filters based on matched listeners,
 * filter chains, routes and endpoints. It is structured as a map, usually from
 * filter name (in reverse DNS format) to metadata specific to the filter. Metadata
 * key-values for a filter are merged as connection and request handling occurs,
 * with later values for the same key overriding earlier values.
 *
 * An example use of metadata is providing additional values to
 * http_connection_manager in the envoy.http_connection_manager.access_log
 * namespace.
 *
 * Another example use of metadata is to per service config info in cluster metadata, which may get
 * consumed by multiple filters.
 *
 * For load balancing, Metadata provides a means to subset cluster endpoints.
 * Endpoints have a Metadata object associated and routes contain a Metadata
 * object to match against. There are some well defined metadata used today for
 * this purpose:
 *
 * * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
 *   endpoint and is also used during header processing
 *   (x-envoy-upstream-canary) and for stats purposes.
 * [#next-major-version: move to type/metadata/v2]
 *
 * @generated from protobuf message envoy.api.v2.core.Metadata
 */
export interface Metadata {
    /**
     * Key is the reverse DNS filter name, e.g. com.acme.widget. The envoy.*
     * namespace is reserved for Envoy's built-in filters.
     *
     * @generated from protobuf field: map<string, google.protobuf.Struct> filter_metadata = 1;
     */
    filterMetadata: {
        [key: string]: Struct;
    };
}
/**
 * Runtime derived uint32 with a default when not specified.
 *
 * @generated from protobuf message envoy.api.v2.core.RuntimeUInt32
 */
export interface RuntimeUInt32 {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: uint32 default_value = 2;
     */
    defaultValue: number;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from protobuf field: string runtime_key = 3;
     */
    runtimeKey: string;
}
/**
 * Runtime derived double with a default when not specified.
 *
 * @generated from protobuf message envoy.api.v2.core.RuntimeDouble
 */
export interface RuntimeDouble {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: double default_value = 1;
     */
    defaultValue: number;
    /**
     * Runtime key to get value for comparison. This value is used if defined.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Runtime derived bool with a default when not specified.
 *
 * @generated from protobuf message envoy.api.v2.core.RuntimeFeatureFlag
 */
export interface RuntimeFeatureFlag {
    /**
     * Default value if runtime value is not available.
     *
     * @generated from protobuf field: google.protobuf.BoolValue default_value = 1;
     */
    defaultValue?: BoolValue;
    /**
     * Runtime key to get value for comparison. This value is used if defined. The boolean value must
     * be represented via its
     * `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Header name/value pair.
 *
 * @generated from protobuf message envoy.api.v2.core.HeaderValue
 */
export interface HeaderValue {
    /**
     * Header name.
     *
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * Header value.
     *
     * The same :ref:`format specifier <config_access_log_format>` as used for
     * :ref:`HTTP access logging <config_access_log>` applies here, however
     * unknown header values are replaced with the empty string instead of `-`.
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * Header name/value pair plus option to control append behavior.
 *
 * @generated from protobuf message envoy.api.v2.core.HeaderValueOption
 */
export interface HeaderValueOption {
    /**
     * Header name/value pair that this option applies to.
     *
     * @generated from protobuf field: envoy.api.v2.core.HeaderValue header = 1;
     */
    header?: HeaderValue;
    /**
     * Should the value be appended? If true (default), the value is appended to
     * existing values.
     *
     * @generated from protobuf field: google.protobuf.BoolValue append = 2;
     */
    append?: BoolValue;
}
/**
 * Wrapper for a set of headers.
 *
 * @generated from protobuf message envoy.api.v2.core.HeaderMap
 */
export interface HeaderMap {
    /**
     * @generated from protobuf field: repeated envoy.api.v2.core.HeaderValue headers = 1;
     */
    headers: HeaderValue[];
}
/**
 * Data source consisting of either a file or an inline value.
 *
 * @generated from protobuf message envoy.api.v2.core.DataSource
 */
export interface DataSource {
    /**
     * @generated from protobuf oneof: specifier
     */
    specifier: {
        oneofKind: "filename";
        /**
         * Local filesystem data source.
         *
         * @generated from protobuf field: string filename = 1;
         */
        filename: string;
    } | {
        oneofKind: "inlineBytes";
        /**
         * Bytes inlined in the configuration.
         *
         * @generated from protobuf field: bytes inline_bytes = 2;
         */
        inlineBytes: Uint8Array;
    } | {
        oneofKind: "inlineString";
        /**
         * String inlined in the configuration.
         *
         * @generated from protobuf field: string inline_string = 3;
         */
        inlineString: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The message specifies the retry policy of remote data source when fetching fails.
 *
 * @generated from protobuf message envoy.api.v2.core.RetryPolicy
 */
export interface RetryPolicy {
    /**
     * Specifies parameters that control :ref:`retry backoff strategy <envoy_api_msg_core.BackoffStrategy>`.
     * This parameter is optional, in which case the default base interval is 1000 milliseconds. The
     * default maximum interval is 10 times the base interval.
     *
     * @generated from protobuf field: envoy.api.v2.core.BackoffStrategy retry_back_off = 1;
     */
    retryBackOff?: BackoffStrategy;
    /**
     * Specifies the allowed number of retries. This parameter is optional and
     * defaults to 1.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value num_retries = 2;
     */
    numRetries?: UInt32Value;
}
/**
 * The message specifies how to fetch data from remote and how to verify it.
 *
 * @generated from protobuf message envoy.api.v2.core.RemoteDataSource
 */
export interface RemoteDataSource {
    /**
     * The HTTP URI to fetch the remote data.
     *
     * @generated from protobuf field: envoy.api.v2.core.HttpUri http_uri = 1;
     */
    httpUri?: HttpUri;
    /**
     * SHA256 string for verifying data.
     *
     * @generated from protobuf field: string sha256 = 2;
     */
    sha256: string;
    /**
     * Retry policy for fetching remote data.
     *
     * @generated from protobuf field: envoy.api.v2.core.RetryPolicy retry_policy = 3;
     */
    retryPolicy?: RetryPolicy;
}
/**
 * Async data source which support async data fetch.
 *
 * @generated from protobuf message envoy.api.v2.core.AsyncDataSource
 */
export interface AsyncDataSource {
    /**
     * @generated from protobuf oneof: specifier
     */
    specifier: {
        oneofKind: "local";
        /**
         * Local async data source.
         *
         * @generated from protobuf field: envoy.api.v2.core.DataSource local = 1;
         */
        local: DataSource;
    } | {
        oneofKind: "remote";
        /**
         * Remote async data source.
         *
         * @generated from protobuf field: envoy.api.v2.core.RemoteDataSource remote = 2;
         */
        remote: RemoteDataSource;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Configuration for transport socket in :ref:`listeners <config_listeners>` and
 * :ref:`clusters <envoy_api_msg_Cluster>`. If the configuration is
 * empty, a default transport socket implementation and configuration will be
 * chosen based on the platform and existence of tls_context.
 *
 * @generated from protobuf message envoy.api.v2.core.TransportSocket
 */
export interface TransportSocket {
    /**
     * The name of the transport socket to instantiate. The name must match a supported transport
     * socket implementation.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
 * specified via a runtime key.
 *
 * .. note::
 *
 *   Parsing of the runtime key's data is implemented such that it may be represented as a
 *   :ref:`FractionalPercent <envoy_api_msg_type.FractionalPercent>` proto represented as JSON/YAML
 *   and may also be represented as an integer with the assumption that the value is an integral
 *   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
 *   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.
 *
 * @generated from protobuf message envoy.api.v2.core.RuntimeFractionalPercent
 */
export interface RuntimeFractionalPercent {
    /**
     * Default value if the runtime value's for the numerator/denominator keys are not available.
     *
     * @generated from protobuf field: envoy.type.FractionalPercent default_value = 1;
     */
    defaultValue?: FractionalPercent;
    /**
     * Runtime key for a YAML representation of a FractionalPercent.
     *
     * @generated from protobuf field: string runtime_key = 2;
     */
    runtimeKey: string;
}
/**
 * Identifies a specific ControlPlane instance that Envoy is connected to.
 *
 * @generated from protobuf message envoy.api.v2.core.ControlPlane
 */
export interface ControlPlane {
    /**
     * An opaque control plane identifier that uniquely identifies an instance
     * of control plane. This can be used to identify which control plane instance,
     * the Envoy is connected to.
     *
     * @generated from protobuf field: string identifier = 1;
     */
    identifier: string;
}
// [#protodoc-title: Common types]

/**
 * Envoy supports :ref:`upstream priority routing
 * <arch_overview_http_routing_priority>` both at the route and the virtual
 * cluster level. The current priority implementation uses different connection
 * pool and circuit breaking settings for each priority level. This means that
 * even for HTTP/2 requests, two physical connections will be used to an
 * upstream host. In the future Envoy will likely support true HTTP/2 priority
 * over a single upstream connection.
 *
 * @generated from protobuf enum envoy.api.v2.core.RoutingPriority
 */
export enum RoutingPriority {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * @generated from protobuf enum value: HIGH = 1;
     */
    HIGH = 1
}
/**
 * HTTP request method.
 *
 * @generated from protobuf enum envoy.api.v2.core.RequestMethod
 */
export enum RequestMethod {
    /**
     * @generated from protobuf enum value: METHOD_UNSPECIFIED = 0;
     */
    METHOD_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: GET = 1;
     */
    GET = 1,
    /**
     * @generated from protobuf enum value: HEAD = 2;
     */
    HEAD = 2,
    /**
     * @generated from protobuf enum value: POST = 3;
     */
    POST = 3,
    /**
     * @generated from protobuf enum value: PUT = 4;
     */
    PUT = 4,
    /**
     * @generated from protobuf enum value: DELETE = 5;
     */
    DELETE = 5,
    /**
     * @generated from protobuf enum value: CONNECT = 6;
     */
    CONNECT = 6,
    /**
     * @generated from protobuf enum value: OPTIONS = 7;
     */
    OPTIONS = 7,
    /**
     * @generated from protobuf enum value: TRACE = 8;
     */
    TRACE = 8,
    /**
     * @generated from protobuf enum value: PATCH = 9;
     */
    PATCH = 9
}
/**
 * Identifies the direction of the traffic relative to the local Envoy.
 *
 * @generated from protobuf enum envoy.api.v2.core.TrafficDirection
 */
export enum TrafficDirection {
    /**
     * Default option is unspecified.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * The transport is used for incoming traffic.
     *
     * @generated from protobuf enum value: INBOUND = 1;
     */
    INBOUND = 1,
    /**
     * The transport is used for outgoing traffic.
     *
     * @generated from protobuf enum value: OUTBOUND = 2;
     */
    OUTBOUND = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Locality$Type extends MessageType<Locality> {
    constructor() {
        super("envoy.api.v2.core.Locality", [
            { no: 1, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sub_zone", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Locality>): Locality {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.region = "";
        message.zone = "";
        message.subZone = "";
        if (value !== undefined)
            reflectionMergePartial<Locality>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Locality): Locality {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string region */ 1:
                    message.region = reader.string();
                    break;
                case /* string zone */ 2:
                    message.zone = reader.string();
                    break;
                case /* string sub_zone */ 3:
                    message.subZone = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Locality, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string region = 1; */
        if (message.region !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.region);
        /* string zone = 2; */
        if (message.zone !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.zone);
        /* string sub_zone = 3; */
        if (message.subZone !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.subZone);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Locality
 */
export const Locality = new Locality$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildVersion$Type extends MessageType<BuildVersion> {
    constructor() {
        super("envoy.api.v2.core.BuildVersion", [
            { no: 1, name: "version", kind: "message", T: () => SemanticVersion },
            { no: 2, name: "metadata", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<BuildVersion>): BuildVersion {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BuildVersion>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildVersion): BuildVersion {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.SemanticVersion version */ 1:
                    message.version = SemanticVersion.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* google.protobuf.Struct metadata */ 2:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildVersion, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.SemanticVersion version = 1; */
        if (message.version)
            SemanticVersion.internalBinaryWrite(message.version, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct metadata = 2; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.BuildVersion
 */
export const BuildVersion = new BuildVersion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Extension$Type extends MessageType<Extension> {
    constructor() {
        super("envoy.api.v2.core.Extension", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type_descriptor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version", kind: "message", T: () => BuildVersion },
            { no: 5, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Extension>): Extension {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.category = "";
        message.typeDescriptor = "";
        message.disabled = false;
        if (value !== undefined)
            reflectionMergePartial<Extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Extension): Extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string category */ 2:
                    message.category = reader.string();
                    break;
                case /* string type_descriptor */ 3:
                    message.typeDescriptor = reader.string();
                    break;
                case /* envoy.api.v2.core.BuildVersion version */ 4:
                    message.version = BuildVersion.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                case /* bool disabled */ 5:
                    message.disabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string category = 2; */
        if (message.category !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.category);
        /* string type_descriptor = 3; */
        if (message.typeDescriptor !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.typeDescriptor);
        /* envoy.api.v2.core.BuildVersion version = 4; */
        if (message.version)
            BuildVersion.internalBinaryWrite(message.version, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool disabled = 5; */
        if (message.disabled !== false)
            writer.tag(5, WireType.Varint).bool(message.disabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Extension
 */
export const Extension = new Extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends MessageType<Node> {
    constructor() {
        super("envoy.api.v2.core.Node", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "metadata", kind: "message", T: () => Struct },
            { no: 4, name: "locality", kind: "message", T: () => Locality },
            { no: 5, name: "build_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "user_agent_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "user_agent_version", kind: "scalar", oneof: "userAgentVersionType", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "user_agent_build_version", kind: "message", oneof: "userAgentVersionType", T: () => BuildVersion },
            { no: 9, name: "extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Extension },
            { no: 10, name: "client_features", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "listening_addresses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Address }
        ]);
    }
    create(value?: PartialMessage<Node>): Node {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.cluster = "";
        message.buildVersion = "";
        message.userAgentName = "";
        message.userAgentVersionType = { oneofKind: undefined };
        message.extensions = [];
        message.clientFeatures = [];
        message.listeningAddresses = [];
        if (value !== undefined)
            reflectionMergePartial<Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string cluster */ 2:
                    message.cluster = reader.string();
                    break;
                case /* google.protobuf.Struct metadata */ 3:
                    message.metadata = Struct.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* envoy.api.v2.core.Locality locality */ 4:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                case /* string build_version = 5 [deprecated = true];*/ 5:
                    message.buildVersion = reader.string();
                    break;
                case /* string user_agent_name */ 6:
                    message.userAgentName = reader.string();
                    break;
                case /* string user_agent_version */ 7:
                    message.userAgentVersionType = {
                        oneofKind: "userAgentVersion",
                        userAgentVersion: reader.string()
                    };
                    break;
                case /* envoy.api.v2.core.BuildVersion user_agent_build_version */ 8:
                    message.userAgentVersionType = {
                        oneofKind: "userAgentBuildVersion",
                        userAgentBuildVersion: BuildVersion.internalBinaryRead(reader, reader.uint32(), options, (message.userAgentVersionType as any).userAgentBuildVersion)
                    };
                    break;
                case /* repeated envoy.api.v2.core.Extension extensions */ 9:
                    message.extensions.push(Extension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string client_features */ 10:
                    message.clientFeatures.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.core.Address listening_addresses */ 11:
                    message.listeningAddresses.push(Address.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string cluster = 2; */
        if (message.cluster !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cluster);
        /* google.protobuf.Struct metadata = 3; */
        if (message.metadata)
            Struct.internalBinaryWrite(message.metadata, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.Locality locality = 4; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string build_version = 5 [deprecated = true]; */
        if (message.buildVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.buildVersion);
        /* string user_agent_name = 6; */
        if (message.userAgentName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userAgentName);
        /* string user_agent_version = 7; */
        if (message.userAgentVersionType.oneofKind === "userAgentVersion")
            writer.tag(7, WireType.LengthDelimited).string(message.userAgentVersionType.userAgentVersion);
        /* envoy.api.v2.core.BuildVersion user_agent_build_version = 8; */
        if (message.userAgentVersionType.oneofKind === "userAgentBuildVersion")
            BuildVersion.internalBinaryWrite(message.userAgentVersionType.userAgentBuildVersion, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.Extension extensions = 9; */
        for (let i = 0; i < message.extensions.length; i++)
            Extension.internalBinaryWrite(message.extensions[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated string client_features = 10; */
        for (let i = 0; i < message.clientFeatures.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.clientFeatures[i]);
        /* repeated envoy.api.v2.core.Address listening_addresses = 11; */
        for (let i = 0; i < message.listeningAddresses.length; i++)
            Address.internalBinaryWrite(message.listeningAddresses[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Node
 */
export const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("envoy.api.v2.core.Metadata", [
            { no: 1, name: "filter_metadata", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Struct } }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filterMetadata = {};
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, google.protobuf.Struct> filter_metadata */ 1:
                    this.binaryReadMap1(message.filterMetadata, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Metadata["filterMetadata"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Metadata["filterMetadata"] | undefined, val: Metadata["filterMetadata"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Struct.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field envoy.api.v2.core.Metadata.filter_metadata");
            }
        }
        map[key ?? ""] = val ?? Struct.create();
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, google.protobuf.Struct> filter_metadata = 1; */
        for (let k of globalThis.Object.keys(message.filterMetadata)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Struct.internalBinaryWrite(message.filterMetadata[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeUInt32$Type extends MessageType<RuntimeUInt32> {
    constructor() {
        super("envoy.api.v2.core.RuntimeUInt32", [
            { no: 2, name: "default_value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RuntimeUInt32>): RuntimeUInt32 {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultValue = 0;
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeUInt32>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeUInt32): RuntimeUInt32 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 default_value */ 2:
                    message.defaultValue = reader.uint32();
                    break;
                case /* string runtime_key */ 3:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeUInt32, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 default_value = 2; */
        if (message.defaultValue !== 0)
            writer.tag(2, WireType.Varint).uint32(message.defaultValue);
        /* string runtime_key = 3; */
        if (message.runtimeKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RuntimeUInt32
 */
export const RuntimeUInt32 = new RuntimeUInt32$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeDouble$Type extends MessageType<RuntimeDouble> {
    constructor() {
        super("envoy.api.v2.core.RuntimeDouble", [
            { no: 1, name: "default_value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RuntimeDouble>): RuntimeDouble {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.defaultValue = 0;
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeDouble>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeDouble): RuntimeDouble {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double default_value */ 1:
                    message.defaultValue = reader.double();
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeDouble, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double default_value = 1; */
        if (message.defaultValue !== 0)
            writer.tag(1, WireType.Bit64).double(message.defaultValue);
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RuntimeDouble
 */
export const RuntimeDouble = new RuntimeDouble$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeFeatureFlag$Type extends MessageType<RuntimeFeatureFlag> {
    constructor() {
        super("envoy.api.v2.core.RuntimeFeatureFlag", [
            { no: 1, name: "default_value", kind: "message", T: () => BoolValue, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<RuntimeFeatureFlag>): RuntimeFeatureFlag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeFeatureFlag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeFeatureFlag): RuntimeFeatureFlag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue default_value */ 1:
                    message.defaultValue = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.defaultValue);
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeFeatureFlag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue default_value = 1; */
        if (message.defaultValue)
            BoolValue.internalBinaryWrite(message.defaultValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RuntimeFeatureFlag
 */
export const RuntimeFeatureFlag = new RuntimeFeatureFlag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderValue$Type extends MessageType<HeaderValue> {
    constructor() {
        super("envoy.api.v2.core.HeaderValue", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1", maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "16384", wellKnownRegex: "HTTP_HEADER_VALUE", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<HeaderValue>): HeaderValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<HeaderValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderValue): HeaderValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HeaderValue
 */
export const HeaderValue = new HeaderValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderValueOption$Type extends MessageType<HeaderValueOption> {
    constructor() {
        super("envoy.api.v2.core.HeaderValueOption", [
            { no: 1, name: "header", kind: "message", T: () => HeaderValue, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "append", kind: "message", T: () => BoolValue }
        ]);
    }
    create(value?: PartialMessage<HeaderValueOption>): HeaderValueOption {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<HeaderValueOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderValueOption): HeaderValueOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.HeaderValue header */ 1:
                    message.header = HeaderValue.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* google.protobuf.BoolValue append */ 2:
                    message.append = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.append);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderValueOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.HeaderValue header = 1; */
        if (message.header)
            HeaderValue.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue append = 2; */
        if (message.append)
            BoolValue.internalBinaryWrite(message.append, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HeaderValueOption
 */
export const HeaderValueOption = new HeaderValueOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeaderMap$Type extends MessageType<HeaderMap> {
    constructor() {
        super("envoy.api.v2.core.HeaderMap", [
            { no: 1, name: "headers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HeaderValue }
        ]);
    }
    create(value?: PartialMessage<HeaderMap>): HeaderMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headers = [];
        if (value !== undefined)
            reflectionMergePartial<HeaderMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderMap): HeaderMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.core.HeaderValue headers */ 1:
                    message.headers.push(HeaderValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeaderMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.core.HeaderValue headers = 1; */
        for (let i = 0; i < message.headers.length; i++)
            HeaderValue.internalBinaryWrite(message.headers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HeaderMap
 */
export const HeaderMap = new HeaderMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataSource$Type extends MessageType<DataSource> {
    constructor() {
        super("envoy.api.v2.core.DataSource", [
            { no: 1, name: "filename", kind: "scalar", oneof: "specifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "inline_bytes", kind: "scalar", oneof: "specifier", T: 12 /*ScalarType.BYTES*/, options: { "validate.rules": { bytes: { minLen: "1" } } } },
            { no: 3, name: "inline_string", kind: "scalar", oneof: "specifier", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<DataSource>): DataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.specifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataSource): DataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string filename */ 1:
                    message.specifier = {
                        oneofKind: "filename",
                        filename: reader.string()
                    };
                    break;
                case /* bytes inline_bytes */ 2:
                    message.specifier = {
                        oneofKind: "inlineBytes",
                        inlineBytes: reader.bytes()
                    };
                    break;
                case /* string inline_string */ 3:
                    message.specifier = {
                        oneofKind: "inlineString",
                        inlineString: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string filename = 1; */
        if (message.specifier.oneofKind === "filename")
            writer.tag(1, WireType.LengthDelimited).string(message.specifier.filename);
        /* bytes inline_bytes = 2; */
        if (message.specifier.oneofKind === "inlineBytes")
            writer.tag(2, WireType.LengthDelimited).bytes(message.specifier.inlineBytes);
        /* string inline_string = 3; */
        if (message.specifier.oneofKind === "inlineString")
            writer.tag(3, WireType.LengthDelimited).string(message.specifier.inlineString);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.DataSource
 */
export const DataSource = new DataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetryPolicy$Type extends MessageType<RetryPolicy> {
    constructor() {
        super("envoy.api.v2.core.RetryPolicy", [
            { no: 1, name: "retry_back_off", kind: "message", T: () => BackoffStrategy },
            { no: 2, name: "num_retries", kind: "message", T: () => UInt32Value }
        ]);
    }
    create(value?: PartialMessage<RetryPolicy>): RetryPolicy {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetryPolicy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetryPolicy): RetryPolicy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.BackoffStrategy retry_back_off */ 1:
                    message.retryBackOff = BackoffStrategy.internalBinaryRead(reader, reader.uint32(), options, message.retryBackOff);
                    break;
                case /* google.protobuf.UInt32Value num_retries */ 2:
                    message.numRetries = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.numRetries);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetryPolicy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.BackoffStrategy retry_back_off = 1; */
        if (message.retryBackOff)
            BackoffStrategy.internalBinaryWrite(message.retryBackOff, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value num_retries = 2; */
        if (message.numRetries)
            UInt32Value.internalBinaryWrite(message.numRetries, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RetryPolicy
 */
export const RetryPolicy = new RetryPolicy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoteDataSource$Type extends MessageType<RemoteDataSource> {
    constructor() {
        super("envoy.api.v2.core.RemoteDataSource", [
            { no: 1, name: "http_uri", kind: "message", T: () => HttpUri, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "sha256", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 3, name: "retry_policy", kind: "message", T: () => RetryPolicy }
        ]);
    }
    create(value?: PartialMessage<RemoteDataSource>): RemoteDataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sha256 = "";
        if (value !== undefined)
            reflectionMergePartial<RemoteDataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoteDataSource): RemoteDataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.HttpUri http_uri */ 1:
                    message.httpUri = HttpUri.internalBinaryRead(reader, reader.uint32(), options, message.httpUri);
                    break;
                case /* string sha256 */ 2:
                    message.sha256 = reader.string();
                    break;
                case /* envoy.api.v2.core.RetryPolicy retry_policy */ 3:
                    message.retryPolicy = RetryPolicy.internalBinaryRead(reader, reader.uint32(), options, message.retryPolicy);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoteDataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.HttpUri http_uri = 1; */
        if (message.httpUri)
            HttpUri.internalBinaryWrite(message.httpUri, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string sha256 = 2; */
        if (message.sha256 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sha256);
        /* envoy.api.v2.core.RetryPolicy retry_policy = 3; */
        if (message.retryPolicy)
            RetryPolicy.internalBinaryWrite(message.retryPolicy, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RemoteDataSource
 */
export const RemoteDataSource = new RemoteDataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AsyncDataSource$Type extends MessageType<AsyncDataSource> {
    constructor() {
        super("envoy.api.v2.core.AsyncDataSource", [
            { no: 1, name: "local", kind: "message", oneof: "specifier", T: () => DataSource },
            { no: 2, name: "remote", kind: "message", oneof: "specifier", T: () => RemoteDataSource }
        ]);
    }
    create(value?: PartialMessage<AsyncDataSource>): AsyncDataSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.specifier = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<AsyncDataSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AsyncDataSource): AsyncDataSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.DataSource local */ 1:
                    message.specifier = {
                        oneofKind: "local",
                        local: DataSource.internalBinaryRead(reader, reader.uint32(), options, (message.specifier as any).local)
                    };
                    break;
                case /* envoy.api.v2.core.RemoteDataSource remote */ 2:
                    message.specifier = {
                        oneofKind: "remote",
                        remote: RemoteDataSource.internalBinaryRead(reader, reader.uint32(), options, (message.specifier as any).remote)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AsyncDataSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.DataSource local = 1; */
        if (message.specifier.oneofKind === "local")
            DataSource.internalBinaryWrite(message.specifier.local, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RemoteDataSource remote = 2; */
        if (message.specifier.oneofKind === "remote")
            RemoteDataSource.internalBinaryWrite(message.specifier.remote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.AsyncDataSource
 */
export const AsyncDataSource = new AsyncDataSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransportSocket$Type extends MessageType<TransportSocket> {
    constructor() {
        super("envoy.api.v2.core.TransportSocket", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<TransportSocket>): TransportSocket {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TransportSocket>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransportSocket): TransportSocket {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransportSocket, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.TransportSocket
 */
export const TransportSocket = new TransportSocket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuntimeFractionalPercent$Type extends MessageType<RuntimeFractionalPercent> {
    constructor() {
        super("envoy.api.v2.core.RuntimeFractionalPercent", [
            { no: 1, name: "default_value", kind: "message", T: () => FractionalPercent, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "runtime_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RuntimeFractionalPercent>): RuntimeFractionalPercent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.runtimeKey = "";
        if (value !== undefined)
            reflectionMergePartial<RuntimeFractionalPercent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuntimeFractionalPercent): RuntimeFractionalPercent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.type.FractionalPercent default_value */ 1:
                    message.defaultValue = FractionalPercent.internalBinaryRead(reader, reader.uint32(), options, message.defaultValue);
                    break;
                case /* string runtime_key */ 2:
                    message.runtimeKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RuntimeFractionalPercent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.type.FractionalPercent default_value = 1; */
        if (message.defaultValue)
            FractionalPercent.internalBinaryWrite(message.defaultValue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string runtime_key = 2; */
        if (message.runtimeKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.runtimeKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RuntimeFractionalPercent
 */
export const RuntimeFractionalPercent = new RuntimeFractionalPercent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControlPlane$Type extends MessageType<ControlPlane> {
    constructor() {
        super("envoy.api.v2.core.ControlPlane", [
            { no: 1, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ControlPlane>): ControlPlane {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.identifier = "";
        if (value !== undefined)
            reflectionMergePartial<ControlPlane>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControlPlane): ControlPlane {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string identifier */ 1:
                    message.identifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControlPlane, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string identifier = 1; */
        if (message.identifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.ControlPlane
 */
export const ControlPlane = new ControlPlane$Type();
