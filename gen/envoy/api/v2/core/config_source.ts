// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/core/config_source.proto" (package "envoy.api.v2.core", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DoubleValue } from "../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Duration } from "../../../../google/protobuf/duration";
import { GrpcService } from "./grpc_service";
/**
 * API configuration source. This identifies the API type and cluster that Envoy
 * will use to fetch an xDS API.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.api.v2.core.ApiConfigSource
 */
export interface ApiConfigSource {
    /**
     * API type (gRPC, REST, delta gRPC)
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiConfigSource.ApiType api_type = 1;
     */
    apiType: ApiConfigSource_ApiType;
    /**
     * API version for xDS transport protocol. This describes the xDS gRPC/REST
     * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiVersion transport_api_version = 8;
     */
    transportApiVersion: ApiVersion;
    /**
     * Cluster names should be used only with REST. If > 1
     * cluster is defined, clusters will be cycled through if any kind of failure
     * occurs.
     *
     * .. note::
     *
     *  The cluster with name ``cluster_name`` must be statically defined and its
     *  type must not be ``EDS``.
     *
     * @generated from protobuf field: repeated string cluster_names = 2;
     */
    clusterNames: string[];
    /**
     * Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
     * services will be cycled through if any kind of failure occurs.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.GrpcService grpc_services = 4;
     */
    grpcServices: GrpcService[];
    /**
     * For REST APIs, the delay between successive polls.
     *
     * @generated from protobuf field: google.protobuf.Duration refresh_delay = 3;
     */
    refreshDelay?: Duration;
    /**
     * For REST APIs, the request timeout. If not set, a default value of 1s will be used.
     *
     * @generated from protobuf field: google.protobuf.Duration request_timeout = 5;
     */
    requestTimeout?: Duration;
    /**
     * For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
     * rate limited.
     *
     * @generated from protobuf field: envoy.api.v2.core.RateLimitSettings rate_limit_settings = 6;
     */
    rateLimitSettings?: RateLimitSettings;
    /**
     * Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
     *
     * @generated from protobuf field: bool set_node_on_first_message_only = 7;
     */
    setNodeOnFirstMessageOnly: boolean;
}
/**
 * APIs may be fetched via either REST or gRPC.
 *
 * @generated from protobuf enum envoy.api.v2.core.ApiConfigSource.ApiType
 */
export enum ApiConfigSource_ApiType {
    /**
     * Ideally this would be 'reserved 0' but one can't reserve the default
     * value. Instead we throw an exception if this is ever used.
     *
     * @deprecated
     * @generated from protobuf enum value: UNSUPPORTED_REST_LEGACY = 0 [deprecated = true];
     */
    UNSUPPORTED_REST_LEGACY = 0,
    /**
     * REST-JSON v2 API. The `canonical JSON encoding
     * <https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
     * the v2 protos is used.
     *
     * @generated from protobuf enum value: REST = 1;
     */
    REST = 1,
    /**
     * gRPC v2 API.
     *
     * @generated from protobuf enum value: GRPC = 2;
     */
    GRPC = 2,
    /**
     * Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
     * rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
     * with every update, the xDS server only sends what has changed since the last update.
     *
     * @generated from protobuf enum value: DELTA_GRPC = 3;
     */
    DELTA_GRPC = 3
}
/**
 * Aggregated Discovery Service (ADS) options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_api_msg_core.ConfigSource>` can be used to
 * specify that ADS is to be used.
 *
 * @generated from protobuf message envoy.api.v2.core.AggregatedConfigSource
 */
export interface AggregatedConfigSource {
}
/**
 * [#not-implemented-hide:]
 * Self-referencing config source options. This is currently empty, but when
 * set in :ref:`ConfigSource <envoy_api_msg_core.ConfigSource>` can be used to
 * specify that other data can be obtained from the same server.
 *
 * @generated from protobuf message envoy.api.v2.core.SelfConfigSource
 */
export interface SelfConfigSource {
    /**
     * API version for xDS transport protocol. This describes the xDS gRPC/REST
     * endpoint and version of [Delta]DiscoveryRequest/Response used on the wire.
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiVersion transport_api_version = 1;
     */
    transportApiVersion: ApiVersion;
}
/**
 * Rate Limit settings to be applied for discovery requests made by Envoy.
 *
 * @generated from protobuf message envoy.api.v2.core.RateLimitSettings
 */
export interface RateLimitSettings {
    /**
     * Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
     * default value of 100 will be used.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_tokens = 1;
     */
    maxTokens?: UInt32Value;
    /**
     * Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
     * per second will be used.
     *
     * @generated from protobuf field: google.protobuf.DoubleValue fill_rate = 2;
     */
    fillRate?: DoubleValue;
}
/**
 * Configuration for :ref:`listeners <config_listeners>`, :ref:`clusters
 * <config_cluster_manager>`, :ref:`routes
 * <envoy_api_msg_RouteConfiguration>`, :ref:`endpoints
 * <arch_overview_service_discovery>` etc. may either be sourced from the
 * filesystem or from an xDS API source. Filesystem configs are watched with
 * inotify for updates.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.core.ConfigSource
 */
export interface ConfigSource {
    /**
     * @generated from protobuf oneof: config_source_specifier
     */
    configSourceSpecifier: {
        oneofKind: "path";
        /**
         * Path on the filesystem to source and watch for configuration updates.
         * When sourcing configuration for :ref:`secret <envoy_api_msg_auth.Secret>`,
         * the certificate and key files are also watched for updates.
         *
         * .. note::
         *
         *  The path to the source must exist at config load time.
         *
         * .. note::
         *
         *   Envoy will only watch the file path for *moves.* This is because in general only moves
         *   are atomic. The same method of swapping files as is demonstrated in the
         *   :ref:`runtime documentation <config_runtime_symbolic_link_swap>` can be used here also.
         *
         * @generated from protobuf field: string path = 1;
         */
        path: string;
    } | {
        oneofKind: "apiConfigSource";
        /**
         * API configuration source.
         *
         * @generated from protobuf field: envoy.api.v2.core.ApiConfigSource api_config_source = 2;
         */
        apiConfigSource: ApiConfigSource;
    } | {
        oneofKind: "ads";
        /**
         * When set, ADS will be used to fetch resources. The ADS API configuration
         * source in the bootstrap configuration is used.
         *
         * @generated from protobuf field: envoy.api.v2.core.AggregatedConfigSource ads = 3;
         */
        ads: AggregatedConfigSource;
    } | {
        oneofKind: "self";
        /**
         * [#not-implemented-hide:]
         * When set, the client will access the resources from the same server it got the
         * ConfigSource from, although not necessarily from the same stream. This is similar to the
         * :ref:`ads<envoy_api_field.ConfigSource.ads>` field, except that the client may use a
         * different stream to the same server. As a result, this field can be used for things
         * like LRS that cannot be sent on an ADS stream. It can also be used to link from (e.g.)
         * LDS to RDS on the same server without requiring the management server to know its name
         * or required credentials.
         * [#next-major-version: In xDS v3, consider replacing the ads field with this one, since
         * this field can implicitly mean to use the same stream in the case where the ConfigSource
         * is provided via ADS and the specified data can also be obtained via ADS.]
         *
         * @generated from protobuf field: envoy.api.v2.core.SelfConfigSource self = 5;
         */
        self: SelfConfigSource;
    } | {
        oneofKind: undefined;
    };
    /**
     * When this timeout is specified, Envoy will wait no longer than the specified time for first
     * config response on this xDS subscription during the :ref:`initialization process
     * <arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
     * initialization phase, even if the first config is not delivered yet. The timer is activated
     * when the xDS API subscription starts, and is disarmed on first config update or on error. 0
     * means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
     * timeout applies). The default is 15s.
     *
     * @generated from protobuf field: google.protobuf.Duration initial_fetch_timeout = 4;
     */
    initialFetchTimeout?: Duration;
    /**
     * API version for xDS resources. This implies the type URLs that the client
     * will request for resources and the resource type that the client will in
     * turn expect to be delivered.
     *
     * @generated from protobuf field: envoy.api.v2.core.ApiVersion resource_api_version = 6;
     */
    resourceApiVersion: ApiVersion;
}
// [#protodoc-title: Configuration sources]

/**
 * xDS API version. This is used to describe both resource and transport
 * protocol versions (in distinct configuration fields).
 *
 * @generated from protobuf enum envoy.api.v2.core.ApiVersion
 */
export enum ApiVersion {
    /**
     * When not specified, we assume v2, to ease migration to Envoy's stable API
     * versioning. If a client does not support v2 (e.g. due to deprecation), this
     * is an invalid value.
     *
     * @deprecated
     * @generated from protobuf enum value: AUTO = 0 [deprecated = true];
     */
    AUTO = 0,
    /**
     * Use xDS v2 API.
     *
     * @deprecated
     * @generated from protobuf enum value: V2 = 1 [deprecated = true];
     */
    V2 = 1,
    /**
     * Use xDS v3 API.
     *
     * @generated from protobuf enum value: V3 = 2;
     */
    V3 = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ApiConfigSource$Type extends MessageType<ApiConfigSource> {
    constructor() {
        super("envoy.api.v2.core.ApiConfigSource", [
            { no: 1, name: "api_type", kind: "enum", T: () => ["envoy.api.v2.core.ApiConfigSource.ApiType", ApiConfigSource_ApiType], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 8, name: "transport_api_version", kind: "enum", T: () => ["envoy.api.v2.core.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "cluster_names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "grpc_services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GrpcService },
            { no: 3, name: "refresh_delay", kind: "message", T: () => Duration },
            { no: 5, name: "request_timeout", kind: "message", T: () => Duration, options: { "validate.rules": { duration: { gt: {} } } } },
            { no: 6, name: "rate_limit_settings", kind: "message", T: () => RateLimitSettings },
            { no: 7, name: "set_node_on_first_message_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ApiConfigSource>): ApiConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.apiType = 0;
        message.transportApiVersion = 0;
        message.clusterNames = [];
        message.grpcServices = [];
        message.setNodeOnFirstMessageOnly = false;
        if (value !== undefined)
            reflectionMergePartial<ApiConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApiConfigSource): ApiConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.ApiConfigSource.ApiType api_type */ 1:
                    message.apiType = reader.int32();
                    break;
                case /* envoy.api.v2.core.ApiVersion transport_api_version */ 8:
                    message.transportApiVersion = reader.int32();
                    break;
                case /* repeated string cluster_names */ 2:
                    message.clusterNames.push(reader.string());
                    break;
                case /* repeated envoy.api.v2.core.GrpcService grpc_services */ 4:
                    message.grpcServices.push(GrpcService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Duration refresh_delay */ 3:
                    message.refreshDelay = Duration.internalBinaryRead(reader, reader.uint32(), options, message.refreshDelay);
                    break;
                case /* google.protobuf.Duration request_timeout */ 5:
                    message.requestTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.requestTimeout);
                    break;
                case /* envoy.api.v2.core.RateLimitSettings rate_limit_settings */ 6:
                    message.rateLimitSettings = RateLimitSettings.internalBinaryRead(reader, reader.uint32(), options, message.rateLimitSettings);
                    break;
                case /* bool set_node_on_first_message_only */ 7:
                    message.setNodeOnFirstMessageOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApiConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.ApiConfigSource.ApiType api_type = 1; */
        if (message.apiType !== 0)
            writer.tag(1, WireType.Varint).int32(message.apiType);
        /* envoy.api.v2.core.ApiVersion transport_api_version = 8; */
        if (message.transportApiVersion !== 0)
            writer.tag(8, WireType.Varint).int32(message.transportApiVersion);
        /* repeated string cluster_names = 2; */
        for (let i = 0; i < message.clusterNames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.clusterNames[i]);
        /* repeated envoy.api.v2.core.GrpcService grpc_services = 4; */
        for (let i = 0; i < message.grpcServices.length; i++)
            GrpcService.internalBinaryWrite(message.grpcServices[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration refresh_delay = 3; */
        if (message.refreshDelay)
            Duration.internalBinaryWrite(message.refreshDelay, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration request_timeout = 5; */
        if (message.requestTimeout)
            Duration.internalBinaryWrite(message.requestTimeout, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.RateLimitSettings rate_limit_settings = 6; */
        if (message.rateLimitSettings)
            RateLimitSettings.internalBinaryWrite(message.rateLimitSettings, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool set_node_on_first_message_only = 7; */
        if (message.setNodeOnFirstMessageOnly !== false)
            writer.tag(7, WireType.Varint).bool(message.setNodeOnFirstMessageOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.ApiConfigSource
 */
export const ApiConfigSource = new ApiConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedConfigSource$Type extends MessageType<AggregatedConfigSource> {
    constructor() {
        super("envoy.api.v2.core.AggregatedConfigSource", []);
    }
    create(value?: PartialMessage<AggregatedConfigSource>): AggregatedConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AggregatedConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregatedConfigSource): AggregatedConfigSource {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AggregatedConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.AggregatedConfigSource
 */
export const AggregatedConfigSource = new AggregatedConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfConfigSource$Type extends MessageType<SelfConfigSource> {
    constructor() {
        super("envoy.api.v2.core.SelfConfigSource", [
            { no: 1, name: "transport_api_version", kind: "enum", T: () => ["envoy.api.v2.core.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<SelfConfigSource>): SelfConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transportApiVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<SelfConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfConfigSource): SelfConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.ApiVersion transport_api_version */ 1:
                    message.transportApiVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.ApiVersion transport_api_version = 1; */
        if (message.transportApiVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.transportApiVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.SelfConfigSource
 */
export const SelfConfigSource = new SelfConfigSource$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RateLimitSettings$Type extends MessageType<RateLimitSettings> {
    constructor() {
        super("envoy.api.v2.core.RateLimitSettings", [
            { no: 1, name: "max_tokens", kind: "message", T: () => UInt32Value },
            { no: 2, name: "fill_rate", kind: "message", T: () => DoubleValue, options: { "validate.rules": { double: { gt: 0 } } } }
        ]);
    }
    create(value?: PartialMessage<RateLimitSettings>): RateLimitSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RateLimitSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RateLimitSettings): RateLimitSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value max_tokens */ 1:
                    message.maxTokens = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxTokens);
                    break;
                case /* google.protobuf.DoubleValue fill_rate */ 2:
                    message.fillRate = DoubleValue.internalBinaryRead(reader, reader.uint32(), options, message.fillRate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RateLimitSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value max_tokens = 1; */
        if (message.maxTokens)
            UInt32Value.internalBinaryWrite(message.maxTokens, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.DoubleValue fill_rate = 2; */
        if (message.fillRate)
            DoubleValue.internalBinaryWrite(message.fillRate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.RateLimitSettings
 */
export const RateLimitSettings = new RateLimitSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigSource$Type extends MessageType<ConfigSource> {
    constructor() {
        super("envoy.api.v2.core.ConfigSource", [
            { no: 1, name: "path", kind: "scalar", oneof: "configSourceSpecifier", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "api_config_source", kind: "message", oneof: "configSourceSpecifier", T: () => ApiConfigSource },
            { no: 3, name: "ads", kind: "message", oneof: "configSourceSpecifier", T: () => AggregatedConfigSource },
            { no: 5, name: "self", kind: "message", oneof: "configSourceSpecifier", T: () => SelfConfigSource },
            { no: 4, name: "initial_fetch_timeout", kind: "message", T: () => Duration },
            { no: 6, name: "resource_api_version", kind: "enum", T: () => ["envoy.api.v2.core.ApiVersion", ApiVersion], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<ConfigSource>): ConfigSource {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configSourceSpecifier = { oneofKind: undefined };
        message.resourceApiVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<ConfigSource>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigSource): ConfigSource {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.configSourceSpecifier = {
                        oneofKind: "path",
                        path: reader.string()
                    };
                    break;
                case /* envoy.api.v2.core.ApiConfigSource api_config_source */ 2:
                    message.configSourceSpecifier = {
                        oneofKind: "apiConfigSource",
                        apiConfigSource: ApiConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).apiConfigSource)
                    };
                    break;
                case /* envoy.api.v2.core.AggregatedConfigSource ads */ 3:
                    message.configSourceSpecifier = {
                        oneofKind: "ads",
                        ads: AggregatedConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).ads)
                    };
                    break;
                case /* envoy.api.v2.core.SelfConfigSource self */ 5:
                    message.configSourceSpecifier = {
                        oneofKind: "self",
                        self: SelfConfigSource.internalBinaryRead(reader, reader.uint32(), options, (message.configSourceSpecifier as any).self)
                    };
                    break;
                case /* google.protobuf.Duration initial_fetch_timeout */ 4:
                    message.initialFetchTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.initialFetchTimeout);
                    break;
                case /* envoy.api.v2.core.ApiVersion resource_api_version */ 6:
                    message.resourceApiVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigSource, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.configSourceSpecifier.oneofKind === "path")
            writer.tag(1, WireType.LengthDelimited).string(message.configSourceSpecifier.path);
        /* envoy.api.v2.core.ApiConfigSource api_config_source = 2; */
        if (message.configSourceSpecifier.oneofKind === "apiConfigSource")
            ApiConfigSource.internalBinaryWrite(message.configSourceSpecifier.apiConfigSource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.AggregatedConfigSource ads = 3; */
        if (message.configSourceSpecifier.oneofKind === "ads")
            AggregatedConfigSource.internalBinaryWrite(message.configSourceSpecifier.ads, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.SelfConfigSource self = 5; */
        if (message.configSourceSpecifier.oneofKind === "self")
            SelfConfigSource.internalBinaryWrite(message.configSourceSpecifier.self, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration initial_fetch_timeout = 4; */
        if (message.initialFetchTimeout)
            Duration.internalBinaryWrite(message.initialFetchTimeout, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.ApiVersion resource_api_version = 6; */
        if (message.resourceApiVersion !== 0)
            writer.tag(6, WireType.Varint).int32(message.resourceApiVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.ConfigSource
 */
export const ConfigSource = new ConfigSource$Type();
