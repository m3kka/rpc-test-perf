// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/core/protocol.proto (package envoy.api.v2.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.api.v2.core.TcpProtocolOptions
 */
export declare class TcpProtocolOptions extends Message<TcpProtocolOptions> {
  constructor(data?: PartialMessage<TcpProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.TcpProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TcpProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TcpProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TcpProtocolOptions;

  static equals(a: TcpProtocolOptions | PlainMessage<TcpProtocolOptions> | undefined, b: TcpProtocolOptions | PlainMessage<TcpProtocolOptions> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.core.UpstreamHttpProtocolOptions
 */
export declare class UpstreamHttpProtocolOptions extends Message<UpstreamHttpProtocolOptions> {
  /**
   * Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
   * upstream connections based on the downstream HTTP host/authority header, as seen by the
   * :ref:`router filter <config_http_filters_router>`.
   *
   * @generated from field: bool auto_sni = 1;
   */
  autoSni: boolean;

  /**
   * Automatic validate upstream presented certificate for new upstream connections based on the
   * downstream HTTP host/authority header, as seen by the
   * :ref:`router filter <config_http_filters_router>`.
   * This field is intended to set with `auto_sni` field.
   *
   * @generated from field: bool auto_san_validation = 2;
   */
  autoSanValidation: boolean;

  constructor(data?: PartialMessage<UpstreamHttpProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.UpstreamHttpProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpstreamHttpProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpstreamHttpProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpstreamHttpProtocolOptions;

  static equals(a: UpstreamHttpProtocolOptions | PlainMessage<UpstreamHttpProtocolOptions> | undefined, b: UpstreamHttpProtocolOptions | PlainMessage<UpstreamHttpProtocolOptions> | undefined): boolean;
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.core.HttpProtocolOptions
 */
export declare class HttpProtocolOptions extends Message<HttpProtocolOptions> {
  /**
   * The idle timeout for connections. The idle timeout is defined as the
   * period in which there are no active requests. When the
   * idle timeout is reached the connection will be closed. If the connection is an HTTP/2
   * downstream connection a drain sequence will occur prior to closing the connection, see
   * :ref:`drain_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
   * Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
   * If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
   *
   * .. warning::
   *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
   *   FIN packets, etc.
   *
   * @generated from field: google.protobuf.Duration idle_timeout = 1;
   */
  idleTimeout?: Duration;

  /**
   * The maximum duration of a connection. The duration is defined as a period since a connection
   * was established. If not set, there is no max duration. When max_connection_duration is reached
   * the connection will be closed. Drain sequence will occur prior to closing the connection if
   * if's applicable. See :ref:`drain_timeout
   * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
   * Note: not implemented for upstream connections.
   *
   * @generated from field: google.protobuf.Duration max_connection_duration = 3;
   */
  maxConnectionDuration?: Duration;

  /**
   * The maximum number of headers. If unconfigured, the default
   * maximum number of request headers allowed is 100. Requests that exceed this limit will receive
   * a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
   *
   * @generated from field: google.protobuf.UInt32Value max_headers_count = 2;
   */
  maxHeadersCount?: number;

  /**
   * Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
   * reset independent of any other timeouts. If not specified, this value is not set.
   *
   * @generated from field: google.protobuf.Duration max_stream_duration = 4;
   */
  maxStreamDuration?: Duration;

  /**
   * Action to take when a client request with a header name containing underscore characters is received.
   * If this setting is not specified, the value defaults to ALLOW.
   * Note: upstream responses are not affected by this setting.
   *
   * @generated from field: envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction headers_with_underscores_action = 5;
   */
  headersWithUnderscoresAction: HttpProtocolOptions_HeadersWithUnderscoresAction;

  constructor(data?: PartialMessage<HttpProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.HttpProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpProtocolOptions;

  static equals(a: HttpProtocolOptions | PlainMessage<HttpProtocolOptions> | undefined, b: HttpProtocolOptions | PlainMessage<HttpProtocolOptions> | undefined): boolean;
}

/**
 * Action to take when Envoy receives client request with header names containing underscore
 * characters.
 * Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
 * as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
 * characters.
 *
 * @generated from enum envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction
 */
export declare enum HttpProtocolOptions_HeadersWithUnderscoresAction {
  /**
   * Allow headers with underscores. This is the default behavior.
   *
   * @generated from enum value: ALLOW = 0;
   */
  ALLOW = 0,

  /**
   * Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
   * end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
   * is incremented for each rejected request.
   *
   * @generated from enum value: REJECT_REQUEST = 1;
   */
  REJECT_REQUEST = 1,

  /**
   * Drop the header with name containing underscores. The header is dropped before the filter chain is
   * invoked and as such filters will not see dropped headers. The
   * "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
   *
   * @generated from enum value: DROP_HEADER = 2;
   */
  DROP_HEADER = 2,
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.core.Http1ProtocolOptions
 */
export declare class Http1ProtocolOptions extends Message<Http1ProtocolOptions> {
  /**
   * Handle HTTP requests with absolute URLs in the requests. These requests
   * are generally sent by clients to forward/explicit proxies. This allows clients to configure
   * envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
   * *http_proxy* environment variable.
   *
   * @generated from field: google.protobuf.BoolValue allow_absolute_url = 1;
   */
  allowAbsoluteUrl?: boolean;

  /**
   * Handle incoming HTTP/1.0 and HTTP 0.9 requests.
   * This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
   * style connect logic, dechunking, and handling lack of client host iff
   * *default_host_for_http_10* is configured.
   *
   * @generated from field: bool accept_http_10 = 2;
   */
  acceptHttp10: boolean;

  /**
   * A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
   * Envoy does not otherwise support HTTP/1.0 without a Host header.
   * This is a no-op if *accept_http_10* is not true.
   *
   * @generated from field: string default_host_for_http_10 = 3;
   */
  defaultHostForHttp10: string;

  /**
   * Describes how the keys for response headers should be formatted. By default, all header keys
   * are lower cased.
   *
   * @generated from field: envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat header_key_format = 4;
   */
  headerKeyFormat?: Http1ProtocolOptions_HeaderKeyFormat;

  /**
   * Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
   *
   * .. attention::
   *
   *   Note that this only happens when Envoy is chunk encoding which occurs when:
   *   - The request is HTTP/1.1.
   *   - Is neither a HEAD only request nor a HTTP Upgrade.
   *   - Not a response to a HEAD request.
   *   - The content length header is not present.
   *
   * @generated from field: bool enable_trailers = 5;
   */
  enableTrailers: boolean;

  constructor(data?: PartialMessage<Http1ProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.Http1ProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Http1ProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Http1ProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Http1ProtocolOptions;

  static equals(a: Http1ProtocolOptions | PlainMessage<Http1ProtocolOptions> | undefined, b: Http1ProtocolOptions | PlainMessage<Http1ProtocolOptions> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat
 */
export declare class Http1ProtocolOptions_HeaderKeyFormat extends Message<Http1ProtocolOptions_HeaderKeyFormat> {
  /**
   * @generated from oneof envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.header_format
   */
  headerFormat: {
    /**
     * Formats the header by proper casing words: the first character and any character following
     * a special character will be capitalized if it's an alpha character. For example,
     * "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
     * Note that while this results in most headers following conventional casing, certain headers
     * are not covered. For example, the "TE" header will be formatted as "Te".
     *
     * @generated from field: envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords proper_case_words = 1;
     */
    value: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords;
    case: "properCaseWords";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<Http1ProtocolOptions_HeaderKeyFormat>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Http1ProtocolOptions_HeaderKeyFormat;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Http1ProtocolOptions_HeaderKeyFormat;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Http1ProtocolOptions_HeaderKeyFormat;

  static equals(a: Http1ProtocolOptions_HeaderKeyFormat | PlainMessage<Http1ProtocolOptions_HeaderKeyFormat> | undefined, b: Http1ProtocolOptions_HeaderKeyFormat | PlainMessage<Http1ProtocolOptions_HeaderKeyFormat> | undefined): boolean;
}

/**
 * @generated from message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords
 */
export declare class Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords extends Message<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords> {
  constructor(data?: PartialMessage<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords;

  static equals(a: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords | PlainMessage<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords> | undefined, b: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords | PlainMessage<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords> | undefined): boolean;
}

/**
 * [#next-free-field: 14]
 *
 * @generated from message envoy.api.v2.core.Http2ProtocolOptions
 */
export declare class Http2ProtocolOptions extends Message<Http2ProtocolOptions> {
  /**
   * `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
   * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
   * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
   * compression.
   *
   * @generated from field: google.protobuf.UInt32Value hpack_table_size = 1;
   */
  hpackTableSize?: number;

  /**
   * `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
   * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
   * and defaults to 2147483647.
   *
   * For upstream connections, this also limits how many streams Envoy will initiate concurrently
   * on a single connection. If the limit is reached, Envoy may queue requests or establish
   * additional connections (as allowed per circuit breaker limits).
   *
   * @generated from field: google.protobuf.UInt32Value max_concurrent_streams = 2;
   */
  maxConcurrentStreams?: number;

  /**
   * `Initial stream-level flow-control window
   * <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
   * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
   * (256 * 1024 * 1024).
   *
   * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
   * window size now, so it's also the minimum.
   *
   * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
   * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
   * stop the flow of data to the codec buffers.
   *
   * @generated from field: google.protobuf.UInt32Value initial_stream_window_size = 3;
   */
  initialStreamWindowSize?: number;

  /**
   * Similar to *initial_stream_window_size*, but for connection-level flow-control
   * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
   *
   * @generated from field: google.protobuf.UInt32Value initial_connection_window_size = 4;
   */
  initialConnectionWindowSize?: number;

  /**
   * Allows proxying Websocket and other upgrades over H2 connect.
   *
   * @generated from field: bool allow_connect = 5;
   */
  allowConnect: boolean;

  /**
   * [#not-implemented-hide:] Hiding until envoy has full metadata support.
   * Still under implementation. DO NOT USE.
   *
   * Allows metadata. See [metadata
   * docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
   * information.
   *
   * @generated from field: bool allow_metadata = 6;
   */
  allowMetadata: boolean;

  /**
   * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
   * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
   * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
   * to flood mitigation. The default limit is 10000.
   * [#comment:TODO: implement same limits for upstream outbound frames as well.]
   *
   * @generated from field: google.protobuf.UInt32Value max_outbound_frames = 7;
   */
  maxOutboundFrames?: number;

  /**
   * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
   * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
   * this limit triggers flood mitigation and connection is terminated. The
   * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
   * mitigation. The default limit is 1000.
   * [#comment:TODO: implement same limits for upstream outbound frames as well.]
   *
   * @generated from field: google.protobuf.UInt32Value max_outbound_control_frames = 8;
   */
  maxOutboundControlFrames?: number;

  /**
   * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
   * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
   * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
   * stat tracks the number of connections terminated due to flood mitigation.
   * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
   * and no end stream flag. The default limit is 1.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   *
   * @generated from field: google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;
   */
  maxConsecutiveInboundFramesWithEmptyPayload?: number;

  /**
   * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
   * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *
   *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
   *
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 100.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   *
   * @generated from field: google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;
   */
  maxInboundPriorityFramesPerStream?: number;

  /**
   * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
   * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
   * using this formula::
   *
   *     1 + 2 * (inbound_streams +
   *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
   *
   * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
   * the number of connections terminated due to flood mitigation. The default limit is 10.
   * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
   * but more complex implementations that try to estimate available bandwidth require at least 2.
   * [#comment:TODO: implement same limits for upstream inbound frames as well.]
   *
   * @generated from field: google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11;
   */
  maxInboundWindowUpdateFramesPerDataFrameSent?: number;

  /**
   * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
   * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
   * when this option is enabled, only the offending stream is terminated.
   *
   * See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
   *
   * @generated from field: bool stream_error_on_invalid_http_messaging = 12;
   */
  streamErrorOnInvalidHttpMessaging: boolean;

  /**
   * [#not-implemented-hide:]
   * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
   *
   * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
   * Envoy.
   *
   * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
   * 'allow_connect'.
   *
   * Note that custom parameters specified through this field can not also be set in the
   * corresponding named parameters:
   *
   * .. code-block:: text
   *
   *   ID    Field Name
   *   ----------------
   *   0x1   hpack_table_size
   *   0x3   max_concurrent_streams
   *   0x4   initial_stream_window_size
   *
   * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
   * between custom parameters with the same identifier will trigger a failure.
   *
   * See `IANA HTTP/2 Settings
   * <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
   * standardized identifiers.
   *
   * @generated from field: repeated envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;
   */
  customSettingsParameters: Http2ProtocolOptions_SettingsParameter[];

  constructor(data?: PartialMessage<Http2ProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.Http2ProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Http2ProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Http2ProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Http2ProtocolOptions;

  static equals(a: Http2ProtocolOptions | PlainMessage<Http2ProtocolOptions> | undefined, b: Http2ProtocolOptions | PlainMessage<Http2ProtocolOptions> | undefined): boolean;
}

/**
 * Defines a parameter to be sent in the SETTINGS frame.
 * See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
 *
 * @generated from message envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter
 */
export declare class Http2ProtocolOptions_SettingsParameter extends Message<Http2ProtocolOptions_SettingsParameter> {
  /**
   * The 16 bit parameter identifier.
   *
   * @generated from field: google.protobuf.UInt32Value identifier = 1;
   */
  identifier?: number;

  /**
   * The 32 bit parameter value.
   *
   * @generated from field: google.protobuf.UInt32Value value = 2;
   */
  value?: number;

  constructor(data?: PartialMessage<Http2ProtocolOptions_SettingsParameter>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Http2ProtocolOptions_SettingsParameter;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Http2ProtocolOptions_SettingsParameter;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Http2ProtocolOptions_SettingsParameter;

  static equals(a: Http2ProtocolOptions_SettingsParameter | PlainMessage<Http2ProtocolOptions_SettingsParameter> | undefined, b: Http2ProtocolOptions_SettingsParameter | PlainMessage<Http2ProtocolOptions_SettingsParameter> | undefined): boolean;
}

/**
 * [#not-implemented-hide:]
 *
 * @generated from message envoy.api.v2.core.GrpcProtocolOptions
 */
export declare class GrpcProtocolOptions extends Message<GrpcProtocolOptions> {
  /**
   * @generated from field: envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 1;
   */
  http2ProtocolOptions?: Http2ProtocolOptions;

  constructor(data?: PartialMessage<GrpcProtocolOptions>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.api.v2.core.GrpcProtocolOptions";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrpcProtocolOptions;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrpcProtocolOptions;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrpcProtocolOptions;

  static equals(a: GrpcProtocolOptions | PlainMessage<GrpcProtocolOptions> | undefined, b: GrpcProtocolOptions | PlainMessage<GrpcProtocolOptions> | undefined): boolean;
}

