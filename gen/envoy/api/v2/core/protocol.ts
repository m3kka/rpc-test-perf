// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/core/protocol.proto" (package "envoy.api.v2.core", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { UInt32Value } from "../../../../google/protobuf/wrappers";
import { Duration } from "../../../../google/protobuf/duration";
// [#protodoc-title: Protocol options]

/**
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.api.v2.core.TcpProtocolOptions
 */
export interface TcpProtocolOptions {
}
/**
 * @generated from protobuf message envoy.api.v2.core.UpstreamHttpProtocolOptions
 */
export interface UpstreamHttpProtocolOptions {
    /**
     * Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
     * upstream connections based on the downstream HTTP host/authority header, as seen by the
     * :ref:`router filter <config_http_filters_router>`.
     *
     * @generated from protobuf field: bool auto_sni = 1;
     */
    autoSni: boolean;
    /**
     * Automatic validate upstream presented certificate for new upstream connections based on the
     * downstream HTTP host/authority header, as seen by the
     * :ref:`router filter <config_http_filters_router>`.
     * This field is intended to set with `auto_sni` field.
     *
     * @generated from protobuf field: bool auto_san_validation = 2;
     */
    autoSanValidation: boolean;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.api.v2.core.HttpProtocolOptions
 */
export interface HttpProtocolOptions {
    /**
     * The idle timeout for connections. The idle timeout is defined as the
     * period in which there are no active requests. When the
     * idle timeout is reached the connection will be closed. If the connection is an HTTP/2
     * downstream connection a drain sequence will occur prior to closing the connection, see
     * :ref:`drain_timeout
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
     * Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
     * If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
     *
     * .. warning::
     *   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
     *   FIN packets, etc.
     *
     * @generated from protobuf field: google.protobuf.Duration idle_timeout = 1;
     */
    idleTimeout?: Duration;
    /**
     * The maximum duration of a connection. The duration is defined as a period since a connection
     * was established. If not set, there is no max duration. When max_connection_duration is reached
     * the connection will be closed. Drain sequence will occur prior to closing the connection if
     * if's applicable. See :ref:`drain_timeout
     * <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.drain_timeout>`.
     * Note: not implemented for upstream connections.
     *
     * @generated from protobuf field: google.protobuf.Duration max_connection_duration = 3;
     */
    maxConnectionDuration?: Duration;
    /**
     * The maximum number of headers. If unconfigured, the default
     * maximum number of request headers allowed is 100. Requests that exceed this limit will receive
     * a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_headers_count = 2;
     */
    maxHeadersCount?: UInt32Value;
    /**
     * Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
     * reset independent of any other timeouts. If not specified, this value is not set.
     *
     * @generated from protobuf field: google.protobuf.Duration max_stream_duration = 4;
     */
    maxStreamDuration?: Duration;
    /**
     * Action to take when a client request with a header name containing underscore characters is received.
     * If this setting is not specified, the value defaults to ALLOW.
     * Note: upstream responses are not affected by this setting.
     *
     * @generated from protobuf field: envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction headers_with_underscores_action = 5;
     */
    headersWithUnderscoresAction: HttpProtocolOptions_HeadersWithUnderscoresAction;
}
/**
 * Action to take when Envoy receives client request with header names containing underscore
 * characters.
 * Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
 * as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
 * characters.
 *
 * @generated from protobuf enum envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction
 */
export enum HttpProtocolOptions_HeadersWithUnderscoresAction {
    /**
     * Allow headers with underscores. This is the default behavior.
     *
     * @generated from protobuf enum value: ALLOW = 0;
     */
    ALLOW = 0,
    /**
     * Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
     * end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
     * is incremented for each rejected request.
     *
     * @generated from protobuf enum value: REJECT_REQUEST = 1;
     */
    REJECT_REQUEST = 1,
    /**
     * Drop the header with name containing underscores. The header is dropped before the filter chain is
     * invoked and as such filters will not see dropped headers. The
     * "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
     *
     * @generated from protobuf enum value: DROP_HEADER = 2;
     */
    DROP_HEADER = 2
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.api.v2.core.Http1ProtocolOptions
 */
export interface Http1ProtocolOptions {
    /**
     * Handle HTTP requests with absolute URLs in the requests. These requests
     * are generally sent by clients to forward/explicit proxies. This allows clients to configure
     * envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
     * *http_proxy* environment variable.
     *
     * @generated from protobuf field: google.protobuf.BoolValue allow_absolute_url = 1;
     */
    allowAbsoluteUrl?: BoolValue;
    /**
     * Handle incoming HTTP/1.0 and HTTP 0.9 requests.
     * This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
     * style connect logic, dechunking, and handling lack of client host iff
     * *default_host_for_http_10* is configured.
     *
     * @generated from protobuf field: bool accept_http_10 = 2;
     */
    acceptHttp10: boolean;
    /**
     * A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
     * Envoy does not otherwise support HTTP/1.0 without a Host header.
     * This is a no-op if *accept_http_10* is not true.
     *
     * @generated from protobuf field: string default_host_for_http_10 = 3;
     */
    defaultHostForHttp10: string;
    /**
     * Describes how the keys for response headers should be formatted. By default, all header keys
     * are lower cased.
     *
     * @generated from protobuf field: envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat header_key_format = 4;
     */
    headerKeyFormat?: Http1ProtocolOptions_HeaderKeyFormat;
    /**
     * Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
     *
     * .. attention::
     *
     *   Note that this only happens when Envoy is chunk encoding which occurs when:
     *   - The request is HTTP/1.1.
     *   - Is neither a HEAD only request nor a HTTP Upgrade.
     *   - Not a response to a HEAD request.
     *   - The content length header is not present.
     *
     * @generated from protobuf field: bool enable_trailers = 5;
     */
    enableTrailers: boolean;
}
/**
 * @generated from protobuf message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat
 */
export interface Http1ProtocolOptions_HeaderKeyFormat {
    /**
     * @generated from protobuf oneof: header_format
     */
    headerFormat: {
        oneofKind: "properCaseWords";
        /**
         * Formats the header by proper casing words: the first character and any character following
         * a special character will be capitalized if it's an alpha character. For example,
         * "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
         * Note that while this results in most headers following conventional casing, certain headers
         * are not covered. For example, the "TE" header will be formatted as "Te".
         *
         * @generated from protobuf field: envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords proper_case_words = 1;
         */
        properCaseWords: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords
 */
export interface Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
}
/**
 * [#next-free-field: 14]
 *
 * @generated from protobuf message envoy.api.v2.core.Http2ProtocolOptions
 */
export interface Http2ProtocolOptions {
    /**
     * `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
     * (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
     * range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
     * compression.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value hpack_table_size = 1;
     */
    hpackTableSize?: UInt32Value;
    /**
     * `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
     * allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
     * and defaults to 2147483647.
     *
     * For upstream connections, this also limits how many streams Envoy will initiate concurrently
     * on a single connection. If the limit is reached, Envoy may queue requests or establish
     * additional connections (as allowed per circuit breaker limits).
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_concurrent_streams = 2;
     */
    maxConcurrentStreams?: UInt32Value;
    /**
     * `Initial stream-level flow-control window
     * <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
     * (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
     * (256 * 1024 * 1024).
     *
     * NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
     * window size now, so it's also the minimum.
     *
     * This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
     * HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
     * stop the flow of data to the codec buffers.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value initial_stream_window_size = 3;
     */
    initialStreamWindowSize?: UInt32Value;
    /**
     * Similar to *initial_stream_window_size*, but for connection-level flow-control
     * window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value initial_connection_window_size = 4;
     */
    initialConnectionWindowSize?: UInt32Value;
    /**
     * Allows proxying Websocket and other upgrades over H2 connect.
     *
     * @generated from protobuf field: bool allow_connect = 5;
     */
    allowConnect: boolean;
    /**
     * [#not-implemented-hide:] Hiding until envoy has full metadata support.
     * Still under implementation. DO NOT USE.
     *
     * Allows metadata. See [metadata
     * docs](https://github.com/envoyproxy/envoy/blob/main/source/docs/h2_metadata.md) for more
     * information.
     *
     * @generated from protobuf field: bool allow_metadata = 6;
     */
    allowMetadata: boolean;
    /**
     * Limit the number of pending outbound downstream frames of all types (frames that are waiting to
     * be written into the socket). Exceeding this limit triggers flood mitigation and connection is
     * terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
     * to flood mitigation. The default limit is 10000.
     * [#comment:TODO: implement same limits for upstream outbound frames as well.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_outbound_frames = 7;
     */
    maxOutboundFrames?: UInt32Value;
    /**
     * Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
     * preventing high memory utilization when receiving continuous stream of these frames. Exceeding
     * this limit triggers flood mitigation and connection is terminated. The
     * ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
     * mitigation. The default limit is 1000.
     * [#comment:TODO: implement same limits for upstream outbound frames as well.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_outbound_control_frames = 8;
     */
    maxOutboundControlFrames?: UInt32Value;
    /**
     * Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
     * empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
     * might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
     * stat tracks the number of connections terminated due to flood mitigation.
     * Setting this to 0 will terminate connection upon receiving first frame with an empty payload
     * and no end stream flag. The default limit is 1.
     * [#comment:TODO: implement same limits for upstream inbound frames as well.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9;
     */
    maxConsecutiveInboundFramesWithEmptyPayload?: UInt32Value;
    /**
     * Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
     * of PRIORITY frames received over the lifetime of connection exceeds the value calculated
     * using this formula::
     *
     *     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
     *
     * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
     * the number of connections terminated due to flood mitigation. The default limit is 100.
     * [#comment:TODO: implement same limits for upstream inbound frames as well.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10;
     */
    maxInboundPriorityFramesPerStream?: UInt32Value;
    /**
     * Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
     * of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
     * using this formula::
     *
     *     1 + 2 * (inbound_streams +
     *              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
     *
     * the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
     * the number of connections terminated due to flood mitigation. The default limit is 10.
     * Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
     * but more complex implementations that try to estimate available bandwidth require at least 2.
     * [#comment:TODO: implement same limits for upstream inbound frames as well.]
     *
     * @generated from protobuf field: google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11;
     */
    maxInboundWindowUpdateFramesPerDataFrameSent?: UInt32Value;
    /**
     * Allows invalid HTTP messaging and headers. When this option is disabled (default), then
     * the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
     * when this option is enabled, only the offending stream is terminated.
     *
     * See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
     *
     * @generated from protobuf field: bool stream_error_on_invalid_http_messaging = 12;
     */
    streamErrorOnInvalidHttpMessaging: boolean;
    /**
     * [#not-implemented-hide:]
     * Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
     *
     * 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
     * Envoy.
     *
     * 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
     * 'allow_connect'.
     *
     * Note that custom parameters specified through this field can not also be set in the
     * corresponding named parameters:
     *
     * .. code-block:: text
     *
     *   ID    Field Name
     *   ----------------
     *   0x1   hpack_table_size
     *   0x3   max_concurrent_streams
     *   0x4   initial_stream_window_size
     *
     * Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
     * between custom parameters with the same identifier will trigger a failure.
     *
     * See `IANA HTTP/2 Settings
     * <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
     * standardized identifiers.
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13;
     */
    customSettingsParameters: Http2ProtocolOptions_SettingsParameter[];
}
/**
 * Defines a parameter to be sent in the SETTINGS frame.
 * See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
 *
 * @generated from protobuf message envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter
 */
export interface Http2ProtocolOptions_SettingsParameter {
    /**
     * The 16 bit parameter identifier.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value identifier = 1;
     */
    identifier?: UInt32Value;
    /**
     * The 32 bit parameter value.
     *
     * @generated from protobuf field: google.protobuf.UInt32Value value = 2;
     */
    value?: UInt32Value;
}
/**
 * [#not-implemented-hide:]
 *
 * @generated from protobuf message envoy.api.v2.core.GrpcProtocolOptions
 */
export interface GrpcProtocolOptions {
    /**
     * @generated from protobuf field: envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 1;
     */
    http2ProtocolOptions?: Http2ProtocolOptions;
}
// @generated message type with reflection information, may provide speed optimized methods
class TcpProtocolOptions$Type extends MessageType<TcpProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.TcpProtocolOptions", []);
    }
    create(value?: PartialMessage<TcpProtocolOptions>): TcpProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TcpProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TcpProtocolOptions): TcpProtocolOptions {
        return target ?? this.create();
    }
    internalBinaryWrite(message: TcpProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.TcpProtocolOptions
 */
export const TcpProtocolOptions = new TcpProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpstreamHttpProtocolOptions$Type extends MessageType<UpstreamHttpProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.UpstreamHttpProtocolOptions", [
            { no: 1, name: "auto_sni", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "auto_san_validation", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpstreamHttpProtocolOptions>): UpstreamHttpProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.autoSni = false;
        message.autoSanValidation = false;
        if (value !== undefined)
            reflectionMergePartial<UpstreamHttpProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpstreamHttpProtocolOptions): UpstreamHttpProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool auto_sni */ 1:
                    message.autoSni = reader.bool();
                    break;
                case /* bool auto_san_validation */ 2:
                    message.autoSanValidation = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpstreamHttpProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool auto_sni = 1; */
        if (message.autoSni !== false)
            writer.tag(1, WireType.Varint).bool(message.autoSni);
        /* bool auto_san_validation = 2; */
        if (message.autoSanValidation !== false)
            writer.tag(2, WireType.Varint).bool(message.autoSanValidation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.UpstreamHttpProtocolOptions
 */
export const UpstreamHttpProtocolOptions = new UpstreamHttpProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpProtocolOptions$Type extends MessageType<HttpProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.HttpProtocolOptions", [
            { no: 1, name: "idle_timeout", kind: "message", T: () => Duration },
            { no: 3, name: "max_connection_duration", kind: "message", T: () => Duration },
            { no: 2, name: "max_headers_count", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 4, name: "max_stream_duration", kind: "message", T: () => Duration },
            { no: 5, name: "headers_with_underscores_action", kind: "enum", T: () => ["envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction", HttpProtocolOptions_HeadersWithUnderscoresAction] }
        ]);
    }
    create(value?: PartialMessage<HttpProtocolOptions>): HttpProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headersWithUnderscoresAction = 0;
        if (value !== undefined)
            reflectionMergePartial<HttpProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpProtocolOptions): HttpProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration idle_timeout */ 1:
                    message.idleTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.idleTimeout);
                    break;
                case /* google.protobuf.Duration max_connection_duration */ 3:
                    message.maxConnectionDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxConnectionDuration);
                    break;
                case /* google.protobuf.UInt32Value max_headers_count */ 2:
                    message.maxHeadersCount = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxHeadersCount);
                    break;
                case /* google.protobuf.Duration max_stream_duration */ 4:
                    message.maxStreamDuration = Duration.internalBinaryRead(reader, reader.uint32(), options, message.maxStreamDuration);
                    break;
                case /* envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction headers_with_underscores_action */ 5:
                    message.headersWithUnderscoresAction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration idle_timeout = 1; */
        if (message.idleTimeout)
            Duration.internalBinaryWrite(message.idleTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_connection_duration = 3; */
        if (message.maxConnectionDuration)
            Duration.internalBinaryWrite(message.maxConnectionDuration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_headers_count = 2; */
        if (message.maxHeadersCount)
            UInt32Value.internalBinaryWrite(message.maxHeadersCount, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration max_stream_duration = 4; */
        if (message.maxStreamDuration)
            Duration.internalBinaryWrite(message.maxStreamDuration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.HttpProtocolOptions.HeadersWithUnderscoresAction headers_with_underscores_action = 5; */
        if (message.headersWithUnderscoresAction !== 0)
            writer.tag(5, WireType.Varint).int32(message.headersWithUnderscoresAction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.HttpProtocolOptions
 */
export const HttpProtocolOptions = new HttpProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Http1ProtocolOptions$Type extends MessageType<Http1ProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.Http1ProtocolOptions", [
            { no: 1, name: "allow_absolute_url", kind: "message", T: () => BoolValue },
            { no: 2, name: "accept_http_10", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "default_host_for_http_10", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "header_key_format", kind: "message", T: () => Http1ProtocolOptions_HeaderKeyFormat },
            { no: 5, name: "enable_trailers", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Http1ProtocolOptions>): Http1ProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.acceptHttp10 = false;
        message.defaultHostForHttp10 = "";
        message.enableTrailers = false;
        if (value !== undefined)
            reflectionMergePartial<Http1ProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Http1ProtocolOptions): Http1ProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.BoolValue allow_absolute_url */ 1:
                    message.allowAbsoluteUrl = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.allowAbsoluteUrl);
                    break;
                case /* bool accept_http_10 */ 2:
                    message.acceptHttp10 = reader.bool();
                    break;
                case /* string default_host_for_http_10 */ 3:
                    message.defaultHostForHttp10 = reader.string();
                    break;
                case /* envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat header_key_format */ 4:
                    message.headerKeyFormat = Http1ProtocolOptions_HeaderKeyFormat.internalBinaryRead(reader, reader.uint32(), options, message.headerKeyFormat);
                    break;
                case /* bool enable_trailers */ 5:
                    message.enableTrailers = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Http1ProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.BoolValue allow_absolute_url = 1; */
        if (message.allowAbsoluteUrl)
            BoolValue.internalBinaryWrite(message.allowAbsoluteUrl, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool accept_http_10 = 2; */
        if (message.acceptHttp10 !== false)
            writer.tag(2, WireType.Varint).bool(message.acceptHttp10);
        /* string default_host_for_http_10 = 3; */
        if (message.defaultHostForHttp10 !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.defaultHostForHttp10);
        /* envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat header_key_format = 4; */
        if (message.headerKeyFormat)
            Http1ProtocolOptions_HeaderKeyFormat.internalBinaryWrite(message.headerKeyFormat, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_trailers = 5; */
        if (message.enableTrailers !== false)
            writer.tag(5, WireType.Varint).bool(message.enableTrailers);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Http1ProtocolOptions
 */
export const Http1ProtocolOptions = new Http1ProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Http1ProtocolOptions_HeaderKeyFormat$Type extends MessageType<Http1ProtocolOptions_HeaderKeyFormat> {
    constructor() {
        super("envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat", [
            { no: 1, name: "proper_case_words", kind: "message", oneof: "headerFormat", T: () => Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords }
        ]);
    }
    create(value?: PartialMessage<Http1ProtocolOptions_HeaderKeyFormat>): Http1ProtocolOptions_HeaderKeyFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerFormat = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Http1ProtocolOptions_HeaderKeyFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Http1ProtocolOptions_HeaderKeyFormat): Http1ProtocolOptions_HeaderKeyFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords proper_case_words */ 1:
                    message.headerFormat = {
                        oneofKind: "properCaseWords",
                        properCaseWords: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.internalBinaryRead(reader, reader.uint32(), options, (message.headerFormat as any).properCaseWords)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Http1ProtocolOptions_HeaderKeyFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords proper_case_words = 1; */
        if (message.headerFormat.oneofKind === "properCaseWords")
            Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords.internalBinaryWrite(message.headerFormat.properCaseWords, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat
 */
export const Http1ProtocolOptions_HeaderKeyFormat = new Http1ProtocolOptions_HeaderKeyFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords$Type extends MessageType<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords> {
    constructor() {
        super("envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords", []);
    }
    create(value?: PartialMessage<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords>): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords): Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords
 */
export const Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords = new Http1ProtocolOptions_HeaderKeyFormat_ProperCaseWords$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Http2ProtocolOptions$Type extends MessageType<Http2ProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.Http2ProtocolOptions", [
            { no: 1, name: "hpack_table_size", kind: "message", T: () => UInt32Value },
            { no: 2, name: "max_concurrent_streams", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 2147483647, gte: 1 } } } },
            { no: 3, name: "initial_stream_window_size", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 2147483647, gte: 65535 } } } },
            { no: 4, name: "initial_connection_window_size", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { lte: 2147483647, gte: 65535 } } } },
            { no: 5, name: "allow_connect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "allow_metadata", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "max_outbound_frames", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 8, name: "max_outbound_control_frames", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 9, name: "max_consecutive_inbound_frames_with_empty_payload", kind: "message", T: () => UInt32Value },
            { no: 10, name: "max_inbound_priority_frames_per_stream", kind: "message", T: () => UInt32Value },
            { no: 11, name: "max_inbound_window_update_frames_per_data_frame_sent", kind: "message", T: () => UInt32Value, options: { "validate.rules": { uint32: { gte: 1 } } } },
            { no: 12, name: "stream_error_on_invalid_http_messaging", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "custom_settings_parameters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Http2ProtocolOptions_SettingsParameter }
        ]);
    }
    create(value?: PartialMessage<Http2ProtocolOptions>): Http2ProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowConnect = false;
        message.allowMetadata = false;
        message.streamErrorOnInvalidHttpMessaging = false;
        message.customSettingsParameters = [];
        if (value !== undefined)
            reflectionMergePartial<Http2ProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Http2ProtocolOptions): Http2ProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value hpack_table_size */ 1:
                    message.hpackTableSize = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.hpackTableSize);
                    break;
                case /* google.protobuf.UInt32Value max_concurrent_streams */ 2:
                    message.maxConcurrentStreams = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxConcurrentStreams);
                    break;
                case /* google.protobuf.UInt32Value initial_stream_window_size */ 3:
                    message.initialStreamWindowSize = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.initialStreamWindowSize);
                    break;
                case /* google.protobuf.UInt32Value initial_connection_window_size */ 4:
                    message.initialConnectionWindowSize = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.initialConnectionWindowSize);
                    break;
                case /* bool allow_connect */ 5:
                    message.allowConnect = reader.bool();
                    break;
                case /* bool allow_metadata */ 6:
                    message.allowMetadata = reader.bool();
                    break;
                case /* google.protobuf.UInt32Value max_outbound_frames */ 7:
                    message.maxOutboundFrames = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxOutboundFrames);
                    break;
                case /* google.protobuf.UInt32Value max_outbound_control_frames */ 8:
                    message.maxOutboundControlFrames = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxOutboundControlFrames);
                    break;
                case /* google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload */ 9:
                    message.maxConsecutiveInboundFramesWithEmptyPayload = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxConsecutiveInboundFramesWithEmptyPayload);
                    break;
                case /* google.protobuf.UInt32Value max_inbound_priority_frames_per_stream */ 10:
                    message.maxInboundPriorityFramesPerStream = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxInboundPriorityFramesPerStream);
                    break;
                case /* google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent */ 11:
                    message.maxInboundWindowUpdateFramesPerDataFrameSent = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.maxInboundWindowUpdateFramesPerDataFrameSent);
                    break;
                case /* bool stream_error_on_invalid_http_messaging */ 12:
                    message.streamErrorOnInvalidHttpMessaging = reader.bool();
                    break;
                case /* repeated envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter custom_settings_parameters */ 13:
                    message.customSettingsParameters.push(Http2ProtocolOptions_SettingsParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Http2ProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value hpack_table_size = 1; */
        if (message.hpackTableSize)
            UInt32Value.internalBinaryWrite(message.hpackTableSize, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_concurrent_streams = 2; */
        if (message.maxConcurrentStreams)
            UInt32Value.internalBinaryWrite(message.maxConcurrentStreams, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value initial_stream_window_size = 3; */
        if (message.initialStreamWindowSize)
            UInt32Value.internalBinaryWrite(message.initialStreamWindowSize, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value initial_connection_window_size = 4; */
        if (message.initialConnectionWindowSize)
            UInt32Value.internalBinaryWrite(message.initialConnectionWindowSize, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_connect = 5; */
        if (message.allowConnect !== false)
            writer.tag(5, WireType.Varint).bool(message.allowConnect);
        /* bool allow_metadata = 6; */
        if (message.allowMetadata !== false)
            writer.tag(6, WireType.Varint).bool(message.allowMetadata);
        /* google.protobuf.UInt32Value max_outbound_frames = 7; */
        if (message.maxOutboundFrames)
            UInt32Value.internalBinaryWrite(message.maxOutboundFrames, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_outbound_control_frames = 8; */
        if (message.maxOutboundControlFrames)
            UInt32Value.internalBinaryWrite(message.maxOutboundControlFrames, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_consecutive_inbound_frames_with_empty_payload = 9; */
        if (message.maxConsecutiveInboundFramesWithEmptyPayload)
            UInt32Value.internalBinaryWrite(message.maxConsecutiveInboundFramesWithEmptyPayload, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_inbound_priority_frames_per_stream = 10; */
        if (message.maxInboundPriorityFramesPerStream)
            UInt32Value.internalBinaryWrite(message.maxInboundPriorityFramesPerStream, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value max_inbound_window_update_frames_per_data_frame_sent = 11; */
        if (message.maxInboundWindowUpdateFramesPerDataFrameSent)
            UInt32Value.internalBinaryWrite(message.maxInboundWindowUpdateFramesPerDataFrameSent, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool stream_error_on_invalid_http_messaging = 12; */
        if (message.streamErrorOnInvalidHttpMessaging !== false)
            writer.tag(12, WireType.Varint).bool(message.streamErrorOnInvalidHttpMessaging);
        /* repeated envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter custom_settings_parameters = 13; */
        for (let i = 0; i < message.customSettingsParameters.length; i++)
            Http2ProtocolOptions_SettingsParameter.internalBinaryWrite(message.customSettingsParameters[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Http2ProtocolOptions
 */
export const Http2ProtocolOptions = new Http2ProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Http2ProtocolOptions_SettingsParameter$Type extends MessageType<Http2ProtocolOptions_SettingsParameter> {
    constructor() {
        super("envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter", [
            { no: 1, name: "identifier", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true }, uint32: { lte: 65536, gte: 1 } } } },
            { no: 2, name: "value", kind: "message", T: () => UInt32Value, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Http2ProtocolOptions_SettingsParameter>): Http2ProtocolOptions_SettingsParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Http2ProtocolOptions_SettingsParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Http2ProtocolOptions_SettingsParameter): Http2ProtocolOptions_SettingsParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.UInt32Value identifier */ 1:
                    message.identifier = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.identifier);
                    break;
                case /* google.protobuf.UInt32Value value */ 2:
                    message.value = UInt32Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Http2ProtocolOptions_SettingsParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.UInt32Value identifier = 1; */
        if (message.identifier)
            UInt32Value.internalBinaryWrite(message.identifier, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.UInt32Value value = 2; */
        if (message.value)
            UInt32Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.Http2ProtocolOptions.SettingsParameter
 */
export const Http2ProtocolOptions_SettingsParameter = new Http2ProtocolOptions_SettingsParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GrpcProtocolOptions$Type extends MessageType<GrpcProtocolOptions> {
    constructor() {
        super("envoy.api.v2.core.GrpcProtocolOptions", [
            { no: 1, name: "http2_protocol_options", kind: "message", T: () => Http2ProtocolOptions }
        ]);
    }
    create(value?: PartialMessage<GrpcProtocolOptions>): GrpcProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GrpcProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GrpcProtocolOptions): GrpcProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options */ 1:
                    message.http2ProtocolOptions = Http2ProtocolOptions.internalBinaryRead(reader, reader.uint32(), options, message.http2ProtocolOptions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GrpcProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.Http2ProtocolOptions http2_protocol_options = 1; */
        if (message.http2ProtocolOptions)
            Http2ProtocolOptions.internalBinaryWrite(message.http2ProtocolOptions, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.core.GrpcProtocolOptions
 */
export const GrpcProtocolOptions = new GrpcProtocolOptions$Type();
