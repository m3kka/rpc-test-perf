// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/api/v2/core/base.proto (package envoy.api.v2.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { Any, BoolValue, proto3, Struct, UInt32Value } from "@bufbuild/protobuf";
import { SemanticVersion } from "../../../type/semantic_version_pb.js";
import { Address } from "./address_pb.js";
import { BackoffStrategy } from "./backoff_pb.js";
import { HttpUri } from "./http_uri_pb.js";
import { FractionalPercent } from "../../../type/percent_pb.js";

/**
 * Envoy supports :ref:`upstream priority routing
 * <arch_overview_http_routing_priority>` both at the route and the virtual
 * cluster level. The current priority implementation uses different connection
 * pool and circuit breaking settings for each priority level. This means that
 * even for HTTP/2 requests, two physical connections will be used to an
 * upstream host. In the future Envoy will likely support true HTTP/2 priority
 * over a single upstream connection.
 *
 * @generated from enum envoy.api.v2.core.RoutingPriority
 */
export const RoutingPriority = proto3.makeEnum(
  "envoy.api.v2.core.RoutingPriority",
  [
    {no: 0, name: "DEFAULT"},
    {no: 1, name: "HIGH"},
  ],
);

/**
 * HTTP request method.
 *
 * @generated from enum envoy.api.v2.core.RequestMethod
 */
export const RequestMethod = proto3.makeEnum(
  "envoy.api.v2.core.RequestMethod",
  [
    {no: 0, name: "METHOD_UNSPECIFIED"},
    {no: 1, name: "GET"},
    {no: 2, name: "HEAD"},
    {no: 3, name: "POST"},
    {no: 4, name: "PUT"},
    {no: 5, name: "DELETE"},
    {no: 6, name: "CONNECT"},
    {no: 7, name: "OPTIONS"},
    {no: 8, name: "TRACE"},
    {no: 9, name: "PATCH"},
  ],
);

/**
 * Identifies the direction of the traffic relative to the local Envoy.
 *
 * @generated from enum envoy.api.v2.core.TrafficDirection
 */
export const TrafficDirection = proto3.makeEnum(
  "envoy.api.v2.core.TrafficDirection",
  [
    {no: 0, name: "UNSPECIFIED"},
    {no: 1, name: "INBOUND"},
    {no: 2, name: "OUTBOUND"},
  ],
);

/**
 * Identifies location of where either Envoy runs or where upstream hosts run.
 *
 * @generated from message envoy.api.v2.core.Locality
 */
export const Locality = proto3.makeMessageType(
  "envoy.api.v2.core.Locality",
  () => [
    { no: 1, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sub_zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * BuildVersion combines SemVer version of extension with free-form build information
 * (i.e. 'alpha', 'private-build') as a set of strings.
 *
 * @generated from message envoy.api.v2.core.BuildVersion
 */
export const BuildVersion = proto3.makeMessageType(
  "envoy.api.v2.core.BuildVersion",
  () => [
    { no: 1, name: "version", kind: "message", T: SemanticVersion },
    { no: 2, name: "metadata", kind: "message", T: Struct },
  ],
);

/**
 * Version and identification for an Envoy extension.
 * [#next-free-field: 6]
 *
 * @generated from message envoy.api.v2.core.Extension
 */
export const Extension = proto3.makeMessageType(
  "envoy.api.v2.core.Extension",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "type_descriptor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "version", kind: "message", T: BuildVersion },
    { no: 5, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
);

/**
 * Identifies a specific Envoy instance. The node identifier is presented to the
 * management server, which may use this identifier to distinguish per Envoy
 * configuration for serving.
 * [#next-free-field: 12]
 *
 * @generated from message envoy.api.v2.core.Node
 */
export const Node = proto3.makeMessageType(
  "envoy.api.v2.core.Node",
  () => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: Struct },
    { no: 4, name: "locality", kind: "message", T: Locality },
    { no: 5, name: "build_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "user_agent_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "user_agent_version", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "user_agent_version_type" },
    { no: 8, name: "user_agent_build_version", kind: "message", T: BuildVersion, oneof: "user_agent_version_type" },
    { no: 9, name: "extensions", kind: "message", T: Extension, repeated: true },
    { no: 10, name: "client_features", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 11, name: "listening_addresses", kind: "message", T: Address, repeated: true },
  ],
);

/**
 * Metadata provides additional inputs to filters based on matched listeners,
 * filter chains, routes and endpoints. It is structured as a map, usually from
 * filter name (in reverse DNS format) to metadata specific to the filter. Metadata
 * key-values for a filter are merged as connection and request handling occurs,
 * with later values for the same key overriding earlier values.
 *
 * An example use of metadata is providing additional values to
 * http_connection_manager in the envoy.http_connection_manager.access_log
 * namespace.
 *
 * Another example use of metadata is to per service config info in cluster metadata, which may get
 * consumed by multiple filters.
 *
 * For load balancing, Metadata provides a means to subset cluster endpoints.
 * Endpoints have a Metadata object associated and routes contain a Metadata
 * object to match against. There are some well defined metadata used today for
 * this purpose:
 *
 * * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
 *   endpoint and is also used during header processing
 *   (x-envoy-upstream-canary) and for stats purposes.
 * [#next-major-version: move to type/metadata/v2]
 *
 * @generated from message envoy.api.v2.core.Metadata
 */
export const Metadata = proto3.makeMessageType(
  "envoy.api.v2.core.Metadata",
  () => [
    { no: 1, name: "filter_metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Struct} },
  ],
);

/**
 * Runtime derived uint32 with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeUInt32
 */
export const RuntimeUInt32 = proto3.makeMessageType(
  "envoy.api.v2.core.RuntimeUInt32",
  () => [
    { no: 2, name: "default_value", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Runtime derived double with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeDouble
 */
export const RuntimeDouble = proto3.makeMessageType(
  "envoy.api.v2.core.RuntimeDouble",
  () => [
    { no: 1, name: "default_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Runtime derived bool with a default when not specified.
 *
 * @generated from message envoy.api.v2.core.RuntimeFeatureFlag
 */
export const RuntimeFeatureFlag = proto3.makeMessageType(
  "envoy.api.v2.core.RuntimeFeatureFlag",
  () => [
    { no: 1, name: "default_value", kind: "message", T: BoolValue },
    { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Header name/value pair.
 *
 * @generated from message envoy.api.v2.core.HeaderValue
 */
export const HeaderValue = proto3.makeMessageType(
  "envoy.api.v2.core.HeaderValue",
  () => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Header name/value pair plus option to control append behavior.
 *
 * @generated from message envoy.api.v2.core.HeaderValueOption
 */
export const HeaderValueOption = proto3.makeMessageType(
  "envoy.api.v2.core.HeaderValueOption",
  () => [
    { no: 1, name: "header", kind: "message", T: HeaderValue },
    { no: 2, name: "append", kind: "message", T: BoolValue },
  ],
);

/**
 * Wrapper for a set of headers.
 *
 * @generated from message envoy.api.v2.core.HeaderMap
 */
export const HeaderMap = proto3.makeMessageType(
  "envoy.api.v2.core.HeaderMap",
  () => [
    { no: 1, name: "headers", kind: "message", T: HeaderValue, repeated: true },
  ],
);

/**
 * Data source consisting of either a file or an inline value.
 *
 * @generated from message envoy.api.v2.core.DataSource
 */
export const DataSource = proto3.makeMessageType(
  "envoy.api.v2.core.DataSource",
  () => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "specifier" },
    { no: 2, name: "inline_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "specifier" },
    { no: 3, name: "inline_string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "specifier" },
  ],
);

/**
 * The message specifies the retry policy of remote data source when fetching fails.
 *
 * @generated from message envoy.api.v2.core.RetryPolicy
 */
export const RetryPolicy = proto3.makeMessageType(
  "envoy.api.v2.core.RetryPolicy",
  () => [
    { no: 1, name: "retry_back_off", kind: "message", T: BackoffStrategy },
    { no: 2, name: "num_retries", kind: "message", T: UInt32Value },
  ],
);

/**
 * The message specifies how to fetch data from remote and how to verify it.
 *
 * @generated from message envoy.api.v2.core.RemoteDataSource
 */
export const RemoteDataSource = proto3.makeMessageType(
  "envoy.api.v2.core.RemoteDataSource",
  () => [
    { no: 1, name: "http_uri", kind: "message", T: HttpUri },
    { no: 2, name: "sha256", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "retry_policy", kind: "message", T: RetryPolicy },
  ],
);

/**
 * Async data source which support async data fetch.
 *
 * @generated from message envoy.api.v2.core.AsyncDataSource
 */
export const AsyncDataSource = proto3.makeMessageType(
  "envoy.api.v2.core.AsyncDataSource",
  () => [
    { no: 1, name: "local", kind: "message", T: DataSource, oneof: "specifier" },
    { no: 2, name: "remote", kind: "message", T: RemoteDataSource, oneof: "specifier" },
  ],
);

/**
 * Configuration for transport socket in :ref:`listeners <config_listeners>` and
 * :ref:`clusters <envoy_api_msg_Cluster>`. If the configuration is
 * empty, a default transport socket implementation and configuration will be
 * chosen based on the platform and existence of tls_context.
 *
 * @generated from message envoy.api.v2.core.TransportSocket
 */
export const TransportSocket = proto3.makeMessageType(
  "envoy.api.v2.core.TransportSocket",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: Struct, oneof: "config_type" },
    { no: 3, name: "typed_config", kind: "message", T: Any, oneof: "config_type" },
  ],
);

/**
 * Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
 * specified via a runtime key.
 *
 * .. note::
 *
 *   Parsing of the runtime key's data is implemented such that it may be represented as a
 *   :ref:`FractionalPercent <envoy_api_msg_type.FractionalPercent>` proto represented as JSON/YAML
 *   and may also be represented as an integer with the assumption that the value is an integral
 *   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
 *   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.
 *
 * @generated from message envoy.api.v2.core.RuntimeFractionalPercent
 */
export const RuntimeFractionalPercent = proto3.makeMessageType(
  "envoy.api.v2.core.RuntimeFractionalPercent",
  () => [
    { no: 1, name: "default_value", kind: "message", T: FractionalPercent },
    { no: 2, name: "runtime_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Identifies a specific ControlPlane instance that Envoy is connected to.
 *
 * @generated from message envoy.api.v2.core.ControlPlane
 */
export const ControlPlane = proto3.makeMessageType(
  "envoy.api.v2.core.ControlPlane",
  () => [
    { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

