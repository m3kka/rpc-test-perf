// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/api/v2/auth/common.proto" (package "envoy.api.v2.auth", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BoolValue } from "../../../../google/protobuf/wrappers";
import { StringMatcher } from "../../../type/matcher/string";
import { DataSource } from "../core/base";
import { Any } from "../../../../google/protobuf/any";
import { Struct } from "../../../../google/protobuf/struct";
// [#protodoc-title: Common TLS configuration]

/**
 * @generated from protobuf message envoy.api.v2.auth.TlsParameters
 */
export interface TlsParameters {
    /**
     * Minimum TLS protocol version. By default, it's ``TLSv1_2`` for both clients and servers.
     *
     * @generated from protobuf field: envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1;
     */
    tlsMinimumProtocolVersion: TlsParameters_TlsProtocol;
    /**
     * Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
     * servers.
     *
     * @generated from protobuf field: envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2;
     */
    tlsMaximumProtocolVersion: TlsParameters_TlsProtocol;
    /**
     * If specified, the TLS listener will only support the specified `cipher list
     * <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
     * when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not
     * specified, the default list will be used.
     *
     * In non-FIPS builds, the default cipher list is:
     *
     * .. code-block:: none
     *
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     *
     * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default cipher list is:
     *
     * .. code-block:: none
     *
     *   ECDHE-ECDSA-AES128-GCM-SHA256
     *   ECDHE-RSA-AES128-GCM-SHA256
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     *
     * @generated from protobuf field: repeated string cipher_suites = 3;
     */
    cipherSuites: string[];
    /**
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves will be used.
     *
     * In non-FIPS builds, the default curves are:
     *
     * .. code-block:: none
     *
     *   X25519
     *   P-256
     *
     * In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
     *
     * .. code-block:: none
     *
     *   P-256
     *
     * @generated from protobuf field: repeated string ecdh_curves = 4;
     */
    ecdhCurves: string[];
}
/**
 * @generated from protobuf enum envoy.api.v2.auth.TlsParameters.TlsProtocol
 */
export enum TlsParameters_TlsProtocol {
    /**
     * Envoy will choose the optimal TLS version.
     *
     * @generated from protobuf enum value: TLS_AUTO = 0;
     */
    TLS_AUTO = 0,
    /**
     * TLS 1.0
     *
     * @generated from protobuf enum value: TLSv1_0 = 1;
     */
    TLSv1_0 = 1,
    /**
     * TLS 1.1
     *
     * @generated from protobuf enum value: TLSv1_1 = 2;
     */
    TLSv1_1 = 2,
    /**
     * TLS 1.2
     *
     * @generated from protobuf enum value: TLSv1_2 = 3;
     */
    TLSv1_2 = 3,
    /**
     * TLS 1.3
     *
     * @generated from protobuf enum value: TLSv1_3 = 4;
     */
    TLSv1_3 = 4
}
/**
 * BoringSSL private key method configuration. The private key methods are used for external
 * (potentially asynchronous) signing and decryption operations. Some use cases for private key
 * methods would be TPM support and TLS acceleration.
 *
 * @generated from protobuf message envoy.api.v2.auth.PrivateKeyProvider
 */
export interface PrivateKeyProvider {
    /**
     * Private key method provider name. The name must match a
     * supported private key method provider type.
     *
     * @generated from protobuf field: string provider_name = 1;
     */
    providerName: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "config";
        /**
         * @deprecated
         * @generated from protobuf field: google.protobuf.Struct config = 2 [deprecated = true];
         */
        config: Struct;
    } | {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.api.v2.auth.TlsCertificate
 */
export interface TlsCertificate {
    /**
     * The TLS certificate chain.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource certificate_chain = 1;
     */
    certificateChain?: DataSource;
    /**
     * The TLS private key.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource private_key = 2;
     */
    privateKey?: DataSource;
    /**
     * BoringSSL private key method provider. This is an alternative to :ref:`private_key
     * <envoy_api_field_auth.TlsCertificate.private_key>` field. This can't be
     * marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
     * <envoy_api_field_auth.TlsCertificate.private_key>` and
     * :ref:`private_key_provider
     * <envoy_api_field_auth.TlsCertificate.private_key_provider>` fields will result in an
     * error.
     *
     * @generated from protobuf field: envoy.api.v2.auth.PrivateKeyProvider private_key_provider = 6;
     */
    privateKeyProvider?: PrivateKeyProvider;
    /**
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource password = 3;
     */
    password?: DataSource;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource ocsp_staple = 4;
     */
    ocspStaple?: DataSource;
    /**
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;
     */
    signedCertificateTimestamp: DataSource[];
}
/**
 * @generated from protobuf message envoy.api.v2.auth.TlsSessionTicketKeys
 */
export interface TlsSessionTicketKeys {
    /**
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     *
     * If :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     *
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     *
     * .. attention::
     *
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     *
     * @generated from protobuf field: repeated envoy.api.v2.core.DataSource keys = 1;
     */
    keys: DataSource[];
}
/**
 * [#next-free-field: 11]
 *
 * @generated from protobuf message envoy.api.v2.auth.CertificateValidationContext
 */
export interface CertificateValidationContext {
    /**
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * <envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,
     * :ref:`verify_certificate_spki
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,
     * :ref:`verify_certificate_hash
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or
     * :ref:`match_subject_alt_names
     * <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>`) is also
     * specified.
     *
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     *
     * See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
     * system CA locations.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource trusted_ca = 1;
     */
    trustedCa?: DataSource;
    /**
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     *
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey
     *     | openssl pkey -pubin -outform DER
     *     | openssl dgst -sha256 -binary
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     *
     * This is the format used in HTTP Public Key Pinning.
     *
     * When both:
     * :ref:`verify_certificate_hash
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
     * :ref:`verify_certificate_spki
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     *
     * .. attention::
     *
     *   This option is preferred over :ref:`verify_certificate_hash
     *   <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     *
     * @generated from protobuf field: repeated string verify_certificate_spki = 3;
     */
    verifyCertificateSpki: string[];
    /**
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     *
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     *
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     *
     * .. code-block:: bash
     *
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     *
     * Both of those formats are acceptable.
     *
     * When both:
     * :ref:`verify_certificate_hash
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and
     * :ref:`verify_certificate_spki
     * <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     *
     * @generated from protobuf field: repeated string verify_certificate_hash = 2;
     */
    verifyCertificateHash: string[];
    /**
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     *
     * .. attention::
     *
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
     *
     * @deprecated
     * @generated from protobuf field: repeated string verify_subject_alt_name = 4 [deprecated = true];
     */
    verifySubjectAltName: string[];
    /**
     * An optional list of Subject Alternative name matchers. Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified matches.
     *
     * When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
     * configured with exact match type in the :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>`.
     * For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
     * it should be configured as shown below.
     *
     * .. code-block:: yaml
     *
     *  match_subject_alt_names:
     *    exact: "api.example.com"
     *
     * .. attention::
     *
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`.
     *
     * @generated from protobuf field: repeated envoy.type.matcher.StringMatcher match_subject_alt_names = 9;
     */
    matchSubjectAltNames: StringMatcher[];
    /**
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     *
     * @generated from protobuf field: google.protobuf.BoolValue require_ocsp_staple = 5;
     */
    requireOcspStaple?: BoolValue;
    /**
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     *
     * @generated from protobuf field: google.protobuf.BoolValue require_signed_certificate_timestamp = 6;
     */
    requireSignedCertificateTimestamp?: BoolValue;
    /**
     * An optional `certificate revocation list
     * <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     *
     * @generated from protobuf field: envoy.api.v2.core.DataSource crl = 7;
     */
    crl?: DataSource;
    /**
     * If specified, Envoy will not reject expired certificates.
     *
     * @generated from protobuf field: bool allow_expired_certificate = 8;
     */
    allowExpiredCertificate: boolean;
    /**
     * Certificate trust chain verification mode.
     *
     * @generated from protobuf field: envoy.api.v2.auth.CertificateValidationContext.TrustChainVerification trust_chain_verification = 10;
     */
    trustChainVerification: CertificateValidationContext_TrustChainVerification;
}
/**
 * Peer certificate verification mode.
 *
 * @generated from protobuf enum envoy.api.v2.auth.CertificateValidationContext.TrustChainVerification
 */
export enum CertificateValidationContext_TrustChainVerification {
    /**
     * Perform default certificate verification (e.g., against CA / verification lists)
     *
     * @generated from protobuf enum value: VERIFY_TRUST_CHAIN = 0;
     */
    VERIFY_TRUST_CHAIN = 0,
    /**
     * Connections where the certificate fails verification will be permitted.
     * For HTTP connections, the result of certificate verification can be used in route matching. (
     * see :ref:`validated <envoy_api_field_route.RouteMatch.TlsContextMatchOptions.validated>` ).
     *
     * @generated from protobuf enum value: ACCEPT_UNTRUSTED = 1;
     */
    ACCEPT_UNTRUSTED = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class TlsParameters$Type extends MessageType<TlsParameters> {
    constructor() {
        super("envoy.api.v2.auth.TlsParameters", [
            { no: 1, name: "tls_minimum_protocol_version", kind: "enum", T: () => ["envoy.api.v2.auth.TlsParameters.TlsProtocol", TlsParameters_TlsProtocol], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "tls_maximum_protocol_version", kind: "enum", T: () => ["envoy.api.v2.auth.TlsParameters.TlsProtocol", TlsParameters_TlsProtocol], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 3, name: "cipher_suites", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "ecdh_curves", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TlsParameters>): TlsParameters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tlsMinimumProtocolVersion = 0;
        message.tlsMaximumProtocolVersion = 0;
        message.cipherSuites = [];
        message.ecdhCurves = [];
        if (value !== undefined)
            reflectionMergePartial<TlsParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsParameters): TlsParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version */ 1:
                    message.tlsMinimumProtocolVersion = reader.int32();
                    break;
                case /* envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version */ 2:
                    message.tlsMaximumProtocolVersion = reader.int32();
                    break;
                case /* repeated string cipher_suites */ 3:
                    message.cipherSuites.push(reader.string());
                    break;
                case /* repeated string ecdh_curves */ 4:
                    message.ecdhCurves.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1; */
        if (message.tlsMinimumProtocolVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.tlsMinimumProtocolVersion);
        /* envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2; */
        if (message.tlsMaximumProtocolVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.tlsMaximumProtocolVersion);
        /* repeated string cipher_suites = 3; */
        for (let i = 0; i < message.cipherSuites.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.cipherSuites[i]);
        /* repeated string ecdh_curves = 4; */
        for (let i = 0; i < message.ecdhCurves.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.ecdhCurves[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.auth.TlsParameters
 */
export const TlsParameters = new TlsParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrivateKeyProvider$Type extends MessageType<PrivateKeyProvider> {
    constructor() {
        super("envoy.api.v2.auth.PrivateKeyProvider", [
            { no: 1, name: "provider_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minBytes: "1" } } } },
            { no: 2, name: "config", kind: "message", oneof: "configType", T: () => Struct, options: { "udpa.annotations.sensitive": true } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any, options: { "udpa.annotations.sensitive": true } }
        ]);
    }
    create(value?: PartialMessage<PrivateKeyProvider>): PrivateKeyProvider {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.providerName = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<PrivateKeyProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrivateKeyProvider): PrivateKeyProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider_name */ 1:
                    message.providerName = reader.string();
                    break;
                case /* google.protobuf.Struct config = 2 [deprecated = true];*/ 2:
                    message.configType = {
                        oneofKind: "config",
                        config: Struct.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).config)
                    };
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrivateKeyProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider_name = 1; */
        if (message.providerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.providerName);
        /* google.protobuf.Struct config = 2 [deprecated = true]; */
        if (message.configType.oneofKind === "config")
            Struct.internalBinaryWrite(message.configType.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.auth.PrivateKeyProvider
 */
export const PrivateKeyProvider = new PrivateKeyProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TlsCertificate$Type extends MessageType<TlsCertificate> {
    constructor() {
        super("envoy.api.v2.auth.TlsCertificate", [
            { no: 1, name: "certificate_chain", kind: "message", T: () => DataSource },
            { no: 2, name: "private_key", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 6, name: "private_key_provider", kind: "message", T: () => PrivateKeyProvider },
            { no: 3, name: "password", kind: "message", T: () => DataSource, options: { "udpa.annotations.sensitive": true } },
            { no: 4, name: "ocsp_staple", kind: "message", T: () => DataSource },
            { no: 5, name: "signed_certificate_timestamp", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataSource }
        ]);
    }
    create(value?: PartialMessage<TlsCertificate>): TlsCertificate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signedCertificateTimestamp = [];
        if (value !== undefined)
            reflectionMergePartial<TlsCertificate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsCertificate): TlsCertificate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.DataSource certificate_chain */ 1:
                    message.certificateChain = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.certificateChain);
                    break;
                case /* envoy.api.v2.core.DataSource private_key */ 2:
                    message.privateKey = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.privateKey);
                    break;
                case /* envoy.api.v2.auth.PrivateKeyProvider private_key_provider */ 6:
                    message.privateKeyProvider = PrivateKeyProvider.internalBinaryRead(reader, reader.uint32(), options, message.privateKeyProvider);
                    break;
                case /* envoy.api.v2.core.DataSource password */ 3:
                    message.password = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.password);
                    break;
                case /* envoy.api.v2.core.DataSource ocsp_staple */ 4:
                    message.ocspStaple = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.ocspStaple);
                    break;
                case /* repeated envoy.api.v2.core.DataSource signed_certificate_timestamp */ 5:
                    message.signedCertificateTimestamp.push(DataSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsCertificate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.DataSource certificate_chain = 1; */
        if (message.certificateChain)
            DataSource.internalBinaryWrite(message.certificateChain, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource private_key = 2; */
        if (message.privateKey)
            DataSource.internalBinaryWrite(message.privateKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.auth.PrivateKeyProvider private_key_provider = 6; */
        if (message.privateKeyProvider)
            PrivateKeyProvider.internalBinaryWrite(message.privateKeyProvider, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource password = 3; */
        if (message.password)
            DataSource.internalBinaryWrite(message.password, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource ocsp_staple = 4; */
        if (message.ocspStaple)
            DataSource.internalBinaryWrite(message.ocspStaple, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.api.v2.core.DataSource signed_certificate_timestamp = 5; */
        for (let i = 0; i < message.signedCertificateTimestamp.length; i++)
            DataSource.internalBinaryWrite(message.signedCertificateTimestamp[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.auth.TlsCertificate
 */
export const TlsCertificate = new TlsCertificate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TlsSessionTicketKeys$Type extends MessageType<TlsSessionTicketKeys> {
    constructor() {
        super("envoy.api.v2.auth.TlsSessionTicketKeys", [
            { no: 1, name: "keys", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataSource, options: { "validate.rules": { repeated: { minItems: "1" } }, "udpa.annotations.sensitive": true } }
        ]);
    }
    create(value?: PartialMessage<TlsSessionTicketKeys>): TlsSessionTicketKeys {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<TlsSessionTicketKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TlsSessionTicketKeys): TlsSessionTicketKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.api.v2.core.DataSource keys */ 1:
                    message.keys.push(DataSource.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TlsSessionTicketKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.api.v2.core.DataSource keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            DataSource.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.auth.TlsSessionTicketKeys
 */
export const TlsSessionTicketKeys = new TlsSessionTicketKeys$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CertificateValidationContext$Type extends MessageType<CertificateValidationContext> {
    constructor() {
        super("envoy.api.v2.auth.CertificateValidationContext", [
            { no: 1, name: "trusted_ca", kind: "message", T: () => DataSource },
            { no: 3, name: "verify_certificate_spki", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minBytes: "44", maxBytes: "44" } } } } } },
            { no: 2, name: "verify_certificate_hash", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { repeated: { items: { string: { minBytes: "64", maxBytes: "95" } } } } } },
            { no: 4, name: "verify_subject_alt_name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "match_subject_alt_names", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => StringMatcher },
            { no: 5, name: "require_ocsp_staple", kind: "message", T: () => BoolValue },
            { no: 6, name: "require_signed_certificate_timestamp", kind: "message", T: () => BoolValue },
            { no: 7, name: "crl", kind: "message", T: () => DataSource },
            { no: 8, name: "allow_expired_certificate", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "trust_chain_verification", kind: "enum", T: () => ["envoy.api.v2.auth.CertificateValidationContext.TrustChainVerification", CertificateValidationContext_TrustChainVerification], options: { "validate.rules": { enum: { definedOnly: true } } } }
        ]);
    }
    create(value?: PartialMessage<CertificateValidationContext>): CertificateValidationContext {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.verifyCertificateSpki = [];
        message.verifyCertificateHash = [];
        message.verifySubjectAltName = [];
        message.matchSubjectAltNames = [];
        message.allowExpiredCertificate = false;
        message.trustChainVerification = 0;
        if (value !== undefined)
            reflectionMergePartial<CertificateValidationContext>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CertificateValidationContext): CertificateValidationContext {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.api.v2.core.DataSource trusted_ca */ 1:
                    message.trustedCa = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.trustedCa);
                    break;
                case /* repeated string verify_certificate_spki */ 3:
                    message.verifyCertificateSpki.push(reader.string());
                    break;
                case /* repeated string verify_certificate_hash */ 2:
                    message.verifyCertificateHash.push(reader.string());
                    break;
                case /* repeated string verify_subject_alt_name = 4 [deprecated = true];*/ 4:
                    message.verifySubjectAltName.push(reader.string());
                    break;
                case /* repeated envoy.type.matcher.StringMatcher match_subject_alt_names */ 9:
                    message.matchSubjectAltNames.push(StringMatcher.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.BoolValue require_ocsp_staple */ 5:
                    message.requireOcspStaple = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.requireOcspStaple);
                    break;
                case /* google.protobuf.BoolValue require_signed_certificate_timestamp */ 6:
                    message.requireSignedCertificateTimestamp = BoolValue.internalBinaryRead(reader, reader.uint32(), options, message.requireSignedCertificateTimestamp);
                    break;
                case /* envoy.api.v2.core.DataSource crl */ 7:
                    message.crl = DataSource.internalBinaryRead(reader, reader.uint32(), options, message.crl);
                    break;
                case /* bool allow_expired_certificate */ 8:
                    message.allowExpiredCertificate = reader.bool();
                    break;
                case /* envoy.api.v2.auth.CertificateValidationContext.TrustChainVerification trust_chain_verification */ 10:
                    message.trustChainVerification = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CertificateValidationContext, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.api.v2.core.DataSource trusted_ca = 1; */
        if (message.trustedCa)
            DataSource.internalBinaryWrite(message.trustedCa, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string verify_certificate_spki = 3; */
        for (let i = 0; i < message.verifyCertificateSpki.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.verifyCertificateSpki[i]);
        /* repeated string verify_certificate_hash = 2; */
        for (let i = 0; i < message.verifyCertificateHash.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.verifyCertificateHash[i]);
        /* repeated string verify_subject_alt_name = 4 [deprecated = true]; */
        for (let i = 0; i < message.verifySubjectAltName.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.verifySubjectAltName[i]);
        /* repeated envoy.type.matcher.StringMatcher match_subject_alt_names = 9; */
        for (let i = 0; i < message.matchSubjectAltNames.length; i++)
            StringMatcher.internalBinaryWrite(message.matchSubjectAltNames[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue require_ocsp_staple = 5; */
        if (message.requireOcspStaple)
            BoolValue.internalBinaryWrite(message.requireOcspStaple, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.BoolValue require_signed_certificate_timestamp = 6; */
        if (message.requireSignedCertificateTimestamp)
            BoolValue.internalBinaryWrite(message.requireSignedCertificateTimestamp, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* envoy.api.v2.core.DataSource crl = 7; */
        if (message.crl)
            DataSource.internalBinaryWrite(message.crl, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* bool allow_expired_certificate = 8; */
        if (message.allowExpiredCertificate !== false)
            writer.tag(8, WireType.Varint).bool(message.allowExpiredCertificate);
        /* envoy.api.v2.auth.CertificateValidationContext.TrustChainVerification trust_chain_verification = 10; */
        if (message.trustChainVerification !== 0)
            writer.tag(10, WireType.Varint).int32(message.trustChainVerification);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.api.v2.auth.CertificateValidationContext
 */
export const CertificateValidationContext = new CertificateValidationContext$Type();
