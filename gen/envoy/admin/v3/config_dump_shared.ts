// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/admin/v3/config_dump_shared.proto" (package "envoy.admin.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Any } from "../../../google/protobuf/any";
/**
 * @generated from protobuf message envoy.admin.v3.UpdateFailureState
 */
export interface UpdateFailureState {
    /**
     * What the component configuration would have been if the update had succeeded.
     * This field may not be populated by xDS clients due to storage overhead.
     *
     * @generated from protobuf field: google.protobuf.Any failed_configuration = 1;
     */
    failedConfiguration?: Any;
    /**
     * Time of the latest failed update attempt.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_update_attempt = 2;
     */
    lastUpdateAttempt?: Timestamp;
    /**
     * Details about the last failed update attempt.
     *
     * @generated from protobuf field: string details = 3;
     */
    details: string;
    /**
     * This is the version of the rejected resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: string version_info = 4;
     */
    versionInfo: string;
}
/**
 * Envoy's listener manager fills this message with all currently known listeners. Listener
 * configuration information can be used to recreate an Envoy configuration by populating all
 * listeners as static listeners or by returning them in a LDS response.
 *
 * @generated from protobuf message envoy.admin.v3.ListenersConfigDump
 */
export interface ListenersConfigDump {
    /**
     * This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
     * last processed LDS discovery response. If there are only static bootstrap listeners, this field
     * will be "".
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The statically loaded listener configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ListenersConfigDump.StaticListener static_listeners = 2;
     */
    staticListeners: ListenersConfigDump_StaticListener[];
    /**
     * State for any warming, active, or draining listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ListenersConfigDump.DynamicListener dynamic_listeners = 3;
     */
    dynamicListeners: ListenersConfigDump_DynamicListener[];
}
/**
 * Describes a statically loaded listener.
 *
 * @generated from protobuf message envoy.admin.v3.ListenersConfigDump.StaticListener
 */
export interface ListenersConfigDump_StaticListener {
    /**
     * The listener config.
     *
     * @generated from protobuf field: google.protobuf.Any listener = 1;
     */
    listener?: Any;
    /**
     * The timestamp when the Listener was last successfully updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * @generated from protobuf message envoy.admin.v3.ListenersConfigDump.DynamicListenerState
 */
export interface ListenersConfigDump_DynamicListenerState {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
     * that the listener was loaded. In the future, discrete per-listener versions may be supported
     * by the API.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The listener config.
     *
     * @generated from protobuf field: google.protobuf.Any listener = 2;
     */
    listener?: Any;
    /**
     * The timestamp when the Listener was last successfully updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * Describes a dynamically loaded listener via the LDS API.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.admin.v3.ListenersConfigDump.DynamicListener
 */
export interface ListenersConfigDump_DynamicListener {
    /**
     * The name or unique id of this listener, pulled from the DynamicListenerState config.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The listener state for any active listener by this name.
     * These are listeners that are available to service data plane traffic.
     *
     * @generated from protobuf field: envoy.admin.v3.ListenersConfigDump.DynamicListenerState active_state = 2;
     */
    activeState?: ListenersConfigDump_DynamicListenerState;
    /**
     * The listener state for any warming listener by this name.
     * These are listeners that are currently undergoing warming in preparation to service data
     * plane traffic. Note that if attempting to recreate an Envoy configuration from a
     * configuration dump, the warming listeners should generally be discarded.
     *
     * @generated from protobuf field: envoy.admin.v3.ListenersConfigDump.DynamicListenerState warming_state = 3;
     */
    warmingState?: ListenersConfigDump_DynamicListenerState;
    /**
     * The listener state for any draining listener by this name.
     * These are listeners that are currently undergoing draining in preparation to stop servicing
     * data plane traffic. Note that if attempting to recreate an Envoy configuration from a
     * configuration dump, the draining listeners should generally be discarded.
     *
     * @generated from protobuf field: envoy.admin.v3.ListenersConfigDump.DynamicListenerState draining_state = 4;
     */
    drainingState?: ListenersConfigDump_DynamicListenerState;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 5;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 6;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * Envoy's cluster manager fills this message with all currently known clusters. Cluster
 * configuration information can be used to recreate an Envoy configuration by populating all
 * clusters as static clusters or by returning them in a CDS response.
 *
 * @generated from protobuf message envoy.admin.v3.ClustersConfigDump
 */
export interface ClustersConfigDump {
    /**
     * This is the :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` in the
     * last processed CDS discovery response. If there are only static bootstrap clusters, this field
     * will be "".
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The statically loaded cluster configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ClustersConfigDump.StaticCluster static_clusters = 2;
     */
    staticClusters: ClustersConfigDump_StaticCluster[];
    /**
     * The dynamically loaded active clusters. These are clusters that are available to service
     * data plane traffic.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_active_clusters = 3;
     */
    dynamicActiveClusters: ClustersConfigDump_DynamicCluster[];
    /**
     * The dynamically loaded warming clusters. These are clusters that are currently undergoing
     * warming in preparation to service data plane traffic. Note that if attempting to recreate an
     * Envoy configuration from a configuration dump, the warming clusters should generally be
     * discarded.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_warming_clusters = 4;
     */
    dynamicWarmingClusters: ClustersConfigDump_DynamicCluster[];
}
/**
 * Describes a statically loaded cluster.
 *
 * @generated from protobuf message envoy.admin.v3.ClustersConfigDump.StaticCluster
 */
export interface ClustersConfigDump_StaticCluster {
    /**
     * The cluster config.
     *
     * @generated from protobuf field: google.protobuf.Any cluster = 1;
     */
    cluster?: Any;
    /**
     * The timestamp when the Cluster was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * Describes a dynamically loaded cluster via the CDS API.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.admin.v3.ClustersConfigDump.DynamicCluster
 */
export interface ClustersConfigDump_DynamicCluster {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time
     * that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
     * the API.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The cluster config.
     *
     * @generated from protobuf field: google.protobuf.Any cluster = 2;
     */
    cluster?: Any;
    /**
     * The timestamp when the Cluster was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 4;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 5;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * Envoy's RDS implementation fills this message with all currently loaded routes, as described by
 * their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
 * or defined inline while configuring listeners are separated from those configured dynamically via RDS.
 * Route configuration information can be used to recreate an Envoy configuration by populating all routes
 * as static routes or by returning them in RDS responses.
 *
 * @generated from protobuf message envoy.admin.v3.RoutesConfigDump
 */
export interface RoutesConfigDump {
    /**
     * The statically loaded route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.RoutesConfigDump.StaticRouteConfig static_route_configs = 2;
     */
    staticRouteConfigs: RoutesConfigDump_StaticRouteConfig[];
    /**
     * The dynamically loaded route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs = 3;
     */
    dynamicRouteConfigs: RoutesConfigDump_DynamicRouteConfig[];
}
/**
 * @generated from protobuf message envoy.admin.v3.RoutesConfigDump.StaticRouteConfig
 */
export interface RoutesConfigDump_StaticRouteConfig {
    /**
     * The route config.
     *
     * @generated from protobuf field: google.protobuf.Any route_config = 1;
     */
    routeConfig?: Any;
    /**
     * The timestamp when the Route was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig
 */
export interface RoutesConfigDump_DynamicRouteConfig {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
     * the route configuration was loaded.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The route config.
     *
     * @generated from protobuf field: google.protobuf.Any route_config = 2;
     */
    routeConfig?: Any;
    /**
     * The timestamp when the Route was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 4;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 5;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * Envoy's scoped RDS implementation fills this message with all currently loaded route
 * configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
 * the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
 * dynamically obtained scopes via the SRDS API.
 *
 * @generated from protobuf message envoy.admin.v3.ScopedRoutesConfigDump
 */
export interface ScopedRoutesConfigDump {
    /**
     * The statically loaded scoped route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs = 1;
     */
    inlineScopedRouteConfigs: ScopedRoutesConfigDump_InlineScopedRouteConfigs[];
    /**
     * The dynamically loaded scoped route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2;
     */
    dynamicScopedRouteConfigs: ScopedRoutesConfigDump_DynamicScopedRouteConfigs[];
}
/**
 * @generated from protobuf message envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs
 */
export interface ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    /**
     * The name assigned to the scoped route configurations.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The scoped route configurations.
     *
     * @generated from protobuf field: repeated google.protobuf.Any scoped_route_configs = 2;
     */
    scopedRouteConfigs: Any[];
    /**
     * The timestamp when the scoped route config set was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs
 */
export interface ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    /**
     * The name assigned to the scoped route configurations.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
     * the scoped routes configuration was loaded.
     *
     * @generated from protobuf field: string version_info = 2;
     */
    versionInfo: string;
    /**
     * The scoped route configurations.
     *
     * @generated from protobuf field: repeated google.protobuf.Any scoped_route_configs = 3;
     */
    scopedRouteConfigs: Any[];
    /**
     * The timestamp when the scoped route config set was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 4;
     */
    lastUpdated?: Timestamp;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 5;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 6;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * Envoy's admin fill this message with all currently known endpoints. Endpoint
 * configuration information can be used to recreate an Envoy configuration by populating all
 * endpoints as static endpoints or by returning them in an EDS response.
 *
 * @generated from protobuf message envoy.admin.v3.EndpointsConfigDump
 */
export interface EndpointsConfigDump {
    /**
     * The statically loaded endpoint configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig static_endpoint_configs = 2;
     */
    staticEndpointConfigs: EndpointsConfigDump_StaticEndpointConfig[];
    /**
     * The dynamically loaded endpoint configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig dynamic_endpoint_configs = 3;
     */
    dynamicEndpointConfigs: EndpointsConfigDump_DynamicEndpointConfig[];
}
/**
 * @generated from protobuf message envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig
 */
export interface EndpointsConfigDump_StaticEndpointConfig {
    /**
     * The endpoint config.
     *
     * @generated from protobuf field: google.protobuf.Any endpoint_config = 1;
     */
    endpointConfig?: Any;
    /**
     * [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig
 */
export interface EndpointsConfigDump_DynamicEndpointConfig {
    /**
     * [#not-implemented-hide:] This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>` field at the time that
     * the endpoint configuration was loaded.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The endpoint config.
     *
     * @generated from protobuf field: google.protobuf.Any endpoint_config = 2;
     */
    endpointConfig?: Any;
    /**
     * [#not-implemented-hide:] The timestamp when the Endpoint was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 4;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 5;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * Envoy's ECDS service fills this message with all currently extension
 * configuration. Extension configuration information can be used to recreate
 * an Envoy ECDS listener and HTTP filters as static filters or by returning
 * them in ECDS response.
 *
 * @generated from protobuf message envoy.admin.v3.EcdsConfigDump
 */
export interface EcdsConfigDump {
    /**
     * The ECDS filter configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig ecds_filters = 1;
     */
    ecdsFilters: EcdsConfigDump_EcdsFilterConfig[];
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig
 */
export interface EcdsConfigDump_EcdsFilterConfig {
    /**
     * This is the per-resource version information. This version is currently
     * taken from the :ref:`version_info
     * <envoy_v3_api_field_service.discovery.v3.DiscoveryResponse.version_info>`
     * field at the time that the ECDS filter was loaded.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The ECDS filter config.
     *
     * @generated from protobuf field: google.protobuf.Any ecds_filter = 2;
     */
    ecdsFilter?: Any;
    /**
     * The timestamp when the ECDS filter was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The ``error_state`` field contains the rejected version of this
     * particular resource along with the reason and timestamp. For successfully
     * updated or acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 4;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 5;
     */
    clientStatus: ClientResourceStatus;
}
// [#protodoc-title: ConfigDump]

/**
 * Resource status from the view of a xDS client, which tells the synchronization
 * status between the xDS client and the xDS server.
 *
 * @generated from protobuf enum envoy.admin.v3.ClientResourceStatus
 */
export enum ClientResourceStatus {
    /**
     * Resource status is not available/unknown.
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * Client requested this resource but hasn't received any update from management
     * server. The client will not fail requests, but will queue them until update
     * arrives or the client times out waiting for the resource.
     *
     * @generated from protobuf enum value: REQUESTED = 1;
     */
    REQUESTED = 1,
    /**
     * This resource has been requested by the client but has either not been
     * delivered by the server or was previously delivered by the server and then
     * subsequently removed from resources provided by the server. For more
     * information, please refer to the :ref:`"Knowing When a Requested Resource
     * Does Not Exist" <xds_protocol_resource_not_existed>` section.
     *
     * @generated from protobuf enum value: DOES_NOT_EXIST = 2;
     */
    DOES_NOT_EXIST = 2,
    /**
     * Client received this resource and replied with ACK.
     *
     * @generated from protobuf enum value: ACKED = 3;
     */
    ACKED = 3,
    /**
     * Client received this resource and replied with NACK.
     *
     * @generated from protobuf enum value: NACKED = 4;
     */
    NACKED = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFailureState$Type extends MessageType<UpdateFailureState> {
    constructor() {
        super("envoy.admin.v3.UpdateFailureState", [
            { no: 1, name: "failed_configuration", kind: "message", T: () => Any },
            { no: 2, name: "last_update_attempt", kind: "message", T: () => Timestamp },
            { no: 3, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.UpdateFailureState" } });
    }
    create(value?: PartialMessage<UpdateFailureState>): UpdateFailureState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.details = "";
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFailureState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFailureState): UpdateFailureState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any failed_configuration */ 1:
                    message.failedConfiguration = Any.internalBinaryRead(reader, reader.uint32(), options, message.failedConfiguration);
                    break;
                case /* google.protobuf.Timestamp last_update_attempt */ 2:
                    message.lastUpdateAttempt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdateAttempt);
                    break;
                case /* string details */ 3:
                    message.details = reader.string();
                    break;
                case /* string version_info */ 4:
                    message.versionInfo = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateFailureState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any failed_configuration = 1; */
        if (message.failedConfiguration)
            Any.internalBinaryWrite(message.failedConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_update_attempt = 2; */
        if (message.lastUpdateAttempt)
            Timestamp.internalBinaryWrite(message.lastUpdateAttempt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string details = 3; */
        if (message.details !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.details);
        /* string version_info = 4; */
        if (message.versionInfo !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.versionInfo);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.UpdateFailureState
 */
export const UpdateFailureState = new UpdateFailureState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump$Type extends MessageType<ListenersConfigDump> {
    constructor() {
        super("envoy.admin.v3.ListenersConfigDump", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "static_listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenersConfigDump_StaticListener },
            { no: 3, name: "dynamic_listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenersConfigDump_DynamicListener }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ListenersConfigDump" } });
    }
    create(value?: PartialMessage<ListenersConfigDump>): ListenersConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.staticListeners = [];
        message.dynamicListeners = [];
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump): ListenersConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated envoy.admin.v3.ListenersConfigDump.StaticListener static_listeners */ 2:
                    message.staticListeners.push(ListenersConfigDump_StaticListener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.ListenersConfigDump.DynamicListener dynamic_listeners */ 3:
                    message.dynamicListeners.push(ListenersConfigDump_DynamicListener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated envoy.admin.v3.ListenersConfigDump.StaticListener static_listeners = 2; */
        for (let i = 0; i < message.staticListeners.length; i++)
            ListenersConfigDump_StaticListener.internalBinaryWrite(message.staticListeners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.ListenersConfigDump.DynamicListener dynamic_listeners = 3; */
        for (let i = 0; i < message.dynamicListeners.length; i++)
            ListenersConfigDump_DynamicListener.internalBinaryWrite(message.dynamicListeners[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ListenersConfigDump
 */
export const ListenersConfigDump = new ListenersConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_StaticListener$Type extends MessageType<ListenersConfigDump_StaticListener> {
    constructor() {
        super("envoy.admin.v3.ListenersConfigDump.StaticListener", [
            { no: 1, name: "listener", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ListenersConfigDump.StaticListener" } });
    }
    create(value?: PartialMessage<ListenersConfigDump_StaticListener>): ListenersConfigDump_StaticListener {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_StaticListener>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_StaticListener): ListenersConfigDump_StaticListener {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any listener */ 1:
                    message.listener = Any.internalBinaryRead(reader, reader.uint32(), options, message.listener);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_StaticListener, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any listener = 1; */
        if (message.listener)
            Any.internalBinaryWrite(message.listener, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ListenersConfigDump.StaticListener
 */
export const ListenersConfigDump_StaticListener = new ListenersConfigDump_StaticListener$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_DynamicListenerState$Type extends MessageType<ListenersConfigDump_DynamicListenerState> {
    constructor() {
        super("envoy.admin.v3.ListenersConfigDump.DynamicListenerState", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "listener", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState" } });
    }
    create(value?: PartialMessage<ListenersConfigDump_DynamicListenerState>): ListenersConfigDump_DynamicListenerState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_DynamicListenerState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_DynamicListenerState): ListenersConfigDump_DynamicListenerState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any listener */ 2:
                    message.listener = Any.internalBinaryRead(reader, reader.uint32(), options, message.listener);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_DynamicListenerState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any listener = 2; */
        if (message.listener)
            Any.internalBinaryWrite(message.listener, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ListenersConfigDump.DynamicListenerState
 */
export const ListenersConfigDump_DynamicListenerState = new ListenersConfigDump_DynamicListenerState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_DynamicListener$Type extends MessageType<ListenersConfigDump_DynamicListener> {
    constructor() {
        super("envoy.admin.v3.ListenersConfigDump.DynamicListener", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 3, name: "warming_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 4, name: "draining_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 5, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 6, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ListenersConfigDump.DynamicListener" } });
    }
    create(value?: PartialMessage<ListenersConfigDump_DynamicListener>): ListenersConfigDump_DynamicListener {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_DynamicListener>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_DynamicListener): ListenersConfigDump_DynamicListener {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState active_state */ 2:
                    message.activeState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.activeState);
                    break;
                case /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState warming_state */ 3:
                    message.warmingState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.warmingState);
                    break;
                case /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState draining_state */ 4:
                    message.drainingState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.drainingState);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 5:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 6:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_DynamicListener, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState active_state = 2; */
        if (message.activeState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.activeState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState warming_state = 3; */
        if (message.warmingState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.warmingState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ListenersConfigDump.DynamicListenerState draining_state = 4; */
        if (message.drainingState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.drainingState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 5; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 6; */
        if (message.clientStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ListenersConfigDump.DynamicListener
 */
export const ListenersConfigDump_DynamicListener = new ListenersConfigDump_DynamicListener$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump$Type extends MessageType<ClustersConfigDump> {
    constructor() {
        super("envoy.admin.v3.ClustersConfigDump", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "static_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_StaticCluster },
            { no: 3, name: "dynamic_active_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_DynamicCluster },
            { no: 4, name: "dynamic_warming_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_DynamicCluster }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ClustersConfigDump" } });
    }
    create(value?: PartialMessage<ClustersConfigDump>): ClustersConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.staticClusters = [];
        message.dynamicActiveClusters = [];
        message.dynamicWarmingClusters = [];
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump): ClustersConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated envoy.admin.v3.ClustersConfigDump.StaticCluster static_clusters */ 2:
                    message.staticClusters.push(ClustersConfigDump_StaticCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_active_clusters */ 3:
                    message.dynamicActiveClusters.push(ClustersConfigDump_DynamicCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_warming_clusters */ 4:
                    message.dynamicWarmingClusters.push(ClustersConfigDump_DynamicCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated envoy.admin.v3.ClustersConfigDump.StaticCluster static_clusters = 2; */
        for (let i = 0; i < message.staticClusters.length; i++)
            ClustersConfigDump_StaticCluster.internalBinaryWrite(message.staticClusters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_active_clusters = 3; */
        for (let i = 0; i < message.dynamicActiveClusters.length; i++)
            ClustersConfigDump_DynamicCluster.internalBinaryWrite(message.dynamicActiveClusters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.ClustersConfigDump.DynamicCluster dynamic_warming_clusters = 4; */
        for (let i = 0; i < message.dynamicWarmingClusters.length; i++)
            ClustersConfigDump_DynamicCluster.internalBinaryWrite(message.dynamicWarmingClusters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ClustersConfigDump
 */
export const ClustersConfigDump = new ClustersConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump_StaticCluster$Type extends MessageType<ClustersConfigDump_StaticCluster> {
    constructor() {
        super("envoy.admin.v3.ClustersConfigDump.StaticCluster", [
            { no: 1, name: "cluster", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ClustersConfigDump.StaticCluster" } });
    }
    create(value?: PartialMessage<ClustersConfigDump_StaticCluster>): ClustersConfigDump_StaticCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump_StaticCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump_StaticCluster): ClustersConfigDump_StaticCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any cluster */ 1:
                    message.cluster = Any.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump_StaticCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any cluster = 1; */
        if (message.cluster)
            Any.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ClustersConfigDump.StaticCluster
 */
export const ClustersConfigDump_StaticCluster = new ClustersConfigDump_StaticCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump_DynamicCluster$Type extends MessageType<ClustersConfigDump_DynamicCluster> {
    constructor() {
        super("envoy.admin.v3.ClustersConfigDump.DynamicCluster", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 5, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster" } });
    }
    create(value?: PartialMessage<ClustersConfigDump_DynamicCluster>): ClustersConfigDump_DynamicCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump_DynamicCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump_DynamicCluster): ClustersConfigDump_DynamicCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any cluster */ 2:
                    message.cluster = Any.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 4:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 5:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump_DynamicCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any cluster = 2; */
        if (message.cluster)
            Any.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 4; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 5; */
        if (message.clientStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ClustersConfigDump.DynamicCluster
 */
export const ClustersConfigDump_DynamicCluster = new ClustersConfigDump_DynamicCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump$Type extends MessageType<RoutesConfigDump> {
    constructor() {
        super("envoy.admin.v3.RoutesConfigDump", [
            { no: 2, name: "static_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutesConfigDump_StaticRouteConfig },
            { no: 3, name: "dynamic_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutesConfigDump_DynamicRouteConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.RoutesConfigDump" } });
    }
    create(value?: PartialMessage<RoutesConfigDump>): RoutesConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticRouteConfigs = [];
        message.dynamicRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump): RoutesConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.RoutesConfigDump.StaticRouteConfig static_route_configs */ 2:
                    message.staticRouteConfigs.push(RoutesConfigDump_StaticRouteConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs */ 3:
                    message.dynamicRouteConfigs.push(RoutesConfigDump_DynamicRouteConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.RoutesConfigDump.StaticRouteConfig static_route_configs = 2; */
        for (let i = 0; i < message.staticRouteConfigs.length; i++)
            RoutesConfigDump_StaticRouteConfig.internalBinaryWrite(message.staticRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs = 3; */
        for (let i = 0; i < message.dynamicRouteConfigs.length; i++)
            RoutesConfigDump_DynamicRouteConfig.internalBinaryWrite(message.dynamicRouteConfigs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.RoutesConfigDump
 */
export const RoutesConfigDump = new RoutesConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump_StaticRouteConfig$Type extends MessageType<RoutesConfigDump_StaticRouteConfig> {
    constructor() {
        super("envoy.admin.v3.RoutesConfigDump.StaticRouteConfig", [
            { no: 1, name: "route_config", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig" } });
    }
    create(value?: PartialMessage<RoutesConfigDump_StaticRouteConfig>): RoutesConfigDump_StaticRouteConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump_StaticRouteConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump_StaticRouteConfig): RoutesConfigDump_StaticRouteConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any route_config */ 1:
                    message.routeConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.routeConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump_StaticRouteConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any route_config = 1; */
        if (message.routeConfig)
            Any.internalBinaryWrite(message.routeConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.RoutesConfigDump.StaticRouteConfig
 */
export const RoutesConfigDump_StaticRouteConfig = new RoutesConfigDump_StaticRouteConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump_DynamicRouteConfig$Type extends MessageType<RoutesConfigDump_DynamicRouteConfig> {
    constructor() {
        super("envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route_config", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 5, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig" } });
    }
    create(value?: PartialMessage<RoutesConfigDump_DynamicRouteConfig>): RoutesConfigDump_DynamicRouteConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump_DynamicRouteConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump_DynamicRouteConfig): RoutesConfigDump_DynamicRouteConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any route_config */ 2:
                    message.routeConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.routeConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 4:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 5:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump_DynamicRouteConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any route_config = 2; */
        if (message.routeConfig)
            Any.internalBinaryWrite(message.routeConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 4; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 5; */
        if (message.clientStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.RoutesConfigDump.DynamicRouteConfig
 */
export const RoutesConfigDump_DynamicRouteConfig = new RoutesConfigDump_DynamicRouteConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump$Type extends MessageType<ScopedRoutesConfigDump> {
    constructor() {
        super("envoy.admin.v3.ScopedRoutesConfigDump", [
            { no: 1, name: "inline_scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRoutesConfigDump_InlineScopedRouteConfigs },
            { no: 2, name: "dynamic_scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRoutesConfigDump_DynamicScopedRouteConfigs }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ScopedRoutesConfigDump" } });
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump>): ScopedRoutesConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inlineScopedRouteConfigs = [];
        message.dynamicScopedRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump): ScopedRoutesConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs */ 1:
                    message.inlineScopedRouteConfigs.push(ScopedRoutesConfigDump_InlineScopedRouteConfigs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs */ 2:
                    message.dynamicScopedRouteConfigs.push(ScopedRoutesConfigDump_DynamicScopedRouteConfigs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs = 1; */
        for (let i = 0; i < message.inlineScopedRouteConfigs.length; i++)
            ScopedRoutesConfigDump_InlineScopedRouteConfigs.internalBinaryWrite(message.inlineScopedRouteConfigs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2; */
        for (let i = 0; i < message.dynamicScopedRouteConfigs.length; i++)
            ScopedRoutesConfigDump_DynamicScopedRouteConfigs.internalBinaryWrite(message.dynamicScopedRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ScopedRoutesConfigDump
 */
export const ScopedRoutesConfigDump = new ScopedRoutesConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump_InlineScopedRouteConfigs$Type extends MessageType<ScopedRoutesConfigDump_InlineScopedRouteConfigs> {
    constructor() {
        super("envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs" } });
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump_InlineScopedRouteConfigs>): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.scopedRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump_InlineScopedRouteConfigs): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated google.protobuf.Any scoped_route_configs */ 2:
                    message.scopedRouteConfigs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump_InlineScopedRouteConfigs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated google.protobuf.Any scoped_route_configs = 2; */
        for (let i = 0; i < message.scopedRouteConfigs.length; i++)
            Any.internalBinaryWrite(message.scopedRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ScopedRoutesConfigDump.InlineScopedRouteConfigs
 */
export const ScopedRoutesConfigDump_InlineScopedRouteConfigs = new ScopedRoutesConfigDump_InlineScopedRouteConfigs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump_DynamicScopedRouteConfigs$Type extends MessageType<ScopedRoutesConfigDump_DynamicScopedRouteConfigs> {
    constructor() {
        super("envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 4, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 5, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 6, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs" } });
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.versionInfo = "";
        message.scopedRouteConfigs = [];
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump_DynamicScopedRouteConfigs): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version_info */ 2:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated google.protobuf.Any scoped_route_configs */ 3:
                    message.scopedRouteConfigs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp last_updated */ 4:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 5:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 6:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version_info = 2; */
        if (message.versionInfo !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated google.protobuf.Any scoped_route_configs = 3; */
        for (let i = 0; i < message.scopedRouteConfigs.length; i++)
            Any.internalBinaryWrite(message.scopedRouteConfigs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 4; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 5; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 6; */
        if (message.clientStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ScopedRoutesConfigDump.DynamicScopedRouteConfigs
 */
export const ScopedRoutesConfigDump_DynamicScopedRouteConfigs = new ScopedRoutesConfigDump_DynamicScopedRouteConfigs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointsConfigDump$Type extends MessageType<EndpointsConfigDump> {
    constructor() {
        super("envoy.admin.v3.EndpointsConfigDump", [
            { no: 2, name: "static_endpoint_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointsConfigDump_StaticEndpointConfig },
            { no: 3, name: "dynamic_endpoint_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EndpointsConfigDump_DynamicEndpointConfig }
        ]);
    }
    create(value?: PartialMessage<EndpointsConfigDump>): EndpointsConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticEndpointConfigs = [];
        message.dynamicEndpointConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<EndpointsConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointsConfigDump): EndpointsConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig static_endpoint_configs */ 2:
                    message.staticEndpointConfigs.push(EndpointsConfigDump_StaticEndpointConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig dynamic_endpoint_configs */ 3:
                    message.dynamicEndpointConfigs.push(EndpointsConfigDump_DynamicEndpointConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointsConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig static_endpoint_configs = 2; */
        for (let i = 0; i < message.staticEndpointConfigs.length; i++)
            EndpointsConfigDump_StaticEndpointConfig.internalBinaryWrite(message.staticEndpointConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig dynamic_endpoint_configs = 3; */
        for (let i = 0; i < message.dynamicEndpointConfigs.length; i++)
            EndpointsConfigDump_DynamicEndpointConfig.internalBinaryWrite(message.dynamicEndpointConfigs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.EndpointsConfigDump
 */
export const EndpointsConfigDump = new EndpointsConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointsConfigDump_StaticEndpointConfig$Type extends MessageType<EndpointsConfigDump_StaticEndpointConfig> {
    constructor() {
        super("envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig", [
            { no: 1, name: "endpoint_config", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<EndpointsConfigDump_StaticEndpointConfig>): EndpointsConfigDump_StaticEndpointConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EndpointsConfigDump_StaticEndpointConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointsConfigDump_StaticEndpointConfig): EndpointsConfigDump_StaticEndpointConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any endpoint_config */ 1:
                    message.endpointConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.endpointConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointsConfigDump_StaticEndpointConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any endpoint_config = 1; */
        if (message.endpointConfig)
            Any.internalBinaryWrite(message.endpointConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.EndpointsConfigDump.StaticEndpointConfig
 */
export const EndpointsConfigDump_StaticEndpointConfig = new EndpointsConfigDump_StaticEndpointConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndpointsConfigDump_DynamicEndpointConfig$Type extends MessageType<EndpointsConfigDump_DynamicEndpointConfig> {
    constructor() {
        super("envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint_config", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 5, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ]);
    }
    create(value?: PartialMessage<EndpointsConfigDump_DynamicEndpointConfig>): EndpointsConfigDump_DynamicEndpointConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<EndpointsConfigDump_DynamicEndpointConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndpointsConfigDump_DynamicEndpointConfig): EndpointsConfigDump_DynamicEndpointConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any endpoint_config */ 2:
                    message.endpointConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.endpointConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 4:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 5:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndpointsConfigDump_DynamicEndpointConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any endpoint_config = 2; */
        if (message.endpointConfig)
            Any.internalBinaryWrite(message.endpointConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 4; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 5; */
        if (message.clientStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.EndpointsConfigDump.DynamicEndpointConfig
 */
export const EndpointsConfigDump_DynamicEndpointConfig = new EndpointsConfigDump_DynamicEndpointConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EcdsConfigDump$Type extends MessageType<EcdsConfigDump> {
    constructor() {
        super("envoy.admin.v3.EcdsConfigDump", [
            { no: 1, name: "ecds_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EcdsConfigDump_EcdsFilterConfig }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.EcdsConfigDump" } });
    }
    create(value?: PartialMessage<EcdsConfigDump>): EcdsConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ecdsFilters = [];
        if (value !== undefined)
            reflectionMergePartial<EcdsConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EcdsConfigDump): EcdsConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig ecds_filters */ 1:
                    message.ecdsFilters.push(EcdsConfigDump_EcdsFilterConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EcdsConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig ecds_filters = 1; */
        for (let i = 0; i < message.ecdsFilters.length; i++)
            EcdsConfigDump_EcdsFilterConfig.internalBinaryWrite(message.ecdsFilters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.EcdsConfigDump
 */
export const EcdsConfigDump = new EcdsConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EcdsConfigDump_EcdsFilterConfig$Type extends MessageType<EcdsConfigDump_EcdsFilterConfig> {
    constructor() {
        super("envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ecds_filter", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 5, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.EcdsConfigDump.EcdsFilterConfig" } });
    }
    create(value?: PartialMessage<EcdsConfigDump_EcdsFilterConfig>): EcdsConfigDump_EcdsFilterConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<EcdsConfigDump_EcdsFilterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EcdsConfigDump_EcdsFilterConfig): EcdsConfigDump_EcdsFilterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any ecds_filter */ 2:
                    message.ecdsFilter = Any.internalBinaryRead(reader, reader.uint32(), options, message.ecdsFilter);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 4:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 5:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EcdsConfigDump_EcdsFilterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any ecds_filter = 2; */
        if (message.ecdsFilter)
            Any.internalBinaryWrite(message.ecdsFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 4; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 5; */
        if (message.clientStatus !== 0)
            writer.tag(5, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.EcdsConfigDump.EcdsFilterConfig
 */
export const EcdsConfigDump_EcdsFilterConfig = new EcdsConfigDump_EcdsFilterConfig$Type();
