// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/admin/v3/clusters.proto" (package "envoy.admin.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HealthStatus } from "../../config/core/v3/health_check";
import { Locality } from "../../config/core/v3/base";
import { SimpleMetric } from "./metrics";
import { Address } from "../../config/core/v3/address";
import { CircuitBreakers } from "../../config/cluster/v3/circuit_breaker";
import { Percent } from "../../type/v3/percent";
// [#protodoc-title: Clusters]

/**
 * Admin endpoint uses this wrapper for ``/clusters`` to display cluster status information.
 * See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
 *
 * @generated from protobuf message envoy.admin.v3.Clusters
 */
export interface Clusters {
    /**
     * Mapping from cluster name to each cluster's status.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.ClusterStatus cluster_statuses = 1;
     */
    clusterStatuses: ClusterStatus[];
}
/**
 * Details an individual cluster's current status.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.admin.v3.ClusterStatus
 */
export interface ClusterStatus {
    /**
     * Name of the cluster.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Denotes whether this cluster was added via API or configured statically.
     *
     * @generated from protobuf field: bool added_via_api = 2;
     */
    addedViaApi: boolean;
    /**
     * The success rate threshold used in the last interval.
     * If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``false``, all errors: externally and locally generated were used to calculate the threshold.
     * If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``true``, only externally generated errors were used to calculate the threshold.
     * The threshold is used to eject hosts based on their success rate. See
     * :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for details.
     *
     * Note: this field may be omitted in any of the three following cases:
     *
     * 1. There were not enough hosts with enough request volume to proceed with success rate based
     *    outlier ejection.
     * 2. The threshold is computed to be < 0 because a negative value implies that there was no
     *    threshold for that interval.
     * 3. Outlier detection is not enabled for this cluster.
     *
     * @generated from protobuf field: envoy.type.v3.Percent success_rate_ejection_threshold = 3;
     */
    successRateEjectionThreshold?: Percent;
    /**
     * Mapping from host address to the host's current status.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.HostStatus host_statuses = 4;
     */
    hostStatuses: HostStatus[];
    /**
     * The success rate threshold used in the last interval when only locally originated failures were
     * taken into account and externally originated errors were treated as success.
     * This field should be interpreted only when
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``true``. The threshold is used to eject hosts based on their success rate.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     * details.
     *
     * Note: this field may be omitted in any of the three following cases:
     *
     * 1. There were not enough hosts with enough request volume to proceed with success rate based
     *    outlier ejection.
     * 2. The threshold is computed to be < 0 because a negative value implies that there was no
     *    threshold for that interval.
     * 3. Outlier detection is not enabled for this cluster.
     *
     * @generated from protobuf field: envoy.type.v3.Percent local_origin_success_rate_ejection_threshold = 5;
     */
    localOriginSuccessRateEjectionThreshold?: Percent;
    /**
     * :ref:`Circuit breaking <arch_overview_circuit_break>` settings of the cluster.
     *
     * @generated from protobuf field: envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 6;
     */
    circuitBreakers?: CircuitBreakers;
    /**
     * Observability name of the cluster.
     *
     * @generated from protobuf field: string observability_name = 7;
     */
    observabilityName: string;
    /**
     * The :ref:`EDS service name <envoy_v3_api_field_config.cluster.v3.Cluster.EdsClusterConfig.service_name>` if the cluster is an EDS cluster.
     *
     * @generated from protobuf field: string eds_service_name = 8;
     */
    edsServiceName: string;
}
/**
 * Current state of a particular host.
 * [#next-free-field: 10]
 *
 * @generated from protobuf message envoy.admin.v3.HostStatus
 */
export interface HostStatus {
    /**
     * Address of this host.
     *
     * @generated from protobuf field: envoy.config.core.v3.Address address = 1;
     */
    address?: Address;
    /**
     * List of stats specific to this host.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.SimpleMetric stats = 2;
     */
    stats: SimpleMetric[];
    /**
     * The host's current health status.
     *
     * @generated from protobuf field: envoy.admin.v3.HostHealthStatus health_status = 3;
     */
    healthStatus?: HostHealthStatus;
    /**
     * Request success rate for this host over the last calculated interval.
     * If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``false``, all errors: externally and locally generated were used in success rate
     * calculation. If
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``true``, only externally generated errors were used in success rate calculation.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     * details.
     *
     * Note: the message will not be present if host did not have enough request volume to calculate
     * success rate or the cluster did not have enough hosts to run through success rate outlier
     * ejection.
     *
     * @generated from protobuf field: envoy.type.v3.Percent success_rate = 4;
     */
    successRate?: Percent;
    /**
     * The host's weight. If not configured, the value defaults to 1.
     *
     * @generated from protobuf field: uint32 weight = 5;
     */
    weight: number;
    /**
     * The hostname of the host, if applicable.
     *
     * @generated from protobuf field: string hostname = 6;
     */
    hostname: string;
    /**
     * The host's priority. If not configured, the value defaults to 0 (highest priority).
     *
     * @generated from protobuf field: uint32 priority = 7;
     */
    priority: number;
    /**
     * Request success rate for this host over the last calculated
     * interval when only locally originated errors are taken into account and externally originated
     * errors were treated as success.
     * This field should be interpreted only when
     * :ref:`outlier_detection.split_external_local_origin_errors<envoy_v3_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
     * is ``true``.
     * See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
     * details.
     *
     * Note: the message will not be present if host did not have enough request volume to calculate
     * success rate or the cluster did not have enough hosts to run through success rate outlier
     * ejection.
     *
     * @generated from protobuf field: envoy.type.v3.Percent local_origin_success_rate = 8;
     */
    localOriginSuccessRate?: Percent;
    /**
     * locality of the host.
     *
     * @generated from protobuf field: envoy.config.core.v3.Locality locality = 9;
     */
    locality?: Locality;
}
/**
 * Health status for a host.
 * [#next-free-field: 9]
 *
 * @generated from protobuf message envoy.admin.v3.HostHealthStatus
 */
export interface HostHealthStatus {
    /**
     * The host is currently failing active health checks.
     *
     * @generated from protobuf field: bool failed_active_health_check = 1;
     */
    failedActiveHealthCheck: boolean;
    /**
     * The host is currently considered an outlier and has been ejected.
     *
     * @generated from protobuf field: bool failed_outlier_check = 2;
     */
    failedOutlierCheck: boolean;
    /**
     * The host is currently being marked as degraded through active health checking.
     *
     * @generated from protobuf field: bool failed_active_degraded_check = 4;
     */
    failedActiveDegradedCheck: boolean;
    /**
     * The host has been removed from service discovery, but is being stabilized due to active
     * health checking.
     *
     * @generated from protobuf field: bool pending_dynamic_removal = 5;
     */
    pendingDynamicRemoval: boolean;
    /**
     * The host has not yet been health checked.
     *
     * @generated from protobuf field: bool pending_active_hc = 6;
     */
    pendingActiveHc: boolean;
    /**
     * The host should be excluded from panic, spillover, etc. calculations because it was explicitly
     * taken out of rotation via protocol signal and is not meant to be routed to.
     *
     * @generated from protobuf field: bool excluded_via_immediate_hc_fail = 7;
     */
    excludedViaImmediateHcFail: boolean;
    /**
     * The host failed active HC due to timeout.
     *
     * @generated from protobuf field: bool active_hc_timeout = 8;
     */
    activeHcTimeout: boolean;
    /**
     * Health status as reported by EDS. Note: only HEALTHY and UNHEALTHY are currently supported
     * here.
     * [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
     *
     * @generated from protobuf field: envoy.config.core.v3.HealthStatus eds_health_status = 3;
     */
    edsHealthStatus: HealthStatus;
}
// @generated message type with reflection information, may provide speed optimized methods
class Clusters$Type extends MessageType<Clusters> {
    constructor() {
        super("envoy.admin.v3.Clusters", [
            { no: 1, name: "cluster_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClusterStatus }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.Clusters" } });
    }
    create(value?: PartialMessage<Clusters>): Clusters {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clusterStatuses = [];
        if (value !== undefined)
            reflectionMergePartial<Clusters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clusters): Clusters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.ClusterStatus cluster_statuses */ 1:
                    message.clusterStatuses.push(ClusterStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Clusters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.ClusterStatus cluster_statuses = 1; */
        for (let i = 0; i < message.clusterStatuses.length; i++)
            ClusterStatus.internalBinaryWrite(message.clusterStatuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.Clusters
 */
export const Clusters = new Clusters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClusterStatus$Type extends MessageType<ClusterStatus> {
    constructor() {
        super("envoy.admin.v3.ClusterStatus", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "added_via_api", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "success_rate_ejection_threshold", kind: "message", T: () => Percent },
            { no: 4, name: "host_statuses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HostStatus },
            { no: 5, name: "local_origin_success_rate_ejection_threshold", kind: "message", T: () => Percent },
            { no: 6, name: "circuit_breakers", kind: "message", T: () => CircuitBreakers },
            { no: 7, name: "observability_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "eds_service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ClusterStatus" } });
    }
    create(value?: PartialMessage<ClusterStatus>): ClusterStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.addedViaApi = false;
        message.hostStatuses = [];
        message.observabilityName = "";
        message.edsServiceName = "";
        if (value !== undefined)
            reflectionMergePartial<ClusterStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClusterStatus): ClusterStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool added_via_api */ 2:
                    message.addedViaApi = reader.bool();
                    break;
                case /* envoy.type.v3.Percent success_rate_ejection_threshold */ 3:
                    message.successRateEjectionThreshold = Percent.internalBinaryRead(reader, reader.uint32(), options, message.successRateEjectionThreshold);
                    break;
                case /* repeated envoy.admin.v3.HostStatus host_statuses */ 4:
                    message.hostStatuses.push(HostStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.type.v3.Percent local_origin_success_rate_ejection_threshold */ 5:
                    message.localOriginSuccessRateEjectionThreshold = Percent.internalBinaryRead(reader, reader.uint32(), options, message.localOriginSuccessRateEjectionThreshold);
                    break;
                case /* envoy.config.cluster.v3.CircuitBreakers circuit_breakers */ 6:
                    message.circuitBreakers = CircuitBreakers.internalBinaryRead(reader, reader.uint32(), options, message.circuitBreakers);
                    break;
                case /* string observability_name */ 7:
                    message.observabilityName = reader.string();
                    break;
                case /* string eds_service_name */ 8:
                    message.edsServiceName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClusterStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool added_via_api = 2; */
        if (message.addedViaApi !== false)
            writer.tag(2, WireType.Varint).bool(message.addedViaApi);
        /* envoy.type.v3.Percent success_rate_ejection_threshold = 3; */
        if (message.successRateEjectionThreshold)
            Percent.internalBinaryWrite(message.successRateEjectionThreshold, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.HostStatus host_statuses = 4; */
        for (let i = 0; i < message.hostStatuses.length; i++)
            HostStatus.internalBinaryWrite(message.hostStatuses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent local_origin_success_rate_ejection_threshold = 5; */
        if (message.localOriginSuccessRateEjectionThreshold)
            Percent.internalBinaryWrite(message.localOriginSuccessRateEjectionThreshold, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.cluster.v3.CircuitBreakers circuit_breakers = 6; */
        if (message.circuitBreakers)
            CircuitBreakers.internalBinaryWrite(message.circuitBreakers, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string observability_name = 7; */
        if (message.observabilityName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.observabilityName);
        /* string eds_service_name = 8; */
        if (message.edsServiceName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.edsServiceName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ClusterStatus
 */
export const ClusterStatus = new ClusterStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostStatus$Type extends MessageType<HostStatus> {
    constructor() {
        super("envoy.admin.v3.HostStatus", [
            { no: 1, name: "address", kind: "message", T: () => Address },
            { no: 2, name: "stats", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SimpleMetric },
            { no: 3, name: "health_status", kind: "message", T: () => HostHealthStatus },
            { no: 4, name: "success_rate", kind: "message", T: () => Percent },
            { no: 5, name: "weight", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "priority", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "local_origin_success_rate", kind: "message", T: () => Percent },
            { no: 9, name: "locality", kind: "message", T: () => Locality }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.HostStatus" } });
    }
    create(value?: PartialMessage<HostStatus>): HostStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stats = [];
        message.weight = 0;
        message.hostname = "";
        message.priority = 0;
        if (value !== undefined)
            reflectionMergePartial<HostStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostStatus): HostStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.core.v3.Address address */ 1:
                    message.address = Address.internalBinaryRead(reader, reader.uint32(), options, message.address);
                    break;
                case /* repeated envoy.admin.v3.SimpleMetric stats */ 2:
                    message.stats.push(SimpleMetric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.admin.v3.HostHealthStatus health_status */ 3:
                    message.healthStatus = HostHealthStatus.internalBinaryRead(reader, reader.uint32(), options, message.healthStatus);
                    break;
                case /* envoy.type.v3.Percent success_rate */ 4:
                    message.successRate = Percent.internalBinaryRead(reader, reader.uint32(), options, message.successRate);
                    break;
                case /* uint32 weight */ 5:
                    message.weight = reader.uint32();
                    break;
                case /* string hostname */ 6:
                    message.hostname = reader.string();
                    break;
                case /* uint32 priority */ 7:
                    message.priority = reader.uint32();
                    break;
                case /* envoy.type.v3.Percent local_origin_success_rate */ 8:
                    message.localOriginSuccessRate = Percent.internalBinaryRead(reader, reader.uint32(), options, message.localOriginSuccessRate);
                    break;
                case /* envoy.config.core.v3.Locality locality */ 9:
                    message.locality = Locality.internalBinaryRead(reader, reader.uint32(), options, message.locality);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.core.v3.Address address = 1; */
        if (message.address)
            Address.internalBinaryWrite(message.address, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.SimpleMetric stats = 2; */
        for (let i = 0; i < message.stats.length; i++)
            SimpleMetric.internalBinaryWrite(message.stats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.HostHealthStatus health_status = 3; */
        if (message.healthStatus)
            HostHealthStatus.internalBinaryWrite(message.healthStatus, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.type.v3.Percent success_rate = 4; */
        if (message.successRate)
            Percent.internalBinaryWrite(message.successRate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 weight = 5; */
        if (message.weight !== 0)
            writer.tag(5, WireType.Varint).uint32(message.weight);
        /* string hostname = 6; */
        if (message.hostname !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.hostname);
        /* uint32 priority = 7; */
        if (message.priority !== 0)
            writer.tag(7, WireType.Varint).uint32(message.priority);
        /* envoy.type.v3.Percent local_origin_success_rate = 8; */
        if (message.localOriginSuccessRate)
            Percent.internalBinaryWrite(message.localOriginSuccessRate, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* envoy.config.core.v3.Locality locality = 9; */
        if (message.locality)
            Locality.internalBinaryWrite(message.locality, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.HostStatus
 */
export const HostStatus = new HostStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HostHealthStatus$Type extends MessageType<HostHealthStatus> {
    constructor() {
        super("envoy.admin.v3.HostHealthStatus", [
            { no: 1, name: "failed_active_health_check", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "failed_outlier_check", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "failed_active_degraded_check", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "pending_dynamic_removal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "pending_active_hc", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "excluded_via_immediate_hc_fail", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "active_hc_timeout", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "eds_health_status", kind: "enum", T: () => ["envoy.config.core.v3.HealthStatus", HealthStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.HostHealthStatus" } });
    }
    create(value?: PartialMessage<HostHealthStatus>): HostHealthStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.failedActiveHealthCheck = false;
        message.failedOutlierCheck = false;
        message.failedActiveDegradedCheck = false;
        message.pendingDynamicRemoval = false;
        message.pendingActiveHc = false;
        message.excludedViaImmediateHcFail = false;
        message.activeHcTimeout = false;
        message.edsHealthStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<HostHealthStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HostHealthStatus): HostHealthStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool failed_active_health_check */ 1:
                    message.failedActiveHealthCheck = reader.bool();
                    break;
                case /* bool failed_outlier_check */ 2:
                    message.failedOutlierCheck = reader.bool();
                    break;
                case /* bool failed_active_degraded_check */ 4:
                    message.failedActiveDegradedCheck = reader.bool();
                    break;
                case /* bool pending_dynamic_removal */ 5:
                    message.pendingDynamicRemoval = reader.bool();
                    break;
                case /* bool pending_active_hc */ 6:
                    message.pendingActiveHc = reader.bool();
                    break;
                case /* bool excluded_via_immediate_hc_fail */ 7:
                    message.excludedViaImmediateHcFail = reader.bool();
                    break;
                case /* bool active_hc_timeout */ 8:
                    message.activeHcTimeout = reader.bool();
                    break;
                case /* envoy.config.core.v3.HealthStatus eds_health_status */ 3:
                    message.edsHealthStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HostHealthStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool failed_active_health_check = 1; */
        if (message.failedActiveHealthCheck !== false)
            writer.tag(1, WireType.Varint).bool(message.failedActiveHealthCheck);
        /* bool failed_outlier_check = 2; */
        if (message.failedOutlierCheck !== false)
            writer.tag(2, WireType.Varint).bool(message.failedOutlierCheck);
        /* bool failed_active_degraded_check = 4; */
        if (message.failedActiveDegradedCheck !== false)
            writer.tag(4, WireType.Varint).bool(message.failedActiveDegradedCheck);
        /* bool pending_dynamic_removal = 5; */
        if (message.pendingDynamicRemoval !== false)
            writer.tag(5, WireType.Varint).bool(message.pendingDynamicRemoval);
        /* bool pending_active_hc = 6; */
        if (message.pendingActiveHc !== false)
            writer.tag(6, WireType.Varint).bool(message.pendingActiveHc);
        /* bool excluded_via_immediate_hc_fail = 7; */
        if (message.excludedViaImmediateHcFail !== false)
            writer.tag(7, WireType.Varint).bool(message.excludedViaImmediateHcFail);
        /* bool active_hc_timeout = 8; */
        if (message.activeHcTimeout !== false)
            writer.tag(8, WireType.Varint).bool(message.activeHcTimeout);
        /* envoy.config.core.v3.HealthStatus eds_health_status = 3; */
        if (message.edsHealthStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.edsHealthStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.HostHealthStatus
 */
export const HostHealthStatus = new HostHealthStatus$Type();
