// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/admin/v3/config_dump.proto" (package "envoy.admin.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ClientResourceStatus } from "./config_dump_shared";
import { UpdateFailureState } from "./config_dump_shared";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Bootstrap } from "../../config/bootstrap/v3/bootstrap";
import { Any } from "../../../google/protobuf/any";
// [#protodoc-title: ConfigDump]

/**
 * The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
 * message to maintain and serve arbitrary configuration information from any component in Envoy.
 *
 * @generated from protobuf message envoy.admin.v3.ConfigDump
 */
export interface ConfigDump {
    /**
     * This list is serialized and dumped in its entirety at the
     * :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
     *
     * The following configurations are currently supported and will be dumped in the order given
     * below:
     *
     * * ``bootstrap``: :ref:`BootstrapConfigDump <envoy_v3_api_msg_admin.v3.BootstrapConfigDump>`
     * * ``clusters``: :ref:`ClustersConfigDump <envoy_v3_api_msg_admin.v3.ClustersConfigDump>`
     * * ``ecds_filter_http``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
     * * ``ecds_filter_tcp_listener``: :ref:`EcdsConfigDump <envoy_v3_api_msg_admin.v3.EcdsConfigDump>`
     * * ``endpoints``:  :ref:`EndpointsConfigDump <envoy_v3_api_msg_admin.v3.EndpointsConfigDump>`
     * * ``listeners``: :ref:`ListenersConfigDump <envoy_v3_api_msg_admin.v3.ListenersConfigDump>`
     * * ``scoped_routes``: :ref:`ScopedRoutesConfigDump <envoy_v3_api_msg_admin.v3.ScopedRoutesConfigDump>`
     * * ``routes``:  :ref:`RoutesConfigDump <envoy_v3_api_msg_admin.v3.RoutesConfigDump>`
     * * ``secrets``:  :ref:`SecretsConfigDump <envoy_v3_api_msg_admin.v3.SecretsConfigDump>`
     *
     * EDS Configuration will only be dumped by using parameter ``?include_eds``
     *
     * Currently ECDS is supported in HTTP and listener filters. Note, ECDS configuration for
     * either HTTP or listener filter will only be dumped if it is actually configured.
     *
     * You can filter output with the resource and mask query parameters.
     * See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
     * :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
     * or :ref:`/config_dump?resource={},mask={}
     * <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
     *
     * @generated from protobuf field: repeated google.protobuf.Any configs = 1;
     */
    configs: Any[];
}
/**
 * This message describes the bootstrap configuration that Envoy was started with. This includes
 * any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
 * the static portions of an Envoy configuration by reusing the output as the bootstrap
 * configuration for another Envoy.
 *
 * @generated from protobuf message envoy.admin.v3.BootstrapConfigDump
 */
export interface BootstrapConfigDump {
    /**
     * @generated from protobuf field: envoy.config.bootstrap.v3.Bootstrap bootstrap = 1;
     */
    bootstrap?: Bootstrap;
    /**
     * The timestamp when the BootstrapConfig was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS.
 *
 * @generated from protobuf message envoy.admin.v3.SecretsConfigDump
 */
export interface SecretsConfigDump {
    /**
     * The statically loaded secrets.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.SecretsConfigDump.StaticSecret static_secrets = 1;
     */
    staticSecrets: SecretsConfigDump_StaticSecret[];
    /**
     * The dynamically loaded active secrets. These are secrets that are available to service
     * clusters or listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_active_secrets = 2;
     */
    dynamicActiveSecrets: SecretsConfigDump_DynamicSecret[];
    /**
     * The dynamically loaded warming secrets. These are secrets that are currently undergoing
     * warming in preparation to service clusters or listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_warming_secrets = 3;
     */
    dynamicWarmingSecrets: SecretsConfigDump_DynamicSecret[];
}
/**
 * DynamicSecret contains secret information fetched via SDS.
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.admin.v3.SecretsConfigDump.DynamicSecret
 */
export interface SecretsConfigDump_DynamicSecret {
    /**
     * The name assigned to the secret.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * This is the per-resource version information.
     *
     * @generated from protobuf field: string version_info = 2;
     */
    versionInfo: string;
    /**
     * The timestamp when the secret was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * The actual secret information.
     * Security sensitive information is redacted (replaced with "[redacted]") for
     * private keys and passwords in TLS certificates.
     *
     * @generated from protobuf field: google.protobuf.Any secret = 4;
     */
    secret?: Any;
    /**
     * Set if the last update failed, cleared after the next successful update.
     * The *error_state* field contains the rejected version of this particular
     * resource along with the reason and timestamp. For successfully updated or
     * acknowledged resource, this field should be empty.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.UpdateFailureState error_state = 5;
     */
    errorState?: UpdateFailureState;
    /**
     * The client status of this resource.
     * [#not-implemented-hide:]
     *
     * @generated from protobuf field: envoy.admin.v3.ClientResourceStatus client_status = 6;
     */
    clientStatus: ClientResourceStatus;
}
/**
 * StaticSecret specifies statically loaded secret in bootstrap.
 *
 * @generated from protobuf message envoy.admin.v3.SecretsConfigDump.StaticSecret
 */
export interface SecretsConfigDump_StaticSecret {
    /**
     * The name assigned to the secret.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The timestamp when the secret was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
    /**
     * The actual secret information.
     * Security sensitive information is redacted (replaced with "[redacted]") for
     * private keys and passwords in TLS certificates.
     *
     * @generated from protobuf field: google.protobuf.Any secret = 3;
     */
    secret?: Any;
}
// @generated message type with reflection information, may provide speed optimized methods
class ConfigDump$Type extends MessageType<ConfigDump> {
    constructor() {
        super("envoy.admin.v3.ConfigDump", [
            { no: 1, name: "configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.ConfigDump" } });
    }
    create(value?: PartialMessage<ConfigDump>): ConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        if (value !== undefined)
            reflectionMergePartial<ConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigDump): ConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.Any configs */ 1:
                    message.configs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.Any configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            Any.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.ConfigDump
 */
export const ConfigDump = new ConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BootstrapConfigDump$Type extends MessageType<BootstrapConfigDump> {
    constructor() {
        super("envoy.admin.v3.BootstrapConfigDump", [
            { no: 1, name: "bootstrap", kind: "message", T: () => Bootstrap },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.BootstrapConfigDump" } });
    }
    create(value?: PartialMessage<BootstrapConfigDump>): BootstrapConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BootstrapConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BootstrapConfigDump): BootstrapConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.bootstrap.v3.Bootstrap bootstrap */ 1:
                    message.bootstrap = Bootstrap.internalBinaryRead(reader, reader.uint32(), options, message.bootstrap);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BootstrapConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.bootstrap.v3.Bootstrap bootstrap = 1; */
        if (message.bootstrap)
            Bootstrap.internalBinaryWrite(message.bootstrap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.BootstrapConfigDump
 */
export const BootstrapConfigDump = new BootstrapConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump$Type extends MessageType<SecretsConfigDump> {
    constructor() {
        super("envoy.admin.v3.SecretsConfigDump", [
            { no: 1, name: "static_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_StaticSecret },
            { no: 2, name: "dynamic_active_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_DynamicSecret },
            { no: 3, name: "dynamic_warming_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_DynamicSecret }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.SecretsConfigDump" } });
    }
    create(value?: PartialMessage<SecretsConfigDump>): SecretsConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticSecrets = [];
        message.dynamicActiveSecrets = [];
        message.dynamicWarmingSecrets = [];
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump): SecretsConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v3.SecretsConfigDump.StaticSecret static_secrets */ 1:
                    message.staticSecrets.push(SecretsConfigDump_StaticSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_active_secrets */ 2:
                    message.dynamicActiveSecrets.push(SecretsConfigDump_DynamicSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_warming_secrets */ 3:
                    message.dynamicWarmingSecrets.push(SecretsConfigDump_DynamicSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v3.SecretsConfigDump.StaticSecret static_secrets = 1; */
        for (let i = 0; i < message.staticSecrets.length; i++)
            SecretsConfigDump_StaticSecret.internalBinaryWrite(message.staticSecrets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_active_secrets = 2; */
        for (let i = 0; i < message.dynamicActiveSecrets.length; i++)
            SecretsConfigDump_DynamicSecret.internalBinaryWrite(message.dynamicActiveSecrets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v3.SecretsConfigDump.DynamicSecret dynamic_warming_secrets = 3; */
        for (let i = 0; i < message.dynamicWarmingSecrets.length; i++)
            SecretsConfigDump_DynamicSecret.internalBinaryWrite(message.dynamicWarmingSecrets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.SecretsConfigDump
 */
export const SecretsConfigDump = new SecretsConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump_DynamicSecret$Type extends MessageType<SecretsConfigDump_DynamicSecret> {
    constructor() {
        super("envoy.admin.v3.SecretsConfigDump.DynamicSecret", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "secret", kind: "message", T: () => Any },
            { no: 5, name: "error_state", kind: "message", T: () => UpdateFailureState },
            { no: 6, name: "client_status", kind: "enum", T: () => ["envoy.admin.v3.ClientResourceStatus", ClientResourceStatus] }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret" } });
    }
    create(value?: PartialMessage<SecretsConfigDump_DynamicSecret>): SecretsConfigDump_DynamicSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.versionInfo = "";
        message.clientStatus = 0;
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump_DynamicSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump_DynamicSecret): SecretsConfigDump_DynamicSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version_info */ 2:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* google.protobuf.Any secret */ 4:
                    message.secret = Any.internalBinaryRead(reader, reader.uint32(), options, message.secret);
                    break;
                case /* envoy.admin.v3.UpdateFailureState error_state */ 5:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                case /* envoy.admin.v3.ClientResourceStatus client_status */ 6:
                    message.clientStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump_DynamicSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version_info = 2; */
        if (message.versionInfo !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any secret = 4; */
        if (message.secret)
            Any.internalBinaryWrite(message.secret, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.UpdateFailureState error_state = 5; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v3.ClientResourceStatus client_status = 6; */
        if (message.clientStatus !== 0)
            writer.tag(6, WireType.Varint).int32(message.clientStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.SecretsConfigDump.DynamicSecret
 */
export const SecretsConfigDump_DynamicSecret = new SecretsConfigDump_DynamicSecret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump_StaticSecret$Type extends MessageType<SecretsConfigDump_StaticSecret> {
    constructor() {
        super("envoy.admin.v3.SecretsConfigDump.StaticSecret", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 3, name: "secret", kind: "message", T: () => Any }
        ], { "udpa.annotations.versioning": { previousMessageType: "envoy.admin.v2alpha.SecretsConfigDump.StaticSecret" } });
    }
    create(value?: PartialMessage<SecretsConfigDump_StaticSecret>): SecretsConfigDump_StaticSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump_StaticSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump_StaticSecret): SecretsConfigDump_StaticSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* google.protobuf.Any secret */ 3:
                    message.secret = Any.internalBinaryRead(reader, reader.uint32(), options, message.secret);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump_StaticSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any secret = 3; */
        if (message.secret)
            Any.internalBinaryWrite(message.secret, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v3.SecretsConfigDump.StaticSecret
 */
export const SecretsConfigDump_StaticSecret = new SecretsConfigDump_StaticSecret$Type();
