// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/admin/v2alpha/config_dump.proto" (package "envoy.admin.v2alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Bootstrap } from "../../config/bootstrap/v2/bootstrap";
import { Timestamp } from "../../../google/protobuf/timestamp";
import { Any } from "../../../google/protobuf/any";
// [#protodoc-title: ConfigDump]

/**
 * The :ref:`/config_dump <operations_admin_interface_config_dump>` admin endpoint uses this wrapper
 * message to maintain and serve arbitrary configuration information from any component in Envoy.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ConfigDump
 */
export interface ConfigDump {
    /**
     * This list is serialized and dumped in its entirety at the
     * :ref:`/config_dump <operations_admin_interface_config_dump>` endpoint.
     *
     * The following configurations are currently supported and will be dumped in the order given
     * below:
     *
     * * *bootstrap*: :ref:`BootstrapConfigDump <envoy_api_msg_admin.v2alpha.BootstrapConfigDump>`
     * * *clusters*: :ref:`ClustersConfigDump <envoy_api_msg_admin.v2alpha.ClustersConfigDump>`
     * * *listeners*: :ref:`ListenersConfigDump <envoy_api_msg_admin.v2alpha.ListenersConfigDump>`
     * * *routes*:  :ref:`RoutesConfigDump <envoy_api_msg_admin.v2alpha.RoutesConfigDump>`
     *
     * You can filter output with the resource and mask query parameters.
     * See :ref:`/config_dump?resource={} <operations_admin_interface_config_dump_by_resource>`,
     * :ref:`/config_dump?mask={} <operations_admin_interface_config_dump_by_mask>`,
     * or :ref:`/config_dump?resource={},mask={}
     * <operations_admin_interface_config_dump_by_resource_and_mask>` for more information.
     *
     * @generated from protobuf field: repeated google.protobuf.Any configs = 1;
     */
    configs: Any[];
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.UpdateFailureState
 */
export interface UpdateFailureState {
    /**
     * What the component configuration would have been if the update had succeeded.
     *
     * @generated from protobuf field: google.protobuf.Any failed_configuration = 1;
     */
    failedConfiguration?: Any;
    /**
     * Time of the latest failed update attempt.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_update_attempt = 2;
     */
    lastUpdateAttempt?: Timestamp;
    /**
     * Details about the last failed update attempt.
     *
     * @generated from protobuf field: string details = 3;
     */
    details: string;
}
/**
 * This message describes the bootstrap configuration that Envoy was started with. This includes
 * any CLI overrides that were merged. Bootstrap configuration information can be used to recreate
 * the static portions of an Envoy configuration by reusing the output as the bootstrap
 * configuration for another Envoy.
 *
 * @generated from protobuf message envoy.admin.v2alpha.BootstrapConfigDump
 */
export interface BootstrapConfigDump {
    /**
     * @generated from protobuf field: envoy.config.bootstrap.v2.Bootstrap bootstrap = 1;
     */
    bootstrap?: Bootstrap;
    /**
     * The timestamp when the BootstrapConfig was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * Envoy's listener manager fills this message with all currently known listeners. Listener
 * configuration information can be used to recreate an Envoy configuration by populating all
 * listeners as static listeners or by returning them in a LDS response.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ListenersConfigDump
 */
export interface ListenersConfigDump {
    /**
     * This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
     * last processed LDS discovery response. If there are only static bootstrap listeners, this field
     * will be "".
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The statically loaded listener configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ListenersConfigDump.StaticListener static_listeners = 2;
     */
    staticListeners: ListenersConfigDump_StaticListener[];
    /**
     * State for any warming, active, or draining listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ListenersConfigDump.DynamicListener dynamic_listeners = 3;
     */
    dynamicListeners: ListenersConfigDump_DynamicListener[];
}
/**
 * Describes a statically loaded listener.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ListenersConfigDump.StaticListener
 */
export interface ListenersConfigDump_StaticListener {
    /**
     * The listener config.
     *
     * @generated from protobuf field: google.protobuf.Any listener = 1;
     */
    listener?: Any;
    /**
     * The timestamp when the Listener was last successfully updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState
 */
export interface ListenersConfigDump_DynamicListenerState {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
     * that the listener was loaded. In the future, discrete per-listener versions may be supported
     * by the API.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The listener config.
     *
     * @generated from protobuf field: google.protobuf.Any listener = 2;
     */
    listener?: Any;
    /**
     * The timestamp when the Listener was last successfully updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * Describes a dynamically loaded listener via the LDS API.
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.admin.v2alpha.ListenersConfigDump.DynamicListener
 */
export interface ListenersConfigDump_DynamicListener {
    /**
     * The name or unique id of this listener, pulled from the DynamicListenerState config.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The listener state for any active listener by this name.
     * These are listeners that are available to service data plane traffic.
     *
     * @generated from protobuf field: envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState active_state = 2;
     */
    activeState?: ListenersConfigDump_DynamicListenerState;
    /**
     * The listener state for any warming listener by this name.
     * These are listeners that are currently undergoing warming in preparation to service data
     * plane traffic. Note that if attempting to recreate an Envoy configuration from a
     * configuration dump, the warming listeners should generally be discarded.
     *
     * @generated from protobuf field: envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState warming_state = 3;
     */
    warmingState?: ListenersConfigDump_DynamicListenerState;
    /**
     * The listener state for any draining listener by this name.
     * These are listeners that are currently undergoing draining in preparation to stop servicing
     * data plane traffic. Note that if attempting to recreate an Envoy configuration from a
     * configuration dump, the draining listeners should generally be discarded.
     *
     * @generated from protobuf field: envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState draining_state = 4;
     */
    drainingState?: ListenersConfigDump_DynamicListenerState;
    /**
     * Set if the last update failed, cleared after the next successful update.
     *
     * @generated from protobuf field: envoy.admin.v2alpha.UpdateFailureState error_state = 5;
     */
    errorState?: UpdateFailureState;
}
/**
 * Envoy's cluster manager fills this message with all currently known clusters. Cluster
 * configuration information can be used to recreate an Envoy configuration by populating all
 * clusters as static clusters or by returning them in a CDS response.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ClustersConfigDump
 */
export interface ClustersConfigDump {
    /**
     * This is the :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` in the
     * last processed CDS discovery response. If there are only static bootstrap clusters, this field
     * will be "".
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The statically loaded cluster configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ClustersConfigDump.StaticCluster static_clusters = 2;
     */
    staticClusters: ClustersConfigDump_StaticCluster[];
    /**
     * The dynamically loaded active clusters. These are clusters that are available to service
     * data plane traffic.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_active_clusters = 3;
     */
    dynamicActiveClusters: ClustersConfigDump_DynamicCluster[];
    /**
     * The dynamically loaded warming clusters. These are clusters that are currently undergoing
     * warming in preparation to service data plane traffic. Note that if attempting to recreate an
     * Envoy configuration from a configuration dump, the warming clusters should generally be
     * discarded.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_warming_clusters = 4;
     */
    dynamicWarmingClusters: ClustersConfigDump_DynamicCluster[];
}
/**
 * Describes a statically loaded cluster.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ClustersConfigDump.StaticCluster
 */
export interface ClustersConfigDump_StaticCluster {
    /**
     * The cluster config.
     *
     * @generated from protobuf field: google.protobuf.Any cluster = 1;
     */
    cluster?: Any;
    /**
     * The timestamp when the Cluster was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * Describes a dynamically loaded cluster via the CDS API.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster
 */
export interface ClustersConfigDump_DynamicCluster {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time
     * that the cluster was loaded. In the future, discrete per-cluster versions may be supported by
     * the API.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The cluster config.
     *
     * @generated from protobuf field: google.protobuf.Any cluster = 2;
     */
    cluster?: Any;
    /**
     * The timestamp when the Cluster was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * Envoy's RDS implementation fills this message with all currently loaded routes, as described by
 * their RouteConfiguration objects. Static routes that are either defined in the bootstrap configuration
 * or defined inline while configuring listeners are separated from those configured dynamically via RDS.
 * Route configuration information can be used to recreate an Envoy configuration by populating all routes
 * as static routes or by returning them in RDS responses.
 *
 * @generated from protobuf message envoy.admin.v2alpha.RoutesConfigDump
 */
export interface RoutesConfigDump {
    /**
     * The statically loaded route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig static_route_configs = 2;
     */
    staticRouteConfigs: RoutesConfigDump_StaticRouteConfig[];
    /**
     * The dynamically loaded route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs = 3;
     */
    dynamicRouteConfigs: RoutesConfigDump_DynamicRouteConfig[];
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig
 */
export interface RoutesConfigDump_StaticRouteConfig {
    /**
     * The route config.
     *
     * @generated from protobuf field: google.protobuf.Any route_config = 1;
     */
    routeConfig?: Any;
    /**
     * The timestamp when the Route was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig
 */
export interface RoutesConfigDump_DynamicRouteConfig {
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
     * the route configuration was loaded.
     *
     * @generated from protobuf field: string version_info = 1;
     */
    versionInfo: string;
    /**
     * The route config.
     *
     * @generated from protobuf field: google.protobuf.Any route_config = 2;
     */
    routeConfig?: Any;
    /**
     * The timestamp when the Route was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * Envoy's scoped RDS implementation fills this message with all currently loaded route
 * configuration scopes (defined via ScopedRouteConfigurationsSet protos). This message lists both
 * the scopes defined inline with the higher order object (i.e., the HttpConnectionManager) and the
 * dynamically obtained scopes via the SRDS API.
 *
 * @generated from protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump
 */
export interface ScopedRoutesConfigDump {
    /**
     * The statically loaded scoped route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs = 1;
     */
    inlineScopedRouteConfigs: ScopedRoutesConfigDump_InlineScopedRouteConfigs[];
    /**
     * The dynamically loaded scoped route configs.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2;
     */
    dynamicScopedRouteConfigs: ScopedRoutesConfigDump_DynamicScopedRouteConfigs[];
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs
 */
export interface ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    /**
     * The name assigned to the scoped route configurations.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The scoped route configurations.
     *
     * @generated from protobuf field: repeated google.protobuf.Any scoped_route_configs = 2;
     */
    scopedRouteConfigs: Any[];
    /**
     * The timestamp when the scoped route config set was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
}
/**
 * @generated from protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs
 */
export interface ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    /**
     * The name assigned to the scoped route configurations.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * This is the per-resource version information. This version is currently taken from the
     * :ref:`version_info <envoy_api_field_DiscoveryResponse.version_info>` field at the time that
     * the scoped routes configuration was loaded.
     *
     * @generated from protobuf field: string version_info = 2;
     */
    versionInfo: string;
    /**
     * The scoped route configurations.
     *
     * @generated from protobuf field: repeated google.protobuf.Any scoped_route_configs = 3;
     */
    scopedRouteConfigs: Any[];
    /**
     * The timestamp when the scoped route config set was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 4;
     */
    lastUpdated?: Timestamp;
}
/**
 * Envoys SDS implementation fills this message with all secrets fetched dynamically via SDS.
 *
 * @generated from protobuf message envoy.admin.v2alpha.SecretsConfigDump
 */
export interface SecretsConfigDump {
    /**
     * The statically loaded secrets.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.SecretsConfigDump.StaticSecret static_secrets = 1;
     */
    staticSecrets: SecretsConfigDump_StaticSecret[];
    /**
     * The dynamically loaded active secrets. These are secrets that are available to service
     * clusters or listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_active_secrets = 2;
     */
    dynamicActiveSecrets: SecretsConfigDump_DynamicSecret[];
    /**
     * The dynamically loaded warming secrets. These are secrets that are currently undergoing
     * warming in preparation to service clusters or listeners.
     *
     * @generated from protobuf field: repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_warming_secrets = 3;
     */
    dynamicWarmingSecrets: SecretsConfigDump_DynamicSecret[];
}
/**
 * DynamicSecret contains secret information fetched via SDS.
 *
 * @generated from protobuf message envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret
 */
export interface SecretsConfigDump_DynamicSecret {
    /**
     * The name assigned to the secret.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * This is the per-resource version information.
     *
     * @generated from protobuf field: string version_info = 2;
     */
    versionInfo: string;
    /**
     * The timestamp when the secret was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 3;
     */
    lastUpdated?: Timestamp;
    /**
     * The actual secret information.
     * Security sensitive information is redacted (replaced with "[redacted]") for
     * private keys and passwords in TLS certificates.
     *
     * @generated from protobuf field: google.protobuf.Any secret = 4;
     */
    secret?: Any;
}
/**
 * StaticSecret specifies statically loaded secret in bootstrap.
 *
 * @generated from protobuf message envoy.admin.v2alpha.SecretsConfigDump.StaticSecret
 */
export interface SecretsConfigDump_StaticSecret {
    /**
     * The name assigned to the secret.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The timestamp when the secret was last updated.
     *
     * @generated from protobuf field: google.protobuf.Timestamp last_updated = 2;
     */
    lastUpdated?: Timestamp;
    /**
     * The actual secret information.
     * Security sensitive information is redacted (replaced with "[redacted]") for
     * private keys and passwords in TLS certificates.
     *
     * @generated from protobuf field: google.protobuf.Any secret = 3;
     */
    secret?: Any;
}
// @generated message type with reflection information, may provide speed optimized methods
class ConfigDump$Type extends MessageType<ConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.ConfigDump", [
            { no: 1, name: "configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ConfigDump>): ConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.configs = [];
        if (value !== undefined)
            reflectionMergePartial<ConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigDump): ConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.protobuf.Any configs */ 1:
                    message.configs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.protobuf.Any configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            Any.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ConfigDump
 */
export const ConfigDump = new ConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFailureState$Type extends MessageType<UpdateFailureState> {
    constructor() {
        super("envoy.admin.v2alpha.UpdateFailureState", [
            { no: 1, name: "failed_configuration", kind: "message", T: () => Any },
            { no: 2, name: "last_update_attempt", kind: "message", T: () => Timestamp },
            { no: 3, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateFailureState>): UpdateFailureState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.details = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateFailureState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateFailureState): UpdateFailureState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any failed_configuration */ 1:
                    message.failedConfiguration = Any.internalBinaryRead(reader, reader.uint32(), options, message.failedConfiguration);
                    break;
                case /* google.protobuf.Timestamp last_update_attempt */ 2:
                    message.lastUpdateAttempt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdateAttempt);
                    break;
                case /* string details */ 3:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateFailureState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any failed_configuration = 1; */
        if (message.failedConfiguration)
            Any.internalBinaryWrite(message.failedConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_update_attempt = 2; */
        if (message.lastUpdateAttempt)
            Timestamp.internalBinaryWrite(message.lastUpdateAttempt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string details = 3; */
        if (message.details !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.UpdateFailureState
 */
export const UpdateFailureState = new UpdateFailureState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BootstrapConfigDump$Type extends MessageType<BootstrapConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.BootstrapConfigDump", [
            { no: 1, name: "bootstrap", kind: "message", T: () => Bootstrap },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<BootstrapConfigDump>): BootstrapConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<BootstrapConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BootstrapConfigDump): BootstrapConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* envoy.config.bootstrap.v2.Bootstrap bootstrap */ 1:
                    message.bootstrap = Bootstrap.internalBinaryRead(reader, reader.uint32(), options, message.bootstrap);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BootstrapConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* envoy.config.bootstrap.v2.Bootstrap bootstrap = 1; */
        if (message.bootstrap)
            Bootstrap.internalBinaryWrite(message.bootstrap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.BootstrapConfigDump
 */
export const BootstrapConfigDump = new BootstrapConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump$Type extends MessageType<ListenersConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.ListenersConfigDump", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "static_listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenersConfigDump_StaticListener },
            { no: 3, name: "dynamic_listeners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ListenersConfigDump_DynamicListener }
        ]);
    }
    create(value?: PartialMessage<ListenersConfigDump>): ListenersConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.staticListeners = [];
        message.dynamicListeners = [];
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump): ListenersConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated envoy.admin.v2alpha.ListenersConfigDump.StaticListener static_listeners */ 2:
                    message.staticListeners.push(ListenersConfigDump_StaticListener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.ListenersConfigDump.DynamicListener dynamic_listeners */ 3:
                    message.dynamicListeners.push(ListenersConfigDump_DynamicListener.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated envoy.admin.v2alpha.ListenersConfigDump.StaticListener static_listeners = 2; */
        for (let i = 0; i < message.staticListeners.length; i++)
            ListenersConfigDump_StaticListener.internalBinaryWrite(message.staticListeners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.ListenersConfigDump.DynamicListener dynamic_listeners = 3; */
        for (let i = 0; i < message.dynamicListeners.length; i++)
            ListenersConfigDump_DynamicListener.internalBinaryWrite(message.dynamicListeners[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ListenersConfigDump
 */
export const ListenersConfigDump = new ListenersConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_StaticListener$Type extends MessageType<ListenersConfigDump_StaticListener> {
    constructor() {
        super("envoy.admin.v2alpha.ListenersConfigDump.StaticListener", [
            { no: 1, name: "listener", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListenersConfigDump_StaticListener>): ListenersConfigDump_StaticListener {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_StaticListener>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_StaticListener): ListenersConfigDump_StaticListener {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any listener */ 1:
                    message.listener = Any.internalBinaryRead(reader, reader.uint32(), options, message.listener);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_StaticListener, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any listener = 1; */
        if (message.listener)
            Any.internalBinaryWrite(message.listener, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ListenersConfigDump.StaticListener
 */
export const ListenersConfigDump_StaticListener = new ListenersConfigDump_StaticListener$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_DynamicListenerState$Type extends MessageType<ListenersConfigDump_DynamicListenerState> {
    constructor() {
        super("envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "listener", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ListenersConfigDump_DynamicListenerState>): ListenersConfigDump_DynamicListenerState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_DynamicListenerState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_DynamicListenerState): ListenersConfigDump_DynamicListenerState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any listener */ 2:
                    message.listener = Any.internalBinaryRead(reader, reader.uint32(), options, message.listener);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_DynamicListenerState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any listener = 2; */
        if (message.listener)
            Any.internalBinaryWrite(message.listener, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState
 */
export const ListenersConfigDump_DynamicListenerState = new ListenersConfigDump_DynamicListenerState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListenersConfigDump_DynamicListener$Type extends MessageType<ListenersConfigDump_DynamicListener> {
    constructor() {
        super("envoy.admin.v2alpha.ListenersConfigDump.DynamicListener", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "active_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 3, name: "warming_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 4, name: "draining_state", kind: "message", T: () => ListenersConfigDump_DynamicListenerState },
            { no: 5, name: "error_state", kind: "message", T: () => UpdateFailureState }
        ]);
    }
    create(value?: PartialMessage<ListenersConfigDump_DynamicListener>): ListenersConfigDump_DynamicListener {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<ListenersConfigDump_DynamicListener>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListenersConfigDump_DynamicListener): ListenersConfigDump_DynamicListener {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState active_state */ 2:
                    message.activeState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.activeState);
                    break;
                case /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState warming_state */ 3:
                    message.warmingState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.warmingState);
                    break;
                case /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState draining_state */ 4:
                    message.drainingState = ListenersConfigDump_DynamicListenerState.internalBinaryRead(reader, reader.uint32(), options, message.drainingState);
                    break;
                case /* envoy.admin.v2alpha.UpdateFailureState error_state */ 5:
                    message.errorState = UpdateFailureState.internalBinaryRead(reader, reader.uint32(), options, message.errorState);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListenersConfigDump_DynamicListener, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState active_state = 2; */
        if (message.activeState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.activeState, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState warming_state = 3; */
        if (message.warmingState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.warmingState, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState draining_state = 4; */
        if (message.drainingState)
            ListenersConfigDump_DynamicListenerState.internalBinaryWrite(message.drainingState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* envoy.admin.v2alpha.UpdateFailureState error_state = 5; */
        if (message.errorState)
            UpdateFailureState.internalBinaryWrite(message.errorState, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ListenersConfigDump.DynamicListener
 */
export const ListenersConfigDump_DynamicListener = new ListenersConfigDump_DynamicListener$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump$Type extends MessageType<ClustersConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.ClustersConfigDump", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "static_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_StaticCluster },
            { no: 3, name: "dynamic_active_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_DynamicCluster },
            { no: 4, name: "dynamic_warming_clusters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ClustersConfigDump_DynamicCluster }
        ]);
    }
    create(value?: PartialMessage<ClustersConfigDump>): ClustersConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        message.staticClusters = [];
        message.dynamicActiveClusters = [];
        message.dynamicWarmingClusters = [];
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump): ClustersConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated envoy.admin.v2alpha.ClustersConfigDump.StaticCluster static_clusters */ 2:
                    message.staticClusters.push(ClustersConfigDump_StaticCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_active_clusters */ 3:
                    message.dynamicActiveClusters.push(ClustersConfigDump_DynamicCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_warming_clusters */ 4:
                    message.dynamicWarmingClusters.push(ClustersConfigDump_DynamicCluster.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated envoy.admin.v2alpha.ClustersConfigDump.StaticCluster static_clusters = 2; */
        for (let i = 0; i < message.staticClusters.length; i++)
            ClustersConfigDump_StaticCluster.internalBinaryWrite(message.staticClusters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_active_clusters = 3; */
        for (let i = 0; i < message.dynamicActiveClusters.length; i++)
            ClustersConfigDump_DynamicCluster.internalBinaryWrite(message.dynamicActiveClusters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_warming_clusters = 4; */
        for (let i = 0; i < message.dynamicWarmingClusters.length; i++)
            ClustersConfigDump_DynamicCluster.internalBinaryWrite(message.dynamicWarmingClusters[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ClustersConfigDump
 */
export const ClustersConfigDump = new ClustersConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump_StaticCluster$Type extends MessageType<ClustersConfigDump_StaticCluster> {
    constructor() {
        super("envoy.admin.v2alpha.ClustersConfigDump.StaticCluster", [
            { no: 1, name: "cluster", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ClustersConfigDump_StaticCluster>): ClustersConfigDump_StaticCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump_StaticCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump_StaticCluster): ClustersConfigDump_StaticCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any cluster */ 1:
                    message.cluster = Any.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump_StaticCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any cluster = 1; */
        if (message.cluster)
            Any.internalBinaryWrite(message.cluster, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ClustersConfigDump.StaticCluster
 */
export const ClustersConfigDump_StaticCluster = new ClustersConfigDump_StaticCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClustersConfigDump_DynamicCluster$Type extends MessageType<ClustersConfigDump_DynamicCluster> {
    constructor() {
        super("envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cluster", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ClustersConfigDump_DynamicCluster>): ClustersConfigDump_DynamicCluster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<ClustersConfigDump_DynamicCluster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClustersConfigDump_DynamicCluster): ClustersConfigDump_DynamicCluster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any cluster */ 2:
                    message.cluster = Any.internalBinaryRead(reader, reader.uint32(), options, message.cluster);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClustersConfigDump_DynamicCluster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any cluster = 2; */
        if (message.cluster)
            Any.internalBinaryWrite(message.cluster, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster
 */
export const ClustersConfigDump_DynamicCluster = new ClustersConfigDump_DynamicCluster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump$Type extends MessageType<RoutesConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.RoutesConfigDump", [
            { no: 2, name: "static_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutesConfigDump_StaticRouteConfig },
            { no: 3, name: "dynamic_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RoutesConfigDump_DynamicRouteConfig }
        ]);
    }
    create(value?: PartialMessage<RoutesConfigDump>): RoutesConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticRouteConfigs = [];
        message.dynamicRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump): RoutesConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig static_route_configs */ 2:
                    message.staticRouteConfigs.push(RoutesConfigDump_StaticRouteConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs */ 3:
                    message.dynamicRouteConfigs.push(RoutesConfigDump_DynamicRouteConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig static_route_configs = 2; */
        for (let i = 0; i < message.staticRouteConfigs.length; i++)
            RoutesConfigDump_StaticRouteConfig.internalBinaryWrite(message.staticRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs = 3; */
        for (let i = 0; i < message.dynamicRouteConfigs.length; i++)
            RoutesConfigDump_DynamicRouteConfig.internalBinaryWrite(message.dynamicRouteConfigs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.RoutesConfigDump
 */
export const RoutesConfigDump = new RoutesConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump_StaticRouteConfig$Type extends MessageType<RoutesConfigDump_StaticRouteConfig> {
    constructor() {
        super("envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig", [
            { no: 1, name: "route_config", kind: "message", T: () => Any },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<RoutesConfigDump_StaticRouteConfig>): RoutesConfigDump_StaticRouteConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump_StaticRouteConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump_StaticRouteConfig): RoutesConfigDump_StaticRouteConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any route_config */ 1:
                    message.routeConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.routeConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump_StaticRouteConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any route_config = 1; */
        if (message.routeConfig)
            Any.internalBinaryWrite(message.routeConfig, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig
 */
export const RoutesConfigDump_StaticRouteConfig = new RoutesConfigDump_StaticRouteConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoutesConfigDump_DynamicRouteConfig$Type extends MessageType<RoutesConfigDump_DynamicRouteConfig> {
    constructor() {
        super("envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig", [
            { no: 1, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "route_config", kind: "message", T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<RoutesConfigDump_DynamicRouteConfig>): RoutesConfigDump_DynamicRouteConfig {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<RoutesConfigDump_DynamicRouteConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoutesConfigDump_DynamicRouteConfig): RoutesConfigDump_DynamicRouteConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version_info */ 1:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Any route_config */ 2:
                    message.routeConfig = Any.internalBinaryRead(reader, reader.uint32(), options, message.routeConfig);
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoutesConfigDump_DynamicRouteConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version_info = 1; */
        if (message.versionInfo !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Any route_config = 2; */
        if (message.routeConfig)
            Any.internalBinaryWrite(message.routeConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig
 */
export const RoutesConfigDump_DynamicRouteConfig = new RoutesConfigDump_DynamicRouteConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump$Type extends MessageType<ScopedRoutesConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.ScopedRoutesConfigDump", [
            { no: 1, name: "inline_scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRoutesConfigDump_InlineScopedRouteConfigs },
            { no: 2, name: "dynamic_scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopedRoutesConfigDump_DynamicScopedRouteConfigs }
        ]);
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump>): ScopedRoutesConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.inlineScopedRouteConfigs = [];
        message.dynamicScopedRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump): ScopedRoutesConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs */ 1:
                    message.inlineScopedRouteConfigs.push(ScopedRoutesConfigDump_InlineScopedRouteConfigs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs */ 2:
                    message.dynamicScopedRouteConfigs.push(ScopedRoutesConfigDump_DynamicScopedRouteConfigs.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs = 1; */
        for (let i = 0; i < message.inlineScopedRouteConfigs.length; i++)
            ScopedRoutesConfigDump_InlineScopedRouteConfigs.internalBinaryWrite(message.inlineScopedRouteConfigs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2; */
        for (let i = 0; i < message.dynamicScopedRouteConfigs.length; i++)
            ScopedRoutesConfigDump_DynamicScopedRouteConfigs.internalBinaryWrite(message.dynamicScopedRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump
 */
export const ScopedRoutesConfigDump = new ScopedRoutesConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump_InlineScopedRouteConfigs$Type extends MessageType<ScopedRoutesConfigDump_InlineScopedRouteConfigs> {
    constructor() {
        super("envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump_InlineScopedRouteConfigs>): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.scopedRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump_InlineScopedRouteConfigs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump_InlineScopedRouteConfigs): ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated google.protobuf.Any scoped_route_configs */ 2:
                    message.scopedRouteConfigs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump_InlineScopedRouteConfigs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated google.protobuf.Any scoped_route_configs = 2; */
        for (let i = 0; i < message.scopedRouteConfigs.length; i++)
            Any.internalBinaryWrite(message.scopedRouteConfigs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs
 */
export const ScopedRoutesConfigDump_InlineScopedRouteConfigs = new ScopedRoutesConfigDump_InlineScopedRouteConfigs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopedRoutesConfigDump_DynamicScopedRouteConfigs$Type extends MessageType<ScopedRoutesConfigDump_DynamicScopedRouteConfigs> {
    constructor() {
        super("envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "scoped_route_configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Any },
            { no: 4, name: "last_updated", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.versionInfo = "";
        message.scopedRouteConfigs = [];
        if (value !== undefined)
            reflectionMergePartial<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopedRoutesConfigDump_DynamicScopedRouteConfigs): ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version_info */ 2:
                    message.versionInfo = reader.string();
                    break;
                case /* repeated google.protobuf.Any scoped_route_configs */ 3:
                    message.scopedRouteConfigs.push(Any.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp last_updated */ 4:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopedRoutesConfigDump_DynamicScopedRouteConfigs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version_info = 2; */
        if (message.versionInfo !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.versionInfo);
        /* repeated google.protobuf.Any scoped_route_configs = 3; */
        for (let i = 0; i < message.scopedRouteConfigs.length; i++)
            Any.internalBinaryWrite(message.scopedRouteConfigs[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp last_updated = 4; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs
 */
export const ScopedRoutesConfigDump_DynamicScopedRouteConfigs = new ScopedRoutesConfigDump_DynamicScopedRouteConfigs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump$Type extends MessageType<SecretsConfigDump> {
    constructor() {
        super("envoy.admin.v2alpha.SecretsConfigDump", [
            { no: 1, name: "static_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_StaticSecret },
            { no: 2, name: "dynamic_active_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_DynamicSecret },
            { no: 3, name: "dynamic_warming_secrets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SecretsConfigDump_DynamicSecret }
        ]);
    }
    create(value?: PartialMessage<SecretsConfigDump>): SecretsConfigDump {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.staticSecrets = [];
        message.dynamicActiveSecrets = [];
        message.dynamicWarmingSecrets = [];
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump): SecretsConfigDump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.admin.v2alpha.SecretsConfigDump.StaticSecret static_secrets */ 1:
                    message.staticSecrets.push(SecretsConfigDump_StaticSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_active_secrets */ 2:
                    message.dynamicActiveSecrets.push(SecretsConfigDump_DynamicSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_warming_secrets */ 3:
                    message.dynamicWarmingSecrets.push(SecretsConfigDump_DynamicSecret.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.admin.v2alpha.SecretsConfigDump.StaticSecret static_secrets = 1; */
        for (let i = 0; i < message.staticSecrets.length; i++)
            SecretsConfigDump_StaticSecret.internalBinaryWrite(message.staticSecrets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_active_secrets = 2; */
        for (let i = 0; i < message.dynamicActiveSecrets.length; i++)
            SecretsConfigDump_DynamicSecret.internalBinaryWrite(message.dynamicActiveSecrets[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_warming_secrets = 3; */
        for (let i = 0; i < message.dynamicWarmingSecrets.length; i++)
            SecretsConfigDump_DynamicSecret.internalBinaryWrite(message.dynamicWarmingSecrets[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.SecretsConfigDump
 */
export const SecretsConfigDump = new SecretsConfigDump$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump_DynamicSecret$Type extends MessageType<SecretsConfigDump_DynamicSecret> {
    constructor() {
        super("envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version_info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 4, name: "secret", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<SecretsConfigDump_DynamicSecret>): SecretsConfigDump_DynamicSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.versionInfo = "";
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump_DynamicSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump_DynamicSecret): SecretsConfigDump_DynamicSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string version_info */ 2:
                    message.versionInfo = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 3:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* google.protobuf.Any secret */ 4:
                    message.secret = Any.internalBinaryRead(reader, reader.uint32(), options, message.secret);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump_DynamicSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string version_info = 2; */
        if (message.versionInfo !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.versionInfo);
        /* google.protobuf.Timestamp last_updated = 3; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any secret = 4; */
        if (message.secret)
            Any.internalBinaryWrite(message.secret, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret
 */
export const SecretsConfigDump_DynamicSecret = new SecretsConfigDump_DynamicSecret$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SecretsConfigDump_StaticSecret$Type extends MessageType<SecretsConfigDump_StaticSecret> {
    constructor() {
        super("envoy.admin.v2alpha.SecretsConfigDump.StaticSecret", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "last_updated", kind: "message", T: () => Timestamp },
            { no: 3, name: "secret", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<SecretsConfigDump_StaticSecret>): SecretsConfigDump_StaticSecret {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SecretsConfigDump_StaticSecret>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SecretsConfigDump_StaticSecret): SecretsConfigDump_StaticSecret {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp last_updated */ 2:
                    message.lastUpdated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastUpdated);
                    break;
                case /* google.protobuf.Any secret */ 3:
                    message.secret = Any.internalBinaryRead(reader, reader.uint32(), options, message.secret);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SecretsConfigDump_StaticSecret, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp last_updated = 2; */
        if (message.lastUpdated)
            Timestamp.internalBinaryWrite(message.lastUpdated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any secret = 3; */
        if (message.secret)
            Any.internalBinaryWrite(message.secret, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.SecretsConfigDump.StaticSecret
 */
export const SecretsConfigDump_StaticSecret = new SecretsConfigDump_StaticSecret$Type();
