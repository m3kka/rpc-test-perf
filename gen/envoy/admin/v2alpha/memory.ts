// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/admin/v2alpha/memory.proto" (package "envoy.admin.v2alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// [#protodoc-title: Memory]

/**
 * Proto representation of the internal memory consumption of an Envoy instance. These represent
 * values extracted from an internal TCMalloc instance. For more information, see the section of the
 * docs entitled ["Generic Tcmalloc Status"](https://gperftools.github.io/gperftools/tcmalloc.html).
 * [#next-free-field: 7]
 *
 * @generated from protobuf message envoy.admin.v2alpha.Memory
 */
export interface Memory {
    /**
     * The number of bytes allocated by the heap for Envoy. This is an alias for
     * `generic.current_allocated_bytes`.
     *
     * @generated from protobuf field: uint64 allocated = 1;
     */
    allocated: bigint;
    /**
     * The number of bytes reserved by the heap but not necessarily allocated. This is an alias for
     * `generic.heap_size`.
     *
     * @generated from protobuf field: uint64 heap_size = 2;
     */
    heapSize: bigint;
    /**
     * The number of bytes in free, unmapped pages in the page heap. These bytes always count towards
     * virtual memory usage, and depending on the OS, typically do not count towards physical memory
     * usage. This is an alias for `tcmalloc.pageheap_unmapped_bytes`.
     *
     * @generated from protobuf field: uint64 pageheap_unmapped = 3;
     */
    pageheapUnmapped: bigint;
    /**
     * The number of bytes in free, mapped pages in the page heap. These bytes always count towards
     * virtual memory usage, and unless the underlying memory is swapped out by the OS, they also
     * count towards physical memory usage. This is an alias for `tcmalloc.pageheap_free_bytes`.
     *
     * @generated from protobuf field: uint64 pageheap_free = 4;
     */
    pageheapFree: bigint;
    /**
     * The amount of memory used by the TCMalloc thread caches (for small objects). This is an alias
     * for `tcmalloc.current_total_thread_cache_bytes`.
     *
     * @generated from protobuf field: uint64 total_thread_cache = 5;
     */
    totalThreadCache: bigint;
    /**
     * The number of bytes of the physical memory usage by the allocator. This is an alias for
     * `generic.total_physical_bytes`.
     *
     * @generated from protobuf field: uint64 total_physical_bytes = 6;
     */
    totalPhysicalBytes: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class Memory$Type extends MessageType<Memory> {
    constructor() {
        super("envoy.admin.v2alpha.Memory", [
            { no: 1, name: "allocated", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "heap_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "pageheap_unmapped", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pageheap_free", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "total_thread_cache", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "total_physical_bytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Memory>): Memory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allocated = 0n;
        message.heapSize = 0n;
        message.pageheapUnmapped = 0n;
        message.pageheapFree = 0n;
        message.totalThreadCache = 0n;
        message.totalPhysicalBytes = 0n;
        if (value !== undefined)
            reflectionMergePartial<Memory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Memory): Memory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 allocated */ 1:
                    message.allocated = reader.uint64().toBigInt();
                    break;
                case /* uint64 heap_size */ 2:
                    message.heapSize = reader.uint64().toBigInt();
                    break;
                case /* uint64 pageheap_unmapped */ 3:
                    message.pageheapUnmapped = reader.uint64().toBigInt();
                    break;
                case /* uint64 pageheap_free */ 4:
                    message.pageheapFree = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_thread_cache */ 5:
                    message.totalThreadCache = reader.uint64().toBigInt();
                    break;
                case /* uint64 total_physical_bytes */ 6:
                    message.totalPhysicalBytes = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Memory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 allocated = 1; */
        if (message.allocated !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.allocated);
        /* uint64 heap_size = 2; */
        if (message.heapSize !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.heapSize);
        /* uint64 pageheap_unmapped = 3; */
        if (message.pageheapUnmapped !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.pageheapUnmapped);
        /* uint64 pageheap_free = 4; */
        if (message.pageheapFree !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.pageheapFree);
        /* uint64 total_thread_cache = 5; */
        if (message.totalThreadCache !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.totalThreadCache);
        /* uint64 total_physical_bytes = 6; */
        if (message.totalPhysicalBytes !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.totalPhysicalBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.admin.v2alpha.Memory
 */
export const Memory = new Memory$Type();
