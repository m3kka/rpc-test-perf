// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/type/matcher/v3/http_inputs.proto (package envoy.type.matcher.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Match input indicates that matching should be done on a specific request header.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.request_headers]
 *
 * @generated from message envoy.type.matcher.v3.HttpRequestHeaderMatchInput
 */
export declare class HttpRequestHeaderMatchInput extends Message<HttpRequestHeaderMatchInput> {
  /**
   * The request header to match on.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  constructor(data?: PartialMessage<HttpRequestHeaderMatchInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.matcher.v3.HttpRequestHeaderMatchInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpRequestHeaderMatchInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpRequestHeaderMatchInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpRequestHeaderMatchInput;

  static equals(a: HttpRequestHeaderMatchInput | PlainMessage<HttpRequestHeaderMatchInput> | undefined, b: HttpRequestHeaderMatchInput | PlainMessage<HttpRequestHeaderMatchInput> | undefined): boolean;
}

/**
 * Match input indicates that matching should be done on a specific request trailer.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.request_trailers]
 *
 * @generated from message envoy.type.matcher.v3.HttpRequestTrailerMatchInput
 */
export declare class HttpRequestTrailerMatchInput extends Message<HttpRequestTrailerMatchInput> {
  /**
   * The request trailer to match on.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  constructor(data?: PartialMessage<HttpRequestTrailerMatchInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.matcher.v3.HttpRequestTrailerMatchInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpRequestTrailerMatchInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpRequestTrailerMatchInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpRequestTrailerMatchInput;

  static equals(a: HttpRequestTrailerMatchInput | PlainMessage<HttpRequestTrailerMatchInput> | undefined, b: HttpRequestTrailerMatchInput | PlainMessage<HttpRequestTrailerMatchInput> | undefined): boolean;
}

/**
 * Match input indicating that matching should be done on a specific response header.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the response contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.response_headers]
 *
 * @generated from message envoy.type.matcher.v3.HttpResponseHeaderMatchInput
 */
export declare class HttpResponseHeaderMatchInput extends Message<HttpResponseHeaderMatchInput> {
  /**
   * The response header to match on.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  constructor(data?: PartialMessage<HttpResponseHeaderMatchInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.matcher.v3.HttpResponseHeaderMatchInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpResponseHeaderMatchInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpResponseHeaderMatchInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpResponseHeaderMatchInput;

  static equals(a: HttpResponseHeaderMatchInput | PlainMessage<HttpResponseHeaderMatchInput> | undefined, b: HttpResponseHeaderMatchInput | PlainMessage<HttpResponseHeaderMatchInput> | undefined): boolean;
}

/**
 * Match input indicates that matching should be done on a specific response trailer.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.response_trailers]
 *
 * @generated from message envoy.type.matcher.v3.HttpResponseTrailerMatchInput
 */
export declare class HttpResponseTrailerMatchInput extends Message<HttpResponseTrailerMatchInput> {
  /**
   * The response trailer to match on.
   *
   * @generated from field: string header_name = 1;
   */
  headerName: string;

  constructor(data?: PartialMessage<HttpResponseTrailerMatchInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.matcher.v3.HttpResponseTrailerMatchInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpResponseTrailerMatchInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpResponseTrailerMatchInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpResponseTrailerMatchInput;

  static equals(a: HttpResponseTrailerMatchInput | PlainMessage<HttpResponseTrailerMatchInput> | undefined, b: HttpResponseTrailerMatchInput | PlainMessage<HttpResponseTrailerMatchInput> | undefined): boolean;
}

/**
 * Match input indicates that matching should be done on a specific query parameter.
 * The resulting input string will be the first query parameter for the value
 * 'query_param'.
 * [#extension: envoy.matching.inputs.query_params]
 *
 * @generated from message envoy.type.matcher.v3.HttpRequestQueryParamMatchInput
 */
export declare class HttpRequestQueryParamMatchInput extends Message<HttpRequestQueryParamMatchInput> {
  /**
   * The query parameter to match on.
   *
   * @generated from field: string query_param = 1;
   */
  queryParam: string;

  constructor(data?: PartialMessage<HttpRequestQueryParamMatchInput>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.matcher.v3.HttpRequestQueryParamMatchInput";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpRequestQueryParamMatchInput;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpRequestQueryParamMatchInput;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpRequestQueryParamMatchInput;

  static equals(a: HttpRequestQueryParamMatchInput | PlainMessage<HttpRequestQueryParamMatchInput> | undefined, b: HttpRequestQueryParamMatchInput | PlainMessage<HttpRequestQueryParamMatchInput> | undefined): boolean;
}

