// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "envoy/type/matcher/v3/http_inputs.proto" (package "envoy.type.matcher.v3", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// [#protodoc-title: Common HTTP inputs]

/**
 * Match input indicates that matching should be done on a specific request header.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.request_headers]
 *
 * @generated from protobuf message envoy.type.matcher.v3.HttpRequestHeaderMatchInput
 */
export interface HttpRequestHeaderMatchInput {
    /**
     * The request header to match on.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
}
/**
 * Match input indicates that matching should be done on a specific request trailer.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.request_trailers]
 *
 * @generated from protobuf message envoy.type.matcher.v3.HttpRequestTrailerMatchInput
 */
export interface HttpRequestTrailerMatchInput {
    /**
     * The request trailer to match on.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
}
/**
 * Match input indicating that matching should be done on a specific response header.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the response contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.response_headers]
 *
 * @generated from protobuf message envoy.type.matcher.v3.HttpResponseHeaderMatchInput
 */
export interface HttpResponseHeaderMatchInput {
    /**
     * The response header to match on.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
}
/**
 * Match input indicates that matching should be done on a specific response trailer.
 * The resulting input string will be all headers for the given key joined by a comma,
 * e.g. if the request contains two 'foo' headers with value 'bar' and 'baz', the input
 * string will be 'bar,baz'.
 * [#comment:TODO(snowp): Link to unified matching docs.]
 * [#extension: envoy.matching.inputs.response_trailers]
 *
 * @generated from protobuf message envoy.type.matcher.v3.HttpResponseTrailerMatchInput
 */
export interface HttpResponseTrailerMatchInput {
    /**
     * The response trailer to match on.
     *
     * @generated from protobuf field: string header_name = 1;
     */
    headerName: string;
}
/**
 * Match input indicates that matching should be done on a specific query parameter.
 * The resulting input string will be the first query parameter for the value
 * 'query_param'.
 * [#extension: envoy.matching.inputs.query_params]
 *
 * @generated from protobuf message envoy.type.matcher.v3.HttpRequestQueryParamMatchInput
 */
export interface HttpRequestQueryParamMatchInput {
    /**
     * The query parameter to match on.
     *
     * @generated from protobuf field: string query_param = 1;
     */
    queryParam: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class HttpRequestHeaderMatchInput$Type extends MessageType<HttpRequestHeaderMatchInput> {
    constructor() {
        super("envoy.type.matcher.v3.HttpRequestHeaderMatchInput", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<HttpRequestHeaderMatchInput>): HttpRequestHeaderMatchInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<HttpRequestHeaderMatchInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpRequestHeaderMatchInput): HttpRequestHeaderMatchInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpRequestHeaderMatchInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.type.matcher.v3.HttpRequestHeaderMatchInput
 */
export const HttpRequestHeaderMatchInput = new HttpRequestHeaderMatchInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpRequestTrailerMatchInput$Type extends MessageType<HttpRequestTrailerMatchInput> {
    constructor() {
        super("envoy.type.matcher.v3.HttpRequestTrailerMatchInput", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<HttpRequestTrailerMatchInput>): HttpRequestTrailerMatchInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<HttpRequestTrailerMatchInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpRequestTrailerMatchInput): HttpRequestTrailerMatchInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpRequestTrailerMatchInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.type.matcher.v3.HttpRequestTrailerMatchInput
 */
export const HttpRequestTrailerMatchInput = new HttpRequestTrailerMatchInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpResponseHeaderMatchInput$Type extends MessageType<HttpResponseHeaderMatchInput> {
    constructor() {
        super("envoy.type.matcher.v3.HttpResponseHeaderMatchInput", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<HttpResponseHeaderMatchInput>): HttpResponseHeaderMatchInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<HttpResponseHeaderMatchInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpResponseHeaderMatchInput): HttpResponseHeaderMatchInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpResponseHeaderMatchInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.type.matcher.v3.HttpResponseHeaderMatchInput
 */
export const HttpResponseHeaderMatchInput = new HttpResponseHeaderMatchInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpResponseTrailerMatchInput$Type extends MessageType<HttpResponseTrailerMatchInput> {
    constructor() {
        super("envoy.type.matcher.v3.HttpResponseTrailerMatchInput", [
            { no: 1, name: "header_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { wellKnownRegex: "HTTP_HEADER_NAME", strict: false } } } }
        ]);
    }
    create(value?: PartialMessage<HttpResponseTrailerMatchInput>): HttpResponseTrailerMatchInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.headerName = "";
        if (value !== undefined)
            reflectionMergePartial<HttpResponseTrailerMatchInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpResponseTrailerMatchInput): HttpResponseTrailerMatchInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header_name */ 1:
                    message.headerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpResponseTrailerMatchInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header_name = 1; */
        if (message.headerName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.headerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.type.matcher.v3.HttpResponseTrailerMatchInput
 */
export const HttpResponseTrailerMatchInput = new HttpResponseTrailerMatchInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HttpRequestQueryParamMatchInput$Type extends MessageType<HttpRequestQueryParamMatchInput> {
    constructor() {
        super("envoy.type.matcher.v3.HttpRequestQueryParamMatchInput", [
            { no: 1, name: "query_param", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<HttpRequestQueryParamMatchInput>): HttpRequestQueryParamMatchInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.queryParam = "";
        if (value !== undefined)
            reflectionMergePartial<HttpRequestQueryParamMatchInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HttpRequestQueryParamMatchInput): HttpRequestQueryParamMatchInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query_param */ 1:
                    message.queryParam = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HttpRequestQueryParamMatchInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query_param = 1; */
        if (message.queryParam !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.queryParam);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.type.matcher.v3.HttpRequestQueryParamMatchInput
 */
export const HttpRequestQueryParamMatchInput = new HttpRequestQueryParamMatchInput$Type();
