// @generated by protoc-gen-es v1.5.1
// @generated from file envoy/type/v3/ratelimit_strategy.proto (package envoy.type.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { TokenBucket } from "./token_bucket_pb.js";
import type { RateLimitUnit } from "./ratelimit_unit_pb.js";

/**
 * @generated from message envoy.type.v3.RateLimitStrategy
 */
export declare class RateLimitStrategy extends Message<RateLimitStrategy> {
  /**
   * @generated from oneof envoy.type.v3.RateLimitStrategy.strategy
   */
  strategy: {
    /**
     * Allow or Deny the requests.
     * If unset, allow all.
     *
     * @generated from field: envoy.type.v3.RateLimitStrategy.BlanketRule blanket_rule = 1;
     */
    value: RateLimitStrategy_BlanketRule;
    case: "blanketRule";
  } | {
    /**
     * Best-effort limit of the number of requests per time unit, f.e. requests per second.
     * Does not prescribe any specific rate limiting algorithm, see :ref:`RequestsPerTimeUnit
     * <envoy_v3_api_msg_type.v3.RateLimitStrategy.RequestsPerTimeUnit>` for details.
     *
     * @generated from field: envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit requests_per_time_unit = 2;
     */
    value: RateLimitStrategy_RequestsPerTimeUnit;
    case: "requestsPerTimeUnit";
  } | {
    /**
     * Limit the requests by consuming tokens from the Token Bucket.
     * Allow the same number of requests as the number of tokens available in
     * the token bucket.
     *
     * @generated from field: envoy.type.v3.TokenBucket token_bucket = 3;
     */
    value: TokenBucket;
    case: "tokenBucket";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<RateLimitStrategy>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.v3.RateLimitStrategy";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitStrategy;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitStrategy;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitStrategy;

  static equals(a: RateLimitStrategy | PlainMessage<RateLimitStrategy> | undefined, b: RateLimitStrategy | PlainMessage<RateLimitStrategy> | undefined): boolean;
}

/**
 * Choose between allow all and deny all.
 *
 * @generated from enum envoy.type.v3.RateLimitStrategy.BlanketRule
 */
export declare enum RateLimitStrategy_BlanketRule {
  /**
   * @generated from enum value: ALLOW_ALL = 0;
   */
  ALLOW_ALL = 0,

  /**
   * @generated from enum value: DENY_ALL = 1;
   */
  DENY_ALL = 1,
}

/**
 * Best-effort limit of the number of requests per time unit.
 *
 * Allows to specify the desired requests per second (RPS, QPS), requests per minute (QPM, RPM),
 * etc., without specifying a rate limiting algorithm implementation.
 *
 * ``RequestsPerTimeUnit`` strategy does not demand any specific rate limiting algorithm to be
 * used (in contrast to the :ref:`TokenBucket <envoy_v3_api_msg_type.v3.TokenBucket>`,
 * for example). It implies that the implementation details of rate limiting algorithm are
 * irrelevant as long as the configured number of "requests per time unit" is achieved.
 *
 * Note that the ``TokenBucket`` is still a valid implementation of the ``RequestsPerTimeUnit``
 * strategy, and may be chosen to enforce the rate limit. However, there's no guarantee it will be
 * the ``TokenBucket`` in particular, and not the Leaky Bucket, the Sliding Window, or any other
 * rate limiting algorithm that fulfills the requirements.
 *
 * @generated from message envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit
 */
export declare class RateLimitStrategy_RequestsPerTimeUnit extends Message<RateLimitStrategy_RequestsPerTimeUnit> {
  /**
   * The desired number of requests per :ref:`time_unit
   * <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.time_unit>` to allow.
   * If set to ``0``, deny all (equivalent to ``BlanketRule.DENY_ALL``).
   *
   * .. note::
   *   Note that the algorithm implementation determines the course of action for the requests
   *   over the limit. As long as the ``requests_per_time_unit`` converges on the desired value,
   *   it's allowed to treat this field as a soft-limit: allow bursts, redistribute the allowance
   *   over time, etc.
   *
   *
   * @generated from field: uint64 requests_per_time_unit = 1;
   */
  requestsPerTimeUnit: bigint;

  /**
   * The unit of time. Ignored when :ref:`requests_per_time_unit
   * <envoy_v3_api_field_type.v3.RateLimitStrategy.RequestsPerTimeUnit.requests_per_time_unit>`
   * is ``0`` (deny all).
   *
   * @generated from field: envoy.type.v3.RateLimitUnit time_unit = 2;
   */
  timeUnit: RateLimitUnit;

  constructor(data?: PartialMessage<RateLimitStrategy_RequestsPerTimeUnit>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.type.v3.RateLimitStrategy.RequestsPerTimeUnit";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitStrategy_RequestsPerTimeUnit;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitStrategy_RequestsPerTimeUnit;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitStrategy_RequestsPerTimeUnit;

  static equals(a: RateLimitStrategy_RequestsPerTimeUnit | PlainMessage<RateLimitStrategy_RequestsPerTimeUnit> | undefined, b: RateLimitStrategy_RequestsPerTimeUnit | PlainMessage<RateLimitStrategy_RequestsPerTimeUnit> | undefined): boolean;
}

