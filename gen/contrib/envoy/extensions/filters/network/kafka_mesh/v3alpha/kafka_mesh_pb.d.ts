// @generated by protoc-gen-es v1.5.1
// @generated from file contrib/envoy/extensions/filters/network/kafka_mesh/v3alpha/kafka_mesh.proto (package envoy.extensions.filters.network.kafka_mesh.v3alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh
 */
export declare class KafkaMesh extends Message<KafkaMesh> {
  /**
   * Envoy's host that's advertised to clients.
   * Has the same meaning as corresponding Kafka broker properties.
   * Usually equal to filter chain's listener config, but needs to be reachable by clients
   * (so 0.0.0.0 will not work).
   *
   * @generated from field: string advertised_host = 1;
   */
  advertisedHost: string;

  /**
   * Envoy's port that's advertised to clients.
   *
   * @generated from field: int32 advertised_port = 2;
   */
  advertisedPort: number;

  /**
   * Upstream clusters this filter will connect to.
   *
   * @generated from field: repeated envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition upstream_clusters = 3;
   */
  upstreamClusters: KafkaClusterDefinition[];

  /**
   * Rules that will decide which cluster gets which request.
   *
   * @generated from field: repeated envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule forwarding_rules = 4;
   */
  forwardingRules: ForwardingRule[];

  /**
   * How the consumer proxying should behave - this relates mostly to Fetch request handling.
   *
   * @generated from field: envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.ConsumerProxyMode consumer_proxy_mode = 5;
   */
  consumerProxyMode: KafkaMesh_ConsumerProxyMode;

  constructor(data?: PartialMessage<KafkaMesh>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KafkaMesh;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KafkaMesh;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KafkaMesh;

  static equals(a: KafkaMesh | PlainMessage<KafkaMesh> | undefined, b: KafkaMesh | PlainMessage<KafkaMesh> | undefined): boolean;
}

/**
 * @generated from enum envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaMesh.ConsumerProxyMode
 */
export declare enum KafkaMesh_ConsumerProxyMode {
  /**
   * Records received are going to be distributed amongst downstream consumer connections.
   * In this mode Envoy uses librdkafka consumers pointing at upstream Kafka clusters, what means that these
   * consumers' position is meaningful and affects what records are received from upstream.
   * Users might want to take a look into these consumers' custom configuration to manage their auto-committing
   * capabilities, as it will impact Envoy's behaviour in case of restarts.
   *
   * @generated from enum value: StatefulConsumerProxy = 0;
   */
  StatefulConsumerProxy = 0,
}

/**
 * [#next-free-field: 6]
 *
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition
 */
export declare class KafkaClusterDefinition extends Message<KafkaClusterDefinition> {
  /**
   * Cluster name.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * Kafka cluster address.
   *
   * @generated from field: string bootstrap_servers = 2;
   */
  bootstrapServers: string;

  /**
   * Default number of partitions present in this cluster.
   * This is especially important for clients that do not specify partition in their payloads and depend on this value for hashing.
   * The same number of partitions is going to be used by upstream-pointing Kafka consumers for consumer proxying scenarios.
   *
   * @generated from field: int32 partition_count = 3;
   */
  partitionCount: number;

  /**
   * Custom configuration passed to Kafka producer.
   *
   * @generated from field: map<string, string> producer_config = 4;
   */
  producerConfig: { [key: string]: string };

  /**
   * Custom configuration passed to Kafka consumer.
   *
   * @generated from field: map<string, string> consumer_config = 5;
   */
  consumerConfig: { [key: string]: string };

  constructor(data?: PartialMessage<KafkaClusterDefinition>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.kafka_mesh.v3alpha.KafkaClusterDefinition";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KafkaClusterDefinition;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KafkaClusterDefinition;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KafkaClusterDefinition;

  static equals(a: KafkaClusterDefinition | PlainMessage<KafkaClusterDefinition> | undefined, b: KafkaClusterDefinition | PlainMessage<KafkaClusterDefinition> | undefined): boolean;
}

/**
 * @generated from message envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule
 */
export declare class ForwardingRule extends Message<ForwardingRule> {
  /**
   * Cluster name.
   *
   * @generated from field: string target_cluster = 1;
   */
  targetCluster: string;

  /**
   * @generated from oneof envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule.trigger
   */
  trigger: {
    /**
     * Intended place for future types of forwarding rules.
     *
     * @generated from field: string topic_prefix = 2;
     */
    value: string;
    case: "topicPrefix";
  } | { case: undefined; value?: undefined };

  constructor(data?: PartialMessage<ForwardingRule>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.network.kafka_mesh.v3alpha.ForwardingRule";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForwardingRule;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForwardingRule;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForwardingRule;

  static equals(a: ForwardingRule | PlainMessage<ForwardingRule> | undefined, b: ForwardingRule | PlainMessage<ForwardingRule> | undefined): boolean;
}

