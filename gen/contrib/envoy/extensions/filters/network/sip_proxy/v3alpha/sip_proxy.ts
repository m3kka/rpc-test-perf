// @generated by protobuf-ts 2.9.2
// @generated from protobuf file "contrib/envoy/extensions/filters/network/sip_proxy/v3alpha/sip_proxy.proto" (package "envoy.extensions.filters.network.sip_proxy.v3alpha", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../../../../../google/protobuf/any";
import { TraServiceConfig } from "../tra/v3alpha/tra";
import { Duration } from "../../../../../../../google/protobuf/duration";
import { RouteConfiguration } from "./route";
// [#protodoc-title: Sip Proxy]
// [#extension: envoy.filters.network.sip_proxy]

/**
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy
 */
export interface SipProxy {
    /**
     * The human readable prefix to use when emitting statistics.
     *
     * @generated from protobuf field: string stat_prefix = 1;
     */
    statPrefix: string;
    /**
     * The route table for the connection manager is static and is specified in this property.
     *
     * @generated from protobuf field: envoy.extensions.filters.network.sip_proxy.v3alpha.RouteConfiguration route_config = 2;
     */
    routeConfig?: RouteConfiguration;
    /**
     * A list of individual Sip filters that make up the filter chain for requests made to the
     * Sip proxy. Order matters as the filters are processed sequentially. For backwards
     * compatibility, if no sip_filters are specified, a default Sip router filter
     * (``envoy.filters.sip.router``) is used.
     * [#extension-category: envoy.sip_proxy.filters]
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter sip_filters = 3;
     */
    sipFilters: SipFilter[];
    /**
     * @generated from protobuf field: envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings settings = 4;
     */
    settings?: SipProxy_SipSettings;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings
 */
export interface SipProxy_SipSettings {
    /**
     * transaction timeout timer [Timer B] unit is milliseconds, default value 64*T1.
     *
     * Session Initiation Protocol (SIP) timer summary
     *
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer   | Default value           | Section  | Meaning                                                                      |
     * +=========+=========================+==========+==============================================================================+
     * | T1      | 500 ms                  | 17.1.1.1 | Round-trip time (RTT) estimate                                               |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | T2      | 4 sec                   | 17.1.2.2 | Maximum re-transmission interval for non-INVITE requests and INVITE responses|
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | T4      | 5 sec                   | 17.1.2.2 | Maximum duration that a message can remain in the network                    |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer A | initially T1            | 17.1.1.2 | INVITE request re-transmission interval, for UDP only                        |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer B | 64*T1                   | 17.1.1.2 | INVITE transaction timeout timer                                             |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer D | > 32 sec. for UDP       | 17.1.1.2 | Wait time for response re-transmissions                                      |
     * |         | 0 sec. for TCP and SCTP |          |                                                                              |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer E | initially T1            | 17.1.2.2 | Non-INVITE request re-transmission interval, UDP only                        |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer F | 64*T1                   | 17.1.2.2 | Non-INVITE transaction timeout timer                                         |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer G | initially T1            | 17.2.1   | INVITE response re-transmission interval                                     |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer H | 64*T1                   | 17.2.1   | Wait time for ACK receipt                                                    |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer I | T4 for UDP              | 17.2.1   | Wait time for ACK re-transmissions                                           |
     * |         | 0 sec. for TCP and SCTP |          |                                                                              |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer J | 64*T1 for UDP           | 17.2.2   | Wait time for re-transmissions of non-INVITE requests                        |
     * |         | 0 sec. for TCP and SCTP |          |                                                                              |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     * | Timer K | T4 for UDP              | 17.1.2.2 | Wait time for response re-transmissions                                      |
     * |         | 0 sec. for TCP and SCTP |          |                                                                              |
     * +---------+-------------------------+----------+------------------------------------------------------------------------------+
     *
     * @generated from protobuf field: google.protobuf.Duration transaction_timeout = 1;
     */
    transactionTimeout?: Duration;
    /**
     * The service to match for ep insert
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService local_services = 2;
     */
    localServices: LocalService[];
    /**
     * @generated from protobuf field: envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraServiceConfig tra_service_config = 3;
     */
    traServiceConfig?: TraServiceConfig;
    /**
     * Whether via header is operated, including add via for request and pop via for response
     * False: sip service proxy
     * True:  sip load balancer
     *
     * @generated from protobuf field: bool operate_via = 4;
     */
    operateVia: boolean;
}
/**
 * SipFilter configures a Sip filter.
 *
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter
 */
export interface SipFilter {
    /**
     * The name of the filter to instantiate. The name must match a supported
     * filter. The built-in filters are:
     *
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: config_type
     */
    configType: {
        oneofKind: "typedConfig";
        /**
         * @generated from protobuf field: google.protobuf.Any typed_config = 3;
         */
        typedConfig: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * SipProtocolOptions specifies Sip upstream protocol options. This object is used in
 * :ref:`typed_extension_protocol_options<envoy_v3_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
 * keyed by the name ``envoy.filters.network.sip_proxy``.
 *
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProtocolOptions
 */
export interface SipProtocolOptions {
    /**
     * All sip messages in one dialog should go to the same endpoint.
     *
     * @generated from protobuf field: bool session_affinity = 1;
     */
    sessionAffinity: boolean;
    /**
     * The Register with Authorization header should go to the same endpoint which send out the 401 Unauthorized.
     *
     * @generated from protobuf field: bool registration_affinity = 2;
     */
    registrationAffinity: boolean;
    /**
     * Customized affinity
     *
     * @generated from protobuf field: envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity customized_affinity = 3;
     */
    customizedAffinity?: CustomizedAffinity;
}
/**
 * For affinity
 *
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity
 */
export interface CustomizedAffinity {
    /**
     * Affinity rules to conclude the upstream endpoint
     *
     * @generated from protobuf field: repeated envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry entries = 1;
     */
    entries: CustomizedAffinityEntry[];
    /**
     * Configures whether load balance should be stopped or continued after affinity handling.
     *
     * @generated from protobuf field: bool stop_load_balance = 2;
     */
    stopLoadBalance: boolean;
}
/**
 * [#next-free-field: 6]
 *
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry
 */
export interface CustomizedAffinityEntry {
    /**
     * The header name to match, e.g. "From", if not specified, default is "Route"
     *
     * @generated from protobuf field: string header = 1;
     */
    header: string;
    /**
     * Affinity key for TRA query/subscribe, e.g. "lskpmc", if key_name is "text" means use the header content as key.
     *
     * @generated from protobuf field: string key_name = 2;
     */
    keyName: string;
    /**
     * Whether subscribe to TRA is required
     *
     * @generated from protobuf field: bool subscribe = 3;
     */
    subscribe: boolean;
    /**
     * Whether query to TRA is required
     *
     * @generated from protobuf field: bool query = 4;
     */
    query: boolean;
    /**
     * Local cache
     *
     * @generated from protobuf field: envoy.extensions.filters.network.sip_proxy.v3alpha.Cache cache = 5;
     */
    cache?: Cache;
}
/**
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.Cache
 */
export interface Cache {
    /**
     * Affinity local cache item max number
     *
     * @generated from protobuf field: int32 max_cache_item = 1;
     */
    maxCacheItem: number;
    /**
     * Whether query result can be added to local cache
     *
     * @generated from protobuf field: bool add_query_to_cache = 2;
     */
    addQueryToCache: boolean;
}
/**
 * Local Service
 *
 * @generated from protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService
 */
export interface LocalService {
    /**
     * The domain need to matched
     *
     * @generated from protobuf field: string domain = 1;
     */
    domain: string;
    /**
     * The parameter to get domain
     *
     * @generated from protobuf field: string parameter = 2;
     */
    parameter: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class SipProxy$Type extends MessageType<SipProxy> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy", [
            { no: 1, name: "stat_prefix", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 2, name: "route_config", kind: "message", T: () => RouteConfiguration },
            { no: 3, name: "sip_filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SipFilter },
            { no: 4, name: "settings", kind: "message", T: () => SipProxy_SipSettings }
        ]);
    }
    create(value?: PartialMessage<SipProxy>): SipProxy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statPrefix = "";
        message.sipFilters = [];
        if (value !== undefined)
            reflectionMergePartial<SipProxy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SipProxy): SipProxy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stat_prefix */ 1:
                    message.statPrefix = reader.string();
                    break;
                case /* envoy.extensions.filters.network.sip_proxy.v3alpha.RouteConfiguration route_config */ 2:
                    message.routeConfig = RouteConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.routeConfig);
                    break;
                case /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter sip_filters */ 3:
                    message.sipFilters.push(SipFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings settings */ 4:
                    message.settings = SipProxy_SipSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SipProxy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stat_prefix = 1; */
        if (message.statPrefix !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.statPrefix);
        /* envoy.extensions.filters.network.sip_proxy.v3alpha.RouteConfiguration route_config = 2; */
        if (message.routeConfig)
            RouteConfiguration.internalBinaryWrite(message.routeConfig, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter sip_filters = 3; */
        for (let i = 0; i < message.sipFilters.length; i++)
            SipFilter.internalBinaryWrite(message.sipFilters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings settings = 4; */
        if (message.settings)
            SipProxy_SipSettings.internalBinaryWrite(message.settings, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy
 */
export const SipProxy = new SipProxy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SipProxy_SipSettings$Type extends MessageType<SipProxy_SipSettings> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings", [
            { no: 1, name: "transaction_timeout", kind: "message", T: () => Duration },
            { no: 2, name: "local_services", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => LocalService },
            { no: 3, name: "tra_service_config", kind: "message", T: () => TraServiceConfig },
            { no: 4, name: "operate_via", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SipProxy_SipSettings>): SipProxy_SipSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.localServices = [];
        message.operateVia = false;
        if (value !== undefined)
            reflectionMergePartial<SipProxy_SipSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SipProxy_SipSettings): SipProxy_SipSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Duration transaction_timeout */ 1:
                    message.transactionTimeout = Duration.internalBinaryRead(reader, reader.uint32(), options, message.transactionTimeout);
                    break;
                case /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService local_services */ 2:
                    message.localServices.push(LocalService.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraServiceConfig tra_service_config */ 3:
                    message.traServiceConfig = TraServiceConfig.internalBinaryRead(reader, reader.uint32(), options, message.traServiceConfig);
                    break;
                case /* bool operate_via */ 4:
                    message.operateVia = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SipProxy_SipSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Duration transaction_timeout = 1; */
        if (message.transactionTimeout)
            Duration.internalBinaryWrite(message.transactionTimeout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService local_services = 2; */
        for (let i = 0; i < message.localServices.length; i++)
            LocalService.internalBinaryWrite(message.localServices[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* envoy.extensions.filters.network.sip_proxy.tra.v3alpha.TraServiceConfig tra_service_config = 3; */
        if (message.traServiceConfig)
            TraServiceConfig.internalBinaryWrite(message.traServiceConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool operate_via = 4; */
        if (message.operateVia !== false)
            writer.tag(4, WireType.Varint).bool(message.operateVia);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProxy.SipSettings
 */
export const SipProxy_SipSettings = new SipProxy_SipSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SipFilter$Type extends MessageType<SipFilter> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { minLen: "1" } } } },
            { no: 3, name: "typed_config", kind: "message", oneof: "configType", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<SipFilter>): SipFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.configType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SipFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SipFilter): SipFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Any typed_config */ 3:
                    message.configType = {
                        oneofKind: "typedConfig",
                        typedConfig: Any.internalBinaryRead(reader, reader.uint32(), options, (message.configType as any).typedConfig)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SipFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Any typed_config = 3; */
        if (message.configType.oneofKind === "typedConfig")
            Any.internalBinaryWrite(message.configType.typedConfig, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipFilter
 */
export const SipFilter = new SipFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SipProtocolOptions$Type extends MessageType<SipProtocolOptions> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.SipProtocolOptions", [
            { no: 1, name: "session_affinity", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "registration_affinity", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "customized_affinity", kind: "message", T: () => CustomizedAffinity }
        ]);
    }
    create(value?: PartialMessage<SipProtocolOptions>): SipProtocolOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessionAffinity = false;
        message.registrationAffinity = false;
        if (value !== undefined)
            reflectionMergePartial<SipProtocolOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SipProtocolOptions): SipProtocolOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool session_affinity */ 1:
                    message.sessionAffinity = reader.bool();
                    break;
                case /* bool registration_affinity */ 2:
                    message.registrationAffinity = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity customized_affinity */ 3:
                    message.customizedAffinity = CustomizedAffinity.internalBinaryRead(reader, reader.uint32(), options, message.customizedAffinity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SipProtocolOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool session_affinity = 1; */
        if (message.sessionAffinity !== false)
            writer.tag(1, WireType.Varint).bool(message.sessionAffinity);
        /* bool registration_affinity = 2; */
        if (message.registrationAffinity !== false)
            writer.tag(2, WireType.Varint).bool(message.registrationAffinity);
        /* envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity customized_affinity = 3; */
        if (message.customizedAffinity)
            CustomizedAffinity.internalBinaryWrite(message.customizedAffinity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.SipProtocolOptions
 */
export const SipProtocolOptions = new SipProtocolOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomizedAffinity$Type extends MessageType<CustomizedAffinity> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity", [
            { no: 1, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CustomizedAffinityEntry },
            { no: 2, name: "stop_load_balance", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CustomizedAffinity>): CustomizedAffinity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        message.stopLoadBalance = false;
        if (value !== undefined)
            reflectionMergePartial<CustomizedAffinity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomizedAffinity): CustomizedAffinity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry entries */ 1:
                    message.entries.push(CustomizedAffinityEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool stop_load_balance */ 2:
                    message.stopLoadBalance = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomizedAffinity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CustomizedAffinityEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool stop_load_balance = 2; */
        if (message.stopLoadBalance !== false)
            writer.tag(2, WireType.Varint).bool(message.stopLoadBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinity
 */
export const CustomizedAffinity = new CustomizedAffinity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomizedAffinityEntry$Type extends MessageType<CustomizedAffinityEntry> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry", [
            { no: 1, name: "header", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "subscribe", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "query", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "cache", kind: "message", T: () => Cache }
        ]);
    }
    create(value?: PartialMessage<CustomizedAffinityEntry>): CustomizedAffinityEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.header = "";
        message.keyName = "";
        message.subscribe = false;
        message.query = false;
        if (value !== undefined)
            reflectionMergePartial<CustomizedAffinityEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomizedAffinityEntry): CustomizedAffinityEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string header */ 1:
                    message.header = reader.string();
                    break;
                case /* string key_name */ 2:
                    message.keyName = reader.string();
                    break;
                case /* bool subscribe */ 3:
                    message.subscribe = reader.bool();
                    break;
                case /* bool query */ 4:
                    message.query = reader.bool();
                    break;
                case /* envoy.extensions.filters.network.sip_proxy.v3alpha.Cache cache */ 5:
                    message.cache = Cache.internalBinaryRead(reader, reader.uint32(), options, message.cache);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomizedAffinityEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string header = 1; */
        if (message.header !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.header);
        /* string key_name = 2; */
        if (message.keyName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.keyName);
        /* bool subscribe = 3; */
        if (message.subscribe !== false)
            writer.tag(3, WireType.Varint).bool(message.subscribe);
        /* bool query = 4; */
        if (message.query !== false)
            writer.tag(4, WireType.Varint).bool(message.query);
        /* envoy.extensions.filters.network.sip_proxy.v3alpha.Cache cache = 5; */
        if (message.cache)
            Cache.internalBinaryWrite(message.cache, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.CustomizedAffinityEntry
 */
export const CustomizedAffinityEntry = new CustomizedAffinityEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cache$Type extends MessageType<Cache> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.Cache", [
            { no: 1, name: "max_cache_item", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "add_query_to_cache", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Cache>): Cache {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxCacheItem = 0;
        message.addQueryToCache = false;
        if (value !== undefined)
            reflectionMergePartial<Cache>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cache): Cache {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 max_cache_item */ 1:
                    message.maxCacheItem = reader.int32();
                    break;
                case /* bool add_query_to_cache */ 2:
                    message.addQueryToCache = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cache, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 max_cache_item = 1; */
        if (message.maxCacheItem !== 0)
            writer.tag(1, WireType.Varint).int32(message.maxCacheItem);
        /* bool add_query_to_cache = 2; */
        if (message.addQueryToCache !== false)
            writer.tag(2, WireType.Varint).bool(message.addQueryToCache);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.Cache
 */
export const Cache = new Cache$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalService$Type extends MessageType<LocalService> {
    constructor() {
        super("envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService", [
            { no: 1, name: "domain", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LocalService>): LocalService {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.domain = "";
        message.parameter = "";
        if (value !== undefined)
            reflectionMergePartial<LocalService>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalService): LocalService {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string domain */ 1:
                    message.domain = reader.string();
                    break;
                case /* string parameter */ 2:
                    message.parameter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalService, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string domain = 1; */
        if (message.domain !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.domain);
        /* string parameter = 2; */
        if (message.parameter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parameter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message envoy.extensions.filters.network.sip_proxy.v3alpha.LocalService
 */
export const LocalService = new LocalService$Type();
