// @generated by protoc-gen-es v1.5.1
// @generated from file contrib/envoy/extensions/filters/http/sxg/v3alpha/sxg.proto (package envoy.extensions.filters.http.sxg.v3alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, Duration, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import type { SdsSecretConfig } from "../../../../../../../envoy/extensions/transport_sockets/tls/v3/secret_pb.js";

/**
 * [#next-free-field: 10]
 *
 * @generated from message envoy.extensions.filters.http.sxg.v3alpha.SXG
 */
export declare class SXG extends Message<SXG> {
  /**
   * The SDS configuration for the public key data for the SSL certificate that will be used to sign the
   * SXG response.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig certificate = 1;
   */
  certificate?: SdsSecretConfig;

  /**
   * The SDS configuration for the private key data for the SSL certificate that will be used to sign the
   * SXG response.
   *
   * @generated from field: envoy.extensions.transport_sockets.tls.v3.SdsSecretConfig private_key = 2;
   */
  privateKey?: SdsSecretConfig;

  /**
   * The duration for which the generated SXG package will be valid. Default is 604800s (7 days in seconds).
   * Note that in order to account for clock skew, the timestamp will be backdated by a day. So, if duration
   * is set to 7 days, that will be 7 days from 24 hours ago (6 days from now). Also note that while 6/7 days
   * is appropriate for most content, if the downstream service is serving Javascript, or HTML with inline
   * Javascript, 1 day (so, with backdated expiry, 2 days, or 172800 seconds) is more appropriate.
   *
   * @generated from field: google.protobuf.Duration duration = 3;
   */
  duration?: Duration;

  /**
   * The SXG response payload is Merkle Integrity Content Encoding (MICE) encoded (specification is [here](https://datatracker.ietf.org/doc/html/draft-thomson-http-mice-03))
   * This value indicates the record size in the encoded payload. The default value is 4096.
   *
   * @generated from field: uint64 mi_record_size = 4;
   */
  miRecordSize: bigint;

  /**
   * The URI of certificate CBOR file published. Since it is required that the certificate CBOR file
   * be served from the same domain as the SXG document, this should be a relative URI.
   *
   * @generated from field: string cbor_url = 5;
   */
  cborUrl: string;

  /**
   * URL to retrieve validity data for signature, a CBOR map. See specification [here](https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-00#section-3.6)
   *
   * @generated from field: string validity_url = 6;
   */
  validityUrl: string;

  /**
   * Header that will be set if it is determined that the client can accept SXG (typically ``accept: application/signed-exchange;v=b3``)
   * If not set, filter will default to: ``x-client-can-accept-sxg``
   *
   * @generated from field: string client_can_accept_sxg_header = 7;
   */
  clientCanAcceptSxgHeader: string;

  /**
   * Header set by downstream service to signal that the response should be transformed to SXG If not set,
   * filter will default to: ``x-should-encode-sxg``
   *
   * @generated from field: string should_encode_sxg_header = 8;
   */
  shouldEncodeSxgHeader: string;

  /**
   * Headers that will be stripped from the SXG document, by listing a prefix (i.e. ``x-custom-`` will cause
   * all headers prefixed by ``x-custom-`` to be omitted from the SXG document)
   *
   * @generated from field: repeated string header_prefix_filters = 9;
   */
  headerPrefixFilters: string[];

  constructor(data?: PartialMessage<SXG>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.filters.http.sxg.v3alpha.SXG";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SXG;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SXG;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SXG;

  static equals(a: SXG | PlainMessage<SXG> | undefined, b: SXG | PlainMessage<SXG> | undefined): boolean;
}

