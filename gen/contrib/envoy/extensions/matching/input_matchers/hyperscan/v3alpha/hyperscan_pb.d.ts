// @generated by protoc-gen-es v1.5.1
// @generated from file contrib/envoy/extensions/matching/input_matchers/hyperscan/v3alpha/hyperscan.proto (package envoy.extensions.matching.input_matchers.hyperscan.v3alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * `Hyperscan <https://github.com/intel/hyperscan>`_ regex matcher. The matcher uses the Hyperscan
 * engine which exploits x86 SIMD instructions to accelerate matching large numbers of regular
 * expressions simultaneously across streams of data.
 *
 * @generated from message envoy.extensions.matching.input_matchers.hyperscan.v3alpha.Hyperscan
 */
export declare class Hyperscan extends Message<Hyperscan> {
  /**
   * Specifies a set of regex expressions that the input should match on.
   *
   * @generated from field: repeated envoy.extensions.matching.input_matchers.hyperscan.v3alpha.Hyperscan.Regex regexes = 1;
   */
  regexes: Hyperscan_Regex[];

  constructor(data?: PartialMessage<Hyperscan>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.input_matchers.hyperscan.v3alpha.Hyperscan";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hyperscan;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hyperscan;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hyperscan;

  static equals(a: Hyperscan | PlainMessage<Hyperscan> | undefined, b: Hyperscan | PlainMessage<Hyperscan> | undefined): boolean;
}

/**
 * [#next-free-field: 11]
 *
 * @generated from message envoy.extensions.matching.input_matchers.hyperscan.v3alpha.Hyperscan.Regex
 */
export declare class Hyperscan_Regex extends Message<Hyperscan_Regex> {
  /**
   * The regex expression.
   *
   * The expression must represent only the pattern to be matched, with no delimiters or flags.
   *
   * @generated from field: string regex = 1;
   */
  regex: string;

  /**
   * The ID of the regex expression.
   *
   * This option is designed to be used on the sub-expressions in logical combinations.
   *
   * @generated from field: uint32 id = 2;
   */
  id: number;

  /**
   * Matching will be performed case-insensitively.
   *
   * The expression may still use PCRE tokens (notably ``(?i)`` and ``(?-i)``) to switch
   * case-insensitive matching on and off.
   *
   * @generated from field: bool caseless = 3;
   */
  caseless: boolean;

  /**
   * Matching a ``.`` will not exclude newlines.
   *
   * @generated from field: bool dot_all = 4;
   */
  dotAll: boolean;

  /**
   * ``^`` and ``$`` anchors match any newlines in data.
   *
   * @generated from field: bool multiline = 5;
   */
  multiline: boolean;

  /**
   * Allow expressions which can match against an empty string.
   *
   * This option instructs the compiler to allow expressions that can match against empty buffers,
   * such as ``.?``, ``.*``, ``(a|)``. Since Hyperscan can return every possible match for an expression,
   * such expressions generally execute very slowly.
   *
   * @generated from field: bool allow_empty = 6;
   */
  allowEmpty: boolean;

  /**
   * Treat the pattern as a sequence of UTF-8 characters.
   *
   * @generated from field: bool utf8 = 7;
   */
  utf8: boolean;

  /**
   * Use Unicode properties for character classes.
   *
   * This option instructs Hyperscan to use Unicode properties, rather than the default ASCII
   * interpretations, for character mnemonics like ``\w`` and ``\s`` as well as the POSIX character
   * classes. It is only meaningful in conjunction with ``utf8``.
   *
   * @generated from field: bool ucp = 8;
   */
  ucp: boolean;

  /**
   * Logical combination.
   *
   * This option instructs Hyperscan to parse this expression as logical combination syntax.
   * Logical constraints consist of operands, operators and parentheses. The operands are
   * expression indices, and operators can be ``!``, ``&`` or ``|``.
   *
   * @generated from field: bool combination = 9;
   */
  combination: boolean;

  /**
   * Donâ€™t do any match reporting.
   *
   * This option instructs Hyperscan to ignore match reporting for this expression. It is
   * designed to be used on the sub-expressions in logical combinations.
   *
   * @generated from field: bool quiet = 10;
   */
  quiet: boolean;

  constructor(data?: PartialMessage<Hyperscan_Regex>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "envoy.extensions.matching.input_matchers.hyperscan.v3alpha.Hyperscan.Regex";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Hyperscan_Regex;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Hyperscan_Regex;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Hyperscan_Regex;

  static equals(a: Hyperscan_Regex | PlainMessage<Hyperscan_Regex> | undefined, b: Hyperscan_Regex | PlainMessage<Hyperscan_Regex> | undefined): boolean;
}

